{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gemforce Documentation \u00b6 Welcome to the official documentation for the Gemforce blockchain platform - a comprehensive solution for digital identity, asset management, and carbon credit tracking. About Gemforce \u00b6 Gemforce is a powerful blockchain-based platform that combines on-chain smart contracts with off-chain cloud services to provide: Digital Identity Management - Secure, verifiable digital identities with claims and attestations Asset Management - Creation, transfer, and management of digital assets Carbon Credit Tracking - Issuance, trading, and retirement of carbon credits Marketplace Functionality - Buy, sell, and trade digital assets securely The platform leverages the Diamond pattern (EIP-2535) for upgradeable smart contracts and integrates with DFNS for secure wallet management and the Bridge API for financial operations and compliance. Documentation Overview \u00b6 This documentation is organized to serve different user roles: System Architecture \u00b6 System Architecture Technical overview of Gemforce's architecture, components, and integration points. Smart Contract Layer Cloud Service Layer Integration Points Security Considerations API Documentation \u00b6 Full API Reference Comprehensive documentation of all API endpoints, parameters, and responses. Quick Reference Concise guide to the most commonly used API endpoints and operations. User Guides \u00b6 Administrator Guide For system administrators managing and maintaining the Gemforce platform. Installation & Configuration User Management Monitoring & Alerts Security Management Deployer Guide For DevOps and technical teams deploying and updating Gemforce. Smart Contract Deployment Cloud Functions Deployment Upgrade Procedures Testing & Verification Integrator Guide For developers integrating external systems with Gemforce. Authentication & Authorization REST API Integration Smart Contract Integration Webhook Implementation Additional Resources \u00b6 External Services Documentation for third-party services integrated with Gemforce. DFNS Wallet Service Bridge API Plaid Integration Getting Started \u00b6 New to Gemforce? Here's how to get started: Read the System Architecture to understand the platform's components Choose the appropriate guide based on your role: System administrators: Administrator Guide DevOps engineers: Deployer Guide Integration developers: Integrator Guide Explore the API Documentation for detailed endpoint information Support \u00b6 If you need assistance with the Gemforce platform, please contact: Technical Support : support@gemforce.io Documentation Issues : docs@gemforce.io General Inquiries : info@gemforce.io Gemforce Documentation \u00a9 2025 Gemforce Team. All rights reserved. .grid-container { display: flex; flex-wrap: wrap; gap: 20px; margin: 20px 0; } .grid-item { flex: 1 1 300px; border: 1px solid #e0e0e0; border-radius: 5px; padding: 15px; background-color: #f9f9f9; } .grid-item h4 { margin-top: 0; } .footer-note { margin-top: 40px; border-top: 1px solid #e0e0e0; padding-top: 10px; font-size: 0.9em; color: #666; }","title":"Home"},{"location":"#gemforce-documentation","text":"Welcome to the official documentation for the Gemforce blockchain platform - a comprehensive solution for digital identity, asset management, and carbon credit tracking.","title":"Gemforce Documentation"},{"location":"#about-gemforce","text":"Gemforce is a powerful blockchain-based platform that combines on-chain smart contracts with off-chain cloud services to provide: Digital Identity Management - Secure, verifiable digital identities with claims and attestations Asset Management - Creation, transfer, and management of digital assets Carbon Credit Tracking - Issuance, trading, and retirement of carbon credits Marketplace Functionality - Buy, sell, and trade digital assets securely The platform leverages the Diamond pattern (EIP-2535) for upgradeable smart contracts and integrates with DFNS for secure wallet management and the Bridge API for financial operations and compliance.","title":"About Gemforce"},{"location":"#documentation-overview","text":"This documentation is organized to serve different user roles:","title":"Documentation Overview"},{"location":"#system-architecture","text":"","title":"System Architecture"},{"location":"#api-documentation","text":"","title":"API Documentation"},{"location":"#user-guides","text":"","title":"User Guides"},{"location":"#additional-resources","text":"","title":"Additional Resources"},{"location":"#getting-started","text":"New to Gemforce? Here's how to get started: Read the System Architecture to understand the platform's components Choose the appropriate guide based on your role: System administrators: Administrator Guide DevOps engineers: Deployer Guide Integration developers: Integrator Guide Explore the API Documentation for detailed endpoint information","title":"Getting Started"},{"location":"#support","text":"If you need assistance with the Gemforce platform, please contact: Technical Support : support@gemforce.io Documentation Issues : docs@gemforce.io General Inquiries : info@gemforce.io Gemforce Documentation \u00a9 2025 Gemforce Team. All rights reserved. .grid-container { display: flex; flex-wrap: wrap; gap: 20px; margin: 20px 0; } .grid-item { flex: 1 1 300px; border: 1px solid #e0e0e0; border-radius: 5px; padding: 15px; background-color: #f9f9f9; } .grid-item h4 { margin-top: 0; } .footer-note { margin-top: 40px; border-top: 1px solid #e0e0e0; padding-top: 10px; font-size: 0.9em; color: #666; }","title":"Support"},{"location":"documentation-plan/","text":"Gemforce Documentation Expansion Plan \u00b6 This plan outlines the additional documentation needed for the Gemforce system, focusing on administrator, deployer, and integrator perspectives. 1. Administrator's Guide \u00b6 Purpose: Provide system administrators with comprehensive instructions for managing, monitoring, and maintaining the Gemforce platform. Target audience: System administrators, operations teams, support staff Filename: gemforce-administrator-guide.md Content structure: System Overview \u00b6 Architecture recap (brief) Component relationships Infrastructure requirements Security model overview Installation and Configuration \u00b6 Prerequisites Environment variables Network settings Database configuration External service connections Security settings User Management \u00b6 User roles and permissions Adding/removing users Role assignment Identity verification processes Managing trusted issuers Monitoring and Alerts \u00b6 System health checks Performance metrics Log management Alert configuration Common warning signs Dashboards setup Backup and Recovery \u00b6 Backup procedures Database backups Configuration backups Recovery procedures Disaster recovery planning Security Management \u00b6 Access control API key rotation Audit logging Security incident response Compliance considerations Troubleshooting \u00b6 Common issues and solutions Diagnostic tools Error codes explanation Support escalation procedures Service dependencies Maintenance Procedures \u00b6 Routine maintenance tasks Update procedures Database optimization Cache management System scaling procedures Performance Optimization \u00b6 Database tuning Cache configuration Rate limiting configuration Resource allocation guidelines 2. Deployer's Guide \u00b6 Purpose: Provide technical teams with detailed instructions for deploying, updating, and managing the Gemforce system in various environments. Target audience: DevOps engineers, blockchain developers, backend developers Filename: gemforce-deployer-guide.md Content structure: Deployment Prerequisites \u00b6 Development environment setup Required tools and software Network access requirements Key management setup Environment preparation Smart Contract Deployment \u00b6 Contract compilation Diamond pattern deployment workflow Facet deployment process Contract initialization Contract verification Gas optimization strategies Cloud Functions Deployment \u00b6 Parse Server deployment Cloud function deployment Environment configuration Database migration WebSocket setup Environment Configuration \u00b6 Development environment Testing environment Staging environment Production environment Environment-specific settings Deployment Automation \u00b6 CI/CD pipeline setup Automated testing Deployment scripts Infrastructure as code Continuous monitoring Upgrade Procedures \u00b6 Smart contract upgrades Cloud function updates Database schema migrations Backward compatibility considerations Feature flagging Rollback Procedures \u00b6 Smart contract rollbacks Cloud function rollbacks Database rollbacks Emergency procedures Data integrity verification Testing and Verification \u00b6 Unit testing Integration testing Contract verification Load testing Security testing Network Management \u00b6 Blockchain node management RPC endpoint configuration Transaction monitoring Gas price management Network upgrades handling Version Control \u00b6 Repository structure Branching strategy Release management Tagging conventions Documentation versioning 3. Integrator's Guide \u00b6 Purpose: Provide third-party developers and partners with comprehensive guidance for integrating their systems with the Gemforce platform. Target audience: External developers, partners, system integrators Filename: gemforce-integrator-guide.md Content structure: Integration Overview \u00b6 System capabilities Integration options Authentication methods Typical integration flows Integration architecture patterns Authentication and Authorization \u00b6 OAuth2 implementation API key management JWT token handling Permission scopes Session management REST API Integration \u00b6 Endpoint documentation Request/response formats Rate limiting Pagination Filtering and sorting Versioning strategy Smart Contract Integration \u00b6 Contract ABIs Transaction construction Gas estimation Event listening Error handling DFNS Wallet Integration \u00b6 Authentication flow Wallet creation Transaction signing Error handling Security best practices Webhook Implementation \u00b6 Available webhooks Webhook configuration Payload format Retry mechanisms Webhook validation Error Handling and Logging \u00b6 Error codes Retry strategies Idempotency Logging best practices Debugging tools Sample Integration Code \u00b6 Authentication examples API call examples Webhook handling Event subscription Error handling Common Integration Patterns \u00b6 User onboarding flow Transaction processing Identity verification Asset management Carbon credit retirement Testing and Sandbox \u00b6 Sandbox environment access Test credentials Mocking responses Integration testing Load testing considerations Security Considerations \u00b6 TLS requirements API key security Input validation Output encoding Rate limiting IP restrictions Compliance Integration \u00b6 KYC/AML considerations Audit logging Compliance reporting Data privacy Regulatory requirements Timeline and Dependencies \u00b6 Phase 1: Research and Content Gathering \u00b6 Review existing documentation Identify missing information Interview stakeholders Collect code examples Document common workflows Phase 2: Content Creation \u00b6 Administrator's Guide (5-7 days) Deployer's Guide (5-7 days) Integrator's Guide (5-7 days) Phase 3: Review and Refinement \u00b6 Internal technical review Stakeholder review User testing Content refinement Phase 4: Publication and Distribution \u00b6 Format for multiple platforms Create PDF versions Add to documentation repository Announce to stakeholders Success Criteria \u00b6 The documentation will be considered successful if it: Enables administrators to confidently manage the Gemforce system Allows deployers to successfully deploy and update the system Helps integrators build reliable integrations with minimal support Reduces support tickets and questions related to common tasks Receives positive feedback from target audiences","title":"Documentation Plan"},{"location":"documentation-plan/#gemforce-documentation-expansion-plan","text":"This plan outlines the additional documentation needed for the Gemforce system, focusing on administrator, deployer, and integrator perspectives.","title":"Gemforce Documentation Expansion Plan"},{"location":"documentation-plan/#1-administrators-guide","text":"Purpose: Provide system administrators with comprehensive instructions for managing, monitoring, and maintaining the Gemforce platform. Target audience: System administrators, operations teams, support staff Filename: gemforce-administrator-guide.md Content structure:","title":"1. Administrator's Guide"},{"location":"documentation-plan/#system-overview","text":"Architecture recap (brief) Component relationships Infrastructure requirements Security model overview","title":"System Overview"},{"location":"documentation-plan/#installation-and-configuration","text":"Prerequisites Environment variables Network settings Database configuration External service connections Security settings","title":"Installation and Configuration"},{"location":"documentation-plan/#user-management","text":"User roles and permissions Adding/removing users Role assignment Identity verification processes Managing trusted issuers","title":"User Management"},{"location":"documentation-plan/#monitoring-and-alerts","text":"System health checks Performance metrics Log management Alert configuration Common warning signs Dashboards setup","title":"Monitoring and Alerts"},{"location":"documentation-plan/#backup-and-recovery","text":"Backup procedures Database backups Configuration backups Recovery procedures Disaster recovery planning","title":"Backup and Recovery"},{"location":"documentation-plan/#security-management","text":"Access control API key rotation Audit logging Security incident response Compliance considerations","title":"Security Management"},{"location":"documentation-plan/#troubleshooting","text":"Common issues and solutions Diagnostic tools Error codes explanation Support escalation procedures Service dependencies","title":"Troubleshooting"},{"location":"documentation-plan/#maintenance-procedures","text":"Routine maintenance tasks Update procedures Database optimization Cache management System scaling procedures","title":"Maintenance Procedures"},{"location":"documentation-plan/#performance-optimization","text":"Database tuning Cache configuration Rate limiting configuration Resource allocation guidelines","title":"Performance Optimization"},{"location":"documentation-plan/#2-deployers-guide","text":"Purpose: Provide technical teams with detailed instructions for deploying, updating, and managing the Gemforce system in various environments. Target audience: DevOps engineers, blockchain developers, backend developers Filename: gemforce-deployer-guide.md Content structure:","title":"2. Deployer's Guide"},{"location":"documentation-plan/#deployment-prerequisites","text":"Development environment setup Required tools and software Network access requirements Key management setup Environment preparation","title":"Deployment Prerequisites"},{"location":"documentation-plan/#smart-contract-deployment","text":"Contract compilation Diamond pattern deployment workflow Facet deployment process Contract initialization Contract verification Gas optimization strategies","title":"Smart Contract Deployment"},{"location":"documentation-plan/#cloud-functions-deployment","text":"Parse Server deployment Cloud function deployment Environment configuration Database migration WebSocket setup","title":"Cloud Functions Deployment"},{"location":"documentation-plan/#environment-configuration","text":"Development environment Testing environment Staging environment Production environment Environment-specific settings","title":"Environment Configuration"},{"location":"documentation-plan/#deployment-automation","text":"CI/CD pipeline setup Automated testing Deployment scripts Infrastructure as code Continuous monitoring","title":"Deployment Automation"},{"location":"documentation-plan/#upgrade-procedures","text":"Smart contract upgrades Cloud function updates Database schema migrations Backward compatibility considerations Feature flagging","title":"Upgrade Procedures"},{"location":"documentation-plan/#rollback-procedures","text":"Smart contract rollbacks Cloud function rollbacks Database rollbacks Emergency procedures Data integrity verification","title":"Rollback Procedures"},{"location":"documentation-plan/#testing-and-verification","text":"Unit testing Integration testing Contract verification Load testing Security testing","title":"Testing and Verification"},{"location":"documentation-plan/#network-management","text":"Blockchain node management RPC endpoint configuration Transaction monitoring Gas price management Network upgrades handling","title":"Network Management"},{"location":"documentation-plan/#version-control","text":"Repository structure Branching strategy Release management Tagging conventions Documentation versioning","title":"Version Control"},{"location":"documentation-plan/#3-integrators-guide","text":"Purpose: Provide third-party developers and partners with comprehensive guidance for integrating their systems with the Gemforce platform. Target audience: External developers, partners, system integrators Filename: gemforce-integrator-guide.md Content structure:","title":"3. Integrator's Guide"},{"location":"documentation-plan/#integration-overview","text":"System capabilities Integration options Authentication methods Typical integration flows Integration architecture patterns","title":"Integration Overview"},{"location":"documentation-plan/#authentication-and-authorization","text":"OAuth2 implementation API key management JWT token handling Permission scopes Session management","title":"Authentication and Authorization"},{"location":"documentation-plan/#rest-api-integration","text":"Endpoint documentation Request/response formats Rate limiting Pagination Filtering and sorting Versioning strategy","title":"REST API Integration"},{"location":"documentation-plan/#smart-contract-integration","text":"Contract ABIs Transaction construction Gas estimation Event listening Error handling","title":"Smart Contract Integration"},{"location":"documentation-plan/#dfns-wallet-integration","text":"Authentication flow Wallet creation Transaction signing Error handling Security best practices","title":"DFNS Wallet Integration"},{"location":"documentation-plan/#webhook-implementation","text":"Available webhooks Webhook configuration Payload format Retry mechanisms Webhook validation","title":"Webhook Implementation"},{"location":"documentation-plan/#error-handling-and-logging","text":"Error codes Retry strategies Idempotency Logging best practices Debugging tools","title":"Error Handling and Logging"},{"location":"documentation-plan/#sample-integration-code","text":"Authentication examples API call examples Webhook handling Event subscription Error handling","title":"Sample Integration Code"},{"location":"documentation-plan/#common-integration-patterns","text":"User onboarding flow Transaction processing Identity verification Asset management Carbon credit retirement","title":"Common Integration Patterns"},{"location":"documentation-plan/#testing-and-sandbox","text":"Sandbox environment access Test credentials Mocking responses Integration testing Load testing considerations","title":"Testing and Sandbox"},{"location":"documentation-plan/#security-considerations","text":"TLS requirements API key security Input validation Output encoding Rate limiting IP restrictions","title":"Security Considerations"},{"location":"documentation-plan/#compliance-integration","text":"KYC/AML considerations Audit logging Compliance reporting Data privacy Regulatory requirements","title":"Compliance Integration"},{"location":"documentation-plan/#timeline-and-dependencies","text":"","title":"Timeline and Dependencies"},{"location":"documentation-plan/#phase-1-research-and-content-gathering","text":"Review existing documentation Identify missing information Interview stakeholders Collect code examples Document common workflows","title":"Phase 1: Research and Content Gathering"},{"location":"documentation-plan/#phase-2-content-creation","text":"Administrator's Guide (5-7 days) Deployer's Guide (5-7 days) Integrator's Guide (5-7 days)","title":"Phase 2: Content Creation"},{"location":"documentation-plan/#phase-3-review-and-refinement","text":"Internal technical review Stakeholder review User testing Content refinement","title":"Phase 3: Review and Refinement"},{"location":"documentation-plan/#phase-4-publication-and-distribution","text":"Format for multiple platforms Create PDF versions Add to documentation repository Announce to stakeholders","title":"Phase 4: Publication and Distribution"},{"location":"documentation-plan/#success-criteria","text":"The documentation will be considered successful if it: Enables administrators to confidently manage the Gemforce system Allows deployers to successfully deploy and update the system Helps integrators build reliable integrations with minimal support Reduces support tickets and questions related to common tasks Receives positive feedback from target audiences","title":"Success Criteria"},{"location":"gemforce-administrator-guide/","text":"Gemforce Administrator Guide \u00b6 Table of Contents \u00b6 System Overview Installation and Configuration User Management Monitoring and Alerts Backup and Recovery Security Management Troubleshooting Maintenance Procedures Performance Optimization System Overview \u00b6 Architecture Components \u00b6 The Gemforce platform consists of the following major components: Blockchain Smart Contracts Diamond contracts (EIP-2535 implementation) Identity management contracts Token management contracts Carbon credit contracts Cloud Services Parse Server backend Database (MongoDB) File storage Cloud functions External Service Integrations DFNS wallet-as-a-service Bridge API SendGrid email service Blockchain RPC providers Client Applications Web applications Mobile applications API integrations Component Relationships \u00b6 The Gemforce system follows a layered architecture: Client Applications \u2193\u2191 Cloud Services (Parse Server) \u2193\u2191 External Services \u27f7 Blockchain Contracts Client applications interact with the Parse Server via REST API Parse Server executes cloud functions that interact with blockchain contracts and external services External services provide specialized functionality (wallet management, financial operations, etc.) Blockchain contracts store and manage on-chain data and logic Infrastructure Requirements \u00b6 Blockchain Nodes : Access to Ethereum-compatible blockchain nodes Server Hardware : Minimum: 4 CPU cores, 8GB RAM, 100GB SSD Recommended: 8 CPU cores, 16GB RAM, 250GB SSD Database : MongoDB 4.4+ Network : Reliable internet connection with low latency to blockchain nodes SSL Certificate : Valid SSL certificate for secure API access Security Model Overview \u00b6 Gemforce implements a multi-layered security approach: Authentication and Authorization User authentication via Parse Server Role-based access control API key authentication for B2B integrations DFNS WebAuthn for wallet operations Smart Contract Security Role-based access control Function-level permissions Upgradeability via Diamond pattern Data Protection Encrypted data at rest TLS for data in transit Private key management via DFNS Monitoring and Auditing Comprehensive logging Activity tracking Alert systems Installation and Configuration \u00b6 Prerequisites \u00b6 Before installing Gemforce, ensure you have: Node.js 16.x or higher MongoDB 4.4 or higher Access to blockchain nodes (RPC endpoints) API keys for external services Domain name with SSL certificate Git access to the Gemforce repositories Environment Variables \u00b6 The Gemforce system requires several environment variables to be set. Create a .env file with the following variables: # Parse Server Configuration APP_ID = your_app_id MASTER_KEY = your_master_key DATABASE_URI = mongodb : // username : password @host : port / database SERVER_URL = https : // your - server - url . com / parse PROJECT_WIZARD_URL = https : // your - server - url . com # Blockchain Configuration ETH_NODE_URI_MAINNET = https : // mainnet . infura . io / v3 / your - key ETH_NODE_URI_BASESEP = https : // sepolia . base . org CHAIN_ID = base - sepolia METADATA_BASE_URI = https : // your - metadata - url . com / # DFNS Configuration DFNS_APP_ID = your_dfns_app_id DFNS_API_URL = https : // api . dfns . io DFNS_CRED_ID = your_dfns_credential_id DFNS_AUTH_TOKEN = your_dfns_auth_token # Bridge API Configuration BASE_BRIDGE_URL = https : // api . bridge - api . com BRIDGE_API_KEY = your_bridge_api_key # Email Configuration SENDGRID_API_KEY = your_sendgrid_key FROM_EMAIL = noreply @your - domain . com # Security Configuration AUTH_SECRET_KEY = your_auth_secret_key Network Settings \u00b6 Firewall Configuration : Allow inbound connections on ports 80 (HTTP), 443 (HTTPS), and your Parse Server port Allow outbound connections to MongoDB, blockchain nodes, and external APIs Load Balancer Configuration (if applicable): Configure health checks to the Parse Server health endpoint Set appropriate timeouts (at least 30 seconds for blockchain operations) Enable SSL termination DNS Configuration : Set up A records for your domain Configure CNAME records for subdomains if needed Database Configuration \u00b6 MongoDB Setup : bash # Create a MongoDB user for the Gemforce database mongo admin -u admin -p admin use gemforce db.createUser({ user: \"gemforce_user\", pwd: \"secure_password\", roles: [{ role: \"readWrite\", db: \"gemforce\" }] }) Indexes : Ensure the following indexes are created for optimal performance: ```javascript // User collection indexes db.User.createIndex({ email: 1 }, { unique: true }) db.User.createIndex({ username: 1 }, { unique: true }) db.User.createIndex({ walletAddress: 1 }) // Identity collection indexes db.Identity.createIndex({ walletAddress: 1 }, { unique: true }) // Transaction collection indexes db.Transaction.createIndex({ hash: 1 }, { unique: true }) db.Transaction.createIndex({ user: 1 }) db.Transaction.createIndex({ createdAt: 1 }) ``` External Service Connections \u00b6 DFNS Setup : Create a DFNS account at https://dashboard.dfns.io Create an application and credential Copy the App ID and Credential ID to your environment variables Store the private key in dfns_private.key Bridge API Setup : Obtain API credentials from Bridge API Configure webhooks for notifications (if needed) Set rate limiting based on expected traffic SendGrid Setup : Create a SendGrid account Set up sender authentication for your domain Create email templates for verification, password reset, etc. Generate API key and add to environment variables Security Settings \u00b6 API Key Management : Rotate API keys periodically (recommended every 90 days) Store API keys securely using environment variables Never expose API keys in client-side code Cross-Origin Resource Sharing (CORS) : Configure CORS settings in the Parse Server configuration: javascript const corsConfig = { allowOrigin: ['https://your-domain.com', 'https://app.your-domain.com'], allowHeaders: ['X-Parse-Application-Id', 'X-Parse-REST-API-Key', 'Content-Type'], allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'] }; Rate Limiting : Configure rate limiting to prevent abuse: javascript const rateLimitConfig = { rateLimit: 1000, // requests per minute burstLimit: 50, // concurrent requests expiration: 60 // seconds until reset }; User Management \u00b6 User Roles and Permissions \u00b6 Gemforce implements role-based access control with the following default roles: Admin : Full access to all functions Can manage users and roles Can deploy and update contracts CentralAuthority : Can manage trusted issuers Can add claim topics Can manage identities TrustedIssuer : Can issue claims to identities Can verify identities Limited access to identity management User : Can manage own wallet Can view own transactions Can participate in marketplace Adding and Removing Users \u00b6 Adding Users \u00b6 Via Admin Dashboard : Navigate to User Management Click \"Add User\" Enter user details (email, name, role) System will send invitation email Via API : ```javascript // Example using Parse JavaScript SDK const user = new Parse.User(); user.set(\"username\", \"user@example.com\"); user.set(\"password\", \"securePassword\"); user.set(\"email\", \"user@example.com\"); user.set(\"firstName\", \"John\"); user.set(\"lastName\", \"Doe\"); await user.signUp(); ``` Via Cloud Function : javascript // Using the registerUser cloud function Parse.Cloud.run(\"registerUser\", { username: \"user@example.com\", password: \"securePassword\", email: \"user@example.com\", firstName: \"John\", lastName: \"Doe\", company: \"Example Inc\" }); Removing Users \u00b6 Via Admin Dashboard : Navigate to User Management Select user(s) to remove Click \"Delete\" or \"Deactivate\" Via API : javascript // Example using Parse JavaScript SDK const query = new Parse.Query(Parse.User); query.equalTo(\"email\", \"user@example.com\"); const user = await query.first({ useMasterKey: true }); await user.destroy({ useMasterKey: true }); Role Assignment \u00b6 Assigning Roles to Users : ```javascript // Example using Parse JavaScript SDK const userQuery = new Parse.Query(Parse.User); userQuery.equalTo(\"email\", \"user@example.com\"); const user = await userQuery.first({ useMasterKey: true }); const roleQuery = new Parse.Query(Parse.Role); roleQuery.equalTo(\"name\", \"TrustedIssuer\"); const role = await roleQuery.first({ useMasterKey: true }); role.getUsers().add(user); await role.save(null, { useMasterKey: true }); ``` Creating New Roles : ```javascript // Example using Parse JavaScript SDK const acl = new Parse.ACL(); acl.setPublicReadAccess(true); const role = new Parse.Role(\"CustomRole\", acl); await role.save(null, { useMasterKey: true }); ``` Identity Verification Processes \u00b6 KYC Verification : Initiate via generateKycLink cloud function User completes KYC via Bridge API Webhook notification sent back to Gemforce Identity status updated accordingly Trusted Issuer Verification : Trusted Issuer reviews identity information Issues verification claim to user identity Claim is written to blockchain Identity state is updated to \"verified\" Managing Trusted Issuers \u00b6 Adding a Trusted Issuer : ```javascript // Using the dfnsAddTrustedIssuerInit/Complete cloud functions const { challenge, requestBody } = await Parse.Cloud.run(\"dfnsAddTrustedIssuerInit\", { trustedIssuer: \"0x1234...\", // Issuer wallet address claimTopics: [1, 2, 3], // Claim topics this issuer can verify walletId: \"wallet_id\", dfns_token: \"dfns_token\" }); // Sign the challenge client-side const signedChallenge = await signChallenge(challenge); // Complete the transaction await Parse.Cloud.run(\"dfnsAddTrustedIssuerComplete\", { walletId: \"wallet_id\", dfns_token: \"dfns_token\", signedChallenge: signedChallenge, requestBody: requestBody }); ``` Removing a Trusted Issuer : Use the dfnsRemoveTrustedIssuerInit/Complete cloud functions following the same pattern as above. Updating Trusted Issuer Claim Topics : Use the dfnsUpdateIssuerClaimTopicsInit/Complete cloud functions. Monitoring and Alerts \u00b6 System Health Checks \u00b6 Parse Server Health Check : Endpoint: /parse/health Expected response: {\"status\":\"ok\"} Monitor response time (should be < 200ms) Database Health Check : Query execution time Connection pool status Replica set status (if applicable) Blockchain Connectivity : RPC endpoint response time Block height synchronization Transaction submission success rate Performance Metrics \u00b6 Key metrics to monitor: API Performance : Request latency (avg, p95, p99) Request throughput Error rate Database Performance : Query execution time Index usage Connection count Blockchain Performance : Gas costs per transaction type Transaction confirmation time Failed transaction rate Log Management \u00b6 Log Aggregation : Implement centralized logging (e.g., ELK Stack, Splunk) Include correlation IDs across service boundaries Implement structured logging for easier querying Log Levels : ERROR: Issues requiring immediate attention WARN: Potential issues to investigate INFO: Normal operations DEBUG: Detailed information for troubleshooting Key Events to Log : Authentication events User management operations Blockchain transactions External API calls Alert Configuration \u00b6 Configure alerts for the following scenarios: Critical Alerts (immediate action required): Parse Server unavailability Database connection failures High error rates (>5%) Failed blockchain transactions Warning Alerts (investigation needed): Elevated API latency (>500ms) Increased error rates (>1%) Low disk space (<20%) Delayed blockchain confirmations Notification Channels : Email SMS/Text Slack/Teams PagerDuty or similar service Common Warning Signs \u00b6 Watch for these indicators of potential issues: Increasing API Latency : May indicate database issues or resource constraints Growing Database Size : May require indexing or cleanup Increasing Error Rates : May indicate bugs or external service issues Blockchain Transaction Failures : May indicate gas price issues or contract bugs Declining User Activity : May indicate UX issues or service degradation Dashboards Setup \u00b6 Implement monitoring dashboards that show: System Overview : Overall health status Current alert status Key metrics summary API Performance : Request volume Response time by endpoint Error rate by endpoint User Activity : Active users Registration rate Transaction volume Blockchain Activity : Transaction success rate Gas costs Contract interactions Backup and Recovery \u00b6 Backup Procedures \u00b6 Database Backups : ```bash # MongoDB backup command mongodump --uri=\"mongodb://username:password@host:port/database\" --out=/backup/path/$(date +%Y-%m-%d) # Compress the backup tar -zcvf /backup/path/$(date +%Y-%m-%d).tar.gz /backup/path/$(date +%Y-%m-%d) ``` Schedule : - Full backup: Daily - Incremental backup: Hourly Configuration Backups : bash # Back up environment variables and config files cp .env /backup/config/$(date +%Y-%m-%d)-env cp gemforce.config.ts /backup/config/$(date +%Y-%m-%d)-gemforce-config.ts Schedule : After any configuration change Contract Deployment Records : bash # Back up deployment records cp ./deployments /backup/deployments/$(date +%Y-%m-%d) -r cp deployed.json /backup/deployments/$(date +%Y-%m-%d)-deployed.json Schedule : After any contract deployment Recovery Procedures \u00b6 Database Recovery : bash # Restore MongoDB database mongorestore --uri=\"mongodb://username:password@host:port/database\" --drop /backup/path/YYYY-MM-DD Configuration Recovery : bash # Restore configuration files cp /backup/config/YYYY-MM-DD-env .env cp /backup/config/YYYY-MM-DD-gemforce-config.ts gemforce.config.ts Contract Redeployment : Restore deployment records Use the DiamondFactory to recreate diamonds if needed Verify contract states Disaster Recovery Planning \u00b6 Disaster Recovery Scenarios : Database corruption Server hardware failure Cloud provider outage Security breach Recovery Time Objectives (RTO) : Critical systems: 4 hours Non-critical systems: 24 hours Recovery Point Objectives (RPO) : Database: 1 hour Configuration: 24 hours Disaster Recovery Runbook : Maintain up-to-date documentation Conduct periodic recovery tests Automate recovery procedures where possible Security Management \u00b6 Access Control \u00b6 API Key Management : Generate strong API keys (min 32 characters) Store securely (environment variables, secret management service) Implement key rotation (90-day cycle) Revoke compromised keys immediately User Authentication Controls : Enforce strong password policies Implement account lockout after failed attempts Consider implementing MFA for admin accounts Session timeout (default: 24 hours) Role-Based Access Control : Limit permissions to minimum required Regularly audit role assignments Implement principle of least privilege API Key Rotation \u00b6 Implement a process for rotating API keys: // Example: Rotate Bridge API key async function rotateBridgeAPIKey () { // Generate a new API key (provider-specific) const newKey = await generateNewBridgeAPIKey (); // Update environment variable process . env . BRIDGE_API_KEY = newKey ; // Update configuration in database const config = await Config . get ( \"bridgeAPIKey\" ); config . set ( \"value\" , newKey ); await config . save ( null , { useMasterKey : true }); // Log the rotation console . log ( `Bridge API key rotated at ${ new Date (). toISOString () } ` ); } Audit Logging \u00b6 Security Events to Log : Authentication attempts (successful and failed) Authorization changes User creation/deletion Role assignment API key usage Admin actions Log Format : json { \"timestamp\": \"2025-02-25T13:51:49.123Z\", \"event\": \"user.login\", \"success\": true, \"userId\": \"user123\", \"ipAddress\": \"192.168.1.1\", \"userAgent\": \"Mozilla/5.0...\", \"additionalDetails\": {} } Log Retention : Security logs: 12 months minimum Normal operation logs: 3 months Security Incident Response \u00b6 Incident Classification : P1: Critical (data breach, service unavailable) P2: High (limited breach, partial service degradation) P3: Medium (minor security issue, limited impact) P4: Low (potential vulnerability, no active exploitation) Response Procedure : Identify and classify the incident Contain the incident Eradicate the cause Recover systems Conduct post-incident analysis Contact List : Security team IT operations Legal department Executive leadership External security consultants (if applicable) Compliance Considerations \u00b6 Data Privacy : Identify personal data stored in the system Implement data minimization Configure data retention policies Provide data export/deletion capabilities Regulatory Compliance : KYC/AML requirements Financial regulations Industry-specific regulations Cross-border data transfer requirements Troubleshooting \u00b6 Common Issues and Solutions \u00b6 API Request Failures : Symptom : HTTP 400/500 errors Check : API logs, request parameters Solution : Verify request format, check server logs for details Blockchain Transaction Failures : Symptom : Transaction hash returned but transaction fails Check : Gas price, contract state, transaction parameters Solution : Adjust gas price, verify contract accepts the transaction Database Connection Issues : Symptom : Cannot connect to database error Check : MongoDB status, network connectivity Solution : Restart MongoDB, check firewall rules DFNS Integration Issues : Symptom : \"Cannot sign transaction\" errors Check : DFNS credentials, WebAuthn support Solution : Verify DFNS credentials, ensure browser supports WebAuthn Diagnostic Tools \u00b6 Log Analysis : ```bash # Search for errors in logs grep \"ERROR\" /var/log/gemforce/app.log # Find recent activity for a specific user grep \"userId\\\":\\\"user123\" /var/log/gemforce/app.log ``` Database Queries : ```javascript // Check user status db.User.findOne({ email: \"user@example.com\" }) // Look for recent errors db.ErrorLog.find().sort({ createdAt: -1 }).limit(10) ``` Blockchain Explorers : Use block explorers to verify transaction status Check contract events for expected emissions Verify contract state after transactions Error Codes Explanation \u00b6 HTTP Status Codes : 400: Bad Request (invalid parameters) 401: Unauthorized (missing/invalid authentication) 403: Forbidden (insufficient permissions) 404: Not Found (resource doesn't exist) 429: Too Many Requests (rate limit exceeded) 500: Internal Server Error (server-side issue) Parse Error Codes : 101: Object not found 141: Missing required field 209: Invalid session token Blockchain Error Codes : \"gas required exceeds allowance\": Insufficient gas \"execution reverted\": Contract condition not met \"nonce too low\": Transaction nonce issue Support Escalation Procedures \u00b6 Tier 1 Support : Initial triage Common issue resolution Escalation timeframe: 30 minutes Tier 2 Support : Technical investigation Complex issue resolution Escalation timeframe: 2 hours Tier 3 Support : Engineering team involvement Critical issue resolution Escalation timeframe: 4 hours Escalation Contact Information : Tier 1: support@gemforce.com Tier 2: tech-support@gemforce.com Tier 3: engineering@gemforce.com Emergency: +1-555-123-4567 Service Dependencies \u00b6 Map of service dependencies to check during outages: Parse Server depends on : MongoDB File storage DFNS API Bridge API Blockchain RPC nodes Blockchain operations depend on : RPC node availability Gas price oracle Contract state User authentication depends on : Parse Server Email service DFNS (for wallet operations) Maintenance Procedures \u00b6 Routine Maintenance Tasks \u00b6 Daily Tasks : Review error logs Check backup status Monitor system performance Weekly Tasks : Analyze API usage patterns Review security logs Check disk space usage Monthly Tasks : User access review API key rotation Performance optimization Database maintenance Update Procedures \u00b6 Parse Server Updates : ```bash # Update Parse Server npm update parse-server # Restart Parse Server pm2 restart parse-server ``` Node.js Updates : ```bash # Update Node.js using NVM nvm install 16.x nvm use 16.x # Verify version node -v ``` Cloud Function Updates : ```bash # Pull latest changes git pull origin main # Install dependencies npm install # Build the project npm run build # Restart the server pm2 restart gemforce ``` Database Optimization \u00b6 Index Optimization : ```javascript // Analyze query performance db.User.find({ walletAddress: { $exists: true } }).explain(\"executionStats\") // Add missing indexes db.User.createIndex({ walletAddress: 1 }) ``` Data Archiving : ```javascript // Move old logs to archive collection db.SystemLog.aggregate([ { $match: { createdAt: { $lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) } } }, { $out: \"SystemLogArchive\" } ]) // Remove archived logs db.SystemLog.deleteMany({ createdAt: { $lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) } }) ``` Database Maintenance : ```javascript // Repair database db.repairDatabase() // Compact collections db.runCommand({ compact: \"User\" }) ``` Cache Management \u00b6 Redis Cache Configuration (if applicable): javascript // Example cache configuration const redisCache = { host: \"localhost\", port: 6379, ttl: 600 // 10 minutes }; Cache Invalidation : ```javascript // Invalidate specific keys redisClient.del(\"user_123_profile\") // Invalidate pattern redisClient.keys(\"user_*_profile\", (err, keys) => { if (keys.length > 0) redisClient.del(keys); }) ``` Cache Monitoring : ```bash # Check Redis info redis-cli info # Monitor cache hit rate redis-cli info stats | grep hit_rate ``` System Scaling Procedures \u00b6 Horizontal Scaling : Add more Parse Server instances Configure load balancer Update DNS if needed Vertical Scaling : Upgrade server resources Schedule downtime for migration Verify performance after upgrade Database Scaling : Implement MongoDB replica set Consider sharding for large deployments Optimize query patterns Performance Optimization \u00b6 Database Tuning \u00b6 Query Optimization : Use explain plan to analyze queries Ensure proper indexes are in place Limit returned fields using projection Use aggregation pipeline for complex queries Connection Pooling : javascript // Example MongoDB connection pool configuration const mongoConfig = { uri: process.env.DATABASE_URI, options: { maxPoolSize: 50, minPoolSize: 10, socketTimeoutMS: 30000, connectTimeoutMS: 30000 } }; Index Analysis : ```javascript // Check index usage db.User.aggregate([ { $indexStats: {} } ]) // Remove unused indexes db.User.dropIndex(\"unusedIndex\") ``` Cache Configuration \u00b6 Cacheable Data Types : User profiles Contract metadata Configuration settings Static content Cache Strategy : Cache-aside: Application checks cache before database TTL-based expiration Event-based invalidation Example Redis Configuration : javascript // Redis cache configuration const redisOptions = { host: process.env.REDIS_HOST || \"localhost\", port: process.env.REDIS_PORT || 6379, password: process.env.REDIS_PASSWORD, db: 0, ttl: 3600 // 1 hour }; Rate Limiting Configuration \u00b6 API Rate Limits : javascript // Example rate limiting configuration const rateLimits = { global: { windowMs: 60 * 1000, // 1 minute max: 1000 // limit each IP to 1000 requests per minute }, login: { windowMs: 60 * 1000, // 1 minute max: 10 // limit each IP to 10 login attempts per minute }, createUser: { windowMs: 60 * 60 * 1000, // 1 hour max: 50 // limit each IP to 50 user creations per hour } }; Rate Limit Response : javascript // Example rate limit exceeded response { \"status\": \"error\", \"code\": 429, \"message\": \"Rate limit exceeded. Try again in X seconds.\", \"retryAfter\": 30 } Rate Limit Monitoring : Track rate limit hits Alert on sustained high rejection rates Analyze traffic patterns to adjust limits Resource Allocation Guidelines \u00b6 Server Resources : Guidelines for allocating resources based on load: Load Level Users API Requests/min CPU Cores RAM Disk Small <1k <100 2 4GB 20GB Medium <10k <1k 4 8GB 50GB Large <100k <10k 8 16GB 100GB X-Large >100k >10k 16+ 32GB+ 200GB+ Database Resources : Guidelines for MongoDB resources: Load Level Documents Indexes RAM Disk Small <1M <20 2GB 10GB Medium <10M <50 4GB 50GB Large <100M <100 16GB 200GB X-Large >100M >100 32GB+ 500GB+ Blockchain Node Resources : Consider using managed node providers for production environments. If running your own nodes: Network Disk RAM Notes Ethereum >2TB 16GB Full node, growing rapidly BaseSepolia >100GB 8GB Testnet, moderate growth Resource Scaling Triggers : CPU usage consistently >70% RAM usage consistently >80% Disk usage >85% Response time increasing trend Error rate increasing trend","title":"Administrator Guide"},{"location":"gemforce-administrator-guide/#gemforce-administrator-guide","text":"","title":"Gemforce Administrator Guide"},{"location":"gemforce-administrator-guide/#table-of-contents","text":"System Overview Installation and Configuration User Management Monitoring and Alerts Backup and Recovery Security Management Troubleshooting Maintenance Procedures Performance Optimization","title":"Table of Contents"},{"location":"gemforce-administrator-guide/#system-overview","text":"","title":"System Overview"},{"location":"gemforce-administrator-guide/#architecture-components","text":"The Gemforce platform consists of the following major components: Blockchain Smart Contracts Diamond contracts (EIP-2535 implementation) Identity management contracts Token management contracts Carbon credit contracts Cloud Services Parse Server backend Database (MongoDB) File storage Cloud functions External Service Integrations DFNS wallet-as-a-service Bridge API SendGrid email service Blockchain RPC providers Client Applications Web applications Mobile applications API integrations","title":"Architecture Components"},{"location":"gemforce-administrator-guide/#component-relationships","text":"The Gemforce system follows a layered architecture: Client Applications \u2193\u2191 Cloud Services (Parse Server) \u2193\u2191 External Services \u27f7 Blockchain Contracts Client applications interact with the Parse Server via REST API Parse Server executes cloud functions that interact with blockchain contracts and external services External services provide specialized functionality (wallet management, financial operations, etc.) Blockchain contracts store and manage on-chain data and logic","title":"Component Relationships"},{"location":"gemforce-administrator-guide/#infrastructure-requirements","text":"Blockchain Nodes : Access to Ethereum-compatible blockchain nodes Server Hardware : Minimum: 4 CPU cores, 8GB RAM, 100GB SSD Recommended: 8 CPU cores, 16GB RAM, 250GB SSD Database : MongoDB 4.4+ Network : Reliable internet connection with low latency to blockchain nodes SSL Certificate : Valid SSL certificate for secure API access","title":"Infrastructure Requirements"},{"location":"gemforce-administrator-guide/#security-model-overview","text":"Gemforce implements a multi-layered security approach: Authentication and Authorization User authentication via Parse Server Role-based access control API key authentication for B2B integrations DFNS WebAuthn for wallet operations Smart Contract Security Role-based access control Function-level permissions Upgradeability via Diamond pattern Data Protection Encrypted data at rest TLS for data in transit Private key management via DFNS Monitoring and Auditing Comprehensive logging Activity tracking Alert systems","title":"Security Model Overview"},{"location":"gemforce-administrator-guide/#installation-and-configuration","text":"","title":"Installation and Configuration"},{"location":"gemforce-administrator-guide/#prerequisites","text":"Before installing Gemforce, ensure you have: Node.js 16.x or higher MongoDB 4.4 or higher Access to blockchain nodes (RPC endpoints) API keys for external services Domain name with SSL certificate Git access to the Gemforce repositories","title":"Prerequisites"},{"location":"gemforce-administrator-guide/#environment-variables","text":"The Gemforce system requires several environment variables to be set. Create a .env file with the following variables: # Parse Server Configuration APP_ID = your_app_id MASTER_KEY = your_master_key DATABASE_URI = mongodb : // username : password @host : port / database SERVER_URL = https : // your - server - url . com / parse PROJECT_WIZARD_URL = https : // your - server - url . com # Blockchain Configuration ETH_NODE_URI_MAINNET = https : // mainnet . infura . io / v3 / your - key ETH_NODE_URI_BASESEP = https : // sepolia . base . org CHAIN_ID = base - sepolia METADATA_BASE_URI = https : // your - metadata - url . com / # DFNS Configuration DFNS_APP_ID = your_dfns_app_id DFNS_API_URL = https : // api . dfns . io DFNS_CRED_ID = your_dfns_credential_id DFNS_AUTH_TOKEN = your_dfns_auth_token # Bridge API Configuration BASE_BRIDGE_URL = https : // api . bridge - api . com BRIDGE_API_KEY = your_bridge_api_key # Email Configuration SENDGRID_API_KEY = your_sendgrid_key FROM_EMAIL = noreply @your - domain . com # Security Configuration AUTH_SECRET_KEY = your_auth_secret_key","title":"Environment Variables"},{"location":"gemforce-administrator-guide/#network-settings","text":"Firewall Configuration : Allow inbound connections on ports 80 (HTTP), 443 (HTTPS), and your Parse Server port Allow outbound connections to MongoDB, blockchain nodes, and external APIs Load Balancer Configuration (if applicable): Configure health checks to the Parse Server health endpoint Set appropriate timeouts (at least 30 seconds for blockchain operations) Enable SSL termination DNS Configuration : Set up A records for your domain Configure CNAME records for subdomains if needed","title":"Network Settings"},{"location":"gemforce-administrator-guide/#database-configuration","text":"MongoDB Setup : bash # Create a MongoDB user for the Gemforce database mongo admin -u admin -p admin use gemforce db.createUser({ user: \"gemforce_user\", pwd: \"secure_password\", roles: [{ role: \"readWrite\", db: \"gemforce\" }] }) Indexes : Ensure the following indexes are created for optimal performance: ```javascript // User collection indexes db.User.createIndex({ email: 1 }, { unique: true }) db.User.createIndex({ username: 1 }, { unique: true }) db.User.createIndex({ walletAddress: 1 }) // Identity collection indexes db.Identity.createIndex({ walletAddress: 1 }, { unique: true }) // Transaction collection indexes db.Transaction.createIndex({ hash: 1 }, { unique: true }) db.Transaction.createIndex({ user: 1 }) db.Transaction.createIndex({ createdAt: 1 }) ```","title":"Database Configuration"},{"location":"gemforce-administrator-guide/#external-service-connections","text":"DFNS Setup : Create a DFNS account at https://dashboard.dfns.io Create an application and credential Copy the App ID and Credential ID to your environment variables Store the private key in dfns_private.key Bridge API Setup : Obtain API credentials from Bridge API Configure webhooks for notifications (if needed) Set rate limiting based on expected traffic SendGrid Setup : Create a SendGrid account Set up sender authentication for your domain Create email templates for verification, password reset, etc. Generate API key and add to environment variables","title":"External Service Connections"},{"location":"gemforce-administrator-guide/#security-settings","text":"API Key Management : Rotate API keys periodically (recommended every 90 days) Store API keys securely using environment variables Never expose API keys in client-side code Cross-Origin Resource Sharing (CORS) : Configure CORS settings in the Parse Server configuration: javascript const corsConfig = { allowOrigin: ['https://your-domain.com', 'https://app.your-domain.com'], allowHeaders: ['X-Parse-Application-Id', 'X-Parse-REST-API-Key', 'Content-Type'], allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'] }; Rate Limiting : Configure rate limiting to prevent abuse: javascript const rateLimitConfig = { rateLimit: 1000, // requests per minute burstLimit: 50, // concurrent requests expiration: 60 // seconds until reset };","title":"Security Settings"},{"location":"gemforce-administrator-guide/#user-management","text":"","title":"User Management"},{"location":"gemforce-administrator-guide/#user-roles-and-permissions","text":"Gemforce implements role-based access control with the following default roles: Admin : Full access to all functions Can manage users and roles Can deploy and update contracts CentralAuthority : Can manage trusted issuers Can add claim topics Can manage identities TrustedIssuer : Can issue claims to identities Can verify identities Limited access to identity management User : Can manage own wallet Can view own transactions Can participate in marketplace","title":"User Roles and Permissions"},{"location":"gemforce-administrator-guide/#adding-and-removing-users","text":"","title":"Adding and Removing Users"},{"location":"gemforce-administrator-guide/#adding-users","text":"Via Admin Dashboard : Navigate to User Management Click \"Add User\" Enter user details (email, name, role) System will send invitation email Via API : ```javascript // Example using Parse JavaScript SDK const user = new Parse.User(); user.set(\"username\", \"user@example.com\"); user.set(\"password\", \"securePassword\"); user.set(\"email\", \"user@example.com\"); user.set(\"firstName\", \"John\"); user.set(\"lastName\", \"Doe\"); await user.signUp(); ``` Via Cloud Function : javascript // Using the registerUser cloud function Parse.Cloud.run(\"registerUser\", { username: \"user@example.com\", password: \"securePassword\", email: \"user@example.com\", firstName: \"John\", lastName: \"Doe\", company: \"Example Inc\" });","title":"Adding Users"},{"location":"gemforce-administrator-guide/#removing-users","text":"Via Admin Dashboard : Navigate to User Management Select user(s) to remove Click \"Delete\" or \"Deactivate\" Via API : javascript // Example using Parse JavaScript SDK const query = new Parse.Query(Parse.User); query.equalTo(\"email\", \"user@example.com\"); const user = await query.first({ useMasterKey: true }); await user.destroy({ useMasterKey: true });","title":"Removing Users"},{"location":"gemforce-administrator-guide/#role-assignment","text":"Assigning Roles to Users : ```javascript // Example using Parse JavaScript SDK const userQuery = new Parse.Query(Parse.User); userQuery.equalTo(\"email\", \"user@example.com\"); const user = await userQuery.first({ useMasterKey: true }); const roleQuery = new Parse.Query(Parse.Role); roleQuery.equalTo(\"name\", \"TrustedIssuer\"); const role = await roleQuery.first({ useMasterKey: true }); role.getUsers().add(user); await role.save(null, { useMasterKey: true }); ``` Creating New Roles : ```javascript // Example using Parse JavaScript SDK const acl = new Parse.ACL(); acl.setPublicReadAccess(true); const role = new Parse.Role(\"CustomRole\", acl); await role.save(null, { useMasterKey: true }); ```","title":"Role Assignment"},{"location":"gemforce-administrator-guide/#identity-verification-processes","text":"KYC Verification : Initiate via generateKycLink cloud function User completes KYC via Bridge API Webhook notification sent back to Gemforce Identity status updated accordingly Trusted Issuer Verification : Trusted Issuer reviews identity information Issues verification claim to user identity Claim is written to blockchain Identity state is updated to \"verified\"","title":"Identity Verification Processes"},{"location":"gemforce-administrator-guide/#managing-trusted-issuers","text":"Adding a Trusted Issuer : ```javascript // Using the dfnsAddTrustedIssuerInit/Complete cloud functions const { challenge, requestBody } = await Parse.Cloud.run(\"dfnsAddTrustedIssuerInit\", { trustedIssuer: \"0x1234...\", // Issuer wallet address claimTopics: [1, 2, 3], // Claim topics this issuer can verify walletId: \"wallet_id\", dfns_token: \"dfns_token\" }); // Sign the challenge client-side const signedChallenge = await signChallenge(challenge); // Complete the transaction await Parse.Cloud.run(\"dfnsAddTrustedIssuerComplete\", { walletId: \"wallet_id\", dfns_token: \"dfns_token\", signedChallenge: signedChallenge, requestBody: requestBody }); ``` Removing a Trusted Issuer : Use the dfnsRemoveTrustedIssuerInit/Complete cloud functions following the same pattern as above. Updating Trusted Issuer Claim Topics : Use the dfnsUpdateIssuerClaimTopicsInit/Complete cloud functions.","title":"Managing Trusted Issuers"},{"location":"gemforce-administrator-guide/#monitoring-and-alerts","text":"","title":"Monitoring and Alerts"},{"location":"gemforce-administrator-guide/#system-health-checks","text":"Parse Server Health Check : Endpoint: /parse/health Expected response: {\"status\":\"ok\"} Monitor response time (should be < 200ms) Database Health Check : Query execution time Connection pool status Replica set status (if applicable) Blockchain Connectivity : RPC endpoint response time Block height synchronization Transaction submission success rate","title":"System Health Checks"},{"location":"gemforce-administrator-guide/#performance-metrics","text":"Key metrics to monitor: API Performance : Request latency (avg, p95, p99) Request throughput Error rate Database Performance : Query execution time Index usage Connection count Blockchain Performance : Gas costs per transaction type Transaction confirmation time Failed transaction rate","title":"Performance Metrics"},{"location":"gemforce-administrator-guide/#log-management","text":"Log Aggregation : Implement centralized logging (e.g., ELK Stack, Splunk) Include correlation IDs across service boundaries Implement structured logging for easier querying Log Levels : ERROR: Issues requiring immediate attention WARN: Potential issues to investigate INFO: Normal operations DEBUG: Detailed information for troubleshooting Key Events to Log : Authentication events User management operations Blockchain transactions External API calls","title":"Log Management"},{"location":"gemforce-administrator-guide/#alert-configuration","text":"Configure alerts for the following scenarios: Critical Alerts (immediate action required): Parse Server unavailability Database connection failures High error rates (>5%) Failed blockchain transactions Warning Alerts (investigation needed): Elevated API latency (>500ms) Increased error rates (>1%) Low disk space (<20%) Delayed blockchain confirmations Notification Channels : Email SMS/Text Slack/Teams PagerDuty or similar service","title":"Alert Configuration"},{"location":"gemforce-administrator-guide/#common-warning-signs","text":"Watch for these indicators of potential issues: Increasing API Latency : May indicate database issues or resource constraints Growing Database Size : May require indexing or cleanup Increasing Error Rates : May indicate bugs or external service issues Blockchain Transaction Failures : May indicate gas price issues or contract bugs Declining User Activity : May indicate UX issues or service degradation","title":"Common Warning Signs"},{"location":"gemforce-administrator-guide/#dashboards-setup","text":"Implement monitoring dashboards that show: System Overview : Overall health status Current alert status Key metrics summary API Performance : Request volume Response time by endpoint Error rate by endpoint User Activity : Active users Registration rate Transaction volume Blockchain Activity : Transaction success rate Gas costs Contract interactions","title":"Dashboards Setup"},{"location":"gemforce-administrator-guide/#backup-and-recovery","text":"","title":"Backup and Recovery"},{"location":"gemforce-administrator-guide/#backup-procedures","text":"Database Backups : ```bash # MongoDB backup command mongodump --uri=\"mongodb://username:password@host:port/database\" --out=/backup/path/$(date +%Y-%m-%d) # Compress the backup tar -zcvf /backup/path/$(date +%Y-%m-%d).tar.gz /backup/path/$(date +%Y-%m-%d) ``` Schedule : - Full backup: Daily - Incremental backup: Hourly Configuration Backups : bash # Back up environment variables and config files cp .env /backup/config/$(date +%Y-%m-%d)-env cp gemforce.config.ts /backup/config/$(date +%Y-%m-%d)-gemforce-config.ts Schedule : After any configuration change Contract Deployment Records : bash # Back up deployment records cp ./deployments /backup/deployments/$(date +%Y-%m-%d) -r cp deployed.json /backup/deployments/$(date +%Y-%m-%d)-deployed.json Schedule : After any contract deployment","title":"Backup Procedures"},{"location":"gemforce-administrator-guide/#recovery-procedures","text":"Database Recovery : bash # Restore MongoDB database mongorestore --uri=\"mongodb://username:password@host:port/database\" --drop /backup/path/YYYY-MM-DD Configuration Recovery : bash # Restore configuration files cp /backup/config/YYYY-MM-DD-env .env cp /backup/config/YYYY-MM-DD-gemforce-config.ts gemforce.config.ts Contract Redeployment : Restore deployment records Use the DiamondFactory to recreate diamonds if needed Verify contract states","title":"Recovery Procedures"},{"location":"gemforce-administrator-guide/#disaster-recovery-planning","text":"Disaster Recovery Scenarios : Database corruption Server hardware failure Cloud provider outage Security breach Recovery Time Objectives (RTO) : Critical systems: 4 hours Non-critical systems: 24 hours Recovery Point Objectives (RPO) : Database: 1 hour Configuration: 24 hours Disaster Recovery Runbook : Maintain up-to-date documentation Conduct periodic recovery tests Automate recovery procedures where possible","title":"Disaster Recovery Planning"},{"location":"gemforce-administrator-guide/#security-management","text":"","title":"Security Management"},{"location":"gemforce-administrator-guide/#access-control","text":"API Key Management : Generate strong API keys (min 32 characters) Store securely (environment variables, secret management service) Implement key rotation (90-day cycle) Revoke compromised keys immediately User Authentication Controls : Enforce strong password policies Implement account lockout after failed attempts Consider implementing MFA for admin accounts Session timeout (default: 24 hours) Role-Based Access Control : Limit permissions to minimum required Regularly audit role assignments Implement principle of least privilege","title":"Access Control"},{"location":"gemforce-administrator-guide/#api-key-rotation","text":"Implement a process for rotating API keys: // Example: Rotate Bridge API key async function rotateBridgeAPIKey () { // Generate a new API key (provider-specific) const newKey = await generateNewBridgeAPIKey (); // Update environment variable process . env . BRIDGE_API_KEY = newKey ; // Update configuration in database const config = await Config . get ( \"bridgeAPIKey\" ); config . set ( \"value\" , newKey ); await config . save ( null , { useMasterKey : true }); // Log the rotation console . log ( `Bridge API key rotated at ${ new Date (). toISOString () } ` ); }","title":"API Key Rotation"},{"location":"gemforce-administrator-guide/#audit-logging","text":"Security Events to Log : Authentication attempts (successful and failed) Authorization changes User creation/deletion Role assignment API key usage Admin actions Log Format : json { \"timestamp\": \"2025-02-25T13:51:49.123Z\", \"event\": \"user.login\", \"success\": true, \"userId\": \"user123\", \"ipAddress\": \"192.168.1.1\", \"userAgent\": \"Mozilla/5.0...\", \"additionalDetails\": {} } Log Retention : Security logs: 12 months minimum Normal operation logs: 3 months","title":"Audit Logging"},{"location":"gemforce-administrator-guide/#security-incident-response","text":"Incident Classification : P1: Critical (data breach, service unavailable) P2: High (limited breach, partial service degradation) P3: Medium (minor security issue, limited impact) P4: Low (potential vulnerability, no active exploitation) Response Procedure : Identify and classify the incident Contain the incident Eradicate the cause Recover systems Conduct post-incident analysis Contact List : Security team IT operations Legal department Executive leadership External security consultants (if applicable)","title":"Security Incident Response"},{"location":"gemforce-administrator-guide/#compliance-considerations","text":"Data Privacy : Identify personal data stored in the system Implement data minimization Configure data retention policies Provide data export/deletion capabilities Regulatory Compliance : KYC/AML requirements Financial regulations Industry-specific regulations Cross-border data transfer requirements","title":"Compliance Considerations"},{"location":"gemforce-administrator-guide/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"gemforce-administrator-guide/#common-issues-and-solutions","text":"API Request Failures : Symptom : HTTP 400/500 errors Check : API logs, request parameters Solution : Verify request format, check server logs for details Blockchain Transaction Failures : Symptom : Transaction hash returned but transaction fails Check : Gas price, contract state, transaction parameters Solution : Adjust gas price, verify contract accepts the transaction Database Connection Issues : Symptom : Cannot connect to database error Check : MongoDB status, network connectivity Solution : Restart MongoDB, check firewall rules DFNS Integration Issues : Symptom : \"Cannot sign transaction\" errors Check : DFNS credentials, WebAuthn support Solution : Verify DFNS credentials, ensure browser supports WebAuthn","title":"Common Issues and Solutions"},{"location":"gemforce-administrator-guide/#diagnostic-tools","text":"Log Analysis : ```bash # Search for errors in logs grep \"ERROR\" /var/log/gemforce/app.log # Find recent activity for a specific user grep \"userId\\\":\\\"user123\" /var/log/gemforce/app.log ``` Database Queries : ```javascript // Check user status db.User.findOne({ email: \"user@example.com\" }) // Look for recent errors db.ErrorLog.find().sort({ createdAt: -1 }).limit(10) ``` Blockchain Explorers : Use block explorers to verify transaction status Check contract events for expected emissions Verify contract state after transactions","title":"Diagnostic Tools"},{"location":"gemforce-administrator-guide/#error-codes-explanation","text":"HTTP Status Codes : 400: Bad Request (invalid parameters) 401: Unauthorized (missing/invalid authentication) 403: Forbidden (insufficient permissions) 404: Not Found (resource doesn't exist) 429: Too Many Requests (rate limit exceeded) 500: Internal Server Error (server-side issue) Parse Error Codes : 101: Object not found 141: Missing required field 209: Invalid session token Blockchain Error Codes : \"gas required exceeds allowance\": Insufficient gas \"execution reverted\": Contract condition not met \"nonce too low\": Transaction nonce issue","title":"Error Codes Explanation"},{"location":"gemforce-administrator-guide/#support-escalation-procedures","text":"Tier 1 Support : Initial triage Common issue resolution Escalation timeframe: 30 minutes Tier 2 Support : Technical investigation Complex issue resolution Escalation timeframe: 2 hours Tier 3 Support : Engineering team involvement Critical issue resolution Escalation timeframe: 4 hours Escalation Contact Information : Tier 1: support@gemforce.com Tier 2: tech-support@gemforce.com Tier 3: engineering@gemforce.com Emergency: +1-555-123-4567","title":"Support Escalation Procedures"},{"location":"gemforce-administrator-guide/#service-dependencies","text":"Map of service dependencies to check during outages: Parse Server depends on : MongoDB File storage DFNS API Bridge API Blockchain RPC nodes Blockchain operations depend on : RPC node availability Gas price oracle Contract state User authentication depends on : Parse Server Email service DFNS (for wallet operations)","title":"Service Dependencies"},{"location":"gemforce-administrator-guide/#maintenance-procedures","text":"","title":"Maintenance Procedures"},{"location":"gemforce-administrator-guide/#routine-maintenance-tasks","text":"Daily Tasks : Review error logs Check backup status Monitor system performance Weekly Tasks : Analyze API usage patterns Review security logs Check disk space usage Monthly Tasks : User access review API key rotation Performance optimization Database maintenance","title":"Routine Maintenance Tasks"},{"location":"gemforce-administrator-guide/#update-procedures","text":"Parse Server Updates : ```bash # Update Parse Server npm update parse-server # Restart Parse Server pm2 restart parse-server ``` Node.js Updates : ```bash # Update Node.js using NVM nvm install 16.x nvm use 16.x # Verify version node -v ``` Cloud Function Updates : ```bash # Pull latest changes git pull origin main # Install dependencies npm install # Build the project npm run build # Restart the server pm2 restart gemforce ```","title":"Update Procedures"},{"location":"gemforce-administrator-guide/#database-optimization","text":"Index Optimization : ```javascript // Analyze query performance db.User.find({ walletAddress: { $exists: true } }).explain(\"executionStats\") // Add missing indexes db.User.createIndex({ walletAddress: 1 }) ``` Data Archiving : ```javascript // Move old logs to archive collection db.SystemLog.aggregate([ { $match: { createdAt: { $lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) } } }, { $out: \"SystemLogArchive\" } ]) // Remove archived logs db.SystemLog.deleteMany({ createdAt: { $lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) } }) ``` Database Maintenance : ```javascript // Repair database db.repairDatabase() // Compact collections db.runCommand({ compact: \"User\" }) ```","title":"Database Optimization"},{"location":"gemforce-administrator-guide/#cache-management","text":"Redis Cache Configuration (if applicable): javascript // Example cache configuration const redisCache = { host: \"localhost\", port: 6379, ttl: 600 // 10 minutes }; Cache Invalidation : ```javascript // Invalidate specific keys redisClient.del(\"user_123_profile\") // Invalidate pattern redisClient.keys(\"user_*_profile\", (err, keys) => { if (keys.length > 0) redisClient.del(keys); }) ``` Cache Monitoring : ```bash # Check Redis info redis-cli info # Monitor cache hit rate redis-cli info stats | grep hit_rate ```","title":"Cache Management"},{"location":"gemforce-administrator-guide/#system-scaling-procedures","text":"Horizontal Scaling : Add more Parse Server instances Configure load balancer Update DNS if needed Vertical Scaling : Upgrade server resources Schedule downtime for migration Verify performance after upgrade Database Scaling : Implement MongoDB replica set Consider sharding for large deployments Optimize query patterns","title":"System Scaling Procedures"},{"location":"gemforce-administrator-guide/#performance-optimization","text":"","title":"Performance Optimization"},{"location":"gemforce-administrator-guide/#database-tuning","text":"Query Optimization : Use explain plan to analyze queries Ensure proper indexes are in place Limit returned fields using projection Use aggregation pipeline for complex queries Connection Pooling : javascript // Example MongoDB connection pool configuration const mongoConfig = { uri: process.env.DATABASE_URI, options: { maxPoolSize: 50, minPoolSize: 10, socketTimeoutMS: 30000, connectTimeoutMS: 30000 } }; Index Analysis : ```javascript // Check index usage db.User.aggregate([ { $indexStats: {} } ]) // Remove unused indexes db.User.dropIndex(\"unusedIndex\") ```","title":"Database Tuning"},{"location":"gemforce-administrator-guide/#cache-configuration","text":"Cacheable Data Types : User profiles Contract metadata Configuration settings Static content Cache Strategy : Cache-aside: Application checks cache before database TTL-based expiration Event-based invalidation Example Redis Configuration : javascript // Redis cache configuration const redisOptions = { host: process.env.REDIS_HOST || \"localhost\", port: process.env.REDIS_PORT || 6379, password: process.env.REDIS_PASSWORD, db: 0, ttl: 3600 // 1 hour };","title":"Cache Configuration"},{"location":"gemforce-administrator-guide/#rate-limiting-configuration","text":"API Rate Limits : javascript // Example rate limiting configuration const rateLimits = { global: { windowMs: 60 * 1000, // 1 minute max: 1000 // limit each IP to 1000 requests per minute }, login: { windowMs: 60 * 1000, // 1 minute max: 10 // limit each IP to 10 login attempts per minute }, createUser: { windowMs: 60 * 60 * 1000, // 1 hour max: 50 // limit each IP to 50 user creations per hour } }; Rate Limit Response : javascript // Example rate limit exceeded response { \"status\": \"error\", \"code\": 429, \"message\": \"Rate limit exceeded. Try again in X seconds.\", \"retryAfter\": 30 } Rate Limit Monitoring : Track rate limit hits Alert on sustained high rejection rates Analyze traffic patterns to adjust limits","title":"Rate Limiting Configuration"},{"location":"gemforce-administrator-guide/#resource-allocation-guidelines","text":"Server Resources : Guidelines for allocating resources based on load: Load Level Users API Requests/min CPU Cores RAM Disk Small <1k <100 2 4GB 20GB Medium <10k <1k 4 8GB 50GB Large <100k <10k 8 16GB 100GB X-Large >100k >10k 16+ 32GB+ 200GB+ Database Resources : Guidelines for MongoDB resources: Load Level Documents Indexes RAM Disk Small <1M <20 2GB 10GB Medium <10M <50 4GB 50GB Large <100M <100 16GB 200GB X-Large >100M >100 32GB+ 500GB+ Blockchain Node Resources : Consider using managed node providers for production environments. If running your own nodes: Network Disk RAM Notes Ethereum >2TB 16GB Full node, growing rapidly BaseSepolia >100GB 8GB Testnet, moderate growth Resource Scaling Triggers : CPU usage consistently >70% RAM usage consistently >80% Disk usage >85% Response time increasing trend Error rate increasing trend","title":"Resource Allocation Guidelines"},{"location":"gemforce-api-documentation/","text":"Gemforce API Documentation \u00b6 This document provides a comprehensive overview of the Gemforce API, detailing both the smart contract interfaces and cloud functions that power the system. Table of Contents \u00b6 Introduction Smart Contract APIs Diamond Pattern DiamondFactory Identity Management Token and Asset Management Marketplace Carbon Credits Cloud Function APIs Authentication Functions Blockchain Management Contract Interaction DFNS Wallet Management Bridge API Integration Project Management Introduction \u00b6 Gemforce is a blockchain-powered platform that implements a Diamond pattern (EIP-2535) for upgradeable smart contracts, digital identity management, and token management. The platform combines on-chain smart contracts with off-chain cloud functions to provide a comprehensive solution for issuing, managing, and trading digital assets with verifiable claims. Smart Contract APIs \u00b6 Diamond Pattern \u00b6 The Diamond pattern is the foundation of Gemforce's smart contract architecture. It provides a way to create upgradeable contracts that can be extended with new functionality without breaking existing functionality. Diamond.sol \u00b6 The Diamond contract is the main contract that implements the Diamond pattern. Key functions: initialize(address _owner, DiamondSettings memory params, IDiamondCut.FacetCut[] memory _facets, address diamondInit, bytes calldata _calldata) : Initialize the diamond with owner, settings, and facets. diamondCut(IDiamondCut.FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) : Add, replace, or remove functions from the diamond. facets() : Get all facets and their selectors. facetFunctionSelectors(address _facet) : Get all function selectors for a facet. facetAddresses() : Get all facet addresses used by a diamond. facetAddress(bytes4 _functionSelector) : Get the facet that supports a given selector. transferOwnership(address _newOwner) : Transfer ownership of the diamond. owner() : Get the owner of the diamond. DiamondFactory \u00b6 The DiamondFactory contract is used to create new Diamond contracts. Key functions: initialize(DiamondFactoryInit memory initData) : Initialize the factory with a set of facets. getFacets(string memory facetSet) : Get the facets for a facet set. setFacet(string memory facetSet, uint256 idx, IDiamondCut.FacetCut memory facetAddress) : Set a facet in a facet set. setFacets(string memory facetSet, IDiamondCut.FacetCut[] memory facetAddress) : Set multiple facets in a facet set. removeFacets(string memory facetSet) : Remove a facet set. getDiamondAddress(string memory symbol) : Get the address of a diamond by symbol. create(DiamondSettings memory params, address diamondInit, bytes calldata _calldata, IDiamondCut.FacetCut[] memory facets) : Create a new diamond with custom facets. createFromSet(DiamondSettings memory params, address diamondInit, bytes calldata _calldata, string memory facets) : Create a new diamond from a predefined facet set. add(string memory symbol, address payable diamondAddress) : Add an existing diamond to the factory. remove(string memory symbol) : Remove a diamond from the factory. exists(string memory symbol) : Check if a diamond exists. symbols() : Get all diamond symbols in the factory. Identity Management \u00b6 Gemforce includes a digital identity system that allows for claims to be made about identities. Identity.sol \u00b6 The Identity contract represents a digital identity for a user. Key functions: initialize(address _owner, address _identityRegistry, address _trustedIssuerRegistry) : Initialize the identity with an owner, identity registry, and trusted issuer registry. getAttribute(string memory _key) : Get an attribute for a token ID keyed by string. setAttribute(string memory key, AttributeType attributeType, string memory value) : Set an attribute for a token ID. addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) : Add a key to the identity. removeKey(bytes32 _key, uint256 _purpose) : Remove a key from the identity. getKey(bytes32 _key) : Get a key from the identity. addClaim(uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) : Add a claim to the identity. removeClaim(bytes32 _claimId) : Remove a claim from the identity. getClaim(bytes32 _claimId) : Get a claim by ID. getClaimIdsByTopic(uint256 _topic) : Get claim IDs by topic. getClaimTopics() : Get all claim topics for the identity. isVerified() : Check if the identity is verified. IdentityFactory.sol \u00b6 The IdentityFactory contract creates new Identity contracts. Key functions: initialize(address identityRegistry, address trustedIssuerRegistry) : Initialize the factory with identity and trusted issuer registries. createIdentity(address ownerAddress) : Create a new identity for an owner. removeIdentity(address ownerAddress) : Remove an identity for an owner. getIdentity(address identityOwner) : Get the identity of an owner. getIdentityUsers() : Get all identity users. ClaimTopicsRegistryFacet.sol \u00b6 Manages claim topics that can be used to make claims about identities. Key functions: addClaimTopic(uint256 _claimTopic) : Add a claim topic to the registry. removeClaimTopic(uint256 _claimTopic) : Remove a claim topic from the registry. getClaimTopics() : Get all claim topics. TrustedIssuersRegistryFacet.sol \u00b6 Manages trusted issuers that can make claims about identities. Key functions: addTrustedIssuer(address _trustedIssuer, uint256[] calldata _claimTopics) : Add a trusted issuer with claim topics. removeTrustedIssuer(address _trustedIssuer) : Remove a trusted issuer. updateIssuerClaimTopics(address _trustedIssuer, uint256[] calldata _claimTopics) : Update claim topics for a trusted issuer. getTrustedIssuers() : Get all trusted issuers. getTrustedIssuerClaimTopics(address _trustedIssuer) : Get claim topics for a trusted issuer. isTrustedIssuer(address _issuer) : Check if an address is a trusted issuer. hasClaimTopic(address _trustedIssuer, uint256 _claimTopic) : Check if a trusted issuer has a claim topic. Token and Asset Management \u00b6 GemforceMinterFacet.sol \u00b6 The GemforceMinterFacet contract is used to mint tokens and set attributes. Key functions: gemforceMint(Attribute[] memory metadata) : Mint a new token with metadata. Marketplace \u00b6 MarketplaceFacet.sol \u00b6 The MarketplaceFacet contract provides functionality for buying and selling tokens. Key functions: purchaseItem(address contract, uint256 tokenId) : Purchase a token. Carbon Credits \u00b6 CarbonCreditFacet.sol \u00b6 The CarbonCreditFacet contract provides functionality for managing carbon credits. Key functions: retireCarbonCredits(uint256 tokenId, uint256 amount) : Retire carbon credits for a token. Cloud Function APIs \u00b6 Gemforce provides a set of cloud functions built on Parse Server that bridge the gap between client applications and the blockchain. Authentication Functions \u00b6 User Registration and Management \u00b6 registerUser : Register a new user with username, password, email, company, and name. verifyEmail : Verify a user's email with a token. retrieveEmailFromToken : Get the email associated with a token. requestPasswordReset : Request a password reset for a user. resetPassword : Reset a user's password with a token. updateUserByEmail : Update a user's profile by email. isUserOnboarded : Check if a user has completed onboarding. getUsersWithIdentityWallets : Get users who have identity wallets. Blockchain Management \u00b6 Network and Provider Management \u00b6 loadAllBlockchains : Get all configured blockchains. loadProviderUrl : Get the RPC endpoint for a network ID. loadProviderWebSocketUrl : Get the WebSocket endpoint for a network ID. loadAllProviderUrls : Get all provider URLs. loadBlockchainDataForNetwork : Get blockchain data (signer, provider, wallet) for a network. Contract Interaction \u00b6 Generic Contract Interaction \u00b6 addDiamondFacet : Add a facet to a diamond. callMethod : Call a method on a contract. viewMethod : View a method on a contract. callContractMethod : Call a method on a contract with custom parameters. viewContractMethod : View a method on a contract with custom parameters. loadSmartContractForNetwork : Load a smart contract for a network. loadSmartContractsForNetwork : Load all smart contracts for a network. DFNS Wallet Management \u00b6 DFNS is a wallet-as-a-service solution integrated with Gemforce for managing user wallets. User Registration and Authentication \u00b6 registerInit : Initialize DFNS user registration. registerComplete : Complete DFNS user registration. login : Login to DFNS. recoverInit : Initialize account recovery for DFNS. recoverComplete : Complete account recovery for DFNS. Wallet Management \u00b6 listWallets : List DFNS wallets. signaturesInit : Initialize a signature. signaturesComplete : Complete a signature. dfnsGetWallet : Get a DFNS wallet by ID. dfnsGetUSDC : Get USDC balance for a wallet. Transaction Management \u00b6 dfnsInitApproval / dfnsCompleteApproval : Approve tokens for spending. dfnsInitTransferUSDC / dfnsCompleteTransferUSDC : Transfer USDC. dfnsInitWithdraw / dfnsCompleteWithdraw : Withdraw tokens from the treasury. dfnsInitiatePurchase / dfnsCompletePurchase : Purchase an item from the marketplace. dfnsInitRetireCredits / dfnsCompleteRetireCredits : Retire carbon credits. Identity Management \u00b6 dfnsAddClaimTopicInit / dfnsAddClaimTopicComplete : Add a claim topic. dfnsAddTrustedIssuerInit / dfnsAddTrustedIssuerComplete : Add a trusted issuer. dfnsRemoveTrustedIssuerInit / dfnsRemoveTrustedIssuerComplete : Remove a trusted issuer. dfnsUpdateIssuerClaimTopicsInit / dfnsUpdateIssuerClaimTopicsComplete : Update claim topics for an issuer. dfnsCreateIdentityInit / dfnsCreateIdentityComplete : Create a digital identity. dfnsAddIdentityInit / dfnsAddIdentityComplete : Add an identity to the registry. dfnsRemoveIdentityInit / dfnsRemoveIdentityComplete : Remove an identity from the factory. dfnsUnregisterIdentityInit / dfnsUnregisterIdentityComplete : Remove an identity from the registry. dfnsSetClaimsInit / dfnsSetClaimsComplete : Set claims for an identity. dfnsAddClaimInit / dfnsAddClaimComplete : Add a claim to an identity. dfnsRemoveClaimInit / dfnsRemoveClaimComplete : Remove a claim from an identity. dfnsGetIdentity : Get the identity for an owner address. Asset Management \u00b6 dfnsGemforceMintInit / dfnsGemforceMintComplete : Mint a new token with metadata. Bridge API Integration \u00b6 Gemforce integrates with a Bridge API for handling financial operations. External Accounts \u00b6 createExternalAccount : Create an external account for a customer. getExternalAccounts : Get all external accounts for a customer. getExternalAccount : Get a specific external account for a customer. deleteExternalAccount : Delete an external account. Transfers \u00b6 createTransfer : Create a transfer between accounts. getCustomerTransfers : Get all transfers for a customer. KYC Management \u00b6 generateKycLink : Generate a KYC link for a user. getKycLinkStatus : Get the status of a KYC link. Plaid Integration \u00b6 getPlaidLinkToken : Get a Plaid link token for a customer. exchangePlaidPublicToken : Exchange a Plaid public token for access. Project Management \u00b6 getProjectMetadata : Get metadata for a project.","title":"Full API Reference"},{"location":"gemforce-api-documentation/#gemforce-api-documentation","text":"This document provides a comprehensive overview of the Gemforce API, detailing both the smart contract interfaces and cloud functions that power the system.","title":"Gemforce API Documentation"},{"location":"gemforce-api-documentation/#table-of-contents","text":"Introduction Smart Contract APIs Diamond Pattern DiamondFactory Identity Management Token and Asset Management Marketplace Carbon Credits Cloud Function APIs Authentication Functions Blockchain Management Contract Interaction DFNS Wallet Management Bridge API Integration Project Management","title":"Table of Contents"},{"location":"gemforce-api-documentation/#introduction","text":"Gemforce is a blockchain-powered platform that implements a Diamond pattern (EIP-2535) for upgradeable smart contracts, digital identity management, and token management. The platform combines on-chain smart contracts with off-chain cloud functions to provide a comprehensive solution for issuing, managing, and trading digital assets with verifiable claims.","title":"Introduction"},{"location":"gemforce-api-documentation/#smart-contract-apis","text":"","title":"Smart Contract APIs"},{"location":"gemforce-api-documentation/#diamond-pattern","text":"The Diamond pattern is the foundation of Gemforce's smart contract architecture. It provides a way to create upgradeable contracts that can be extended with new functionality without breaking existing functionality.","title":"Diamond Pattern"},{"location":"gemforce-api-documentation/#diamondsol","text":"The Diamond contract is the main contract that implements the Diamond pattern. Key functions: initialize(address _owner, DiamondSettings memory params, IDiamondCut.FacetCut[] memory _facets, address diamondInit, bytes calldata _calldata) : Initialize the diamond with owner, settings, and facets. diamondCut(IDiamondCut.FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) : Add, replace, or remove functions from the diamond. facets() : Get all facets and their selectors. facetFunctionSelectors(address _facet) : Get all function selectors for a facet. facetAddresses() : Get all facet addresses used by a diamond. facetAddress(bytes4 _functionSelector) : Get the facet that supports a given selector. transferOwnership(address _newOwner) : Transfer ownership of the diamond. owner() : Get the owner of the diamond.","title":"Diamond.sol"},{"location":"gemforce-api-documentation/#diamondfactory","text":"The DiamondFactory contract is used to create new Diamond contracts. Key functions: initialize(DiamondFactoryInit memory initData) : Initialize the factory with a set of facets. getFacets(string memory facetSet) : Get the facets for a facet set. setFacet(string memory facetSet, uint256 idx, IDiamondCut.FacetCut memory facetAddress) : Set a facet in a facet set. setFacets(string memory facetSet, IDiamondCut.FacetCut[] memory facetAddress) : Set multiple facets in a facet set. removeFacets(string memory facetSet) : Remove a facet set. getDiamondAddress(string memory symbol) : Get the address of a diamond by symbol. create(DiamondSettings memory params, address diamondInit, bytes calldata _calldata, IDiamondCut.FacetCut[] memory facets) : Create a new diamond with custom facets. createFromSet(DiamondSettings memory params, address diamondInit, bytes calldata _calldata, string memory facets) : Create a new diamond from a predefined facet set. add(string memory symbol, address payable diamondAddress) : Add an existing diamond to the factory. remove(string memory symbol) : Remove a diamond from the factory. exists(string memory symbol) : Check if a diamond exists. symbols() : Get all diamond symbols in the factory.","title":"DiamondFactory"},{"location":"gemforce-api-documentation/#identity-management","text":"Gemforce includes a digital identity system that allows for claims to be made about identities.","title":"Identity Management"},{"location":"gemforce-api-documentation/#identitysol","text":"The Identity contract represents a digital identity for a user. Key functions: initialize(address _owner, address _identityRegistry, address _trustedIssuerRegistry) : Initialize the identity with an owner, identity registry, and trusted issuer registry. getAttribute(string memory _key) : Get an attribute for a token ID keyed by string. setAttribute(string memory key, AttributeType attributeType, string memory value) : Set an attribute for a token ID. addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) : Add a key to the identity. removeKey(bytes32 _key, uint256 _purpose) : Remove a key from the identity. getKey(bytes32 _key) : Get a key from the identity. addClaim(uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) : Add a claim to the identity. removeClaim(bytes32 _claimId) : Remove a claim from the identity. getClaim(bytes32 _claimId) : Get a claim by ID. getClaimIdsByTopic(uint256 _topic) : Get claim IDs by topic. getClaimTopics() : Get all claim topics for the identity. isVerified() : Check if the identity is verified.","title":"Identity.sol"},{"location":"gemforce-api-documentation/#identityfactorysol","text":"The IdentityFactory contract creates new Identity contracts. Key functions: initialize(address identityRegistry, address trustedIssuerRegistry) : Initialize the factory with identity and trusted issuer registries. createIdentity(address ownerAddress) : Create a new identity for an owner. removeIdentity(address ownerAddress) : Remove an identity for an owner. getIdentity(address identityOwner) : Get the identity of an owner. getIdentityUsers() : Get all identity users.","title":"IdentityFactory.sol"},{"location":"gemforce-api-documentation/#claimtopicsregistryfacetsol","text":"Manages claim topics that can be used to make claims about identities. Key functions: addClaimTopic(uint256 _claimTopic) : Add a claim topic to the registry. removeClaimTopic(uint256 _claimTopic) : Remove a claim topic from the registry. getClaimTopics() : Get all claim topics.","title":"ClaimTopicsRegistryFacet.sol"},{"location":"gemforce-api-documentation/#trustedissuersregistryfacetsol","text":"Manages trusted issuers that can make claims about identities. Key functions: addTrustedIssuer(address _trustedIssuer, uint256[] calldata _claimTopics) : Add a trusted issuer with claim topics. removeTrustedIssuer(address _trustedIssuer) : Remove a trusted issuer. updateIssuerClaimTopics(address _trustedIssuer, uint256[] calldata _claimTopics) : Update claim topics for a trusted issuer. getTrustedIssuers() : Get all trusted issuers. getTrustedIssuerClaimTopics(address _trustedIssuer) : Get claim topics for a trusted issuer. isTrustedIssuer(address _issuer) : Check if an address is a trusted issuer. hasClaimTopic(address _trustedIssuer, uint256 _claimTopic) : Check if a trusted issuer has a claim topic.","title":"TrustedIssuersRegistryFacet.sol"},{"location":"gemforce-api-documentation/#token-and-asset-management","text":"","title":"Token and Asset Management"},{"location":"gemforce-api-documentation/#gemforceminterfacetsol","text":"The GemforceMinterFacet contract is used to mint tokens and set attributes. Key functions: gemforceMint(Attribute[] memory metadata) : Mint a new token with metadata.","title":"GemforceMinterFacet.sol"},{"location":"gemforce-api-documentation/#marketplace","text":"","title":"Marketplace"},{"location":"gemforce-api-documentation/#marketplacefacetsol","text":"The MarketplaceFacet contract provides functionality for buying and selling tokens. Key functions: purchaseItem(address contract, uint256 tokenId) : Purchase a token.","title":"MarketplaceFacet.sol"},{"location":"gemforce-api-documentation/#carbon-credits","text":"","title":"Carbon Credits"},{"location":"gemforce-api-documentation/#carboncreditfacetsol","text":"The CarbonCreditFacet contract provides functionality for managing carbon credits. Key functions: retireCarbonCredits(uint256 tokenId, uint256 amount) : Retire carbon credits for a token.","title":"CarbonCreditFacet.sol"},{"location":"gemforce-api-documentation/#cloud-function-apis","text":"Gemforce provides a set of cloud functions built on Parse Server that bridge the gap between client applications and the blockchain.","title":"Cloud Function APIs"},{"location":"gemforce-api-documentation/#authentication-functions","text":"","title":"Authentication Functions"},{"location":"gemforce-api-documentation/#user-registration-and-management","text":"registerUser : Register a new user with username, password, email, company, and name. verifyEmail : Verify a user's email with a token. retrieveEmailFromToken : Get the email associated with a token. requestPasswordReset : Request a password reset for a user. resetPassword : Reset a user's password with a token. updateUserByEmail : Update a user's profile by email. isUserOnboarded : Check if a user has completed onboarding. getUsersWithIdentityWallets : Get users who have identity wallets.","title":"User Registration and Management"},{"location":"gemforce-api-documentation/#blockchain-management","text":"","title":"Blockchain Management"},{"location":"gemforce-api-documentation/#network-and-provider-management","text":"loadAllBlockchains : Get all configured blockchains. loadProviderUrl : Get the RPC endpoint for a network ID. loadProviderWebSocketUrl : Get the WebSocket endpoint for a network ID. loadAllProviderUrls : Get all provider URLs. loadBlockchainDataForNetwork : Get blockchain data (signer, provider, wallet) for a network.","title":"Network and Provider Management"},{"location":"gemforce-api-documentation/#contract-interaction","text":"","title":"Contract Interaction"},{"location":"gemforce-api-documentation/#generic-contract-interaction","text":"addDiamondFacet : Add a facet to a diamond. callMethod : Call a method on a contract. viewMethod : View a method on a contract. callContractMethod : Call a method on a contract with custom parameters. viewContractMethod : View a method on a contract with custom parameters. loadSmartContractForNetwork : Load a smart contract for a network. loadSmartContractsForNetwork : Load all smart contracts for a network.","title":"Generic Contract Interaction"},{"location":"gemforce-api-documentation/#dfns-wallet-management","text":"DFNS is a wallet-as-a-service solution integrated with Gemforce for managing user wallets.","title":"DFNS Wallet Management"},{"location":"gemforce-api-documentation/#user-registration-and-authentication","text":"registerInit : Initialize DFNS user registration. registerComplete : Complete DFNS user registration. login : Login to DFNS. recoverInit : Initialize account recovery for DFNS. recoverComplete : Complete account recovery for DFNS.","title":"User Registration and Authentication"},{"location":"gemforce-api-documentation/#wallet-management","text":"listWallets : List DFNS wallets. signaturesInit : Initialize a signature. signaturesComplete : Complete a signature. dfnsGetWallet : Get a DFNS wallet by ID. dfnsGetUSDC : Get USDC balance for a wallet.","title":"Wallet Management"},{"location":"gemforce-api-documentation/#transaction-management","text":"dfnsInitApproval / dfnsCompleteApproval : Approve tokens for spending. dfnsInitTransferUSDC / dfnsCompleteTransferUSDC : Transfer USDC. dfnsInitWithdraw / dfnsCompleteWithdraw : Withdraw tokens from the treasury. dfnsInitiatePurchase / dfnsCompletePurchase : Purchase an item from the marketplace. dfnsInitRetireCredits / dfnsCompleteRetireCredits : Retire carbon credits.","title":"Transaction Management"},{"location":"gemforce-api-documentation/#identity-management_1","text":"dfnsAddClaimTopicInit / dfnsAddClaimTopicComplete : Add a claim topic. dfnsAddTrustedIssuerInit / dfnsAddTrustedIssuerComplete : Add a trusted issuer. dfnsRemoveTrustedIssuerInit / dfnsRemoveTrustedIssuerComplete : Remove a trusted issuer. dfnsUpdateIssuerClaimTopicsInit / dfnsUpdateIssuerClaimTopicsComplete : Update claim topics for an issuer. dfnsCreateIdentityInit / dfnsCreateIdentityComplete : Create a digital identity. dfnsAddIdentityInit / dfnsAddIdentityComplete : Add an identity to the registry. dfnsRemoveIdentityInit / dfnsRemoveIdentityComplete : Remove an identity from the factory. dfnsUnregisterIdentityInit / dfnsUnregisterIdentityComplete : Remove an identity from the registry. dfnsSetClaimsInit / dfnsSetClaimsComplete : Set claims for an identity. dfnsAddClaimInit / dfnsAddClaimComplete : Add a claim to an identity. dfnsRemoveClaimInit / dfnsRemoveClaimComplete : Remove a claim from an identity. dfnsGetIdentity : Get the identity for an owner address.","title":"Identity Management"},{"location":"gemforce-api-documentation/#asset-management","text":"dfnsGemforceMintInit / dfnsGemforceMintComplete : Mint a new token with metadata.","title":"Asset Management"},{"location":"gemforce-api-documentation/#bridge-api-integration","text":"Gemforce integrates with a Bridge API for handling financial operations.","title":"Bridge API Integration"},{"location":"gemforce-api-documentation/#external-accounts","text":"createExternalAccount : Create an external account for a customer. getExternalAccounts : Get all external accounts for a customer. getExternalAccount : Get a specific external account for a customer. deleteExternalAccount : Delete an external account.","title":"External Accounts"},{"location":"gemforce-api-documentation/#transfers","text":"createTransfer : Create a transfer between accounts. getCustomerTransfers : Get all transfers for a customer.","title":"Transfers"},{"location":"gemforce-api-documentation/#kyc-management","text":"generateKycLink : Generate a KYC link for a user. getKycLinkStatus : Get the status of a KYC link.","title":"KYC Management"},{"location":"gemforce-api-documentation/#plaid-integration","text":"getPlaidLinkToken : Get a Plaid link token for a customer. exchangePlaidPublicToken : Exchange a Plaid public token for access.","title":"Plaid Integration"},{"location":"gemforce-api-documentation/#project-management","text":"getProjectMetadata : Get metadata for a project.","title":"Project Management"},{"location":"gemforce-api-quick-reference/","text":"Gemforce API Quick Reference \u00b6 This document provides a concise reference for developers who need to interact with the Gemforce API, including smart contract calls and cloud function endpoints. Smart Contract Interactions \u00b6 Diamond Pattern \u00b6 The Diamond pattern allows for modular and upgradeable smart contracts. All functionality is implemented through facets. // Get the diamond address by symbol address diamondAddress = diamondFactory . getDiamondAddress ( \"GEM\" ); // Check if a diamond exists bool exists = diamondFactory . exists ( \"GEM\" ); // Create a new diamond DiamondSettings memory settings = DiamondSettings ({ name : \"Gemforce\" , symbol : \"GEM\" , // Other settings... }); address newDiamond = diamondFactory . createFromSet ( settings , initializer , initData , \"defaultFacetSet\" ); Identity Management \u00b6 // Create a new identity identityFactory . createIdentity ( userAddress ); // Get an identity address identityAddress = identityFactory . getIdentity ( userAddress ); // Add a claim topic claimTopicsRegistry . addClaimTopic ( 1 ); // e.g., KYC claim // Add a trusted issuer uint256 [] memory topics = new uint256 []( 1 ); topics [ 0 ] = 1 ; // KYC claim topic trustedIssuersRegistry . addTrustedIssuer ( issuerAddress , topics ); // Add a claim identity . addClaim ( 1 , // topic 1 , // scheme issuerAddress , signature , data , \"https://example.com/claim\" ); // Check if an identity has a claim bool hasKYC = identity . getClaim ( claimId ) != 0 ; Token Management \u00b6 // Mint a new token Attribute [] memory attributes = new Attribute []( 2 ); attributes [ 0 ] = Attribute ( \"name\" , AttributeType . String , \"Carbon Credit\" ); attributes [ 1 ] = Attribute ( \"amount\" , AttributeType . Number , \"100\" ); uint256 tokenId = gemforceMinter . gemforceMint ( attributes ); // Purchase a token marketplace . purchaseItem ( diamondAddress , tokenId ); // Retire carbon credits carbonCredits . retireCarbonCredits ( tokenId , 50 ); Cloud Function APIs \u00b6 Authentication \u00b6 // Register a user Parse . Cloud . run ( \"registerUser\" , { username : \"user@example.com\" , password : \"password123\" , email : \"user@example.com\" , company : \"Example Corp\" , firstName : \"John\" , lastName : \"Doe\" }). then ( result => { console . log ( \"User registered:\" , result ); }); // Login (using Parse SDK) Parse . User . logIn ( \"username\" , \"password\" ). then ( user => { console . log ( \"Logged in:\" , user ); }); DFNS Wallet Management \u00b6 // Register with DFNS Parse . Cloud . run ( \"registerInit\" , { username : \"user@example.com\" }). then ( challenge => { // Handle challenge with WebAuthn // Then complete registration return Parse . Cloud . run ( \"registerComplete\" , { signedChallenge : signedChallenge , temporaryAuthenticationToken : tempToken }); }). then ( result => { console . log ( \"DFNS registration complete:\" , result ); }); // Login to DFNS Parse . Cloud . run ( \"login\" , { username : \"user@example.com\" }). then ( result => { const dfnsToken = result . token ; // Store DFNS token for future operations }); // List wallets Parse . Cloud . run ( \"listWallets\" , { authToken : dfnsToken }). then ( wallets => { console . log ( \"User wallets:\" , wallets ); }); Contract Interactions via DFNS \u00b6 This pattern is used for all blockchain interactions through DFNS: 1. Initialize the transaction 2. Sign the challenge client-side 3. Complete the transaction with the signed challenge // Example: Purchase an item Parse . Cloud . run ( \"dfnsInitiatePurchase\" , { tokenId : \"123\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side using DFNS SDK const signedChallenge = await signChallenge ( challenge ); // Complete the purchase return Parse . Cloud . run ( \"dfnsCompletePurchase\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Purchase complete:\" , result ); }); Identity Management via DFNS \u00b6 // Create an identity Parse . Cloud . run ( \"dfnsCreateIdentityInit\" , { ownerAddress : \"0x123...\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete the identity creation return Parse . Cloud . run ( \"dfnsCreateIdentityComplete\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Identity created:\" , result ); }); // Add a claim topic Parse . Cloud . run ( \"dfnsAddClaimTopicInit\" , { claimTopic : 1 , // e.g., KYC claim walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete adding claim topic return Parse . Cloud . run ( \"dfnsAddClaimTopicComplete\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Claim topic added:\" , result ); }); Carbon Credit Management \u00b6 // Retire carbon credits Parse . Cloud . run ( \"dfnsInitRetireCredits\" , { tokenId : \"123\" , amount : \"50\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete retirement return Parse . Cloud . run ( \"dfnsCompleteRetireCredits\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Credits retired:\" , result ); }); Bridge API Integration \u00b6 // Create an external account Parse . Cloud . run ( \"createExternalAccount\" , { customer_id : \"cust_123\" , currency : \"usd\" , account_owner_name : \"John Doe\" , account_type : \"us\" , account : { account_number : \"123456789\" , routing_number : \"123456789\" , checking_or_savings : \"checking\" } }). then ( result => { console . log ( \"External account created:\" , result ); }); // Create a transfer Parse . Cloud . run ( \"createTransfer\" , { amount : \"100.00\" , on_behalf_of : \"cust_123\" , source : { currency : \"usd\" , payment_rail : \"ach\" , external_account_id : \"ext_acct_123\" }, destination : { currency : \"usdc\" , payment_rail : \"ethereum\" , to_address : \"0x123...\" } }). then ( result => { console . log ( \"Transfer created:\" , result ); }); Plaid Integration \u00b6 // Get a Plaid link token Parse . Cloud . run ( \"getPlaidLinkToken\" , { customerId : \"cust_123\" }). then ( result => { const linkToken = result . link_token ; // Use linkToken with Plaid Link }); // Exchange a Plaid public token Parse . Cloud . run ( \"exchangePlaidPublicToken\" , { customerId : \"cust_123\" , linkToken : \"link-123\" , publicToken : \"public-123\" }). then ( result => { console . log ( \"Plaid token exchanged:\" , result ); }); Common Patterns \u00b6 Two-Step Transaction Pattern \u00b6 Most blockchain interactions follow this pattern: Initialization Step : Call the *Init function with required parameters Receive a challenge and request body Completion Step : Sign the challenge client-side (typically with WebAuthn) Call the *Complete function with the signed challenge and request body Receive transaction result Error Handling \u00b6 Parse . Cloud . run ( \"someFunction\" , params ) . then ( result => { // Handle success }) . catch ( error => { // Parse Server error codes if ( error . code === Parse . Error . VALIDATION_ERROR ) { console . error ( \"Validation error:\" , error . message ); } else if ( error . code === Parse . Error . SCRIPT_FAILED ) { console . error ( \"Script error:\" , error . message ); } else { console . error ( \"Unknown error:\" , error ); } }); Important Considerations \u00b6 Authentication : Always ensure users are authenticated before accessing protected endpoints. DFNS Token Management : Store the DFNS token securely and refresh it when needed. Transaction Monitoring : Monitor transaction status after submission as blockchain transactions can take time to confirm. Gas Management : Be mindful of gas costs for transactions, especially for operations like minting tokens. Error Handling : Implement robust error handling for both client-side and server-side errors. Idempotency : Use idempotency keys for financial operations to prevent duplicate transactions. Wallet Address Validation : Validate Ethereum addresses before sending transactions. Testing : Test all interactions on test networks before moving to production.","title":"Quick Reference"},{"location":"gemforce-api-quick-reference/#gemforce-api-quick-reference","text":"This document provides a concise reference for developers who need to interact with the Gemforce API, including smart contract calls and cloud function endpoints.","title":"Gemforce API Quick Reference"},{"location":"gemforce-api-quick-reference/#smart-contract-interactions","text":"","title":"Smart Contract Interactions"},{"location":"gemforce-api-quick-reference/#diamond-pattern","text":"The Diamond pattern allows for modular and upgradeable smart contracts. All functionality is implemented through facets. // Get the diamond address by symbol address diamondAddress = diamondFactory . getDiamondAddress ( \"GEM\" ); // Check if a diamond exists bool exists = diamondFactory . exists ( \"GEM\" ); // Create a new diamond DiamondSettings memory settings = DiamondSettings ({ name : \"Gemforce\" , symbol : \"GEM\" , // Other settings... }); address newDiamond = diamondFactory . createFromSet ( settings , initializer , initData , \"defaultFacetSet\" );","title":"Diamond Pattern"},{"location":"gemforce-api-quick-reference/#identity-management","text":"// Create a new identity identityFactory . createIdentity ( userAddress ); // Get an identity address identityAddress = identityFactory . getIdentity ( userAddress ); // Add a claim topic claimTopicsRegistry . addClaimTopic ( 1 ); // e.g., KYC claim // Add a trusted issuer uint256 [] memory topics = new uint256 []( 1 ); topics [ 0 ] = 1 ; // KYC claim topic trustedIssuersRegistry . addTrustedIssuer ( issuerAddress , topics ); // Add a claim identity . addClaim ( 1 , // topic 1 , // scheme issuerAddress , signature , data , \"https://example.com/claim\" ); // Check if an identity has a claim bool hasKYC = identity . getClaim ( claimId ) != 0 ;","title":"Identity Management"},{"location":"gemforce-api-quick-reference/#token-management","text":"// Mint a new token Attribute [] memory attributes = new Attribute []( 2 ); attributes [ 0 ] = Attribute ( \"name\" , AttributeType . String , \"Carbon Credit\" ); attributes [ 1 ] = Attribute ( \"amount\" , AttributeType . Number , \"100\" ); uint256 tokenId = gemforceMinter . gemforceMint ( attributes ); // Purchase a token marketplace . purchaseItem ( diamondAddress , tokenId ); // Retire carbon credits carbonCredits . retireCarbonCredits ( tokenId , 50 );","title":"Token Management"},{"location":"gemforce-api-quick-reference/#cloud-function-apis","text":"","title":"Cloud Function APIs"},{"location":"gemforce-api-quick-reference/#authentication","text":"// Register a user Parse . Cloud . run ( \"registerUser\" , { username : \"user@example.com\" , password : \"password123\" , email : \"user@example.com\" , company : \"Example Corp\" , firstName : \"John\" , lastName : \"Doe\" }). then ( result => { console . log ( \"User registered:\" , result ); }); // Login (using Parse SDK) Parse . User . logIn ( \"username\" , \"password\" ). then ( user => { console . log ( \"Logged in:\" , user ); });","title":"Authentication"},{"location":"gemforce-api-quick-reference/#dfns-wallet-management","text":"// Register with DFNS Parse . Cloud . run ( \"registerInit\" , { username : \"user@example.com\" }). then ( challenge => { // Handle challenge with WebAuthn // Then complete registration return Parse . Cloud . run ( \"registerComplete\" , { signedChallenge : signedChallenge , temporaryAuthenticationToken : tempToken }); }). then ( result => { console . log ( \"DFNS registration complete:\" , result ); }); // Login to DFNS Parse . Cloud . run ( \"login\" , { username : \"user@example.com\" }). then ( result => { const dfnsToken = result . token ; // Store DFNS token for future operations }); // List wallets Parse . Cloud . run ( \"listWallets\" , { authToken : dfnsToken }). then ( wallets => { console . log ( \"User wallets:\" , wallets ); });","title":"DFNS Wallet Management"},{"location":"gemforce-api-quick-reference/#contract-interactions-via-dfns","text":"This pattern is used for all blockchain interactions through DFNS: 1. Initialize the transaction 2. Sign the challenge client-side 3. Complete the transaction with the signed challenge // Example: Purchase an item Parse . Cloud . run ( \"dfnsInitiatePurchase\" , { tokenId : \"123\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side using DFNS SDK const signedChallenge = await signChallenge ( challenge ); // Complete the purchase return Parse . Cloud . run ( \"dfnsCompletePurchase\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Purchase complete:\" , result ); });","title":"Contract Interactions via DFNS"},{"location":"gemforce-api-quick-reference/#identity-management-via-dfns","text":"// Create an identity Parse . Cloud . run ( \"dfnsCreateIdentityInit\" , { ownerAddress : \"0x123...\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete the identity creation return Parse . Cloud . run ( \"dfnsCreateIdentityComplete\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Identity created:\" , result ); }); // Add a claim topic Parse . Cloud . run ( \"dfnsAddClaimTopicInit\" , { claimTopic : 1 , // e.g., KYC claim walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete adding claim topic return Parse . Cloud . run ( \"dfnsAddClaimTopicComplete\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Claim topic added:\" , result ); });","title":"Identity Management via DFNS"},{"location":"gemforce-api-quick-reference/#carbon-credit-management","text":"// Retire carbon credits Parse . Cloud . run ( \"dfnsInitRetireCredits\" , { tokenId : \"123\" , amount : \"50\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete retirement return Parse . Cloud . run ( \"dfnsCompleteRetireCredits\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Credits retired:\" , result ); });","title":"Carbon Credit Management"},{"location":"gemforce-api-quick-reference/#bridge-api-integration","text":"// Create an external account Parse . Cloud . run ( \"createExternalAccount\" , { customer_id : \"cust_123\" , currency : \"usd\" , account_owner_name : \"John Doe\" , account_type : \"us\" , account : { account_number : \"123456789\" , routing_number : \"123456789\" , checking_or_savings : \"checking\" } }). then ( result => { console . log ( \"External account created:\" , result ); }); // Create a transfer Parse . Cloud . run ( \"createTransfer\" , { amount : \"100.00\" , on_behalf_of : \"cust_123\" , source : { currency : \"usd\" , payment_rail : \"ach\" , external_account_id : \"ext_acct_123\" }, destination : { currency : \"usdc\" , payment_rail : \"ethereum\" , to_address : \"0x123...\" } }). then ( result => { console . log ( \"Transfer created:\" , result ); });","title":"Bridge API Integration"},{"location":"gemforce-api-quick-reference/#plaid-integration","text":"// Get a Plaid link token Parse . Cloud . run ( \"getPlaidLinkToken\" , { customerId : \"cust_123\" }). then ( result => { const linkToken = result . link_token ; // Use linkToken with Plaid Link }); // Exchange a Plaid public token Parse . Cloud . run ( \"exchangePlaidPublicToken\" , { customerId : \"cust_123\" , linkToken : \"link-123\" , publicToken : \"public-123\" }). then ( result => { console . log ( \"Plaid token exchanged:\" , result ); });","title":"Plaid Integration"},{"location":"gemforce-api-quick-reference/#common-patterns","text":"","title":"Common Patterns"},{"location":"gemforce-api-quick-reference/#two-step-transaction-pattern","text":"Most blockchain interactions follow this pattern: Initialization Step : Call the *Init function with required parameters Receive a challenge and request body Completion Step : Sign the challenge client-side (typically with WebAuthn) Call the *Complete function with the signed challenge and request body Receive transaction result","title":"Two-Step Transaction Pattern"},{"location":"gemforce-api-quick-reference/#error-handling","text":"Parse . Cloud . run ( \"someFunction\" , params ) . then ( result => { // Handle success }) . catch ( error => { // Parse Server error codes if ( error . code === Parse . Error . VALIDATION_ERROR ) { console . error ( \"Validation error:\" , error . message ); } else if ( error . code === Parse . Error . SCRIPT_FAILED ) { console . error ( \"Script error:\" , error . message ); } else { console . error ( \"Unknown error:\" , error ); } });","title":"Error Handling"},{"location":"gemforce-api-quick-reference/#important-considerations","text":"Authentication : Always ensure users are authenticated before accessing protected endpoints. DFNS Token Management : Store the DFNS token securely and refresh it when needed. Transaction Monitoring : Monitor transaction status after submission as blockchain transactions can take time to confirm. Gas Management : Be mindful of gas costs for transactions, especially for operations like minting tokens. Error Handling : Implement robust error handling for both client-side and server-side errors. Idempotency : Use idempotency keys for financial operations to prevent duplicate transactions. Wallet Address Validation : Validate Ethereum addresses before sending transactions. Testing : Test all interactions on test networks before moving to production.","title":"Important Considerations"},{"location":"gemforce-deployer-guide/","text":"Gemforce Deployer Guide \u00b6 Table of Contents \u00b6 Deployment Prerequisites Smart Contract Deployment Cloud Functions Deployment Environment Configuration Deployment Automation Upgrade Procedures Rollback Procedures Testing and Verification Network Management Version Control Deployment Prerequisites \u00b6 Development Environment Setup \u00b6 To deploy the Gemforce platform, you'll need the following tools and software: Node.js and npm : Node.js v16 or later npm v7 or later ```bash # Install using nvm (recommended) nvm install 16 nvm use 16 # Verify installation node -v npm -v ``` Hardhat : Used for smart contract development and deployment ```bash # Install hardhat npm install --save-dev hardhat # Verify installation npx hardhat --version ``` MongoDB : Version 4.4 or later Required for Parse Server ```bash # Installation varies by OS # macOS (using Homebrew) brew install mongodb-community # Verify installation mongod --version ``` Git : For version control bash # Verify installation git --version TypeScript : Latest version ```bash # Install TypeScript npm install -g typescript # Verify installation tsc --version ``` Required Tools and Software \u00b6 Development IDE : Visual Studio Code (recommended) Plugins: Solidity TypeScript ESLint Prettier Blockchain Tools : MetaMask or similar wallet Etherscan account (for contract verification) Infura or Alchemy account (for RPC endpoints) Deployment Tools : PM2 (for process management) Docker (optional, for containerized deployment) ```bash # Install PM2 npm install -g pm2 # Verify installation pm2 --version ``` Database Tools : MongoDB Compass (GUI for MongoDB) MongoDB Database Tools (mongodump, mongorestore) Network Access Requirements \u00b6 Ensure your deployment environment has access to: Blockchain Networks : Ethereum Mainnet (if deploying to production) BaseSepolia (for testing) Other EVM-compatible networks as needed External APIs : DFNS API Bridge API SendGrid API Database Access : MongoDB server (local or hosted) Redis (if using for caching) Github/Version Control : Access to Gemforce repositories Key Management Setup \u00b6 Create a secure key management strategy : bash # Create a directory for keys (outside of repository) mkdir -p ~/.gemforce/keys chmod 700 ~/.gemforce/keys Generate deployment keys : ```bash # Generate a private key for deployment openssl genpkey -algorithm RSA -out ~/.gemforce/keys/deployment_key.pem -pkeyopt rsa_keygen_bits:2048 chmod 600 ~/.gemforce/keys/deployment_key.pem # Generate a DFNS private key openssl genpkey -algorithm RSA -out ~/.gemforce/keys/dfns_private.key -pkeyopt rsa_keygen_bits:2048 chmod 600 ~/.gemforce/keys/dfns_private.key ``` Use environment files for sensitive data : ```bash # Create a .env file for local development cp .env.example .env # Edit to add your keys and endpoints nano .env ``` Environment Preparation \u00b6 Clone the repository : bash git clone https://github.com/your-org/gemforce.git cd gemforce Install dependencies : bash npm install Set up environment files : ```bash # Copy sample environment files cp .env.example .env cp gemforce.config.example.ts gemforce.config.ts # Edit the files with your configuration nano .env nano gemforce.config.ts ``` Create deployment directories : bash mkdir -p deployments Smart Contract Deployment \u00b6 Contract Compilation \u00b6 Compile contracts using Hardhat : bash npx hardhat compile Verify compilation output : Check for successful compilation in artifacts/ directory Resolve any compilation errors Configuration for different networks : javascript // hardhat.config.ts module.exports = { solidity: { version: \"0.8.17\", settings: { optimizer: { enabled: true, runs: 200 } } }, networks: { hardhat: { chainId: 31337 }, baseSepolia: { url: `https://sepolia.base.org`, accounts: [process.env.PRIVATE_KEY], chainId: 84532 }, mainnet: { url: `https://mainnet.infura.io/v3/${process.env.INFURA_KEY}`, accounts: [process.env.PRIVATE_KEY], chainId: 1 } } }; Diamond Pattern Deployment Workflow \u00b6 The Gemforce platform uses the Diamond pattern (EIP-2535) for smart contract deployment: Deploy libraries first : bash npx hardhat deploy --tags Libraries --network baseSepolia Deploy facets : bash npx hardhat deploy --tags Facets --network baseSepolia Deploy Diamond contract : bash npx hardhat deploy --tags Diamond --network baseSepolia Verify the deployment : bash npx hardhat verify --network baseSepolia <DIAMOND_ADDRESS> Facet Deployment Process \u00b6 Develop new facets in the /contracts/facets directory Add to deployment scripts in /deploy directory Set up facet cut data for the Diamond contract: javascript // Example facet cut data const facetCuts = [ { facetAddress: newFacetAddress, action: FacetCutAction.Add, functionSelectors: selectors } ]; Update the Diamond with new facets: javascript // Using the DiamondFactory await diamondFactory.setFacets(setName, facetCuts); Contract Initialization \u00b6 Prepare initialization data : javascript // Example initialization data const initData = diamondInit.interface.encodeFunctionData(\"init\", [ [ // Initial parameters tokenName, tokenSymbol, baseURI, // ...other params ] ]); Initialize the Diamond : ```javascript const settings = { name: \"Gemforce Token\", symbol: \"GEM\", // other settings }; await diamondFactory.createFromSet( settings, diamondInit.address, initData, \"defaultFacetSet\" ); ``` Contract Verification \u00b6 Verify Diamond contract on Etherscan/Basescan : bash npx hardhat verify --network baseSepolia <DIAMOND_ADDRESS> Verify individual facets : bash npx hardhat verify --network baseSepolia <FACET_ADDRESS> Manual verification (if automatic verification fails): Flatten the contract using Hardhat Upload the flattened contract to the block explorer Verify with the correct compiler settings Gas Optimization Strategies \u00b6 Use optimized Solidity patterns : Minimize storage operations Batch operations where possible Use efficient data structures Configure gas prices for deployment : javascript // Example configuration for gas const tx = await contract.functionName(params, { gasPrice: (await ethers.provider.getGasPrice()).mul(2), // 2x current gas price gasLimit: 5000000 }); Monitor gas usage during testing : javascript // Add gas reporter to Hardhat config gasReporter: { enabled: true, currency: 'USD', gasPrice: 100, coinmarketcap: process.env.COINMARKETCAP_API_KEY } Cloud Functions Deployment \u00b6 Parse Server Deployment \u00b6 Prepare Parse Server configuration : javascript // Example Parse Server configuration const parseServerConfig = { appId: process.env.APP_ID, masterKey: process.env.MASTER_KEY, databaseURI: process.env.DATABASE_URI, serverURL: process.env.SERVER_URL, cloud: \"./dist/src/cloud-functions.js\", allowClientClassCreation: false, enableAnonymousUsers: false, maxUploadSize: \"20mb\", // ... other configuration }; Deploy Parse Server : Using PM2: ```bash # Start Parse Server with PM2 pm2 start app.js --name gemforce-server # Save PM2 configuration pm2 save # Set up PM2 to start on system boot pm2 startup ``` Using Docker: ```bash # Build Docker image docker build -t gemforce-server . # Run container docker run -d -p 1337:1337 \\ --env-file .env \\ --name gemforce-server \\ gemforce-server ``` Verify Parse Server deployment : ```bash # Check server status curl https://your-server-url.com/parse/health # Expected response: {\"status\":\"ok\"} ``` Cloud Function Deployment \u00b6 Compile TypeScript files : bash # Build the project npm run build Deploy cloud functions : If using PM2: bash # Restart the server to apply changes pm2 restart gemforce-server If using Docker: bash # Rebuild and redeploy docker build -t gemforce-server . docker stop gemforce-server docker rm gemforce-server docker run -d -p 1337:1337 \\ --env-file .env \\ --name gemforce-server \\ gemforce-server Verify cloud function deployment : bash # Test a simple cloud function curl -X POST \\ -H \"X-Parse-Application-Id: ${APP_ID}\" \\ -H \"Content-Type: application/json\" \\ -d '{}' \\ https://your-server-url.com/parse/functions/loadAllBlockchains Environment Configuration \u00b6 Set environment variables : ```bash # Set environment variables in .env file cat > .env << EOL # Parse Server APP_ID=your_app_id MASTER_KEY=your_master_key DATABASE_URI=mongodb://username:password@host:port/database SERVER_URL=https://your-server-url.com/parse # Blockchain ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=base-sepolia PRIVATE_KEY=your_private_key # External Services DFNS_APP_ID=your_dfns_app_id DFNS_API_URL=https://api.dfns.io DFNS_CRED_ID=your_dfns_credential_id # Additional Configuration METADATA_BASE_URI=https://metadata.gemforce.com/ EOL ``` Configure database : Set up MongoDB Create database user Configure connection string Set up web server (nginx example): ```nginx # /etc/nginx/sites-available/gemforce server { listen 80; server_name api.gemforce.com; location / { return 301 https : // $ host $ request_uri ; } } server { listen 443 ssl; server_name api.gemforce.com; ssl_certificate / etc / letsencrypt / live / api . gemforce . com / fullchain . pem ; ssl_certificate_key / etc / letsencrypt / live / api . gemforce . com / privkey . pem ; location / { proxy_pass http : // localhost : 1337 ; proxy_http_version 1.1 ; proxy_set_header Upgrade $http_upgrade ; proxy_set_header Connection 'upgrade' ; proxy_set_header Host $host ; proxy_cache_bypass $http_upgrade ; } } ``` Database Migration \u00b6 Create database migrations : ```javascript // Example migration script (migrations/001_add_indexes.js) async function up(db) { await db.collection('User').createIndex({ walletAddress: 1 }); await db.collection('Identity').createIndex({ walletAddress: 1 }, { unique: true }); await db.collection('Transaction').createIndex({ hash: 1 }, { unique: true }); } async function down(db) { await db.collection('User').dropIndex({ walletAddress: 1 }); await db.collection('Identity').dropIndex({ walletAddress: 1 }); await db.collection('Transaction').dropIndex({ hash: 1 }); } module.exports = { up, down }; ``` Run migrations : bash # Example using a simple migration tool npx migrate-mongo up Verify migrations : javascript // Check indexes db.User.getIndexes() db.Identity.getIndexes() db.Transaction.getIndexes() WebSocket Setup \u00b6 Configure WebSocket endpoints : ```javascript // Example WebSocket server setup const wss = new WebSocketServer({ server: httpServer, path: \"/ws\" }); wss.on('connection', (ws) => { // Handle connection ws.on('message', (message) => { // Handle message }); ws.on('close', () => { // Handle disconnection }); }); ``` Set up blockchain event listeners : ```javascript // Example blockchain event listener function setupEventListeners(provider, diamondAddress) { const diamond = new ethers.Contract( diamondAddress, DiamondABI, provider ); diamond . on ( \"Transfer\" , ( from , to , tokenId ) => { // Handle transfer event // Broadcast to connected WebSocket clients wss.clients.forEach((client) => { if (client.readyState === WebSocket.OPEN) { client.send(JSON.stringify({ event : \"Transfer\" , data : { from , to , tokenId : tokenId . toString () } } )); } } ); } ); } ``` Environment Configuration \u00b6 Development Environment \u00b6 Local environment setup : ```bash # Start local hardhat node npx hardhat node # Deploy contracts to local node npx hardhat deploy --network localhost # Start Parse Server locally npm run dev ``` Environment configuration file for development : ``` # .env.development APP_ID=gemforce_dev MASTER_KEY=your_dev_master_key DATABASE_URI=mongodb://localhost:27017/gemforce_dev SERVER_URL=http://localhost:1337/parse # Use local hardhat node ETH_NODE_URI_LOCAL=http://localhost:8545 CHAIN_ID=31337 # Development keys PRIVATE_KEY=your_dev_private_key ``` Development database setup : ```bash # Start MongoDB locally mongod --dbpath ./data # Create database and user mongo use gemforce_dev db.createUser({ user: \"gemforce_user\", pwd: \"password\", roles: [{ role: \"readWrite\", db: \"gemforce_dev\" }] }) ``` Testing Environment \u00b6 Testing environment configuration : ``` # .env.test APP_ID=gemforce_test MASTER_KEY=your_test_master_key DATABASE_URI=mongodb://localhost:27017/gemforce_test SERVER_URL=http://localhost:1337/parse # Use BaseSepolia for testing ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=84532 # Test keys PRIVATE_KEY=your_test_private_key ``` Automated testing setup : ```bash # Run tests npm test # Run specific tests npx mocha test/specific-test.js ``` Test database initialization : javascript // Initialize test database before(async () => { const client = await MongoClient.connect(process.env.DATABASE_URI); const db = client.db(); await db.collection('User').deleteMany({}); await db.collection('Identity').deleteMany({}); // Seed with test data await db.collection('User').insertMany(testUsers); }); Staging Environment \u00b6 Staging environment configuration : ``` # .env.staging APP_ID=gemforce_staging MASTER_KEY=your_staging_master_key DATABASE_URI=mongodb://user:password@staging-db:27017/gemforce_staging SERVER_URL=https://staging-api.gemforce.com/parse # Use BaseSepolia for staging ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=84532 # Staging keys PRIVATE_KEY=your_staging_private_key ``` Staging deployment : ```bash # Deploy to staging npm run deploy:staging # Run database migrations npm run migrate:staging ``` Staging verification : bash # Verify staging deployment curl https://staging-api.gemforce.com/parse/health Production Environment \u00b6 Production environment configuration : ``` # .env.production APP_ID=gemforce_prod MASTER_KEY=your_production_master_key DATABASE_URI=mongodb://user:password@production-db:27017/gemforce_production SERVER_URL=https://api.gemforce.com/parse # Use production endpoints ETH_NODE_URI_MAINNET=https://mainnet.infura.io/v3/your_infura_key CHAIN_ID=1 # Production keys stored securely # PRIVATE_KEY should be handled with extra security ``` Production deployment steps : ```bash # Deploy to production npm run deploy:production # Run database migrations npm run migrate:production ``` Production verification : ```bash # Verify production deployment curl https://api.gemforce.com/parse/health # Monitor logs pm2 logs gemforce-server ``` Environment-Specific Settings \u00b6 Configuration management : ``javascript // Load environment-specific configuration const envConfig = require( ./config/${process.env.NODE_ENV || 'development'}`); module.exports = { // Base configuration appName: 'Gemforce', // Merge with environment-specific config ... envConfig }; ``` Feature flags : ```javascript // Example feature flags configuration const featureFlags = { development: { enableNewMarketplace: true, enableCarbonCredits: true }, staging: { enableNewMarketplace: true, enableCarbonCredits: false }, production: { enableNewMarketplace: false, enableCarbonCredits: false } }; // Usage if (featureFlags[process.env.NODE_ENV].enableNewMarketplace) { // Initialize new marketplace } ``` Deployment Automation \u00b6 CI/CD Pipeline Setup \u00b6 GitHub Actions workflow : ```yaml # .github/workflows/deploy.yml name: Deploy Gemforce on: push: branches: [ main, staging ] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: '16' - name: Install dependencies run: npm ci - name: Run tests run: npm test build : needs : test runs - on : ubuntu - latest steps : - uses : actions / checkout @ v2 - name : Setup Node . js uses : actions / setup - node @ v2 with : node - version : '16' - name : Install dependencies run : npm ci - name : Build project run : npm run build - name : Upload build artifacts uses : actions / upload - artifact @ v2 with : name : build path : dist / deploy : needs : build runs - on : ubuntu - latest steps : - uses : actions / checkout @ v2 - name : Download build artifacts uses : actions / download - artifact @ v2 with : name : build path : dist / - name : Deploy to server uses : appleboy / ssh - action @ master with : host : $ {{ secrets . SERVER_HOST }} username : $ {{ secrets . SERVER_USERNAME }} key : $ {{ secrets . SSH_PRIVATE_KEY }} script : | cd / var / www / gemforce git pull npm ci cp - r $ {{ github . workspace }} / dist /* ./ dist / pm2 restart gemforce - server ``` Automatic testing : ```yaml # .github/workflows/test.yml name: Test Gemforce on: pull_request: branches: [ main, staging ] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: '16' - name: Install dependencies run: npm ci - name: Run linting run: npm run lint - name: Run tests run: npm test ``` Automated Testing \u00b6 Unit tests for smart contracts : ```javascript // test/GemforceMinter.test.ts describe(\"GemforceMinter\", function() { let owner, user; let diamond, gemforceMinter; beforeEach ( async function () { [ owner , user ] = await ethers . getSigners (); // Deploy diamond with GemforceMinterFacet // ... deployment code gemforceMinter = await ethers . getContractAt ( \"GemforceMinterFacet\" , diamond . address ); }); it ( \"should mint a token with metadata\" , async function () { const metadata = [ { key : \"name\" , attributeType : 0 , value : \"Carbon Credit\" }, { key : \"amount\" , attributeType : 1 , value : \"100\" } ]; await expect ( gemforceMinter . connect ( owner ) . gemforceMint ( metadata )) . to . emit ( gemforceMinter , \"GemforceMinted\" ) . withArgs ( 0 , owner . address , metadata ); }); }); ``` API endpoint tests : ```javascript // test/cloud-functions.test.js describe(\"Cloud Functions\", function() { before(async function() { // Initialize Parse Server for testing Parse.initialize(\"test_app_id\", \"test_js_key\", \"test_master_key\"); Parse.serverURL = \"http://localhost:1337/parse\"; }); it ( \"should retrieve blockchain data\" , async function () { const result = await Parse . Cloud . run ( \"loadAllBlockchains\" ); expect ( result ) . to . be . an ( \"array\" ); }); }); ``` End-to-end tests : ```javascript // test/e2e/user-flow.test.js describe(\"User Flow\", function() { it(\"should register, create identity, and mint token\", async function() { // Register user const user = await registerUser(\"test@example.com\", \"password\"); // Create DFNS wallet const { walletId } = await createDFNSWallet ( user ); // Create identity const { identityAddress } = await createIdentity ( user , walletId ); // Mint token const { tokenId } = await mintToken ( user , walletId ); // Verify token ownership const owner = await getTokenOwner ( tokenId ); expect ( owner ) . to . equal ( user . get ( \"walletAddress\" )); }); }); ``` Deployment Scripts \u00b6 Smart contract deployment script : ```javascript // scripts/deploy-contracts.js async function main() { // Get deployer const [deployer] = await ethers.getSigners(); console.log(\"Deploying contracts with account:\", deployer.address); // Deploy libraries const LibraryA = await ethers . getContractFactory ( \"LibraryA\" ); const libraryA = await LibraryA . deploy (); await libraryA . deployed (); console . log ( \"LibraryA deployed to:\" , libraryA . address ); // Deploy facets with libraries const FacetA = await ethers . getContractFactory ( \"FacetA\" , { libraries : { LibraryA : libraryA . address } }); const facetA = await FacetA . deploy (); await facetA . deployed (); console . log ( \"FacetA deployed to:\" , facetA . address ); // More deployments... } main() .then(() => process.exit(0)) .catch(error => { console.error(error); process.exit(1); }); ``` Parse Server deployment script : ```bash #!/bin/bash # scripts/deploy-parse.sh # Load environment variables source .env.${NODE_ENV:-production} # Build the project echo \"Building project...\" npm run build # Deploy to server echo \"Deploying to server...\" rsync -avz --exclude node_modules --exclude .git . user@server:/var/www/gemforce/ # SSH into server and restart ssh user@server << EOF cd /var/www/gemforce npm ci --production pm2 restart gemforce-server EOF echo \"Deployment complete!\" ``` Infrastructure as Code \u00b6 Terraform configuration : ```hcl # main.tf provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"gemforce_server\" { ami = \"ami-0c55b159cbfafe1f0\" instance_type = \"t2.medium\" key_name = \"gemforce-key\" tags = { Name = \"gemforce-server\" Environment = var . environment } root_block_device { volume_size = 50 volume_type = \"gp2\" } vpc_security_group_ids = [ aws_security_group . gemforce_sg . id ] } resource \"aws_security_group\" \"gemforce_sg\" { name = \"gemforce-sg\" description = \"Allow web and SSH traffic\" ingress { from_port = 80 to_port = 80 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } ingress { from_port = 443 to_port = 443 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } ingress { from_port = 22 to_port = 22 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } egress { from_port = 0 to_port = 0 protocol = \"-1\" cidr_blocks = [\"0.0.0.0/0\"] } } output \"server_ip\" { value = aws_instance.gemforce_server.public_ip } ``` Docker Compose setup : ```yaml # docker-compose.yml version: '3' services: mongodb: image: mongo:4.4 ports: - \"27017:27017\" volumes: - mongo-data:/data/db environment: MONGO_INITDB_ROOT_USERNAME: ${MONGO_USERNAME} MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD} restart: always parse - server : build : . ports : - \"1337:1337\" environment : - APP_ID =$ { APP_ID } - MASTER_KEY =$ { MASTER_KEY } - DATABASE_URI = mongodb : //$ { MONGO_USERNAME }: $ { MONGO_PASSWORD } @ mongodb : 27017 /$ { DATABASE_NAME } ? authSource = admin - SERVER_URL =$ { SERVER_URL } - CLOUD_PATH =/ parse - server / cloud / main . js volumes : - ./ cloud : / parse - server / cloud depends_on : - mongodb restart : always nginx : image : nginx : latest ports : - \"80:80\" - \"443:443\" volumes : - ./ nginx / conf . d : / etc / nginx / conf . d - ./ nginx / ssl : / etc / nginx / ssl - ./ nginx / www : / var / www / html depends_on : - parse - server restart : always volumes: mongo-data: ``` Continuous Monitoring \u00b6 Setup monitoring tools : ```javascript // Monitoring setup in app.js const prometheus = require('prom-client'); const collectDefaultMetrics = prometheus.collectDefaultMetrics; // Enable default metrics collectDefaultMetrics({ timeout: 5000 }); // Custom metrics const httpRequestDurationMicroseconds = new prometheus.Histogram({ name: 'http_request_duration_ms', help: 'Duration of HTTP requests in ms', labelNames: ['method', 'route', 'status_code'], buckets: [0.1, 5, 15, 50, 100, 500] }); // Endpoint for metrics app.get('/metrics', (req, res) => { res.set('Content-Type', prometheus.register.contentType); res.end(prometheus.register.metrics()); }); ``` Logging configuration : ```javascript // Logging setup in app.js const winston = require('winston'); const logger = winston.createLogger({ level: process.env.LOG_LEVEL || 'info', format: winston.format.combine( winston.format.timestamp(), winston.format.json() ), transports: [ new winston.transports.Console(), new winston.transports.File({ filename: 'error.log', level: 'error' }), new winston.transports.File({ filename: 'combined.log' }) ] }); // Use in application logger.info('Server started', { port: 1337 }); ``` Upgrade Procedures \u00b6 Smart Contract Upgrades \u00b6 Upgrading a facet : ```javascript // scripts/upgrade-facet.js async function main() { // Get signer const [signer] = await ethers.getSigners(); // Deploy new version of the facet const NewFacet = await ethers . getContractFactory ( \"NewFacetV2\" ); const newFacet = await NewFacet . deploy (); await newFacet . deployed (); console . log ( \"New facet deployed to:\" , newFacet . address ); // Get diamond contract const diamond = await ethers . getContractAt ( \"Diamond\" , DIAMOND_ADDRESS ); // Get selectors for the facet const selectors = getSelectors ( newFacet ); // Create facet cut const facetCut = { facetAddress : newFacet . address , action : FacetCutAction . Replace , // Replace existing facet functionSelectors : selectors } ; // Perform the upgrade const tx = await diamond . diamondCut ( [ facetCut ] , ethers . constants . AddressZero , // No initialization \"0x\" ); await tx . wait (); console . log ( \"Facet upgraded successfully\" ); } main() .then(() => process.exit(0)) .catch(error => { console.error(error); process.exit(1); }); ``` Adding a new facet : ```javascript // scripts/add-facet.js async function main() { // Get signer const [signer] = await ethers.getSigners(); // Deploy new facet const NewFacet = await ethers . getContractFactory ( \"NewFacet\" ); const newFacet = await NewFacet . deploy (); await newFacet . deployed (); console . log ( \"New facet deployed to:\" , newFacet . address ); // Get diamond contract const diamond = await ethers . getContractAt ( \"Diamond\" , DIAMOND_ADDRESS ); // Get selectors for the facet const selectors = getSelectors ( newFacet ); // Create facet cut const facetCut = { facetAddress : newFacet . address , action : FacetCutAction . Add , // Add new facet functionSelectors : selectors } ; // Perform the upgrade const tx = await diamond . diamondCut ( [ facetCut ] , ethers . constants . AddressZero , // No initialization \"0x\" ); await tx . wait (); console . log ( \"Facet added successfully\" ); } ``` Upgrading Diamond implementation : ```javascript // scripts/upgrade-diamond.js async function main() { // Get diamond factory const diamondFactory = await ethers.getContractAt(\"DiamondFactory\", FACTORY_ADDRESS); // Get existing diamond const diamond = await ethers . getContractAt ( \"Diamond\" , DIAMOND_ADDRESS ); // Deploy new facets const newFacets = await deployNewFacets (); // Create facet cuts const facetCuts = createFacetCuts ( newFacets ); // Set new facet set on factory await diamondFactory . setFacets ( \"newFacetSet\" , facetCuts ); // Deploy new diamond initializer if needed const diamondInit = await deployDiamondInit (); // Prepare initialization data const initData = diamondInit . interface . encodeFunctionData ( \"init\" , [ /* initialization parameters */ ]); // Upgrade diamond const tx = await diamond . diamondCut ( facetCuts , diamondInit . address , initData ); await tx . wait (); console . log ( \"Diamond upgraded successfully\" ); } ``` Cloud Function Updates \u00b6 Updating cloud functions : ```bash # Update cloud functions git pull origin main npm install npm run build # Restart Parse Server pm2 restart gemforce-server ``` Testing cloud function updates : javascript // test/cloud-functions/updated-function.test.js describe(\"Updated Cloud Function\", function() { it(\"should handle new functionality\", async function() { const result = await Parse.Cloud.run(\"updatedFunction\", { param: \"value\" }); expect(result).to.have.property(\"newProperty\"); }); }); Deploying specific cloud function changes : ```bash # Deploy specific cloud function changes scp dist/src/cloud-functions/specific-function.js user@server:/var/www/gemforce/dist/src/cloud-functions/ # Restart Parse Server ssh user@server \"cd /var/www/gemforce && pm2 restart gemforce-server\" ``` Database Schema Migrations \u00b6 Creating a migration : ```javascript // migrations/1625000000000_add_new_field.js exports.up = async (db) => { // Add new field to all documents in a collection await db.collection('User').updateMany( { newField: { $exists: false } }, { $set: { newField: \"\" } } ); // Create new index await db . collection ( 'User' ). createIndex ({ newField : 1 }); }; exports.down = async (db) => { // Remove the field await db.collection('User').updateMany( {}, { $unset: { newField: \"\" } } ); // Remove the index await db . collection ( 'User' ). dropIndex ({ newField : 1 }); }; ``` Running migrations : ```bash # Run migrations npx migrate-mongo up # Check migration status npx migrate-mongo status ``` Rolling back migrations : ```bash # Roll back last migration npx migrate-mongo down # Roll back to specific migration npx migrate-mongo down 1625000000000 ``` Backward Compatibility Considerations \u00b6 API versioning : ```javascript // Example API versioning app.use('/api/v1', v1Routes); app.use('/api/v2', v2Routes); // Redirect old routes app.use('/api/legacy/:resource', (req, res) => { res.redirect( /api/v1/${req.params.resource} ); }); ``` Smart contract compatibility : Never remove storage variables Add new functions rather than changing existing ones Use new facets for significant changes Use feature flags to control access to new features Client compatibility : ```javascript // Check client version and provide appropriate response Parse.Cloud.define(\"getFeatures\", async (request) => { const clientVersion = request.params.clientVersion; if ( semver . lt ( clientVersion , \"2.0.0\" )) { return legacyFeatureList ; } else { return newFeatureList ; } }); ``` Feature Flagging \u00b6 Implementing feature flags : ```javascript // Feature flag configuration const featureFlags = { newMarketplace: process.env.ENABLE_NEW_MARKETPLACE === \"true\", carbonCredits: process.env.ENABLE_CARBON_CREDITS === \"true\", nftFractionalization: process.env.ENABLE_NFT_FRACTIONALIZATION === \"true\" }; // Using feature flags Parse.Cloud.define(\"getMarketplace\", async (request) => { if (featureFlags.newMarketplace) { return getNewMarketplace(); } else { return getLegacyMarketplace(); } }); ``` Controlling access to new features : ```javascript // Progressive rollout Parse.Cloud.define(\"checkFeatureAccess\", async (request) => { const { feature, userId } = request.params; // Check if feature is enabled globally if ( ! featureFlags [ feature ] ) { return { hasAccess : false } ; } // Check if user is in beta group const user = await new Parse . Query ( Parse . User ) . get ( userId , { useMasterKey : true } ); const isBetaTester = user . get ( \"betaTester\" ) === true ; // Calculate percentage - based rollout const rolloutPercentage = 25 ; // 25 % of users const userIdNumber = parseInt ( userId . substring ( 0 , 8 ), 16 ); const userPercentile = userIdNumber % 100 ; return { hasAccess : isBetaTester || userPercentile < rolloutPercentage } ; }); ``` Rollback Procedures \u00b6 Smart Contract Rollbacks \u00b6 Rollback strategy for facets : ```javascript // scripts/rollback-facet.js async function main() { // Get diamond contract const diamond = await ethers.getContractAt(\"Diamond\", DIAMOND_ADDRESS); // Get previous version of the facet const previousFacetAddress = PREVIOUS_FACET_ADDRESS ; // Get selectors for the facet const selectors = SELECTORS ; // Create facet cut for rollback const facetCut = { facetAddress : previousFacetAddress , action : FacetCutAction . Replace , functionSelectors : selectors } ; // Perform the rollback const tx = await diamond . diamondCut ( [ facetCut ] , ethers . constants . AddressZero , \"0x\" ); await tx . wait (); console . log ( \"Facet rolled back successfully\" ); } ``` Diamond upgrade rollback : ```javascript // scripts/rollback-diamond.js async function main() { // Get diamond factory const diamondFactory = await ethers.getContractAt(\"DiamondFactory\", FACTORY_ADDRESS); // Get diamond to rollback const diamond = await ethers . getContractAt ( \"Diamond\" , DIAMOND_ADDRESS ); // Use previous facet set const previousFacetSet = \"previousFacetSet\" ; // Get facets from the set const facets = await diamondFactory . getFacets ( previousFacetSet ); // Rollback diamond const tx = await diamond . diamondCut ( facets , ethers . constants . AddressZero , \"0x\" ); await tx . wait (); console . log ( \"Diamond rolled back successfully\" ); } ``` Emergency pause : ```javascript // scripts/emergency-pause.js async function main() { // Get contract const contract = await ethers.getContractAt(\"PausableFacet\", DIAMOND_ADDRESS); // Pause the contract const tx = await contract . pause (); await tx . wait (); console . log ( \"Contract paused successfully\" ); } ``` Cloud Function Rollbacks \u00b6 Rolling back with Git : ```bash # Rollback to previous commit git reset --hard HEAD~1 npm install npm run build # Restart server pm2 restart gemforce-server ``` Using deployment tags : ```bash # List tags git tag -l # Checkout specific version git checkout v1.2.3 npm install npm run build # Restart server pm2 restart gemforce-server ``` Specific file rollback : ```bash # Revert specific file git checkout HEAD~1 -- src/cloud-functions/specific-file.ts npm run build # Restart server pm2 restart gemforce-server ``` Database Rollbacks \u00b6 Restoring from backup : bash # Restore MongoDB from backup mongorestore --uri=\"mongodb://username:password@host:port/database\" --drop /backup/path/YYYY-MM-DD Rolling back a migration : bash # Roll back the last migration npx migrate-mongo down Manual data correction script : ```javascript // scripts/correct-data.js async function main() { const MongoClient = require('mongodb').MongoClient; const client = await MongoClient.connect(process.env.DATABASE_URI); const db = client.db(); try { // Correct data issues await db.collection('User').updateMany( { incorrectField : { $ exists : true } } , { $ rename : { \"incorrectField\" : \"correctField\" } } ); console . log ( \"Data correction complete\" ); } catch ( error ) { console.error(\"Error correcting data : \" , error ); } finally { await client.close() ; } } main().catch(console.error); ``` Emergency Procedures \u00b6 Complete service rollback : ```bash # Emergency rollback script #!/bin/bash # scripts/emergency-rollback.sh # Stop the current service pm2 stop gemforce-server # Restore code from known good state git checkout v1.2.3 npm install npm run build # Restore database mongorestore --uri=\"$DATABASE_URI\" --drop /backups/latest # Restart the service pm2 start gemforce-server # Notify team curl -X POST -H \"Content-Type: application/json\" \\ -d '{\"text\":\"Emergency rollback performed to v1.2.3\"}' \\ $SLACK_WEBHOOK_URL ``` Read-only mode : ```javascript // Enable read-only mode Parse.Cloud.beforeSave(\"*\", async () => { if (process.env.READONLY_MODE === \"true\") { throw new Parse.Error( Parse.Error.OPERATION_FORBIDDEN, \"System is currently in read-only mode for maintenance.\" ); } }); Parse.Cloud.beforeDelete(\"*\", async () => { if (process.env.READONLY_MODE === \"true\") { throw new Parse.Error( Parse.Error.OPERATION_FORBIDDEN, \"System is currently in read-only mode for maintenance.\" ); } }); ``` Data Integrity Verification \u00b6 Verifying contract state : ```javascript // scripts/verify-contract-state.js async function main() { // Get contract const contract = await ethers.getContractAt(\"DiamondLoupe\", DIAMOND_ADDRESS); // Get all facets const facets = await contract . facets (); // Verify each facet for ( const facet of facets ) { console . log ( ` Verifying facet at $ { facet . facetAddress } ` ); // Get facet code const code = await ethers . provider . getCode ( facet . facetAddress ); // Check code is not empty if ( code === \"0x\" || code === \"0x0\" ) { throw new Error ( ` Facet at $ { facet . facetAddress } has no code ! ` ); } // Verify selectors for ( const selector of facet . functionSelectors ) { const result = await contract . facetAddress ( selector ); if ( result !== facet . facetAddress ) { throw new Error ( ` Selector $ { selector } points to wrong facet ! ` ); } } } console . log ( \"Contract state verification successful\" ); } main().catch(console.error); ``` Database integrity check : ```javascript // scripts/verify-database.js async function main() { const MongoClient = require('mongodb').MongoClient; const client = await MongoClient.connect(process.env.DATABASE_URI); const db = client.db(); try { // Check User collection integrity const userCount = await db . collection ( 'User' ) . countDocuments (); console . log ( ` User count : $ { userCount } ` ); // Check for duplicate emails const duplicateEmails = await db . collection ( 'User' ) . aggregate ([ { $ group : { _id : \"$email\" , count : { $ sum : 1 } } }, { $ match : { count : { $ gt : 1 } } } ]) . toArray (); if ( duplicateEmails . length > 0 ) { console . error ( ` Found $ { duplicateEmails . length } duplicate emails ! ` ); console . error ( duplicateEmails ); } // Verify indexes const indexes = await db . collection ( 'User' ) . indexes (); console . log ( \"Indexes:\" , indexes ); // More integrity checks ... console . log ( \"Database integrity check complete\" ); } finally { await client . close (); } } main().catch(console.error); ``` Testing and Verification \u00b6 Unit Testing \u00b6 Smart contract unit tests : ```javascript // test/unit/GemforceMinter.test.ts describe(\"GemforceMinter\", function() { let owner, user1, user2; let diamond, gemforceMinter; beforeEach ( async function () { [ owner , user1 , user2 ] = await ethers . getSigners (); // Deploy diamond with facets // ... deployment code gemforceMinter = await ethers . getContractAt ( \"GemforceMinterFacet\" , diamond . address ); }); it ( \"should allow owner to mint\" , async function () { const metadata = [ { key : \"name\" , attributeType : 0 , value : \"Carbon Credit\" } ]; const tx = await gemforceMinter . connect ( owner ) . gemforceMint ( metadata ); const receipt = await tx . wait (); // Check events const event = receipt . events . find ( e => e . event === \"GemforceMinted\" ); expect ( event ) . to . exist ; expect ( event . args . tokenId ) . to . equal ( 0 ); expect ( event . args . minter ) . to . equal ( owner . address ); }); it ( \"should revert when non-owner tries to mint\" , async function () { const metadata = [ { key : \"name\" , attributeType : 0 , value : \"Carbon Credit\" } ]; await expect ( gemforceMinter . connect ( user1 ) . gemforceMint ( metadata ) ) . to . be . revertedWith ( \"Only contract owner\" ); }); }); ``` Cloud function unit tests : ```javascript // test/unit/cloud-functions.test.js describe(\"Cloud Functions Unit Tests\", function() { before(function() { // Mock Parse this.originalParse = global.Parse; global.Parse = { Cloud: { define: (name, handler) => { this.cloudFunctions[name] = handler; } }, Error: { INVALID_PARAMS: 141 } }; // Load cloud functions this . cloudFunctions = {}; require ( \"../../src/cloud-functions/contracts\" ); }); after ( function () { global . Parse = this . originalParse ; }); it ( \"should validate parameters in addDiamondFacet\" , async function () { const handler = this . cloudFunctions . addDiamondFacet ; // Missing parameters try { await handler ({ params : {} }); assert . fail ( \"Should have thrown an error\" ); } catch ( e ) { expect ( e . code ) . to . equal ( Parse . Error . INVALID_PARAMS ); } // With valid parameters ( mocked ) const mockResult = { success : true }; this . addDiamondFacet = sinon . stub () . resolves ( mockResult ); const result = await handler ({ params : { networkId : \"1\" , diamondAddress : \"0x123\" , facetName : \"TestFacet\" } }); expect ( result ) . to . deep . equal ( mockResult ); }); }); ``` Integration Testing \u00b6 Smart contract integration tests : ```javascript // test/integration/marketplace-flow.test.ts describe(\"Marketplace Integration\", function() { let owner, seller, buyer; let diamond, marketplace, gem, treasury; before ( async function () { [ owner , seller , buyer ] = await ethers . getSigners (); // Deploy all contracts // ... deployment code // Get contract instances diamond = await ethers . getContractAt ( \"Diamond\" , diamondAddress ); marketplace = await ethers . getContractAt ( \"MarketplaceFacet\" , diamondAddress ); gem = await ethers . getContractAt ( \"GemforceMinterFacet\" , diamondAddress ); treasury = await ethers . getContractAt ( \"Treasury\" , treasuryAddress ); }); it ( \"should support full marketplace flow\" , async function () { // Mint token const metadata = [{ key : \"test\" , attributeType : 0 , value : \"value\" }]; await gem . connect ( owner ) . gemforceMint ( metadata ); // List token await marketplace . connect ( owner ) . listItem ( 0 , ethers . utils . parseEther ( \"1.0\" )); // Check listing const listing = await marketplace . getListing ( 0 ); expect ( listing . price ) . to . equal ( ethers . utils . parseEther ( \"1.0\" )); // Purchase token await marketplace . connect ( buyer ) . purchaseItem ( diamondAddress , 0 , { value : ethers . utils . parseEther ( \"1.0\" ) }); // Check ownership const newOwner = await diamond . ownerOf ( 0 ); expect ( newOwner ) . to . equal ( buyer . address ); // Check treasury balance const balance = await treasury . getBalance (); expect ( balance ) . to . be . gt ( 0 ); }); }); ``` API integration tests : ```javascript // test/integration/api-flow.test.js describe(\"API Integration\", function() { let user; before ( async function () { // Initialize Parse Parse . initialize ( \"test_app_id\" , \"test_js_key\" , \"test_master_key\" ); Parse . serverURL = \"http://localhost:1337/parse\" ; // Create test user user = new Parse . User (); user . set ( \"username\" , \"test@example.com\" ); user . set ( \"password\" , \"password\" ); user . set ( \"email\" , \"test@example.com\" ); await user . signUp (); }); it ( \"should handle user blockchain operations\" , async function () { // Get blockchains const blockchains = await Parse . Cloud . run ( \"loadAllBlockchains\" ); expect ( blockchains ) . to . be . an ( \"array\" ); // Create DFNS wallet ( mocked ) const walletResult = await Parse . Cloud . run ( \"registerInit\" , { username : user . get ( \"email\" ) }); expect ( walletResult ) . to . have . property ( \"challenge\" ); // Complete registration ( mocked ) const registrationResult = await Parse . Cloud . run ( \"registerComplete\" , { signedChallenge : \"mocked_challenge\" , temporaryAuthenticationToken : \"mocked_token\" }); expect ( registrationResult ) . to . have . property ( \"token\" ); // List wallets const wallets = await Parse . Cloud . run ( \"listWallets\" , { authToken : registrationResult . token }); expect ( wallets ) . to . have . property ( \"wallets\" ); }); }); ``` Contract Verification \u00b6 Verifying contracts on block explorer : ```bash # Verify contract on Etherscan or Basescan npx hardhat verify --network baseSepolia # Verify contract with libraries npx hardhat verify --network baseSepolia \\ --libraries Library1=0x123... Library2=0x456... ``` Automated verification script : ```javascript // scripts/verify-contracts.js async function main() { // Get deployment data const deployments = require('../deployments.json'); const network = process.env.NETWORK || 'baseSepolia'; const networkId = hre.config.networks[network].chainId; // Verify Diamond contract const diamondAddress = deployments [ networkId ] . diamondAddress ; console . log ( ` Verifying Diamond at ${ diamondAddress }` ); try { await hre . run ( \"verify:verify\" , { address : diamondAddress , constructorArguments : [] } ); } catch ( e ) { console . log ( ` Error verifying Diamond : ${ e . message }` ); } // Verify Facets const facets = deployments [ networkId ] . facets || [] ; for ( const facet of facets ) { console . log ( ` Verifying facet ${ facet . name } at ${ facet . address }` ); try { await hre . run ( \"verify:verify\" , { address : facet . address , constructorArguments : [] } ); } catch ( e ) { console . log ( ` Error verifying ${ facet . name }: ${ e . message }` ); } } } main().catch(console.error); ``` Load Testing \u00b6 Smart contract load testing : ```javascript // test/load/contract-load.test.js describe(\"Contract Load Test\", function() { // Increase timeout for load tests this.timeout(300000); let diamond , minter ; let signers ; before ( async function () { // Get signers signers = await ethers . getSigners (); // Deploy contracts // ... deployment code diamond = await ethers . getContractAt ( \"Diamond\" , diamondAddress ); minter = await ethers . getContractAt ( \"GemforceMinterFacet\" , diamondAddress ); }); it ( \"should handle concurrent minting\" , async function () { const concurrentMints = 50 ; const mintPromises = []; // Create concurrent mint operations for ( let i = 0 ; i < concurrentMints ; i ++ ) { const metadata = [ { key : \"name\" , attributeType : 0 , value : ` Token $ { i } ` }, { key : \"value\" , attributeType : 1 , value : i . toString () } ]; mintPromises . push ( minter . connect ( signers [ 0 ]) . gemforceMint ( metadata )); } // Wait for all mints to complete const results = await Promise . allSettled ( mintPromises ); // Count successful mints const successfulMints = results . filter ( r => r . status === \"fulfilled\" ) . length ; console . log ( ` Successfully minted $ { successfulMints } of $ { concurrentMints } tokens ` ); // Analyze failures const failures = results . filter ( r => r . status === \"rejected\" ); for ( const failure of failures ) { console . log ( ` Failure reason : $ { failure . reason } ` ); } expect ( successfulMints ) . to . be . gt ( 0 ); }); }); ``` API load testing with Artillery : ```yaml # load-tests/api-load.yml config: target: \"https://api.gemforce.com\" phases: - duration: 60 arrivalRate: 5 rampTo: 50 name: \"Warm up phase\" - duration: 120 arrivalRate: 50 name: \"Sustained load\" - duration: 60 arrivalRate: 50 rampTo: 100 name: \"Peak load\" defaults: headers: X-Parse-Application-Id: \"{{APP_ID}}\" Content-Type: \"application/json\" scenarios: - name: \"Load test API endpoints\" flow: - post: url: \"/parse/functions/loadAllBlockchains\" json: {} expect: - statusCode: 200 - post: url: \"/parse/functions/loadProviderUrl\" json: networkId: \"84532\" expect: - statusCode: 200 - post: url: \"/parse/functions/loadSmartContractsForNetwork\" json: networkId: \"84532\" expect: - statusCode: 200 ``` Run with: bash npx artillery run load-tests/api-load.yml --environment production Security Testing \u00b6 Smart contract security testing : ```bash # Run Slither security analyzer slither contracts/ # Run Mythril myth analyze contracts/Diamond.sol ``` Penetration testing for API : bash # Run OWASP ZAP scan zap-cli quick-scan -s xss,sqli -r report.html https://api.gemforce.com Authentication security tests : ```javascript // test/security/auth.test.js describe(\"Authentication Security\", function() { it(\"should reject invalid authentication\", async function() { // Try with invalid app ID try { Parse.initialize(\"invalid_app_id\", \"test_js_key\"); await Parse.Cloud.run(\"loadAllBlockchains\"); assert.fail(\"Should have thrown an error\"); } catch (e) { expect(e.code).to.equal(Parse.Error.INVALID_APP_ID); } // Try with invalid master key try { Parse . initialize ( \"test_app_id\" , \"test_js_key\" , \"invalid_master_key\" ); const user = new Parse . User (); await user . fetch ({ useMasterKey : true }); assert . fail ( \"Should have thrown an error\" ); } catch ( e ) { expect ( e . code ) . to . equal ( Parse . Error . INVALID_MASTER_KEY ); } }); }); ``` Network Management \u00b6 Blockchain Node Management \u00b6 Connecting to blockchain nodes : ```javascript // src/lib/blockchain.js const { ethers } = require(\"ethers\"); // Get provider for network function getProvider(networkId) { const networks = { \"1\": process.env.ETH_NODE_URI_MAINNET, \"84532\": process.env.ETH_NODE_URI_BASESEP }; const nodeUrl = networks [ networkId ] ; if ( ! nodeUrl ) { throw new Error ( ` No RPC endpoint configured for network ${ networkId }` ); } return new ethers . providers . JsonRpcProvider ( nodeUrl ); } // Get WebSocket provider for network function getWebSocketProvider(networkId) { const networks = { \"1\": process.env.ETH_WSS_URI_MAINNET, \"84532\": process.env.ETH_WSS_URI_BASESEP }; const nodeUrl = networks [ networkId ] ; if ( ! nodeUrl ) { throw new Error ( ` No WebSocket endpoint configured for network ${ networkId }` ); } return new ethers . providers . WebSocketProvider ( nodeUrl ); } module.exports = { getProvider, getWebSocketProvider }; ``` Monitoring node health : ```javascript // src/lib/node-monitor.js const { getProvider } = require(\"./blockchain\"); async function checkNodeHealth(networkId) { try { const provider = getProvider(networkId); // Check if node is responding const blockNumber = await provider . getBlockNumber (); // Check if node is synced const syncStatus = await provider . send ( \"eth_syncing\" , []); const isSynced = syncStatus === false ; // Check chain ID const chainId = await provider . getNetwork () . then ( net => net . chainId ); const isCorrectChain = chainId . toString () === networkId ; // Check peers const peerCount = await provider . send ( \"net_peerCount\" , []); const peers = parseInt ( peerCount , 16 ); const hasPeers = peers > 0 ; return { isHealthy : isSynced && isCorrectChain && hasPeers , blockNumber , isSynced , isCorrectChain , peers }; } catch ( error ) { return { isHealthy : false , error : error . message }; } } ``` Node failover : ```javascript // src/lib/node-failover.js const { ethers } = require(\"ethers\"); class FailoverProvider extends ethers.providers.StaticJsonRpcProvider { constructor(urls, network) { super(urls[0], network); this.urls = urls; this.currentUrlIndex = 0; } async send(method, params) { try { return await super.send(method, params); } catch (error) { // Try failover if (this.urls.length > 1) { this.currentUrlIndex = (this.currentUrlIndex + 1) % this.urls.length; this.connection.url = this.urls[this.currentUrlIndex]; console.log(`Failing over to ${ this . connection . url } `); return await super.send(method, params); } throw error; } } } function getFailoverProvider(networkId) { const networks = { \"1\": [ process.env.ETH_NODE_URI_MAINNET_1, process.env.ETH_NODE_URI_MAINNET_2, process.env.ETH_NODE_URI_MAINNET_3 ], \"84532\": [ process.env.ETH_NODE_URI_BASESEP_1, process.env.ETH_NODE_URI_BASESEP_2 ] }; const urls = networks [ networkId ] . filter ( Boolean ); if ( urls . length === 0 ) { throw new Error ( ` No RPC endpoints configured for network ${ networkId }` ); } return new FailoverProvider ( urls , parseInt ( networkId )); } ``` RPC Endpoint Configuration \u00b6 Configuration file for RPC endpoints : javascript // config/networks.js module.exports = { mainnet: { chainId: 1, name: \"Ethereum Mainnet\", rpcEndpoints: [ { url: process.env.ETH_NODE_URI_MAINNET_1, provider: \"Infura\", weight: 10 }, { url: process.env.ETH_NODE_URI_MAINNET_2, provider: \"Alchemy\", weight: 5 }, { url: process.env.ETH_NODE_URI_MAINNET_3, provider: \"Custom\", weight: 1 } ], wsEndpoints: [ { url: process.env.ETH_WSS_URI_MAINNET, provider: \"Infura\" } ], explorerUrl: \"https://etherscan.io\" }, baseSepolia: { chainId: 84532, name: \"Base Sepolia\", rpcEndpoints: [ { url: process.env.ETH_NODE_URI_BASESEP_1, provider: \"Base\", weight: 10 }, { url: process.env.ETH_NODE_URI_BASESEP_2, provider: \"Alchemy\", weight: 5 } ], wsEndpoints: [ { url: process.env.ETH_WSS_URI_BASESEP, provider: \"Base\" } ], explorerUrl: \"https://sepolia.basescan.org\" } }; RPC endpoint selection logic : ```javascript // src/lib/rpc-manager.js const networks = require(\"../../config/networks\"); function selectRpcEndpoint(networkId) { const network = Object.values(networks).find(n => n.chainId === parseInt(networkId)); if (!network) { throw new Error( Network ${networkId} not found in configuration ); } // Use weighted selection const endpoints = network . rpcEndpoints . filter ( e => e . url ); if ( endpoints . length === 0 ) { throw new Error ( ` No RPC endpoints configured for network $ { networkId } ` ); } // Simple random selection for now // Could be expanded to use performance metrics or more complex selection const totalWeight = endpoints . reduce (( sum , e ) => sum + e . weight , 0 ); let random = Math . random () * totalWeight ; for ( const endpoint of endpoints ) { random -= endpoint . weight ; if ( random <= 0 ) { return endpoint . url ; } } // Fallback to first endpoint return endpoints [ 0 ] . url ; } ``` Environment-specific configuration : ```javascript // src/lib/network-config.js const networks = require(\"../../config/networks\"); function getNetworkConfig(networkId, environment = process.env.NODE_ENV) { const network = Object.values(networks).find(n => n.chainId === parseInt(networkId)); if (!network) { throw new Error( Network ${networkId} not found in configuration ); } // Apply environment - specific overrides const envOverrides = { development : { rpcEndpoints : [ { url: \"http://localhost:8545\", provider: \"Local\", weight: 100 } ] } , test : { // Test environment might use special endpoints } , // production uses default configuration } ; if ( envOverrides [ environment ] ) { return { ... network , ... envOverrides [ environment ] } ; } return network ; } ``` Transaction Monitoring \u00b6 Monitoring transaction status : ```javascript // src/lib/transaction-monitor.js const { getProvider } = require(\"./blockchain\"); const db = require(\"./db\"); async function monitorTransaction(txHash, networkId) { const provider = getProvider(networkId); // Store the transaction in the database await db . collection ( \"Transaction\" ). insertOne ({ hash : txHash , networkId , status : \"pending\" , createdAt : new Date (), attempts : 0 }); // Get initial transaction receipt let receipt = await provider . getTransactionReceipt ( txHash ); // Transaction is still pending if ( ! receipt ) { // Schedule check for later setTimeout (() = > checkTransaction ( txHash , networkId ), 15000 ); return { status : \"pending\" }; } // Transaction is mined updateTransactionStatus ( txHash , receipt ); return { status : receipt . status ? \"confirmed\" : \"failed\" , receipt }; } async function checkTransaction(txHash, networkId) { try { const provider = getProvider(networkId); const receipt = await provider.getTransactionReceipt(txHash); if ( ! receipt ) { // Still pending , check if it 's been too long const tx = await db . collection ( \"Transaction\" ) . findOne ({ hash : txHash }); const age = Date . now () - tx . createdAt . getTime (); const attempts = tx . attempts + 1 ; await db . collection ( \"Transaction\" ) . updateOne ( { hash : txHash }, { $ set : { attempts }, $ currentDate : { lastChecked : true } } ); if ( age > 3600000 ) { // 1 hour // Transaction has been pending too long await db . collection ( \"Transaction\" ) . updateOne ( { hash : txHash }, { $ set : { status : \"stalled\" } } ); // Could notify an admin here } else { // Check again later setTimeout (() => checkTransaction ( txHash , networkId ), 30000 ); } return ; } // Transaction is mined , update status updateTransactionStatus ( txHash , receipt ); } catch ( error ) { console . error ( ` Error checking transaction $ { txHash }: ` , error ); } } async function updateTransactionStatus(txHash, receipt) { const status = receipt.status ? \"confirmed\" : \"failed\"; await db . collection ( \"Transaction\" ) . updateOne ( { hash : txHash } , { $ set : { status , blockNumber : receipt . blockNumber , gasUsed : receipt . gasUsed . toString (), effectiveGasPrice : receipt . effectiveGasPrice . toString () } } ); } ``` Transaction event listener : ```javascript // src/lib/event-listener.js const { getWebSocketProvider } = require(\"./blockchain\"); const db = require(\"./db\"); class TransactionEventListener { constructor(networkId) { this.networkId = networkId; this.provider = getWebSocketProvider(networkId); this.contracts = new Map(); } addContract ( address , abi , name ) { const contract = new ethers . Contract ( address , abi , this . provider ); this . contracts . set ( address , { contract , name }); console . log ( ` Added contract $ { name } at $ { address } for event monitoring ` ); return contract ; } startListening () { // Listen for new blocks this . provider . on ( \"block\" , this . handleNewBlock . bind ( this )); // Listen for specific events on each contract for ( const [ address , { contract , name }] of this . contracts . entries ()) { contract . on ( \"*\" , ( ... args ) => { const event = args [ args . length - 1 ]; this . handleContractEvent ( name , event ); }); } } async handleNewBlock ( blockNumber ) { console . log ( ` New block : $ { blockNumber } on network $ { this . networkId } ` ); // Check pending transactions const pendingTxs = await db . collection ( \"Transaction\" ) . find ({ networkId : this . networkId , status : \"pending\" }) . toArray (); for ( const tx of pendingTxs ) { try { const receipt = await this . provider . getTransactionReceipt ( tx . hash ); if ( receipt ) { const status = receipt . status ? \"confirmed\" : \"failed\" ; await db . collection ( \"Transaction\" ) . updateOne ( { hash : tx . hash }, { $ set : { status , blockNumber : receipt . blockNumber , gasUsed : receipt . gasUsed . toString (), effectiveGasPrice : receipt . effectiveGasPrice . toString () } } ); console . log ( ` Transaction $ { tx . hash } $ { status } in block $ { receipt . blockNumber } ` ); } } catch ( error ) { console . error ( ` Error checking transaction $ { tx . hash }: ` , error ); } } } async handleContractEvent ( contractName , event ) { console . log ( ` Event from $ { contractName }: $ { event . event } ` ); // Store event in database await db . collection ( \"ContractEvent\" ) . insertOne ({ contractName , eventName : event . event , transactionHash : event . transactionHash , blockNumber : event . blockNumber , args : JSON . parse ( JSON . stringify ( event . args )), // Convert BigNumber to string timestamp : new Date () }); // Emit event for WebSocket clients if needed } stop () { this . provider . removeAllListeners (); for ( const [ address , { contract }] of this . contracts . entries ()) { contract . removeAllListeners (); } console . log ( ` Stopped event listener for network $ { this . networkId } ` ); } } ``` Gas Price Management \u00b6 Gas price estimation : ```javascript // src/lib/gas-price.js const { ethers } = require(\"ethers\"); const { getProvider } = require(\"./blockchain\"); async function estimateGasPrice(networkId, priority = \"medium\") { try { const provider = getProvider(networkId); // Get current gas price from provider const gasPrice = await provider . getGasPrice (); // Apply multipliers based on priority const multipliers = { low : 0.8 , medium : 1.0 , high : 1.5 , urgent : 2.0 } ; const multiplier = multipliers [ priority ] || 1.0 ; return gasPrice . mul ( Math . floor ( multiplier * 100 )). div ( 100 ); } catch ( error ) { console . error ( ` Error estimating gas price : ` , error ); // Fallback gas prices ( in gwei ) const fallbackPrices = { 1 : { low : 20 , medium : 30 , high : 50 , urgent : 80 } , // Mainnet 84532 : { low : 1 , medium : 1.5 , high : 2 , urgent : 3 } // BaseSepolia } ; const gweiPrice = fallbackPrices [ networkId ] ? . [ priority ] || 10 ; return ethers . utils . parseUnits ( gweiPrice . toString (), \"gwei\" ); } } async function getGasSettings(networkId, priority = \"medium\") { const gasPrice = await estimateGasPrice(networkId, priority); // For EIP - 1559 compatible networks , use maxFeePerGas and maxPriorityFeePerGas const provider = getProvider ( networkId ); const network = await provider . getNetwork (); // Check if network supports EIP - 1559 const block = await provider . getBlock ( \"latest\" ); const eip1559Support = block && block . baseFeePerGas !== undefined ; if ( eip1559Support ) { const baseFeePerGas = block . baseFeePerGas ; // Priority fee multipliers const priorityFeeMultipliers = { low : 1.0 , medium : 1.5 , high : 2.0 , urgent : 3.0 } ; const multiplier = priorityFeeMultipliers [ priority ] || 1.5 ; const maxPriorityFeePerGas = ethers . utils . parseUnits ( \"1\" , \"gwei\" ). mul ( multiplier ); // maxFeePerGas = ( baseFeePerGas * 2 ) + maxPriorityFeePerGas const maxFeePerGas = baseFeePerGas . mul ( 2 ). add ( maxPriorityFeePerGas ); return { maxFeePerGas , maxPriorityFeePerGas } ; } // Fallback to regular gasPrice for non - EIP - 1559 networks return { gasPrice } ; } ``` Transaction submission with gas management : ```javascript // src/lib/transaction.js const { getProvider } = require(\"./blockchain\"); const { getGasSettings } = require(\"./gas-price\"); async function sendTransaction(networkId, txData, priority = \"medium\") { const provider = getProvider(networkId); const signer = new ethers.Wallet(process.env.PRIVATE_KEY, provider); // Get gas settings based on network and priority const gasSettings = await getGasSettings ( networkId , priority ); // Estimate gas limit const gasLimit = await provider . estimateGas ({ from : signer . address , to : txData . to , data : txData . data , value : txData . value || 0 }); // Add buffer to gas limit const gasLimitWithBuffer = gasLimit . mul ( 120 ) . div ( 100 ); // 20 % buffer // Construct transaction const transaction = { from : signer . address , to : txData . to , data : txData . data , value : txData . value || 0 , gasLimit : gasLimitWithBuffer , ... gasSettings }; // Send transaction const tx = await signer . sendTransaction ( transaction ); console . log ( ` Transaction sent : $ { tx . hash } ` ); return tx ; } ``` Network Upgrades Handling \u00b6 Network upgrade detector : ```javascript // src/lib/network-upgrade.js const { getProvider } = require(\"./blockchain\"); async function checkNetworkUpgrade(networkId) { try { const provider = getProvider(networkId); // Get current block const block = await provider . getBlock ( \"latest\" ); // Check for fork identifier or other upgrade indicators const isEIP1559 = block && block . baseFeePerGas !== undefined ; // Check for upcoming network upgrades const upgrades = { 1 : [ // Ethereum Mainnet { name: \"Cancun\", block: 19000000, active: block.number >= 19000000 } ] , 84532 : [ // BaseSepolia { name: \"Future Upgrade\", block: 5000000, active: block.number >= 5000000 } ] } ; const networkUpgrades = upgrades [ networkId ] || [] ; const upcomingUpgrades = networkUpgrades . filter ( u => ! u . active ); const activeUpgrades = networkUpgrades . filter ( u => u . active ); return { currentBlock : block . number , features : { eip1559 : isEIP1559 } , activeUpgrades , upcomingUpgrades } ; } catch ( error ) { console . error ( ` Error checking network upgrade : ` , error ); return { error : error . message } ; } } ``` Handling network forks : ```javascript // src/lib/fork-handler.js const { getProvider } = require(\"./blockchain\"); class ForkHandler { constructor(networkId) { this.networkId = networkId; this.provider = getProvider(networkId); this.forkBlocks = { 1: { // Ethereum Mainnet \"Cancun\": 19000000 }, 84532: { // BaseSepolia \"FutureUpgrade\": 5000000 } }; } async detectFork () { const currentBlock = await this . provider . getBlockNumber (); const networkForks = this . forkBlocks [ this . networkId ] || {}; const activeForks = []; const pendingForks = []; for ( const [ name , blockNumber ] of Object . entries ( networkForks )) { if ( currentBlock >= blockNumber ) { activeForks . push ({ name , blockNumber }); } else { pendingForks . push ({ name , blockNumber , blocksRemaining : blockNumber - currentBlock }); } } return { currentBlock , activeForks , pendingForks }; } async adjustForFork ( txParams ) { const forkStatus = await this . detectFork (); const newParams = { ... txParams }; // Adjust transaction parameters based on active forks for ( const fork of forkStatus . activeForks ) { if ( fork . name === \"Cancun\" || fork . name === \"London\" ) { // EIP - 1559 transaction type delete newParams . gasPrice ; if ( ! newParams . maxFeePerGas ) { const block = await this . provider . getBlock ( \"latest\" ); const baseFeePerGas = block . baseFeePerGas ; newParams . maxPriorityFeePerGas = ethers . utils . parseUnits ( \"1.5\" , \"gwei\" ); newParams . maxFeePerGas = baseFeePerGas . mul ( 2 ) . add ( newParams . maxPriorityFeePerGas ); } // Set type 2 transaction ( EIP - 1559 ) newParams . type = 2 ; } } return newParams ; } } ``` Version Control \u00b6 Repository Structure \u00b6 Recommended repository structure : gemforce/ \u251c\u2500\u2500 .github/ # GitHub workflows and templates \u251c\u2500\u2500 contracts/ # Smart contracts \u2502 \u251c\u2500\u2500 facets/ # Diamond facets \u2502 \u251c\u2500\u2500 interfaces/ # Contract interfaces \u2502 \u251c\u2500\u2500 libraries/ # Contract libraries \u2502 \u251c\u2500\u2500 upgradeInitializers/ # Initializers for upgrades \u251c\u2500\u2500 deploy/ # Deployment scripts \u251c\u2500\u2500 deployments/ # Deployment artifacts \u251c\u2500\u2500 docs/ # Documentation \u251c\u2500\u2500 scripts/ # Utility scripts \u251c\u2500\u2500 src/ # Source code \u2502 \u251c\u2500\u2500 cloud-functions/ # Parse cloud functions \u2502 \u251c\u2500\u2500 lib/ # Shared libraries \u2502 \u251c\u2500\u2500 indexer/ # Blockchain indexer \u2502 \u251c\u2500\u2500 triggers/ # Parse triggers \u251c\u2500\u2500 test/ # Tests \u2502 \u251c\u2500\u2500 unit/ # Unit tests \u2502 \u251c\u2500\u2500 integration/ # Integration tests \u2502 \u251c\u2500\u2500 fixtures/ # Test fixtures \u251c\u2500\u2500 .env.example # Example environment variables \u251c\u2500\u2500 hardhat.config.ts # Hardhat configuration \u251c\u2500\u2500 package.json # Project metadata and dependencies \u251c\u2500\u2500 tsconfig.json # TypeScript configuration \u2514\u2500\u2500 README.md # Project documentation Repository organization best practices : Separate smart contracts from off-chain code Organize contracts by functionality Use descriptive folder names Keep tests close to the code they test Include documentation for each component Branching Strategy \u00b6 Git Flow branching model : main \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500 (production releases) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 staging \u2502 \u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500 (pre-production testing) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 develop \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500 (integration branch) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 feature/xyz \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf \u2502 \u2502 (feature branches) \u2502 \u2502 \u2502 feature/abc \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u25cf \u2502 (feature branches) \u2502 hotfix/123 \u25cf\u2500\u2500\u2500\u2500\u2500 (hotfix branches) main : Production code, tagged with version numbers staging : Pre-production testing develop : Integration branch for feature development feature/ *: Feature branches for new development hotfix/ *: Urgent fixes for production issues Branching guidelines : ```bash # Create a new feature branch from develop git checkout develop git pull git checkout -b feature/new-feature # Work on the feature, committing changes git add . git commit -m \"Implement new feature\" # Push feature branch to remote git push -u origin feature/new-feature # When feature is complete, merge to develop git checkout develop git pull git merge --no-ff feature/new-feature git push origin develop # Create a hotfix branch from main git checkout main git pull git checkout -b hotfix/critical-fix # Fix the issue, commit changes git add . git commit -m \"Fix critical issue\" # Push hotfix branch git push -u origin hotfix/critical-fix # When hotfix is complete, merge to main and develop git checkout main git pull git merge --no-ff hotfix/critical-fix git push origin main git checkout develop git pull git merge --no-ff hotfix/critical-fix git push origin develop ``` Release Management \u00b6 Semantic versioning : MAJOR.MINOR.PATCH MAJOR : Breaking changes MINOR : New features, backwards compatible PATCH : Bug fixes, backwards compatible Release process : ```bash # Prepare release from develop git checkout develop git pull git checkout -b release/1.2.0 # Update version numbers npm version minor --no-git-tag-version # Make final adjustments git add . git commit -m \"Prepare release 1.2.0\" # Merge to staging for testing git checkout staging git pull git merge --no-ff release/1.2.0 git push origin staging # Deploy to staging environment npm run deploy:staging # After testing, merge to main git checkout main git pull git merge --no-ff release/1.2.0 git tag -a v1.2.0 -m \"Release 1.2.0\" git push origin main --tags # Update develop with any changes git checkout develop git pull git merge --no-ff release/1.2.0 git push origin develop # Delete release branch git branch -d release/1.2.0 ``` Changelog management : ```markdown # Changelog All notable changes to this project will be documented in this file. ## [1.2.0] - 2025-02-25 ### Added - New carbon credit retirement feature - Support for multiple wallet providers ### Changed - Improved marketplace performance - Updated identity verification flow ### Fixed - Fixed issue with token minting - Resolved WebSocket connection stability ## [1.1.0] - 2025-01-15 ### Added - Identity management system - DFNS wallet integration ### Changed - Upgraded Parse Server to latest version - Improved error handling ### Deprecated - Legacy API endpoints (to be removed in 2.0) ``` Tagging Conventions \u00b6 Version tags : ```bash # Create an annotated version tag git tag -a v1.2.0 -m \"Release 1.2.0\" # Push tags to remote git push origin --tags ``` Environment tags : ```bash # Create a tag for production deployment git tag -a prod-2025-02-25 -m \"Production deployment on Feb 25, 2025\" # Create a tag for staging deployment git tag -a staging-2025-02-20 -m \"Staging deployment on Feb 20, 2025\" ``` Contract deployment tags : ```bash # Create a tag for contract deployment git tag -a deploy-mainnet-1.2.0 -m \"Mainnet contract deployment v1.2.0\" # Create a tag for facet upgrade git tag -a upgrade-marketplace-1.2.1 -m \"Marketplace facet upgrade to v1.2.1\" ``` Documentation Versioning \u00b6 Documentation directory structure : docs/ \u251c\u2500\u2500 latest/ # Latest documentation (symlink to current version) \u251c\u2500\u2500 v1.2.0/ # Documentation for v1.2.0 \u2502 \u251c\u2500\u2500 admin-guide.md # Administrator guide \u2502 \u251c\u2500\u2500 api-reference.md # API reference \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 v1.1.0/ # Documentation for v1.1.0 \u2502 \u251c\u2500\u2500 admin-guide.md # Administrator guide \u2502 \u251c\u2500\u2500 api-reference.md # API reference \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 ... Version-specific documentation : ```bash # Create a new documentation version mkdir -p docs/v1.2.0 cp -r docs/v1.1.0/* docs/v1.2.0/ # Update documentation for new version # Edit files in docs/v1.2.0/ # Update the latest symlink rm docs/latest ln -s v1.2.0 docs/latest ``` Documentation in the codebase : ```solidity // contracts/facets/MarketplaceFacet.sol /* * @title MarketplaceFacet * @dev Implements marketplace functionality for the Diamond * @notice This facet handles listing, buying, and selling tokens * @version 1.2.0 / contract MarketplaceFacet is Modifiers { // ... ``` ```javascript // src/cloud-functions/marketplace.js /* * @api {post} /parse/functions/listItem List an item for sale * @apiVersion 1.2.0 * @apiName ListItem * @apiGroup Marketplace * @apiDescription Lists a token for sale in the marketplace * * @apiParam {String} tokenId The ID of the token to list * @apiParam {String} price The price in ETH * * @apiSuccess {Object} result The result of the operation * @apiSuccess {Boolean} result.success Whether the operation was successful * @apiSuccess {String} result.transactionHash The transaction hash / Parse.Cloud.define(\"listItem\", async (request) => { // ... });","title":"Deployer Guide"},{"location":"gemforce-deployer-guide/#gemforce-deployer-guide","text":"","title":"Gemforce Deployer Guide"},{"location":"gemforce-deployer-guide/#table-of-contents","text":"Deployment Prerequisites Smart Contract Deployment Cloud Functions Deployment Environment Configuration Deployment Automation Upgrade Procedures Rollback Procedures Testing and Verification Network Management Version Control","title":"Table of Contents"},{"location":"gemforce-deployer-guide/#deployment-prerequisites","text":"","title":"Deployment Prerequisites"},{"location":"gemforce-deployer-guide/#development-environment-setup","text":"To deploy the Gemforce platform, you'll need the following tools and software: Node.js and npm : Node.js v16 or later npm v7 or later ```bash # Install using nvm (recommended) nvm install 16 nvm use 16 # Verify installation node -v npm -v ``` Hardhat : Used for smart contract development and deployment ```bash # Install hardhat npm install --save-dev hardhat # Verify installation npx hardhat --version ``` MongoDB : Version 4.4 or later Required for Parse Server ```bash # Installation varies by OS # macOS (using Homebrew) brew install mongodb-community # Verify installation mongod --version ``` Git : For version control bash # Verify installation git --version TypeScript : Latest version ```bash # Install TypeScript npm install -g typescript # Verify installation tsc --version ```","title":"Development Environment Setup"},{"location":"gemforce-deployer-guide/#required-tools-and-software","text":"Development IDE : Visual Studio Code (recommended) Plugins: Solidity TypeScript ESLint Prettier Blockchain Tools : MetaMask or similar wallet Etherscan account (for contract verification) Infura or Alchemy account (for RPC endpoints) Deployment Tools : PM2 (for process management) Docker (optional, for containerized deployment) ```bash # Install PM2 npm install -g pm2 # Verify installation pm2 --version ``` Database Tools : MongoDB Compass (GUI for MongoDB) MongoDB Database Tools (mongodump, mongorestore)","title":"Required Tools and Software"},{"location":"gemforce-deployer-guide/#network-access-requirements","text":"Ensure your deployment environment has access to: Blockchain Networks : Ethereum Mainnet (if deploying to production) BaseSepolia (for testing) Other EVM-compatible networks as needed External APIs : DFNS API Bridge API SendGrid API Database Access : MongoDB server (local or hosted) Redis (if using for caching) Github/Version Control : Access to Gemforce repositories","title":"Network Access Requirements"},{"location":"gemforce-deployer-guide/#key-management-setup","text":"Create a secure key management strategy : bash # Create a directory for keys (outside of repository) mkdir -p ~/.gemforce/keys chmod 700 ~/.gemforce/keys Generate deployment keys : ```bash # Generate a private key for deployment openssl genpkey -algorithm RSA -out ~/.gemforce/keys/deployment_key.pem -pkeyopt rsa_keygen_bits:2048 chmod 600 ~/.gemforce/keys/deployment_key.pem # Generate a DFNS private key openssl genpkey -algorithm RSA -out ~/.gemforce/keys/dfns_private.key -pkeyopt rsa_keygen_bits:2048 chmod 600 ~/.gemforce/keys/dfns_private.key ``` Use environment files for sensitive data : ```bash # Create a .env file for local development cp .env.example .env # Edit to add your keys and endpoints nano .env ```","title":"Key Management Setup"},{"location":"gemforce-deployer-guide/#environment-preparation","text":"Clone the repository : bash git clone https://github.com/your-org/gemforce.git cd gemforce Install dependencies : bash npm install Set up environment files : ```bash # Copy sample environment files cp .env.example .env cp gemforce.config.example.ts gemforce.config.ts # Edit the files with your configuration nano .env nano gemforce.config.ts ``` Create deployment directories : bash mkdir -p deployments","title":"Environment Preparation"},{"location":"gemforce-deployer-guide/#smart-contract-deployment","text":"","title":"Smart Contract Deployment"},{"location":"gemforce-deployer-guide/#contract-compilation","text":"Compile contracts using Hardhat : bash npx hardhat compile Verify compilation output : Check for successful compilation in artifacts/ directory Resolve any compilation errors Configuration for different networks : javascript // hardhat.config.ts module.exports = { solidity: { version: \"0.8.17\", settings: { optimizer: { enabled: true, runs: 200 } } }, networks: { hardhat: { chainId: 31337 }, baseSepolia: { url: `https://sepolia.base.org`, accounts: [process.env.PRIVATE_KEY], chainId: 84532 }, mainnet: { url: `https://mainnet.infura.io/v3/${process.env.INFURA_KEY}`, accounts: [process.env.PRIVATE_KEY], chainId: 1 } } };","title":"Contract Compilation"},{"location":"gemforce-deployer-guide/#diamond-pattern-deployment-workflow","text":"The Gemforce platform uses the Diamond pattern (EIP-2535) for smart contract deployment: Deploy libraries first : bash npx hardhat deploy --tags Libraries --network baseSepolia Deploy facets : bash npx hardhat deploy --tags Facets --network baseSepolia Deploy Diamond contract : bash npx hardhat deploy --tags Diamond --network baseSepolia Verify the deployment : bash npx hardhat verify --network baseSepolia <DIAMOND_ADDRESS>","title":"Diamond Pattern Deployment Workflow"},{"location":"gemforce-deployer-guide/#facet-deployment-process","text":"Develop new facets in the /contracts/facets directory Add to deployment scripts in /deploy directory Set up facet cut data for the Diamond contract: javascript // Example facet cut data const facetCuts = [ { facetAddress: newFacetAddress, action: FacetCutAction.Add, functionSelectors: selectors } ]; Update the Diamond with new facets: javascript // Using the DiamondFactory await diamondFactory.setFacets(setName, facetCuts);","title":"Facet Deployment Process"},{"location":"gemforce-deployer-guide/#contract-initialization","text":"Prepare initialization data : javascript // Example initialization data const initData = diamondInit.interface.encodeFunctionData(\"init\", [ [ // Initial parameters tokenName, tokenSymbol, baseURI, // ...other params ] ]); Initialize the Diamond : ```javascript const settings = { name: \"Gemforce Token\", symbol: \"GEM\", // other settings }; await diamondFactory.createFromSet( settings, diamondInit.address, initData, \"defaultFacetSet\" ); ```","title":"Contract Initialization"},{"location":"gemforce-deployer-guide/#contract-verification","text":"Verify Diamond contract on Etherscan/Basescan : bash npx hardhat verify --network baseSepolia <DIAMOND_ADDRESS> Verify individual facets : bash npx hardhat verify --network baseSepolia <FACET_ADDRESS> Manual verification (if automatic verification fails): Flatten the contract using Hardhat Upload the flattened contract to the block explorer Verify with the correct compiler settings","title":"Contract Verification"},{"location":"gemforce-deployer-guide/#gas-optimization-strategies","text":"Use optimized Solidity patterns : Minimize storage operations Batch operations where possible Use efficient data structures Configure gas prices for deployment : javascript // Example configuration for gas const tx = await contract.functionName(params, { gasPrice: (await ethers.provider.getGasPrice()).mul(2), // 2x current gas price gasLimit: 5000000 }); Monitor gas usage during testing : javascript // Add gas reporter to Hardhat config gasReporter: { enabled: true, currency: 'USD', gasPrice: 100, coinmarketcap: process.env.COINMARKETCAP_API_KEY }","title":"Gas Optimization Strategies"},{"location":"gemforce-deployer-guide/#cloud-functions-deployment","text":"","title":"Cloud Functions Deployment"},{"location":"gemforce-deployer-guide/#parse-server-deployment","text":"Prepare Parse Server configuration : javascript // Example Parse Server configuration const parseServerConfig = { appId: process.env.APP_ID, masterKey: process.env.MASTER_KEY, databaseURI: process.env.DATABASE_URI, serverURL: process.env.SERVER_URL, cloud: \"./dist/src/cloud-functions.js\", allowClientClassCreation: false, enableAnonymousUsers: false, maxUploadSize: \"20mb\", // ... other configuration }; Deploy Parse Server : Using PM2: ```bash # Start Parse Server with PM2 pm2 start app.js --name gemforce-server # Save PM2 configuration pm2 save # Set up PM2 to start on system boot pm2 startup ``` Using Docker: ```bash # Build Docker image docker build -t gemforce-server . # Run container docker run -d -p 1337:1337 \\ --env-file .env \\ --name gemforce-server \\ gemforce-server ``` Verify Parse Server deployment : ```bash # Check server status curl https://your-server-url.com/parse/health # Expected response: {\"status\":\"ok\"} ```","title":"Parse Server Deployment"},{"location":"gemforce-deployer-guide/#cloud-function-deployment","text":"Compile TypeScript files : bash # Build the project npm run build Deploy cloud functions : If using PM2: bash # Restart the server to apply changes pm2 restart gemforce-server If using Docker: bash # Rebuild and redeploy docker build -t gemforce-server . docker stop gemforce-server docker rm gemforce-server docker run -d -p 1337:1337 \\ --env-file .env \\ --name gemforce-server \\ gemforce-server Verify cloud function deployment : bash # Test a simple cloud function curl -X POST \\ -H \"X-Parse-Application-Id: ${APP_ID}\" \\ -H \"Content-Type: application/json\" \\ -d '{}' \\ https://your-server-url.com/parse/functions/loadAllBlockchains","title":"Cloud Function Deployment"},{"location":"gemforce-deployer-guide/#environment-configuration","text":"Set environment variables : ```bash # Set environment variables in .env file cat > .env << EOL # Parse Server APP_ID=your_app_id MASTER_KEY=your_master_key DATABASE_URI=mongodb://username:password@host:port/database SERVER_URL=https://your-server-url.com/parse # Blockchain ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=base-sepolia PRIVATE_KEY=your_private_key # External Services DFNS_APP_ID=your_dfns_app_id DFNS_API_URL=https://api.dfns.io DFNS_CRED_ID=your_dfns_credential_id # Additional Configuration METADATA_BASE_URI=https://metadata.gemforce.com/ EOL ``` Configure database : Set up MongoDB Create database user Configure connection string Set up web server (nginx example): ```nginx # /etc/nginx/sites-available/gemforce server { listen 80; server_name api.gemforce.com; location / { return 301 https : // $ host $ request_uri ; } } server { listen 443 ssl; server_name api.gemforce.com; ssl_certificate / etc / letsencrypt / live / api . gemforce . com / fullchain . pem ; ssl_certificate_key / etc / letsencrypt / live / api . gemforce . com / privkey . pem ; location / { proxy_pass http : // localhost : 1337 ; proxy_http_version 1.1 ; proxy_set_header Upgrade $http_upgrade ; proxy_set_header Connection 'upgrade' ; proxy_set_header Host $host ; proxy_cache_bypass $http_upgrade ; } } ```","title":"Environment Configuration"},{"location":"gemforce-deployer-guide/#database-migration","text":"Create database migrations : ```javascript // Example migration script (migrations/001_add_indexes.js) async function up(db) { await db.collection('User').createIndex({ walletAddress: 1 }); await db.collection('Identity').createIndex({ walletAddress: 1 }, { unique: true }); await db.collection('Transaction').createIndex({ hash: 1 }, { unique: true }); } async function down(db) { await db.collection('User').dropIndex({ walletAddress: 1 }); await db.collection('Identity').dropIndex({ walletAddress: 1 }); await db.collection('Transaction').dropIndex({ hash: 1 }); } module.exports = { up, down }; ``` Run migrations : bash # Example using a simple migration tool npx migrate-mongo up Verify migrations : javascript // Check indexes db.User.getIndexes() db.Identity.getIndexes() db.Transaction.getIndexes()","title":"Database Migration"},{"location":"gemforce-deployer-guide/#websocket-setup","text":"Configure WebSocket endpoints : ```javascript // Example WebSocket server setup const wss = new WebSocketServer({ server: httpServer, path: \"/ws\" }); wss.on('connection', (ws) => { // Handle connection ws.on('message', (message) => { // Handle message }); ws.on('close', () => { // Handle disconnection }); }); ``` Set up blockchain event listeners : ```javascript // Example blockchain event listener function setupEventListeners(provider, diamondAddress) { const diamond = new ethers.Contract( diamondAddress, DiamondABI, provider ); diamond . on ( \"Transfer\" , ( from , to , tokenId ) => { // Handle transfer event // Broadcast to connected WebSocket clients wss.clients.forEach((client) => { if (client.readyState === WebSocket.OPEN) { client.send(JSON.stringify({ event : \"Transfer\" , data : { from , to , tokenId : tokenId . toString () } } )); } } ); } ); } ```","title":"WebSocket Setup"},{"location":"gemforce-deployer-guide/#environment-configuration_1","text":"","title":"Environment Configuration"},{"location":"gemforce-deployer-guide/#development-environment","text":"Local environment setup : ```bash # Start local hardhat node npx hardhat node # Deploy contracts to local node npx hardhat deploy --network localhost # Start Parse Server locally npm run dev ``` Environment configuration file for development : ``` # .env.development APP_ID=gemforce_dev MASTER_KEY=your_dev_master_key DATABASE_URI=mongodb://localhost:27017/gemforce_dev SERVER_URL=http://localhost:1337/parse # Use local hardhat node ETH_NODE_URI_LOCAL=http://localhost:8545 CHAIN_ID=31337 # Development keys PRIVATE_KEY=your_dev_private_key ``` Development database setup : ```bash # Start MongoDB locally mongod --dbpath ./data # Create database and user mongo use gemforce_dev db.createUser({ user: \"gemforce_user\", pwd: \"password\", roles: [{ role: \"readWrite\", db: \"gemforce_dev\" }] }) ```","title":"Development Environment"},{"location":"gemforce-deployer-guide/#testing-environment","text":"Testing environment configuration : ``` # .env.test APP_ID=gemforce_test MASTER_KEY=your_test_master_key DATABASE_URI=mongodb://localhost:27017/gemforce_test SERVER_URL=http://localhost:1337/parse # Use BaseSepolia for testing ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=84532 # Test keys PRIVATE_KEY=your_test_private_key ``` Automated testing setup : ```bash # Run tests npm test # Run specific tests npx mocha test/specific-test.js ``` Test database initialization : javascript // Initialize test database before(async () => { const client = await MongoClient.connect(process.env.DATABASE_URI); const db = client.db(); await db.collection('User').deleteMany({}); await db.collection('Identity').deleteMany({}); // Seed with test data await db.collection('User').insertMany(testUsers); });","title":"Testing Environment"},{"location":"gemforce-deployer-guide/#staging-environment","text":"Staging environment configuration : ``` # .env.staging APP_ID=gemforce_staging MASTER_KEY=your_staging_master_key DATABASE_URI=mongodb://user:password@staging-db:27017/gemforce_staging SERVER_URL=https://staging-api.gemforce.com/parse # Use BaseSepolia for staging ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=84532 # Staging keys PRIVATE_KEY=your_staging_private_key ``` Staging deployment : ```bash # Deploy to staging npm run deploy:staging # Run database migrations npm run migrate:staging ``` Staging verification : bash # Verify staging deployment curl https://staging-api.gemforce.com/parse/health","title":"Staging Environment"},{"location":"gemforce-deployer-guide/#production-environment","text":"Production environment configuration : ``` # .env.production APP_ID=gemforce_prod MASTER_KEY=your_production_master_key DATABASE_URI=mongodb://user:password@production-db:27017/gemforce_production SERVER_URL=https://api.gemforce.com/parse # Use production endpoints ETH_NODE_URI_MAINNET=https://mainnet.infura.io/v3/your_infura_key CHAIN_ID=1 # Production keys stored securely # PRIVATE_KEY should be handled with extra security ``` Production deployment steps : ```bash # Deploy to production npm run deploy:production # Run database migrations npm run migrate:production ``` Production verification : ```bash # Verify production deployment curl https://api.gemforce.com/parse/health # Monitor logs pm2 logs gemforce-server ```","title":"Production Environment"},{"location":"gemforce-deployer-guide/#environment-specific-settings","text":"Configuration management : ``javascript // Load environment-specific configuration const envConfig = require( ./config/${process.env.NODE_ENV || 'development'}`); module.exports = { // Base configuration appName: 'Gemforce', // Merge with environment-specific config ... envConfig }; ``` Feature flags : ```javascript // Example feature flags configuration const featureFlags = { development: { enableNewMarketplace: true, enableCarbonCredits: true }, staging: { enableNewMarketplace: true, enableCarbonCredits: false }, production: { enableNewMarketplace: false, enableCarbonCredits: false } }; // Usage if (featureFlags[process.env.NODE_ENV].enableNewMarketplace) { // Initialize new marketplace } ```","title":"Environment-Specific Settings"},{"location":"gemforce-deployer-guide/#deployment-automation","text":"","title":"Deployment Automation"},{"location":"gemforce-deployer-guide/#cicd-pipeline-setup","text":"GitHub Actions workflow : ```yaml # .github/workflows/deploy.yml name: Deploy Gemforce on: push: branches: [ main, staging ] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: '16' - name: Install dependencies run: npm ci - name: Run tests run: npm test build : needs : test runs - on : ubuntu - latest steps : - uses : actions / checkout @ v2 - name : Setup Node . js uses : actions / setup - node @ v2 with : node - version : '16' - name : Install dependencies run : npm ci - name : Build project run : npm run build - name : Upload build artifacts uses : actions / upload - artifact @ v2 with : name : build path : dist / deploy : needs : build runs - on : ubuntu - latest steps : - uses : actions / checkout @ v2 - name : Download build artifacts uses : actions / download - artifact @ v2 with : name : build path : dist / - name : Deploy to server uses : appleboy / ssh - action @ master with : host : $ {{ secrets . SERVER_HOST }} username : $ {{ secrets . SERVER_USERNAME }} key : $ {{ secrets . SSH_PRIVATE_KEY }} script : | cd / var / www / gemforce git pull npm ci cp - r $ {{ github . workspace }} / dist /* ./ dist / pm2 restart gemforce - server ``` Automatic testing : ```yaml # .github/workflows/test.yml name: Test Gemforce on: pull_request: branches: [ main, staging ] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: '16' - name: Install dependencies run: npm ci - name: Run linting run: npm run lint - name: Run tests run: npm test ```","title":"CI/CD Pipeline Setup"},{"location":"gemforce-deployer-guide/#automated-testing","text":"Unit tests for smart contracts : ```javascript // test/GemforceMinter.test.ts describe(\"GemforceMinter\", function() { let owner, user; let diamond, gemforceMinter; beforeEach ( async function () { [ owner , user ] = await ethers . getSigners (); // Deploy diamond with GemforceMinterFacet // ... deployment code gemforceMinter = await ethers . getContractAt ( \"GemforceMinterFacet\" , diamond . address ); }); it ( \"should mint a token with metadata\" , async function () { const metadata = [ { key : \"name\" , attributeType : 0 , value : \"Carbon Credit\" }, { key : \"amount\" , attributeType : 1 , value : \"100\" } ]; await expect ( gemforceMinter . connect ( owner ) . gemforceMint ( metadata )) . to . emit ( gemforceMinter , \"GemforceMinted\" ) . withArgs ( 0 , owner . address , metadata ); }); }); ``` API endpoint tests : ```javascript // test/cloud-functions.test.js describe(\"Cloud Functions\", function() { before(async function() { // Initialize Parse Server for testing Parse.initialize(\"test_app_id\", \"test_js_key\", \"test_master_key\"); Parse.serverURL = \"http://localhost:1337/parse\"; }); it ( \"should retrieve blockchain data\" , async function () { const result = await Parse . Cloud . run ( \"loadAllBlockchains\" ); expect ( result ) . to . be . an ( \"array\" ); }); }); ``` End-to-end tests : ```javascript // test/e2e/user-flow.test.js describe(\"User Flow\", function() { it(\"should register, create identity, and mint token\", async function() { // Register user const user = await registerUser(\"test@example.com\", \"password\"); // Create DFNS wallet const { walletId } = await createDFNSWallet ( user ); // Create identity const { identityAddress } = await createIdentity ( user , walletId ); // Mint token const { tokenId } = await mintToken ( user , walletId ); // Verify token ownership const owner = await getTokenOwner ( tokenId ); expect ( owner ) . to . equal ( user . get ( \"walletAddress\" )); }); }); ```","title":"Automated Testing"},{"location":"gemforce-deployer-guide/#deployment-scripts","text":"Smart contract deployment script : ```javascript // scripts/deploy-contracts.js async function main() { // Get deployer const [deployer] = await ethers.getSigners(); console.log(\"Deploying contracts with account:\", deployer.address); // Deploy libraries const LibraryA = await ethers . getContractFactory ( \"LibraryA\" ); const libraryA = await LibraryA . deploy (); await libraryA . deployed (); console . log ( \"LibraryA deployed to:\" , libraryA . address ); // Deploy facets with libraries const FacetA = await ethers . getContractFactory ( \"FacetA\" , { libraries : { LibraryA : libraryA . address } }); const facetA = await FacetA . deploy (); await facetA . deployed (); console . log ( \"FacetA deployed to:\" , facetA . address ); // More deployments... } main() .then(() => process.exit(0)) .catch(error => { console.error(error); process.exit(1); }); ``` Parse Server deployment script : ```bash #!/bin/bash # scripts/deploy-parse.sh # Load environment variables source .env.${NODE_ENV:-production} # Build the project echo \"Building project...\" npm run build # Deploy to server echo \"Deploying to server...\" rsync -avz --exclude node_modules --exclude .git . user@server:/var/www/gemforce/ # SSH into server and restart ssh user@server << EOF cd /var/www/gemforce npm ci --production pm2 restart gemforce-server EOF echo \"Deployment complete!\" ```","title":"Deployment Scripts"},{"location":"gemforce-deployer-guide/#infrastructure-as-code","text":"Terraform configuration : ```hcl # main.tf provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"gemforce_server\" { ami = \"ami-0c55b159cbfafe1f0\" instance_type = \"t2.medium\" key_name = \"gemforce-key\" tags = { Name = \"gemforce-server\" Environment = var . environment } root_block_device { volume_size = 50 volume_type = \"gp2\" } vpc_security_group_ids = [ aws_security_group . gemforce_sg . id ] } resource \"aws_security_group\" \"gemforce_sg\" { name = \"gemforce-sg\" description = \"Allow web and SSH traffic\" ingress { from_port = 80 to_port = 80 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } ingress { from_port = 443 to_port = 443 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } ingress { from_port = 22 to_port = 22 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } egress { from_port = 0 to_port = 0 protocol = \"-1\" cidr_blocks = [\"0.0.0.0/0\"] } } output \"server_ip\" { value = aws_instance.gemforce_server.public_ip } ``` Docker Compose setup : ```yaml # docker-compose.yml version: '3' services: mongodb: image: mongo:4.4 ports: - \"27017:27017\" volumes: - mongo-data:/data/db environment: MONGO_INITDB_ROOT_USERNAME: ${MONGO_USERNAME} MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD} restart: always parse - server : build : . ports : - \"1337:1337\" environment : - APP_ID =$ { APP_ID } - MASTER_KEY =$ { MASTER_KEY } - DATABASE_URI = mongodb : //$ { MONGO_USERNAME }: $ { MONGO_PASSWORD } @ mongodb : 27017 /$ { DATABASE_NAME } ? authSource = admin - SERVER_URL =$ { SERVER_URL } - CLOUD_PATH =/ parse - server / cloud / main . js volumes : - ./ cloud : / parse - server / cloud depends_on : - mongodb restart : always nginx : image : nginx : latest ports : - \"80:80\" - \"443:443\" volumes : - ./ nginx / conf . d : / etc / nginx / conf . d - ./ nginx / ssl : / etc / nginx / ssl - ./ nginx / www : / var / www / html depends_on : - parse - server restart : always volumes: mongo-data: ```","title":"Infrastructure as Code"},{"location":"gemforce-deployer-guide/#continuous-monitoring","text":"Setup monitoring tools : ```javascript // Monitoring setup in app.js const prometheus = require('prom-client'); const collectDefaultMetrics = prometheus.collectDefaultMetrics; // Enable default metrics collectDefaultMetrics({ timeout: 5000 }); // Custom metrics const httpRequestDurationMicroseconds = new prometheus.Histogram({ name: 'http_request_duration_ms', help: 'Duration of HTTP requests in ms', labelNames: ['method', 'route', 'status_code'], buckets: [0.1, 5, 15, 50, 100, 500] }); // Endpoint for metrics app.get('/metrics', (req, res) => { res.set('Content-Type', prometheus.register.contentType); res.end(prometheus.register.metrics()); }); ``` Logging configuration : ```javascript // Logging setup in app.js const winston = require('winston'); const logger = winston.createLogger({ level: process.env.LOG_LEVEL || 'info', format: winston.format.combine( winston.format.timestamp(), winston.format.json() ), transports: [ new winston.transports.Console(), new winston.transports.File({ filename: 'error.log', level: 'error' }), new winston.transports.File({ filename: 'combined.log' }) ] }); // Use in application logger.info('Server started', { port: 1337 }); ```","title":"Continuous Monitoring"},{"location":"gemforce-deployer-guide/#upgrade-procedures","text":"","title":"Upgrade Procedures"},{"location":"gemforce-deployer-guide/#smart-contract-upgrades","text":"Upgrading a facet : ```javascript // scripts/upgrade-facet.js async function main() { // Get signer const [signer] = await ethers.getSigners(); // Deploy new version of the facet const NewFacet = await ethers . getContractFactory ( \"NewFacetV2\" ); const newFacet = await NewFacet . deploy (); await newFacet . deployed (); console . log ( \"New facet deployed to:\" , newFacet . address ); // Get diamond contract const diamond = await ethers . getContractAt ( \"Diamond\" , DIAMOND_ADDRESS ); // Get selectors for the facet const selectors = getSelectors ( newFacet ); // Create facet cut const facetCut = { facetAddress : newFacet . address , action : FacetCutAction . Replace , // Replace existing facet functionSelectors : selectors } ; // Perform the upgrade const tx = await diamond . diamondCut ( [ facetCut ] , ethers . constants . AddressZero , // No initialization \"0x\" ); await tx . wait (); console . log ( \"Facet upgraded successfully\" ); } main() .then(() => process.exit(0)) .catch(error => { console.error(error); process.exit(1); }); ``` Adding a new facet : ```javascript // scripts/add-facet.js async function main() { // Get signer const [signer] = await ethers.getSigners(); // Deploy new facet const NewFacet = await ethers . getContractFactory ( \"NewFacet\" ); const newFacet = await NewFacet . deploy (); await newFacet . deployed (); console . log ( \"New facet deployed to:\" , newFacet . address ); // Get diamond contract const diamond = await ethers . getContractAt ( \"Diamond\" , DIAMOND_ADDRESS ); // Get selectors for the facet const selectors = getSelectors ( newFacet ); // Create facet cut const facetCut = { facetAddress : newFacet . address , action : FacetCutAction . Add , // Add new facet functionSelectors : selectors } ; // Perform the upgrade const tx = await diamond . diamondCut ( [ facetCut ] , ethers . constants . AddressZero , // No initialization \"0x\" ); await tx . wait (); console . log ( \"Facet added successfully\" ); } ``` Upgrading Diamond implementation : ```javascript // scripts/upgrade-diamond.js async function main() { // Get diamond factory const diamondFactory = await ethers.getContractAt(\"DiamondFactory\", FACTORY_ADDRESS); // Get existing diamond const diamond = await ethers . getContractAt ( \"Diamond\" , DIAMOND_ADDRESS ); // Deploy new facets const newFacets = await deployNewFacets (); // Create facet cuts const facetCuts = createFacetCuts ( newFacets ); // Set new facet set on factory await diamondFactory . setFacets ( \"newFacetSet\" , facetCuts ); // Deploy new diamond initializer if needed const diamondInit = await deployDiamondInit (); // Prepare initialization data const initData = diamondInit . interface . encodeFunctionData ( \"init\" , [ /* initialization parameters */ ]); // Upgrade diamond const tx = await diamond . diamondCut ( facetCuts , diamondInit . address , initData ); await tx . wait (); console . log ( \"Diamond upgraded successfully\" ); } ```","title":"Smart Contract Upgrades"},{"location":"gemforce-deployer-guide/#cloud-function-updates","text":"Updating cloud functions : ```bash # Update cloud functions git pull origin main npm install npm run build # Restart Parse Server pm2 restart gemforce-server ``` Testing cloud function updates : javascript // test/cloud-functions/updated-function.test.js describe(\"Updated Cloud Function\", function() { it(\"should handle new functionality\", async function() { const result = await Parse.Cloud.run(\"updatedFunction\", { param: \"value\" }); expect(result).to.have.property(\"newProperty\"); }); }); Deploying specific cloud function changes : ```bash # Deploy specific cloud function changes scp dist/src/cloud-functions/specific-function.js user@server:/var/www/gemforce/dist/src/cloud-functions/ # Restart Parse Server ssh user@server \"cd /var/www/gemforce && pm2 restart gemforce-server\" ```","title":"Cloud Function Updates"},{"location":"gemforce-deployer-guide/#database-schema-migrations","text":"Creating a migration : ```javascript // migrations/1625000000000_add_new_field.js exports.up = async (db) => { // Add new field to all documents in a collection await db.collection('User').updateMany( { newField: { $exists: false } }, { $set: { newField: \"\" } } ); // Create new index await db . collection ( 'User' ). createIndex ({ newField : 1 }); }; exports.down = async (db) => { // Remove the field await db.collection('User').updateMany( {}, { $unset: { newField: \"\" } } ); // Remove the index await db . collection ( 'User' ). dropIndex ({ newField : 1 }); }; ``` Running migrations : ```bash # Run migrations npx migrate-mongo up # Check migration status npx migrate-mongo status ``` Rolling back migrations : ```bash # Roll back last migration npx migrate-mongo down # Roll back to specific migration npx migrate-mongo down 1625000000000 ```","title":"Database Schema Migrations"},{"location":"gemforce-deployer-guide/#backward-compatibility-considerations","text":"API versioning : ```javascript // Example API versioning app.use('/api/v1', v1Routes); app.use('/api/v2', v2Routes); // Redirect old routes app.use('/api/legacy/:resource', (req, res) => { res.redirect( /api/v1/${req.params.resource} ); }); ``` Smart contract compatibility : Never remove storage variables Add new functions rather than changing existing ones Use new facets for significant changes Use feature flags to control access to new features Client compatibility : ```javascript // Check client version and provide appropriate response Parse.Cloud.define(\"getFeatures\", async (request) => { const clientVersion = request.params.clientVersion; if ( semver . lt ( clientVersion , \"2.0.0\" )) { return legacyFeatureList ; } else { return newFeatureList ; } }); ```","title":"Backward Compatibility Considerations"},{"location":"gemforce-deployer-guide/#feature-flagging","text":"Implementing feature flags : ```javascript // Feature flag configuration const featureFlags = { newMarketplace: process.env.ENABLE_NEW_MARKETPLACE === \"true\", carbonCredits: process.env.ENABLE_CARBON_CREDITS === \"true\", nftFractionalization: process.env.ENABLE_NFT_FRACTIONALIZATION === \"true\" }; // Using feature flags Parse.Cloud.define(\"getMarketplace\", async (request) => { if (featureFlags.newMarketplace) { return getNewMarketplace(); } else { return getLegacyMarketplace(); } }); ``` Controlling access to new features : ```javascript // Progressive rollout Parse.Cloud.define(\"checkFeatureAccess\", async (request) => { const { feature, userId } = request.params; // Check if feature is enabled globally if ( ! featureFlags [ feature ] ) { return { hasAccess : false } ; } // Check if user is in beta group const user = await new Parse . Query ( Parse . User ) . get ( userId , { useMasterKey : true } ); const isBetaTester = user . get ( \"betaTester\" ) === true ; // Calculate percentage - based rollout const rolloutPercentage = 25 ; // 25 % of users const userIdNumber = parseInt ( userId . substring ( 0 , 8 ), 16 ); const userPercentile = userIdNumber % 100 ; return { hasAccess : isBetaTester || userPercentile < rolloutPercentage } ; }); ```","title":"Feature Flagging"},{"location":"gemforce-deployer-guide/#rollback-procedures","text":"","title":"Rollback Procedures"},{"location":"gemforce-deployer-guide/#smart-contract-rollbacks","text":"Rollback strategy for facets : ```javascript // scripts/rollback-facet.js async function main() { // Get diamond contract const diamond = await ethers.getContractAt(\"Diamond\", DIAMOND_ADDRESS); // Get previous version of the facet const previousFacetAddress = PREVIOUS_FACET_ADDRESS ; // Get selectors for the facet const selectors = SELECTORS ; // Create facet cut for rollback const facetCut = { facetAddress : previousFacetAddress , action : FacetCutAction . Replace , functionSelectors : selectors } ; // Perform the rollback const tx = await diamond . diamondCut ( [ facetCut ] , ethers . constants . AddressZero , \"0x\" ); await tx . wait (); console . log ( \"Facet rolled back successfully\" ); } ``` Diamond upgrade rollback : ```javascript // scripts/rollback-diamond.js async function main() { // Get diamond factory const diamondFactory = await ethers.getContractAt(\"DiamondFactory\", FACTORY_ADDRESS); // Get diamond to rollback const diamond = await ethers . getContractAt ( \"Diamond\" , DIAMOND_ADDRESS ); // Use previous facet set const previousFacetSet = \"previousFacetSet\" ; // Get facets from the set const facets = await diamondFactory . getFacets ( previousFacetSet ); // Rollback diamond const tx = await diamond . diamondCut ( facets , ethers . constants . AddressZero , \"0x\" ); await tx . wait (); console . log ( \"Diamond rolled back successfully\" ); } ``` Emergency pause : ```javascript // scripts/emergency-pause.js async function main() { // Get contract const contract = await ethers.getContractAt(\"PausableFacet\", DIAMOND_ADDRESS); // Pause the contract const tx = await contract . pause (); await tx . wait (); console . log ( \"Contract paused successfully\" ); } ```","title":"Smart Contract Rollbacks"},{"location":"gemforce-deployer-guide/#cloud-function-rollbacks","text":"Rolling back with Git : ```bash # Rollback to previous commit git reset --hard HEAD~1 npm install npm run build # Restart server pm2 restart gemforce-server ``` Using deployment tags : ```bash # List tags git tag -l # Checkout specific version git checkout v1.2.3 npm install npm run build # Restart server pm2 restart gemforce-server ``` Specific file rollback : ```bash # Revert specific file git checkout HEAD~1 -- src/cloud-functions/specific-file.ts npm run build # Restart server pm2 restart gemforce-server ```","title":"Cloud Function Rollbacks"},{"location":"gemforce-deployer-guide/#database-rollbacks","text":"Restoring from backup : bash # Restore MongoDB from backup mongorestore --uri=\"mongodb://username:password@host:port/database\" --drop /backup/path/YYYY-MM-DD Rolling back a migration : bash # Roll back the last migration npx migrate-mongo down Manual data correction script : ```javascript // scripts/correct-data.js async function main() { const MongoClient = require('mongodb').MongoClient; const client = await MongoClient.connect(process.env.DATABASE_URI); const db = client.db(); try { // Correct data issues await db.collection('User').updateMany( { incorrectField : { $ exists : true } } , { $ rename : { \"incorrectField\" : \"correctField\" } } ); console . log ( \"Data correction complete\" ); } catch ( error ) { console.error(\"Error correcting data : \" , error ); } finally { await client.close() ; } } main().catch(console.error); ```","title":"Database Rollbacks"},{"location":"gemforce-deployer-guide/#emergency-procedures","text":"Complete service rollback : ```bash # Emergency rollback script #!/bin/bash # scripts/emergency-rollback.sh # Stop the current service pm2 stop gemforce-server # Restore code from known good state git checkout v1.2.3 npm install npm run build # Restore database mongorestore --uri=\"$DATABASE_URI\" --drop /backups/latest # Restart the service pm2 start gemforce-server # Notify team curl -X POST -H \"Content-Type: application/json\" \\ -d '{\"text\":\"Emergency rollback performed to v1.2.3\"}' \\ $SLACK_WEBHOOK_URL ``` Read-only mode : ```javascript // Enable read-only mode Parse.Cloud.beforeSave(\"*\", async () => { if (process.env.READONLY_MODE === \"true\") { throw new Parse.Error( Parse.Error.OPERATION_FORBIDDEN, \"System is currently in read-only mode for maintenance.\" ); } }); Parse.Cloud.beforeDelete(\"*\", async () => { if (process.env.READONLY_MODE === \"true\") { throw new Parse.Error( Parse.Error.OPERATION_FORBIDDEN, \"System is currently in read-only mode for maintenance.\" ); } }); ```","title":"Emergency Procedures"},{"location":"gemforce-deployer-guide/#data-integrity-verification","text":"Verifying contract state : ```javascript // scripts/verify-contract-state.js async function main() { // Get contract const contract = await ethers.getContractAt(\"DiamondLoupe\", DIAMOND_ADDRESS); // Get all facets const facets = await contract . facets (); // Verify each facet for ( const facet of facets ) { console . log ( ` Verifying facet at $ { facet . facetAddress } ` ); // Get facet code const code = await ethers . provider . getCode ( facet . facetAddress ); // Check code is not empty if ( code === \"0x\" || code === \"0x0\" ) { throw new Error ( ` Facet at $ { facet . facetAddress } has no code ! ` ); } // Verify selectors for ( const selector of facet . functionSelectors ) { const result = await contract . facetAddress ( selector ); if ( result !== facet . facetAddress ) { throw new Error ( ` Selector $ { selector } points to wrong facet ! ` ); } } } console . log ( \"Contract state verification successful\" ); } main().catch(console.error); ``` Database integrity check : ```javascript // scripts/verify-database.js async function main() { const MongoClient = require('mongodb').MongoClient; const client = await MongoClient.connect(process.env.DATABASE_URI); const db = client.db(); try { // Check User collection integrity const userCount = await db . collection ( 'User' ) . countDocuments (); console . log ( ` User count : $ { userCount } ` ); // Check for duplicate emails const duplicateEmails = await db . collection ( 'User' ) . aggregate ([ { $ group : { _id : \"$email\" , count : { $ sum : 1 } } }, { $ match : { count : { $ gt : 1 } } } ]) . toArray (); if ( duplicateEmails . length > 0 ) { console . error ( ` Found $ { duplicateEmails . length } duplicate emails ! ` ); console . error ( duplicateEmails ); } // Verify indexes const indexes = await db . collection ( 'User' ) . indexes (); console . log ( \"Indexes:\" , indexes ); // More integrity checks ... console . log ( \"Database integrity check complete\" ); } finally { await client . close (); } } main().catch(console.error); ```","title":"Data Integrity Verification"},{"location":"gemforce-deployer-guide/#testing-and-verification","text":"","title":"Testing and Verification"},{"location":"gemforce-deployer-guide/#unit-testing","text":"Smart contract unit tests : ```javascript // test/unit/GemforceMinter.test.ts describe(\"GemforceMinter\", function() { let owner, user1, user2; let diamond, gemforceMinter; beforeEach ( async function () { [ owner , user1 , user2 ] = await ethers . getSigners (); // Deploy diamond with facets // ... deployment code gemforceMinter = await ethers . getContractAt ( \"GemforceMinterFacet\" , diamond . address ); }); it ( \"should allow owner to mint\" , async function () { const metadata = [ { key : \"name\" , attributeType : 0 , value : \"Carbon Credit\" } ]; const tx = await gemforceMinter . connect ( owner ) . gemforceMint ( metadata ); const receipt = await tx . wait (); // Check events const event = receipt . events . find ( e => e . event === \"GemforceMinted\" ); expect ( event ) . to . exist ; expect ( event . args . tokenId ) . to . equal ( 0 ); expect ( event . args . minter ) . to . equal ( owner . address ); }); it ( \"should revert when non-owner tries to mint\" , async function () { const metadata = [ { key : \"name\" , attributeType : 0 , value : \"Carbon Credit\" } ]; await expect ( gemforceMinter . connect ( user1 ) . gemforceMint ( metadata ) ) . to . be . revertedWith ( \"Only contract owner\" ); }); }); ``` Cloud function unit tests : ```javascript // test/unit/cloud-functions.test.js describe(\"Cloud Functions Unit Tests\", function() { before(function() { // Mock Parse this.originalParse = global.Parse; global.Parse = { Cloud: { define: (name, handler) => { this.cloudFunctions[name] = handler; } }, Error: { INVALID_PARAMS: 141 } }; // Load cloud functions this . cloudFunctions = {}; require ( \"../../src/cloud-functions/contracts\" ); }); after ( function () { global . Parse = this . originalParse ; }); it ( \"should validate parameters in addDiamondFacet\" , async function () { const handler = this . cloudFunctions . addDiamondFacet ; // Missing parameters try { await handler ({ params : {} }); assert . fail ( \"Should have thrown an error\" ); } catch ( e ) { expect ( e . code ) . to . equal ( Parse . Error . INVALID_PARAMS ); } // With valid parameters ( mocked ) const mockResult = { success : true }; this . addDiamondFacet = sinon . stub () . resolves ( mockResult ); const result = await handler ({ params : { networkId : \"1\" , diamondAddress : \"0x123\" , facetName : \"TestFacet\" } }); expect ( result ) . to . deep . equal ( mockResult ); }); }); ```","title":"Unit Testing"},{"location":"gemforce-deployer-guide/#integration-testing","text":"Smart contract integration tests : ```javascript // test/integration/marketplace-flow.test.ts describe(\"Marketplace Integration\", function() { let owner, seller, buyer; let diamond, marketplace, gem, treasury; before ( async function () { [ owner , seller , buyer ] = await ethers . getSigners (); // Deploy all contracts // ... deployment code // Get contract instances diamond = await ethers . getContractAt ( \"Diamond\" , diamondAddress ); marketplace = await ethers . getContractAt ( \"MarketplaceFacet\" , diamondAddress ); gem = await ethers . getContractAt ( \"GemforceMinterFacet\" , diamondAddress ); treasury = await ethers . getContractAt ( \"Treasury\" , treasuryAddress ); }); it ( \"should support full marketplace flow\" , async function () { // Mint token const metadata = [{ key : \"test\" , attributeType : 0 , value : \"value\" }]; await gem . connect ( owner ) . gemforceMint ( metadata ); // List token await marketplace . connect ( owner ) . listItem ( 0 , ethers . utils . parseEther ( \"1.0\" )); // Check listing const listing = await marketplace . getListing ( 0 ); expect ( listing . price ) . to . equal ( ethers . utils . parseEther ( \"1.0\" )); // Purchase token await marketplace . connect ( buyer ) . purchaseItem ( diamondAddress , 0 , { value : ethers . utils . parseEther ( \"1.0\" ) }); // Check ownership const newOwner = await diamond . ownerOf ( 0 ); expect ( newOwner ) . to . equal ( buyer . address ); // Check treasury balance const balance = await treasury . getBalance (); expect ( balance ) . to . be . gt ( 0 ); }); }); ``` API integration tests : ```javascript // test/integration/api-flow.test.js describe(\"API Integration\", function() { let user; before ( async function () { // Initialize Parse Parse . initialize ( \"test_app_id\" , \"test_js_key\" , \"test_master_key\" ); Parse . serverURL = \"http://localhost:1337/parse\" ; // Create test user user = new Parse . User (); user . set ( \"username\" , \"test@example.com\" ); user . set ( \"password\" , \"password\" ); user . set ( \"email\" , \"test@example.com\" ); await user . signUp (); }); it ( \"should handle user blockchain operations\" , async function () { // Get blockchains const blockchains = await Parse . Cloud . run ( \"loadAllBlockchains\" ); expect ( blockchains ) . to . be . an ( \"array\" ); // Create DFNS wallet ( mocked ) const walletResult = await Parse . Cloud . run ( \"registerInit\" , { username : user . get ( \"email\" ) }); expect ( walletResult ) . to . have . property ( \"challenge\" ); // Complete registration ( mocked ) const registrationResult = await Parse . Cloud . run ( \"registerComplete\" , { signedChallenge : \"mocked_challenge\" , temporaryAuthenticationToken : \"mocked_token\" }); expect ( registrationResult ) . to . have . property ( \"token\" ); // List wallets const wallets = await Parse . Cloud . run ( \"listWallets\" , { authToken : registrationResult . token }); expect ( wallets ) . to . have . property ( \"wallets\" ); }); }); ```","title":"Integration Testing"},{"location":"gemforce-deployer-guide/#contract-verification_1","text":"Verifying contracts on block explorer : ```bash # Verify contract on Etherscan or Basescan npx hardhat verify --network baseSepolia # Verify contract with libraries npx hardhat verify --network baseSepolia \\ --libraries Library1=0x123... Library2=0x456... ``` Automated verification script : ```javascript // scripts/verify-contracts.js async function main() { // Get deployment data const deployments = require('../deployments.json'); const network = process.env.NETWORK || 'baseSepolia'; const networkId = hre.config.networks[network].chainId; // Verify Diamond contract const diamondAddress = deployments [ networkId ] . diamondAddress ; console . log ( ` Verifying Diamond at ${ diamondAddress }` ); try { await hre . run ( \"verify:verify\" , { address : diamondAddress , constructorArguments : [] } ); } catch ( e ) { console . log ( ` Error verifying Diamond : ${ e . message }` ); } // Verify Facets const facets = deployments [ networkId ] . facets || [] ; for ( const facet of facets ) { console . log ( ` Verifying facet ${ facet . name } at ${ facet . address }` ); try { await hre . run ( \"verify:verify\" , { address : facet . address , constructorArguments : [] } ); } catch ( e ) { console . log ( ` Error verifying ${ facet . name }: ${ e . message }` ); } } } main().catch(console.error); ```","title":"Contract Verification"},{"location":"gemforce-deployer-guide/#load-testing","text":"Smart contract load testing : ```javascript // test/load/contract-load.test.js describe(\"Contract Load Test\", function() { // Increase timeout for load tests this.timeout(300000); let diamond , minter ; let signers ; before ( async function () { // Get signers signers = await ethers . getSigners (); // Deploy contracts // ... deployment code diamond = await ethers . getContractAt ( \"Diamond\" , diamondAddress ); minter = await ethers . getContractAt ( \"GemforceMinterFacet\" , diamondAddress ); }); it ( \"should handle concurrent minting\" , async function () { const concurrentMints = 50 ; const mintPromises = []; // Create concurrent mint operations for ( let i = 0 ; i < concurrentMints ; i ++ ) { const metadata = [ { key : \"name\" , attributeType : 0 , value : ` Token $ { i } ` }, { key : \"value\" , attributeType : 1 , value : i . toString () } ]; mintPromises . push ( minter . connect ( signers [ 0 ]) . gemforceMint ( metadata )); } // Wait for all mints to complete const results = await Promise . allSettled ( mintPromises ); // Count successful mints const successfulMints = results . filter ( r => r . status === \"fulfilled\" ) . length ; console . log ( ` Successfully minted $ { successfulMints } of $ { concurrentMints } tokens ` ); // Analyze failures const failures = results . filter ( r => r . status === \"rejected\" ); for ( const failure of failures ) { console . log ( ` Failure reason : $ { failure . reason } ` ); } expect ( successfulMints ) . to . be . gt ( 0 ); }); }); ``` API load testing with Artillery : ```yaml # load-tests/api-load.yml config: target: \"https://api.gemforce.com\" phases: - duration: 60 arrivalRate: 5 rampTo: 50 name: \"Warm up phase\" - duration: 120 arrivalRate: 50 name: \"Sustained load\" - duration: 60 arrivalRate: 50 rampTo: 100 name: \"Peak load\" defaults: headers: X-Parse-Application-Id: \"{{APP_ID}}\" Content-Type: \"application/json\" scenarios: - name: \"Load test API endpoints\" flow: - post: url: \"/parse/functions/loadAllBlockchains\" json: {} expect: - statusCode: 200 - post: url: \"/parse/functions/loadProviderUrl\" json: networkId: \"84532\" expect: - statusCode: 200 - post: url: \"/parse/functions/loadSmartContractsForNetwork\" json: networkId: \"84532\" expect: - statusCode: 200 ``` Run with: bash npx artillery run load-tests/api-load.yml --environment production","title":"Load Testing"},{"location":"gemforce-deployer-guide/#security-testing","text":"Smart contract security testing : ```bash # Run Slither security analyzer slither contracts/ # Run Mythril myth analyze contracts/Diamond.sol ``` Penetration testing for API : bash # Run OWASP ZAP scan zap-cli quick-scan -s xss,sqli -r report.html https://api.gemforce.com Authentication security tests : ```javascript // test/security/auth.test.js describe(\"Authentication Security\", function() { it(\"should reject invalid authentication\", async function() { // Try with invalid app ID try { Parse.initialize(\"invalid_app_id\", \"test_js_key\"); await Parse.Cloud.run(\"loadAllBlockchains\"); assert.fail(\"Should have thrown an error\"); } catch (e) { expect(e.code).to.equal(Parse.Error.INVALID_APP_ID); } // Try with invalid master key try { Parse . initialize ( \"test_app_id\" , \"test_js_key\" , \"invalid_master_key\" ); const user = new Parse . User (); await user . fetch ({ useMasterKey : true }); assert . fail ( \"Should have thrown an error\" ); } catch ( e ) { expect ( e . code ) . to . equal ( Parse . Error . INVALID_MASTER_KEY ); } }); }); ```","title":"Security Testing"},{"location":"gemforce-deployer-guide/#network-management","text":"","title":"Network Management"},{"location":"gemforce-deployer-guide/#blockchain-node-management","text":"Connecting to blockchain nodes : ```javascript // src/lib/blockchain.js const { ethers } = require(\"ethers\"); // Get provider for network function getProvider(networkId) { const networks = { \"1\": process.env.ETH_NODE_URI_MAINNET, \"84532\": process.env.ETH_NODE_URI_BASESEP }; const nodeUrl = networks [ networkId ] ; if ( ! nodeUrl ) { throw new Error ( ` No RPC endpoint configured for network ${ networkId }` ); } return new ethers . providers . JsonRpcProvider ( nodeUrl ); } // Get WebSocket provider for network function getWebSocketProvider(networkId) { const networks = { \"1\": process.env.ETH_WSS_URI_MAINNET, \"84532\": process.env.ETH_WSS_URI_BASESEP }; const nodeUrl = networks [ networkId ] ; if ( ! nodeUrl ) { throw new Error ( ` No WebSocket endpoint configured for network ${ networkId }` ); } return new ethers . providers . WebSocketProvider ( nodeUrl ); } module.exports = { getProvider, getWebSocketProvider }; ``` Monitoring node health : ```javascript // src/lib/node-monitor.js const { getProvider } = require(\"./blockchain\"); async function checkNodeHealth(networkId) { try { const provider = getProvider(networkId); // Check if node is responding const blockNumber = await provider . getBlockNumber (); // Check if node is synced const syncStatus = await provider . send ( \"eth_syncing\" , []); const isSynced = syncStatus === false ; // Check chain ID const chainId = await provider . getNetwork () . then ( net => net . chainId ); const isCorrectChain = chainId . toString () === networkId ; // Check peers const peerCount = await provider . send ( \"net_peerCount\" , []); const peers = parseInt ( peerCount , 16 ); const hasPeers = peers > 0 ; return { isHealthy : isSynced && isCorrectChain && hasPeers , blockNumber , isSynced , isCorrectChain , peers }; } catch ( error ) { return { isHealthy : false , error : error . message }; } } ``` Node failover : ```javascript // src/lib/node-failover.js const { ethers } = require(\"ethers\"); class FailoverProvider extends ethers.providers.StaticJsonRpcProvider { constructor(urls, network) { super(urls[0], network); this.urls = urls; this.currentUrlIndex = 0; } async send(method, params) { try { return await super.send(method, params); } catch (error) { // Try failover if (this.urls.length > 1) { this.currentUrlIndex = (this.currentUrlIndex + 1) % this.urls.length; this.connection.url = this.urls[this.currentUrlIndex]; console.log(`Failing over to ${ this . connection . url } `); return await super.send(method, params); } throw error; } } } function getFailoverProvider(networkId) { const networks = { \"1\": [ process.env.ETH_NODE_URI_MAINNET_1, process.env.ETH_NODE_URI_MAINNET_2, process.env.ETH_NODE_URI_MAINNET_3 ], \"84532\": [ process.env.ETH_NODE_URI_BASESEP_1, process.env.ETH_NODE_URI_BASESEP_2 ] }; const urls = networks [ networkId ] . filter ( Boolean ); if ( urls . length === 0 ) { throw new Error ( ` No RPC endpoints configured for network ${ networkId }` ); } return new FailoverProvider ( urls , parseInt ( networkId )); } ```","title":"Blockchain Node Management"},{"location":"gemforce-deployer-guide/#rpc-endpoint-configuration","text":"Configuration file for RPC endpoints : javascript // config/networks.js module.exports = { mainnet: { chainId: 1, name: \"Ethereum Mainnet\", rpcEndpoints: [ { url: process.env.ETH_NODE_URI_MAINNET_1, provider: \"Infura\", weight: 10 }, { url: process.env.ETH_NODE_URI_MAINNET_2, provider: \"Alchemy\", weight: 5 }, { url: process.env.ETH_NODE_URI_MAINNET_3, provider: \"Custom\", weight: 1 } ], wsEndpoints: [ { url: process.env.ETH_WSS_URI_MAINNET, provider: \"Infura\" } ], explorerUrl: \"https://etherscan.io\" }, baseSepolia: { chainId: 84532, name: \"Base Sepolia\", rpcEndpoints: [ { url: process.env.ETH_NODE_URI_BASESEP_1, provider: \"Base\", weight: 10 }, { url: process.env.ETH_NODE_URI_BASESEP_2, provider: \"Alchemy\", weight: 5 } ], wsEndpoints: [ { url: process.env.ETH_WSS_URI_BASESEP, provider: \"Base\" } ], explorerUrl: \"https://sepolia.basescan.org\" } }; RPC endpoint selection logic : ```javascript // src/lib/rpc-manager.js const networks = require(\"../../config/networks\"); function selectRpcEndpoint(networkId) { const network = Object.values(networks).find(n => n.chainId === parseInt(networkId)); if (!network) { throw new Error( Network ${networkId} not found in configuration ); } // Use weighted selection const endpoints = network . rpcEndpoints . filter ( e => e . url ); if ( endpoints . length === 0 ) { throw new Error ( ` No RPC endpoints configured for network $ { networkId } ` ); } // Simple random selection for now // Could be expanded to use performance metrics or more complex selection const totalWeight = endpoints . reduce (( sum , e ) => sum + e . weight , 0 ); let random = Math . random () * totalWeight ; for ( const endpoint of endpoints ) { random -= endpoint . weight ; if ( random <= 0 ) { return endpoint . url ; } } // Fallback to first endpoint return endpoints [ 0 ] . url ; } ``` Environment-specific configuration : ```javascript // src/lib/network-config.js const networks = require(\"../../config/networks\"); function getNetworkConfig(networkId, environment = process.env.NODE_ENV) { const network = Object.values(networks).find(n => n.chainId === parseInt(networkId)); if (!network) { throw new Error( Network ${networkId} not found in configuration ); } // Apply environment - specific overrides const envOverrides = { development : { rpcEndpoints : [ { url: \"http://localhost:8545\", provider: \"Local\", weight: 100 } ] } , test : { // Test environment might use special endpoints } , // production uses default configuration } ; if ( envOverrides [ environment ] ) { return { ... network , ... envOverrides [ environment ] } ; } return network ; } ```","title":"RPC Endpoint Configuration"},{"location":"gemforce-deployer-guide/#transaction-monitoring","text":"Monitoring transaction status : ```javascript // src/lib/transaction-monitor.js const { getProvider } = require(\"./blockchain\"); const db = require(\"./db\"); async function monitorTransaction(txHash, networkId) { const provider = getProvider(networkId); // Store the transaction in the database await db . collection ( \"Transaction\" ). insertOne ({ hash : txHash , networkId , status : \"pending\" , createdAt : new Date (), attempts : 0 }); // Get initial transaction receipt let receipt = await provider . getTransactionReceipt ( txHash ); // Transaction is still pending if ( ! receipt ) { // Schedule check for later setTimeout (() = > checkTransaction ( txHash , networkId ), 15000 ); return { status : \"pending\" }; } // Transaction is mined updateTransactionStatus ( txHash , receipt ); return { status : receipt . status ? \"confirmed\" : \"failed\" , receipt }; } async function checkTransaction(txHash, networkId) { try { const provider = getProvider(networkId); const receipt = await provider.getTransactionReceipt(txHash); if ( ! receipt ) { // Still pending , check if it 's been too long const tx = await db . collection ( \"Transaction\" ) . findOne ({ hash : txHash }); const age = Date . now () - tx . createdAt . getTime (); const attempts = tx . attempts + 1 ; await db . collection ( \"Transaction\" ) . updateOne ( { hash : txHash }, { $ set : { attempts }, $ currentDate : { lastChecked : true } } ); if ( age > 3600000 ) { // 1 hour // Transaction has been pending too long await db . collection ( \"Transaction\" ) . updateOne ( { hash : txHash }, { $ set : { status : \"stalled\" } } ); // Could notify an admin here } else { // Check again later setTimeout (() => checkTransaction ( txHash , networkId ), 30000 ); } return ; } // Transaction is mined , update status updateTransactionStatus ( txHash , receipt ); } catch ( error ) { console . error ( ` Error checking transaction $ { txHash }: ` , error ); } } async function updateTransactionStatus(txHash, receipt) { const status = receipt.status ? \"confirmed\" : \"failed\"; await db . collection ( \"Transaction\" ) . updateOne ( { hash : txHash } , { $ set : { status , blockNumber : receipt . blockNumber , gasUsed : receipt . gasUsed . toString (), effectiveGasPrice : receipt . effectiveGasPrice . toString () } } ); } ``` Transaction event listener : ```javascript // src/lib/event-listener.js const { getWebSocketProvider } = require(\"./blockchain\"); const db = require(\"./db\"); class TransactionEventListener { constructor(networkId) { this.networkId = networkId; this.provider = getWebSocketProvider(networkId); this.contracts = new Map(); } addContract ( address , abi , name ) { const contract = new ethers . Contract ( address , abi , this . provider ); this . contracts . set ( address , { contract , name }); console . log ( ` Added contract $ { name } at $ { address } for event monitoring ` ); return contract ; } startListening () { // Listen for new blocks this . provider . on ( \"block\" , this . handleNewBlock . bind ( this )); // Listen for specific events on each contract for ( const [ address , { contract , name }] of this . contracts . entries ()) { contract . on ( \"*\" , ( ... args ) => { const event = args [ args . length - 1 ]; this . handleContractEvent ( name , event ); }); } } async handleNewBlock ( blockNumber ) { console . log ( ` New block : $ { blockNumber } on network $ { this . networkId } ` ); // Check pending transactions const pendingTxs = await db . collection ( \"Transaction\" ) . find ({ networkId : this . networkId , status : \"pending\" }) . toArray (); for ( const tx of pendingTxs ) { try { const receipt = await this . provider . getTransactionReceipt ( tx . hash ); if ( receipt ) { const status = receipt . status ? \"confirmed\" : \"failed\" ; await db . collection ( \"Transaction\" ) . updateOne ( { hash : tx . hash }, { $ set : { status , blockNumber : receipt . blockNumber , gasUsed : receipt . gasUsed . toString (), effectiveGasPrice : receipt . effectiveGasPrice . toString () } } ); console . log ( ` Transaction $ { tx . hash } $ { status } in block $ { receipt . blockNumber } ` ); } } catch ( error ) { console . error ( ` Error checking transaction $ { tx . hash }: ` , error ); } } } async handleContractEvent ( contractName , event ) { console . log ( ` Event from $ { contractName }: $ { event . event } ` ); // Store event in database await db . collection ( \"ContractEvent\" ) . insertOne ({ contractName , eventName : event . event , transactionHash : event . transactionHash , blockNumber : event . blockNumber , args : JSON . parse ( JSON . stringify ( event . args )), // Convert BigNumber to string timestamp : new Date () }); // Emit event for WebSocket clients if needed } stop () { this . provider . removeAllListeners (); for ( const [ address , { contract }] of this . contracts . entries ()) { contract . removeAllListeners (); } console . log ( ` Stopped event listener for network $ { this . networkId } ` ); } } ```","title":"Transaction Monitoring"},{"location":"gemforce-deployer-guide/#gas-price-management","text":"Gas price estimation : ```javascript // src/lib/gas-price.js const { ethers } = require(\"ethers\"); const { getProvider } = require(\"./blockchain\"); async function estimateGasPrice(networkId, priority = \"medium\") { try { const provider = getProvider(networkId); // Get current gas price from provider const gasPrice = await provider . getGasPrice (); // Apply multipliers based on priority const multipliers = { low : 0.8 , medium : 1.0 , high : 1.5 , urgent : 2.0 } ; const multiplier = multipliers [ priority ] || 1.0 ; return gasPrice . mul ( Math . floor ( multiplier * 100 )). div ( 100 ); } catch ( error ) { console . error ( ` Error estimating gas price : ` , error ); // Fallback gas prices ( in gwei ) const fallbackPrices = { 1 : { low : 20 , medium : 30 , high : 50 , urgent : 80 } , // Mainnet 84532 : { low : 1 , medium : 1.5 , high : 2 , urgent : 3 } // BaseSepolia } ; const gweiPrice = fallbackPrices [ networkId ] ? . [ priority ] || 10 ; return ethers . utils . parseUnits ( gweiPrice . toString (), \"gwei\" ); } } async function getGasSettings(networkId, priority = \"medium\") { const gasPrice = await estimateGasPrice(networkId, priority); // For EIP - 1559 compatible networks , use maxFeePerGas and maxPriorityFeePerGas const provider = getProvider ( networkId ); const network = await provider . getNetwork (); // Check if network supports EIP - 1559 const block = await provider . getBlock ( \"latest\" ); const eip1559Support = block && block . baseFeePerGas !== undefined ; if ( eip1559Support ) { const baseFeePerGas = block . baseFeePerGas ; // Priority fee multipliers const priorityFeeMultipliers = { low : 1.0 , medium : 1.5 , high : 2.0 , urgent : 3.0 } ; const multiplier = priorityFeeMultipliers [ priority ] || 1.5 ; const maxPriorityFeePerGas = ethers . utils . parseUnits ( \"1\" , \"gwei\" ). mul ( multiplier ); // maxFeePerGas = ( baseFeePerGas * 2 ) + maxPriorityFeePerGas const maxFeePerGas = baseFeePerGas . mul ( 2 ). add ( maxPriorityFeePerGas ); return { maxFeePerGas , maxPriorityFeePerGas } ; } // Fallback to regular gasPrice for non - EIP - 1559 networks return { gasPrice } ; } ``` Transaction submission with gas management : ```javascript // src/lib/transaction.js const { getProvider } = require(\"./blockchain\"); const { getGasSettings } = require(\"./gas-price\"); async function sendTransaction(networkId, txData, priority = \"medium\") { const provider = getProvider(networkId); const signer = new ethers.Wallet(process.env.PRIVATE_KEY, provider); // Get gas settings based on network and priority const gasSettings = await getGasSettings ( networkId , priority ); // Estimate gas limit const gasLimit = await provider . estimateGas ({ from : signer . address , to : txData . to , data : txData . data , value : txData . value || 0 }); // Add buffer to gas limit const gasLimitWithBuffer = gasLimit . mul ( 120 ) . div ( 100 ); // 20 % buffer // Construct transaction const transaction = { from : signer . address , to : txData . to , data : txData . data , value : txData . value || 0 , gasLimit : gasLimitWithBuffer , ... gasSettings }; // Send transaction const tx = await signer . sendTransaction ( transaction ); console . log ( ` Transaction sent : $ { tx . hash } ` ); return tx ; } ```","title":"Gas Price Management"},{"location":"gemforce-deployer-guide/#network-upgrades-handling","text":"Network upgrade detector : ```javascript // src/lib/network-upgrade.js const { getProvider } = require(\"./blockchain\"); async function checkNetworkUpgrade(networkId) { try { const provider = getProvider(networkId); // Get current block const block = await provider . getBlock ( \"latest\" ); // Check for fork identifier or other upgrade indicators const isEIP1559 = block && block . baseFeePerGas !== undefined ; // Check for upcoming network upgrades const upgrades = { 1 : [ // Ethereum Mainnet { name: \"Cancun\", block: 19000000, active: block.number >= 19000000 } ] , 84532 : [ // BaseSepolia { name: \"Future Upgrade\", block: 5000000, active: block.number >= 5000000 } ] } ; const networkUpgrades = upgrades [ networkId ] || [] ; const upcomingUpgrades = networkUpgrades . filter ( u => ! u . active ); const activeUpgrades = networkUpgrades . filter ( u => u . active ); return { currentBlock : block . number , features : { eip1559 : isEIP1559 } , activeUpgrades , upcomingUpgrades } ; } catch ( error ) { console . error ( ` Error checking network upgrade : ` , error ); return { error : error . message } ; } } ``` Handling network forks : ```javascript // src/lib/fork-handler.js const { getProvider } = require(\"./blockchain\"); class ForkHandler { constructor(networkId) { this.networkId = networkId; this.provider = getProvider(networkId); this.forkBlocks = { 1: { // Ethereum Mainnet \"Cancun\": 19000000 }, 84532: { // BaseSepolia \"FutureUpgrade\": 5000000 } }; } async detectFork () { const currentBlock = await this . provider . getBlockNumber (); const networkForks = this . forkBlocks [ this . networkId ] || {}; const activeForks = []; const pendingForks = []; for ( const [ name , blockNumber ] of Object . entries ( networkForks )) { if ( currentBlock >= blockNumber ) { activeForks . push ({ name , blockNumber }); } else { pendingForks . push ({ name , blockNumber , blocksRemaining : blockNumber - currentBlock }); } } return { currentBlock , activeForks , pendingForks }; } async adjustForFork ( txParams ) { const forkStatus = await this . detectFork (); const newParams = { ... txParams }; // Adjust transaction parameters based on active forks for ( const fork of forkStatus . activeForks ) { if ( fork . name === \"Cancun\" || fork . name === \"London\" ) { // EIP - 1559 transaction type delete newParams . gasPrice ; if ( ! newParams . maxFeePerGas ) { const block = await this . provider . getBlock ( \"latest\" ); const baseFeePerGas = block . baseFeePerGas ; newParams . maxPriorityFeePerGas = ethers . utils . parseUnits ( \"1.5\" , \"gwei\" ); newParams . maxFeePerGas = baseFeePerGas . mul ( 2 ) . add ( newParams . maxPriorityFeePerGas ); } // Set type 2 transaction ( EIP - 1559 ) newParams . type = 2 ; } } return newParams ; } } ```","title":"Network Upgrades Handling"},{"location":"gemforce-deployer-guide/#version-control","text":"","title":"Version Control"},{"location":"gemforce-deployer-guide/#repository-structure","text":"Recommended repository structure : gemforce/ \u251c\u2500\u2500 .github/ # GitHub workflows and templates \u251c\u2500\u2500 contracts/ # Smart contracts \u2502 \u251c\u2500\u2500 facets/ # Diamond facets \u2502 \u251c\u2500\u2500 interfaces/ # Contract interfaces \u2502 \u251c\u2500\u2500 libraries/ # Contract libraries \u2502 \u251c\u2500\u2500 upgradeInitializers/ # Initializers for upgrades \u251c\u2500\u2500 deploy/ # Deployment scripts \u251c\u2500\u2500 deployments/ # Deployment artifacts \u251c\u2500\u2500 docs/ # Documentation \u251c\u2500\u2500 scripts/ # Utility scripts \u251c\u2500\u2500 src/ # Source code \u2502 \u251c\u2500\u2500 cloud-functions/ # Parse cloud functions \u2502 \u251c\u2500\u2500 lib/ # Shared libraries \u2502 \u251c\u2500\u2500 indexer/ # Blockchain indexer \u2502 \u251c\u2500\u2500 triggers/ # Parse triggers \u251c\u2500\u2500 test/ # Tests \u2502 \u251c\u2500\u2500 unit/ # Unit tests \u2502 \u251c\u2500\u2500 integration/ # Integration tests \u2502 \u251c\u2500\u2500 fixtures/ # Test fixtures \u251c\u2500\u2500 .env.example # Example environment variables \u251c\u2500\u2500 hardhat.config.ts # Hardhat configuration \u251c\u2500\u2500 package.json # Project metadata and dependencies \u251c\u2500\u2500 tsconfig.json # TypeScript configuration \u2514\u2500\u2500 README.md # Project documentation Repository organization best practices : Separate smart contracts from off-chain code Organize contracts by functionality Use descriptive folder names Keep tests close to the code they test Include documentation for each component","title":"Repository Structure"},{"location":"gemforce-deployer-guide/#branching-strategy","text":"Git Flow branching model : main \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500 (production releases) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 staging \u2502 \u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500 (pre-production testing) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 develop \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500 (integration branch) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 feature/xyz \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf \u2502 \u2502 (feature branches) \u2502 \u2502 \u2502 feature/abc \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u25cf \u2502 (feature branches) \u2502 hotfix/123 \u25cf\u2500\u2500\u2500\u2500\u2500 (hotfix branches) main : Production code, tagged with version numbers staging : Pre-production testing develop : Integration branch for feature development feature/ *: Feature branches for new development hotfix/ *: Urgent fixes for production issues Branching guidelines : ```bash # Create a new feature branch from develop git checkout develop git pull git checkout -b feature/new-feature # Work on the feature, committing changes git add . git commit -m \"Implement new feature\" # Push feature branch to remote git push -u origin feature/new-feature # When feature is complete, merge to develop git checkout develop git pull git merge --no-ff feature/new-feature git push origin develop # Create a hotfix branch from main git checkout main git pull git checkout -b hotfix/critical-fix # Fix the issue, commit changes git add . git commit -m \"Fix critical issue\" # Push hotfix branch git push -u origin hotfix/critical-fix # When hotfix is complete, merge to main and develop git checkout main git pull git merge --no-ff hotfix/critical-fix git push origin main git checkout develop git pull git merge --no-ff hotfix/critical-fix git push origin develop ```","title":"Branching Strategy"},{"location":"gemforce-deployer-guide/#release-management","text":"Semantic versioning : MAJOR.MINOR.PATCH MAJOR : Breaking changes MINOR : New features, backwards compatible PATCH : Bug fixes, backwards compatible Release process : ```bash # Prepare release from develop git checkout develop git pull git checkout -b release/1.2.0 # Update version numbers npm version minor --no-git-tag-version # Make final adjustments git add . git commit -m \"Prepare release 1.2.0\" # Merge to staging for testing git checkout staging git pull git merge --no-ff release/1.2.0 git push origin staging # Deploy to staging environment npm run deploy:staging # After testing, merge to main git checkout main git pull git merge --no-ff release/1.2.0 git tag -a v1.2.0 -m \"Release 1.2.0\" git push origin main --tags # Update develop with any changes git checkout develop git pull git merge --no-ff release/1.2.0 git push origin develop # Delete release branch git branch -d release/1.2.0 ``` Changelog management : ```markdown # Changelog All notable changes to this project will be documented in this file. ## [1.2.0] - 2025-02-25 ### Added - New carbon credit retirement feature - Support for multiple wallet providers ### Changed - Improved marketplace performance - Updated identity verification flow ### Fixed - Fixed issue with token minting - Resolved WebSocket connection stability ## [1.1.0] - 2025-01-15 ### Added - Identity management system - DFNS wallet integration ### Changed - Upgraded Parse Server to latest version - Improved error handling ### Deprecated - Legacy API endpoints (to be removed in 2.0) ```","title":"Release Management"},{"location":"gemforce-deployer-guide/#tagging-conventions","text":"Version tags : ```bash # Create an annotated version tag git tag -a v1.2.0 -m \"Release 1.2.0\" # Push tags to remote git push origin --tags ``` Environment tags : ```bash # Create a tag for production deployment git tag -a prod-2025-02-25 -m \"Production deployment on Feb 25, 2025\" # Create a tag for staging deployment git tag -a staging-2025-02-20 -m \"Staging deployment on Feb 20, 2025\" ``` Contract deployment tags : ```bash # Create a tag for contract deployment git tag -a deploy-mainnet-1.2.0 -m \"Mainnet contract deployment v1.2.0\" # Create a tag for facet upgrade git tag -a upgrade-marketplace-1.2.1 -m \"Marketplace facet upgrade to v1.2.1\" ```","title":"Tagging Conventions"},{"location":"gemforce-deployer-guide/#documentation-versioning","text":"Documentation directory structure : docs/ \u251c\u2500\u2500 latest/ # Latest documentation (symlink to current version) \u251c\u2500\u2500 v1.2.0/ # Documentation for v1.2.0 \u2502 \u251c\u2500\u2500 admin-guide.md # Administrator guide \u2502 \u251c\u2500\u2500 api-reference.md # API reference \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 v1.1.0/ # Documentation for v1.1.0 \u2502 \u251c\u2500\u2500 admin-guide.md # Administrator guide \u2502 \u251c\u2500\u2500 api-reference.md # API reference \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 ... Version-specific documentation : ```bash # Create a new documentation version mkdir -p docs/v1.2.0 cp -r docs/v1.1.0/* docs/v1.2.0/ # Update documentation for new version # Edit files in docs/v1.2.0/ # Update the latest symlink rm docs/latest ln -s v1.2.0 docs/latest ``` Documentation in the codebase : ```solidity // contracts/facets/MarketplaceFacet.sol /* * @title MarketplaceFacet * @dev Implements marketplace functionality for the Diamond * @notice This facet handles listing, buying, and selling tokens * @version 1.2.0 / contract MarketplaceFacet is Modifiers { // ... ``` ```javascript // src/cloud-functions/marketplace.js /* * @api {post} /parse/functions/listItem List an item for sale * @apiVersion 1.2.0 * @apiName ListItem * @apiGroup Marketplace * @apiDescription Lists a token for sale in the marketplace * * @apiParam {String} tokenId The ID of the token to list * @apiParam {String} price The price in ETH * * @apiSuccess {Object} result The result of the operation * @apiSuccess {Boolean} result.success Whether the operation was successful * @apiSuccess {String} result.transactionHash The transaction hash / Parse.Cloud.define(\"listItem\", async (request) => { // ... });","title":"Documentation Versioning"},{"location":"gemforce-external-services/","text":"Gemforce External Services Integration \u00b6 This document provides detailed information about the external services and third-party integrations used by the Gemforce platform. Understanding these services is essential for developers working with the Gemforce API. DFNS Wallet-as-a-Service \u00b6 DFNS provides a secure and user-friendly wallet management system that Gemforce uses for managing blockchain transactions. Overview \u00b6 DFNS is a wallet-as-a-service platform that offers: - Non-custodial wallet management - WebAuthn-based authentication - Transaction signing without exposing private keys - Delegated transaction execution Integration Points \u00b6 Gemforce integrates with DFNS via: - DFNS API Client - DFNS Delegated API Client Key Features Used \u00b6 User Registration & Authentication WebAuthn-based registration Passwordless authentication Recovery mechanisms Wallet Management Wallet creation Asset listing Transaction history Transaction Signing Challenge-based signing Two-step transaction process (Init/Complete) Delegated transaction execution API Flow \u00b6 Client App <-> Gemforce Cloud Functions <-> DFNS API Client initiates a request to Gemforce Cloud Functions Gemforce creates a transaction payload and requests a challenge from DFNS Challenge is passed to the client for signing with WebAuthn Signed challenge is sent back to Gemforce Gemforce completes the transaction with DFNS DFNS broadcasts the transaction to the blockchain Configuration \u00b6 DFNS requires the following environment variables: - DFNS_APP_ID : Application ID for DFNS - DFNS_API_URL : Base URL for DFNS API - DFNS_CRED_ID : Credential ID for DFNS - DFNS_AUTH_TOKEN : Authentication token (for server operations) Bridge API Integration \u00b6 Bridge API provides financial services integration for Gemforce, enabling external account management, transfers, and KYC processes. Overview \u00b6 Bridge API offers: - External account management - Transfer operations between traditional finance and crypto - KYC verification - Plaid integration for banking connections Integration Points \u00b6 Gemforce integrates with Bridge API via RESTful HTTP endpoints. Key Features Used \u00b6 External Account Management Creation of external accounts Multiple account types (US, IBAN) Account listing and retrieval Account deletion Transfer Operations Cross-currency transfers Multiple payment rails (ACH, SEPA, Wire, Blockchain) Transfer status tracking Idempotent operations KYC Management KYC link generation KYC status tracking Individual and business verification Plaid Integration Link token generation Token exchange Account verification API Flow \u00b6 Client App <-> Gemforce Cloud Functions <-> Bridge API Client app calls Gemforce Cloud Functions Gemforce validates and formats the request Gemforce calls Bridge API with appropriate headers Bridge API processes the request and returns a response Gemforce processes and returns the response to the client Configuration \u00b6 Bridge API requires the following environment variables: - BASE_BRIDGE_URL : Base URL for Bridge API - BRIDGE_API_KEY : API key for authentication Parse Server \u00b6 Parse Server provides the backend infrastructure for Gemforce's cloud functions and data storage. Overview \u00b6 Parse Server offers: - User authentication and management - Cloud functions - Database operations - File storage - Push notifications Integration Points \u00b6 Gemforce uses Parse Server as the primary backend platform. Key Features Used \u00b6 User Management Registration Email verification Password reset Session management Cloud Functions Blockchain operations DFNS integration Bridge API integration Business logic Data Storage User profiles Blockchain data Identity information Transaction history Role-Based Access Control User roles Permission management Object-level ACLs Configuration \u00b6 Parse Server requires the following environment variables: - APP_ID : Parse application ID - MASTER_KEY : Parse master key - DATABASE_URI : MongoDB connection string - SERVER_URL : Parse Server URL - PROJECT_WIZARD_URL : URL for the project wizard Ethereum Blockchain Networks \u00b6 Gemforce interacts with multiple Ethereum-compatible blockchain networks. Overview \u00b6 Gemforce supports multiple blockchain networks including: - Ethereum Mainnet - BaseSepolia - Other EVM-compatible networks Integration Points \u00b6 Gemforce interacts with blockchain networks via: - JSON-RPC providers - WebSocket connections Key Features Used \u00b6 Smart Contract Deployment Diamond contract deployment Facet deployment Contract initialization Transaction Submission Method calls Value transfers Contract interactions Event Monitoring WebSocket subscriptions Event filtering Log parsing State Reading View function calls State synchronization Configuration \u00b6 Blockchain integration requires the following environment variables: - ETH_NODE_URI_[NETWORK] : JSON-RPC endpoint for each network - CHAIN_ID : ID of the default chain - METADATA_BASE_URI : Base URI for token metadata SendGrid Email Service \u00b6 SendGrid is used for transactional email communications. Overview \u00b6 SendGrid provides email delivery services for: - User verification - Password reset - Notifications - Other transactional emails Integration Points \u00b6 Gemforce uses SendGrid's Node.js SDK. Key Features Used \u00b6 Email Templates EJS templating HTML email content Dynamic content insertion Email Sending Transactional emails HTML content Attachments Configuration \u00b6 SendGrid requires the following environment variables: - SendGrid API key (configured through environment variables) - From email address Plaid (via Bridge API) \u00b6 Plaid is integrated through Bridge API to provide banking connection services. Overview \u00b6 Plaid offers: - Bank account verification - Account linking - Transaction history - Balance information Integration Points \u00b6 Gemforce interacts with Plaid through Bridge API. Key Features Used \u00b6 Link Token Creation Generated for each user session Configured for specific use cases Public Token Exchange Convert public tokens to access tokens Securely store access tokens API Flow \u00b6 Client App <-> Plaid Link <-> Client App <-> Gemforce <-> Bridge API <-> Plaid Client requests a Plaid link token from Gemforce Gemforce obtains the token through Bridge API Client uses the token with Plaid Link Plaid Link provides a public token to the client Client sends the public token to Gemforce Gemforce exchanges it via Bridge API Bridge API handles Plaid API communication Integration Diagram \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Client App \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 Parse Server \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba DFNS \u2502 \u2502 (Cloud Functions)\u2502 \u2502 Wallet-as-Service \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 Blockchain \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Networks \u2502 \u2502 \u2502 Bridge API \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - Ethereum Mainnet \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 - BaseSepolia \u2502 \u2502 \u2502 \u2502 \u2502 - Others \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Plaid \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25b2 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Smart Contracts \u2502 \u2502 \u2502 \u2502 - Diamond \u2502 \u2502 - Identity System \u2502 \u2502 - Asset Management \u2502 \u2502 - Carbon Credits \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Authentication Flows \u00b6 User Registration & Login \u00b6 User registers through Parse Server Email verification is sent via SendGrid User verifies email User logs in with username/password Parse Server creates a session token DFNS Registration \u00b6 User initiates DFNS registration Gemforce requests a registration challenge from DFNS User completes WebAuthn registration on client Signed challenge is sent to Gemforce Gemforce completes registration with DFNS DFNS creates a wallet for the user Bridge API Authentication \u00b6 Bridge API authentication is handled server-side with API keys. The client never interacts directly with Bridge API credentials. Security Considerations \u00b6 API Keys & Secrets \u00b6 All API keys and secrets are stored as environment variables API keys are never exposed to clients All external API calls are made server-side Delegated Authentication \u00b6 DFNS uses delegated authentication Client never has access to private keys WebAuthn provides phishing-resistant authentication Idempotency \u00b6 Bridge API calls use idempotency keys Prevents duplicate transactions Allows safe retries Rate Limiting \u00b6 DFNS \u00b6 DFNS imposes rate limits on API calls Gemforce implements exponential backoff for retries Bridge API \u00b6 Bridge API has rate limits based on API key Gemforce handles rate limit errors Error Handling \u00b6 DFNS Errors \u00b6 Challenge-related errors WebAuthn errors Transaction errors Bridge API Errors \u00b6 Validation errors Processing errors External account errors KYC errors Blockchain Errors \u00b6 Gas-related errors Transaction failure Network congestion Monitoring & Logging \u00b6 All external service interactions are logged for: - Debugging - Audit trails - Performance monitoring - Error tracking Conclusion \u00b6 Gemforce integrates with several external services to provide a comprehensive platform. Understanding these integrations is crucial for effectively working with the Gemforce API.","title":"External Services"},{"location":"gemforce-external-services/#gemforce-external-services-integration","text":"This document provides detailed information about the external services and third-party integrations used by the Gemforce platform. Understanding these services is essential for developers working with the Gemforce API.","title":"Gemforce External Services Integration"},{"location":"gemforce-external-services/#dfns-wallet-as-a-service","text":"DFNS provides a secure and user-friendly wallet management system that Gemforce uses for managing blockchain transactions.","title":"DFNS Wallet-as-a-Service"},{"location":"gemforce-external-services/#overview","text":"DFNS is a wallet-as-a-service platform that offers: - Non-custodial wallet management - WebAuthn-based authentication - Transaction signing without exposing private keys - Delegated transaction execution","title":"Overview"},{"location":"gemforce-external-services/#integration-points","text":"Gemforce integrates with DFNS via: - DFNS API Client - DFNS Delegated API Client","title":"Integration Points"},{"location":"gemforce-external-services/#key-features-used","text":"User Registration & Authentication WebAuthn-based registration Passwordless authentication Recovery mechanisms Wallet Management Wallet creation Asset listing Transaction history Transaction Signing Challenge-based signing Two-step transaction process (Init/Complete) Delegated transaction execution","title":"Key Features Used"},{"location":"gemforce-external-services/#api-flow","text":"Client App <-> Gemforce Cloud Functions <-> DFNS API Client initiates a request to Gemforce Cloud Functions Gemforce creates a transaction payload and requests a challenge from DFNS Challenge is passed to the client for signing with WebAuthn Signed challenge is sent back to Gemforce Gemforce completes the transaction with DFNS DFNS broadcasts the transaction to the blockchain","title":"API Flow"},{"location":"gemforce-external-services/#configuration","text":"DFNS requires the following environment variables: - DFNS_APP_ID : Application ID for DFNS - DFNS_API_URL : Base URL for DFNS API - DFNS_CRED_ID : Credential ID for DFNS - DFNS_AUTH_TOKEN : Authentication token (for server operations)","title":"Configuration"},{"location":"gemforce-external-services/#bridge-api-integration","text":"Bridge API provides financial services integration for Gemforce, enabling external account management, transfers, and KYC processes.","title":"Bridge API Integration"},{"location":"gemforce-external-services/#overview_1","text":"Bridge API offers: - External account management - Transfer operations between traditional finance and crypto - KYC verification - Plaid integration for banking connections","title":"Overview"},{"location":"gemforce-external-services/#integration-points_1","text":"Gemforce integrates with Bridge API via RESTful HTTP endpoints.","title":"Integration Points"},{"location":"gemforce-external-services/#key-features-used_1","text":"External Account Management Creation of external accounts Multiple account types (US, IBAN) Account listing and retrieval Account deletion Transfer Operations Cross-currency transfers Multiple payment rails (ACH, SEPA, Wire, Blockchain) Transfer status tracking Idempotent operations KYC Management KYC link generation KYC status tracking Individual and business verification Plaid Integration Link token generation Token exchange Account verification","title":"Key Features Used"},{"location":"gemforce-external-services/#api-flow_1","text":"Client App <-> Gemforce Cloud Functions <-> Bridge API Client app calls Gemforce Cloud Functions Gemforce validates and formats the request Gemforce calls Bridge API with appropriate headers Bridge API processes the request and returns a response Gemforce processes and returns the response to the client","title":"API Flow"},{"location":"gemforce-external-services/#configuration_1","text":"Bridge API requires the following environment variables: - BASE_BRIDGE_URL : Base URL for Bridge API - BRIDGE_API_KEY : API key for authentication","title":"Configuration"},{"location":"gemforce-external-services/#parse-server","text":"Parse Server provides the backend infrastructure for Gemforce's cloud functions and data storage.","title":"Parse Server"},{"location":"gemforce-external-services/#overview_2","text":"Parse Server offers: - User authentication and management - Cloud functions - Database operations - File storage - Push notifications","title":"Overview"},{"location":"gemforce-external-services/#integration-points_2","text":"Gemforce uses Parse Server as the primary backend platform.","title":"Integration Points"},{"location":"gemforce-external-services/#key-features-used_2","text":"User Management Registration Email verification Password reset Session management Cloud Functions Blockchain operations DFNS integration Bridge API integration Business logic Data Storage User profiles Blockchain data Identity information Transaction history Role-Based Access Control User roles Permission management Object-level ACLs","title":"Key Features Used"},{"location":"gemforce-external-services/#configuration_2","text":"Parse Server requires the following environment variables: - APP_ID : Parse application ID - MASTER_KEY : Parse master key - DATABASE_URI : MongoDB connection string - SERVER_URL : Parse Server URL - PROJECT_WIZARD_URL : URL for the project wizard","title":"Configuration"},{"location":"gemforce-external-services/#ethereum-blockchain-networks","text":"Gemforce interacts with multiple Ethereum-compatible blockchain networks.","title":"Ethereum Blockchain Networks"},{"location":"gemforce-external-services/#overview_3","text":"Gemforce supports multiple blockchain networks including: - Ethereum Mainnet - BaseSepolia - Other EVM-compatible networks","title":"Overview"},{"location":"gemforce-external-services/#integration-points_3","text":"Gemforce interacts with blockchain networks via: - JSON-RPC providers - WebSocket connections","title":"Integration Points"},{"location":"gemforce-external-services/#key-features-used_3","text":"Smart Contract Deployment Diamond contract deployment Facet deployment Contract initialization Transaction Submission Method calls Value transfers Contract interactions Event Monitoring WebSocket subscriptions Event filtering Log parsing State Reading View function calls State synchronization","title":"Key Features Used"},{"location":"gemforce-external-services/#configuration_3","text":"Blockchain integration requires the following environment variables: - ETH_NODE_URI_[NETWORK] : JSON-RPC endpoint for each network - CHAIN_ID : ID of the default chain - METADATA_BASE_URI : Base URI for token metadata","title":"Configuration"},{"location":"gemforce-external-services/#sendgrid-email-service","text":"SendGrid is used for transactional email communications.","title":"SendGrid Email Service"},{"location":"gemforce-external-services/#overview_4","text":"SendGrid provides email delivery services for: - User verification - Password reset - Notifications - Other transactional emails","title":"Overview"},{"location":"gemforce-external-services/#integration-points_4","text":"Gemforce uses SendGrid's Node.js SDK.","title":"Integration Points"},{"location":"gemforce-external-services/#key-features-used_4","text":"Email Templates EJS templating HTML email content Dynamic content insertion Email Sending Transactional emails HTML content Attachments","title":"Key Features Used"},{"location":"gemforce-external-services/#configuration_4","text":"SendGrid requires the following environment variables: - SendGrid API key (configured through environment variables) - From email address","title":"Configuration"},{"location":"gemforce-external-services/#plaid-via-bridge-api","text":"Plaid is integrated through Bridge API to provide banking connection services.","title":"Plaid (via Bridge API)"},{"location":"gemforce-external-services/#overview_5","text":"Plaid offers: - Bank account verification - Account linking - Transaction history - Balance information","title":"Overview"},{"location":"gemforce-external-services/#integration-points_5","text":"Gemforce interacts with Plaid through Bridge API.","title":"Integration Points"},{"location":"gemforce-external-services/#key-features-used_5","text":"Link Token Creation Generated for each user session Configured for specific use cases Public Token Exchange Convert public tokens to access tokens Securely store access tokens","title":"Key Features Used"},{"location":"gemforce-external-services/#api-flow_2","text":"Client App <-> Plaid Link <-> Client App <-> Gemforce <-> Bridge API <-> Plaid Client requests a Plaid link token from Gemforce Gemforce obtains the token through Bridge API Client uses the token with Plaid Link Plaid Link provides a public token to the client Client sends the public token to Gemforce Gemforce exchanges it via Bridge API Bridge API handles Plaid API communication","title":"API Flow"},{"location":"gemforce-external-services/#integration-diagram","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Client App \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 Parse Server \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba DFNS \u2502 \u2502 (Cloud Functions)\u2502 \u2502 Wallet-as-Service \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 Blockchain \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Networks \u2502 \u2502 \u2502 Bridge API \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - Ethereum Mainnet \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 - BaseSepolia \u2502 \u2502 \u2502 \u2502 \u2502 - Others \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Plaid \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25b2 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Smart Contracts \u2502 \u2502 \u2502 \u2502 - Diamond \u2502 \u2502 - Identity System \u2502 \u2502 - Asset Management \u2502 \u2502 - Carbon Credits \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Integration Diagram"},{"location":"gemforce-external-services/#authentication-flows","text":"","title":"Authentication Flows"},{"location":"gemforce-external-services/#user-registration-login","text":"User registers through Parse Server Email verification is sent via SendGrid User verifies email User logs in with username/password Parse Server creates a session token","title":"User Registration &amp; Login"},{"location":"gemforce-external-services/#dfns-registration","text":"User initiates DFNS registration Gemforce requests a registration challenge from DFNS User completes WebAuthn registration on client Signed challenge is sent to Gemforce Gemforce completes registration with DFNS DFNS creates a wallet for the user","title":"DFNS Registration"},{"location":"gemforce-external-services/#bridge-api-authentication","text":"Bridge API authentication is handled server-side with API keys. The client never interacts directly with Bridge API credentials.","title":"Bridge API Authentication"},{"location":"gemforce-external-services/#security-considerations","text":"","title":"Security Considerations"},{"location":"gemforce-external-services/#api-keys-secrets","text":"All API keys and secrets are stored as environment variables API keys are never exposed to clients All external API calls are made server-side","title":"API Keys &amp; Secrets"},{"location":"gemforce-external-services/#delegated-authentication","text":"DFNS uses delegated authentication Client never has access to private keys WebAuthn provides phishing-resistant authentication","title":"Delegated Authentication"},{"location":"gemforce-external-services/#idempotency","text":"Bridge API calls use idempotency keys Prevents duplicate transactions Allows safe retries","title":"Idempotency"},{"location":"gemforce-external-services/#rate-limiting","text":"","title":"Rate Limiting"},{"location":"gemforce-external-services/#dfns","text":"DFNS imposes rate limits on API calls Gemforce implements exponential backoff for retries","title":"DFNS"},{"location":"gemforce-external-services/#bridge-api","text":"Bridge API has rate limits based on API key Gemforce handles rate limit errors","title":"Bridge API"},{"location":"gemforce-external-services/#error-handling","text":"","title":"Error Handling"},{"location":"gemforce-external-services/#dfns-errors","text":"Challenge-related errors WebAuthn errors Transaction errors","title":"DFNS Errors"},{"location":"gemforce-external-services/#bridge-api-errors","text":"Validation errors Processing errors External account errors KYC errors","title":"Bridge API Errors"},{"location":"gemforce-external-services/#blockchain-errors","text":"Gas-related errors Transaction failure Network congestion","title":"Blockchain Errors"},{"location":"gemforce-external-services/#monitoring-logging","text":"All external service interactions are logged for: - Debugging - Audit trails - Performance monitoring - Error tracking","title":"Monitoring &amp; Logging"},{"location":"gemforce-external-services/#conclusion","text":"Gemforce integrates with several external services to provide a comprehensive platform. Understanding these integrations is crucial for effectively working with the Gemforce API.","title":"Conclusion"},{"location":"gemforce-integrator-guide/","text":"Gemforce Integrator Guide \u00b6 Table of Contents \u00b6 Integration Overview Authentication and Authorization REST API Integration Smart Contract Integration DFNS Wallet Integration Webhook Implementation Error Handling and Logging Sample Integration Code Common Integration Patterns Testing and Sandbox Security Considerations Compliance Integration","title":"Integrator Guide"},{"location":"gemforce-integrator-guide/#gemforce-integrator-guide","text":"","title":"Gemforce Integrator Guide"},{"location":"gemforce-integrator-guide/#table-of-contents","text":"Integration Overview Authentication and Authorization REST API Integration Smart Contract Integration DFNS Wallet Integration Webhook Implementation Error Handling and Logging Sample Integration Code Common Integration Patterns Testing and Sandbox Security Considerations Compliance Integration","title":"Table of Contents"},{"location":"gemforce-system-architecture/","text":"Gemforce System Architecture \u00b6 Overview \u00b6 Gemforce is a comprehensive blockchain-based platform that combines on-chain smart contracts with off-chain cloud services to provide a robust system for digital identity, asset management, and carbon credit tracking. This document provides a technical overview of the system's architecture and integration points. System Components \u00b6 Smart Contract Layer \u00b6 The smart contract layer is built on the Ethereum blockchain (with support for multiple networks) and uses the Diamond pattern (EIP-2535) for upgradeability. Key Components: \u00b6 Diamond Contract Central proxy contract that delegates calls to facet contracts Implements EIP-2535 for upgradeable contracts Supports multiple interfaces through facets Maintains common storage for all facets DiamondFactory Creates new Diamond contracts Manages facet sets for deployment Registers diamonds by symbol Identity System Identity Contract : Represents user identities IdentityFactory : Creates and manages identities IdentityRegistry : Maps addresses to identities ClaimTopicsRegistry : Manages claim topics TrustedIssuersRegistry : Manages authorized issuers Asset Management GemforceMinterFacet : Mints tokens with metadata MarketplaceFacet : Handles buying and selling Treasury : Manages funds and withdrawals CarbonCreditFacet : Handles carbon credit operations Cloud Service Layer \u00b6 The cloud service layer is built on Parse Server and provides API endpoints for interacting with the blockchain and managing user data. Key Components: \u00b6 Parse Server User authentication and management Data storage and retrieval Cloud functions for blockchain interaction Scheduled jobs for background tasks DFNS Integration Wallet management service Transaction signing Key management Recovery mechanisms Bridge API Integration External account management Transfer operations KYC/AML compliance Plaid integration for banking connections Blockchain Connection Service Provider management Contract deployment and interaction Network configuration Architecture Diagram \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Client Applications \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Parse Server API Layer \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Authentication \u2502 \u2502 Blockchain \u2502 \u2502 DFNS Wallet \u2502 \u2502 \u2502 \u2502 Functions \u2502 \u2502 Functions \u2502 \u2502 Functions \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Bridge API \u2502 \u2502 Contract \u2502 \u2502 Project \u2502 \u2502 \u2502 \u2502 Integration \u2502 \u2502 Interaction \u2502 \u2502 Management \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Blockchain Layer \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Diamond \u2502 \u2502 Identity \u2502 \u2502 Asset \u2502 \u2502 \u2502 \u2502 Contract \u2502\u25c4\u2500\u253c\u2500\u2524 System \u2502\u25c4\u2500\u253c\u2500\u2524 Management \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 DiamondFactory \u2502 \u2502 Marketplace \u2502 \u2502 Carbon Credits \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Integration Points \u00b6 Client Applications to Parse Server \u00b6 RESTful API endpoints Authentication via Parse Server DFNS wallet integration WebSocket connections for real-time updates Parse Server to Blockchain \u00b6 Contract Deployment : Deploys Diamond contracts, facets, and initializes systems Transaction Submission : Handles transaction creation, signing, and submission Event Monitoring : Listens for relevant blockchain events State Synchronization : Keeps off-chain database in sync with blockchain state Parse Server to External Services \u00b6 DFNS : API integration for wallet creation and management Bridge API : Integration for financial operations and compliance Plaid : Integration for banking connections Email Services : Notifications and verification Data Flow \u00b6 Identity Creation and Management \u00b6 User registers through Parse Server DFNS wallet is created for the user IdentityFactory creates a new Identity contract IdentityRegistry registers the Identity Claims can be added by trusted issuers Asset Management \u00b6 GemforceMinterFacet creates new tokens with metadata MarketplaceFacet handles buying and selling Treasury manages funds CarbonCreditFacet tracks and retires carbon credits Transaction Flow \u00b6 Client initiates transaction through Parse Server Parse Server creates transaction data DFNS handles transaction signing Transaction is submitted to the blockchain Events are monitored for transaction confirmation Client is notified of transaction status Security Considerations \u00b6 Smart Contract Security \u00b6 Diamond pattern for upgradeability Role-based access control Function-level permissions Reentrancy protection Cloud Service Security \u00b6 Authentication and authorization API key management Rate limiting Input validation Encrypted data storage Wallet Security (DFNS) \u00b6 Delegated transaction signing Multi-factor authentication Key recovery mechanisms Transaction approval flows Deployment Model \u00b6 Smart Contracts \u00b6 Multiple environments (development, staging, production) Network-specific deployments Facet management Upgrade paths Cloud Services \u00b6 Parse Server deployment Database configuration Cache layer API gateway Monitoring and logging Scalability Considerations \u00b6 Smart Contract Scalability \u00b6 Gas optimization State minimization L2 solutions when needed Batched operations Cloud Service Scalability \u00b6 Horizontal scaling of Parse Server Database sharding Load balancing Caching strategies Conclusion \u00b6 The Gemforce system leverages the Diamond pattern for upgradeable smart contracts, combined with a powerful cloud service layer, to create a flexible and robust platform for digital identity and asset management. The integration with DFNS provides secure wallet management, while the Bridge API integration enables financial operations and compliance.","title":"System Architecture"},{"location":"gemforce-system-architecture/#gemforce-system-architecture","text":"","title":"Gemforce System Architecture"},{"location":"gemforce-system-architecture/#overview","text":"Gemforce is a comprehensive blockchain-based platform that combines on-chain smart contracts with off-chain cloud services to provide a robust system for digital identity, asset management, and carbon credit tracking. This document provides a technical overview of the system's architecture and integration points.","title":"Overview"},{"location":"gemforce-system-architecture/#system-components","text":"","title":"System Components"},{"location":"gemforce-system-architecture/#smart-contract-layer","text":"The smart contract layer is built on the Ethereum blockchain (with support for multiple networks) and uses the Diamond pattern (EIP-2535) for upgradeability.","title":"Smart Contract Layer"},{"location":"gemforce-system-architecture/#key-components","text":"Diamond Contract Central proxy contract that delegates calls to facet contracts Implements EIP-2535 for upgradeable contracts Supports multiple interfaces through facets Maintains common storage for all facets DiamondFactory Creates new Diamond contracts Manages facet sets for deployment Registers diamonds by symbol Identity System Identity Contract : Represents user identities IdentityFactory : Creates and manages identities IdentityRegistry : Maps addresses to identities ClaimTopicsRegistry : Manages claim topics TrustedIssuersRegistry : Manages authorized issuers Asset Management GemforceMinterFacet : Mints tokens with metadata MarketplaceFacet : Handles buying and selling Treasury : Manages funds and withdrawals CarbonCreditFacet : Handles carbon credit operations","title":"Key Components:"},{"location":"gemforce-system-architecture/#cloud-service-layer","text":"The cloud service layer is built on Parse Server and provides API endpoints for interacting with the blockchain and managing user data.","title":"Cloud Service Layer"},{"location":"gemforce-system-architecture/#key-components_1","text":"Parse Server User authentication and management Data storage and retrieval Cloud functions for blockchain interaction Scheduled jobs for background tasks DFNS Integration Wallet management service Transaction signing Key management Recovery mechanisms Bridge API Integration External account management Transfer operations KYC/AML compliance Plaid integration for banking connections Blockchain Connection Service Provider management Contract deployment and interaction Network configuration","title":"Key Components:"},{"location":"gemforce-system-architecture/#architecture-diagram","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Client Applications \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Parse Server API Layer \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Authentication \u2502 \u2502 Blockchain \u2502 \u2502 DFNS Wallet \u2502 \u2502 \u2502 \u2502 Functions \u2502 \u2502 Functions \u2502 \u2502 Functions \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Bridge API \u2502 \u2502 Contract \u2502 \u2502 Project \u2502 \u2502 \u2502 \u2502 Integration \u2502 \u2502 Interaction \u2502 \u2502 Management \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Blockchain Layer \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Diamond \u2502 \u2502 Identity \u2502 \u2502 Asset \u2502 \u2502 \u2502 \u2502 Contract \u2502\u25c4\u2500\u253c\u2500\u2524 System \u2502\u25c4\u2500\u253c\u2500\u2524 Management \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 DiamondFactory \u2502 \u2502 Marketplace \u2502 \u2502 Carbon Credits \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Architecture Diagram"},{"location":"gemforce-system-architecture/#integration-points","text":"","title":"Integration Points"},{"location":"gemforce-system-architecture/#client-applications-to-parse-server","text":"RESTful API endpoints Authentication via Parse Server DFNS wallet integration WebSocket connections for real-time updates","title":"Client Applications to Parse Server"},{"location":"gemforce-system-architecture/#parse-server-to-blockchain","text":"Contract Deployment : Deploys Diamond contracts, facets, and initializes systems Transaction Submission : Handles transaction creation, signing, and submission Event Monitoring : Listens for relevant blockchain events State Synchronization : Keeps off-chain database in sync with blockchain state","title":"Parse Server to Blockchain"},{"location":"gemforce-system-architecture/#parse-server-to-external-services","text":"DFNS : API integration for wallet creation and management Bridge API : Integration for financial operations and compliance Plaid : Integration for banking connections Email Services : Notifications and verification","title":"Parse Server to External Services"},{"location":"gemforce-system-architecture/#data-flow","text":"","title":"Data Flow"},{"location":"gemforce-system-architecture/#identity-creation-and-management","text":"User registers through Parse Server DFNS wallet is created for the user IdentityFactory creates a new Identity contract IdentityRegistry registers the Identity Claims can be added by trusted issuers","title":"Identity Creation and Management"},{"location":"gemforce-system-architecture/#asset-management","text":"GemforceMinterFacet creates new tokens with metadata MarketplaceFacet handles buying and selling Treasury manages funds CarbonCreditFacet tracks and retires carbon credits","title":"Asset Management"},{"location":"gemforce-system-architecture/#transaction-flow","text":"Client initiates transaction through Parse Server Parse Server creates transaction data DFNS handles transaction signing Transaction is submitted to the blockchain Events are monitored for transaction confirmation Client is notified of transaction status","title":"Transaction Flow"},{"location":"gemforce-system-architecture/#security-considerations","text":"","title":"Security Considerations"},{"location":"gemforce-system-architecture/#smart-contract-security","text":"Diamond pattern for upgradeability Role-based access control Function-level permissions Reentrancy protection","title":"Smart Contract Security"},{"location":"gemforce-system-architecture/#cloud-service-security","text":"Authentication and authorization API key management Rate limiting Input validation Encrypted data storage","title":"Cloud Service Security"},{"location":"gemforce-system-architecture/#wallet-security-dfns","text":"Delegated transaction signing Multi-factor authentication Key recovery mechanisms Transaction approval flows","title":"Wallet Security (DFNS)"},{"location":"gemforce-system-architecture/#deployment-model","text":"","title":"Deployment Model"},{"location":"gemforce-system-architecture/#smart-contracts","text":"Multiple environments (development, staging, production) Network-specific deployments Facet management Upgrade paths","title":"Smart Contracts"},{"location":"gemforce-system-architecture/#cloud-services","text":"Parse Server deployment Database configuration Cache layer API gateway Monitoring and logging","title":"Cloud Services"},{"location":"gemforce-system-architecture/#scalability-considerations","text":"","title":"Scalability Considerations"},{"location":"gemforce-system-architecture/#smart-contract-scalability","text":"Gas optimization State minimization L2 solutions when needed Batched operations","title":"Smart Contract Scalability"},{"location":"gemforce-system-architecture/#cloud-service-scalability","text":"Horizontal scaling of Parse Server Database sharding Load balancing Caching strategies","title":"Cloud Service Scalability"},{"location":"gemforce-system-architecture/#conclusion","text":"The Gemforce system leverages the Diamond pattern for upgradeable smart contracts, combined with a powerful cloud service layer, to create a flexible and robust platform for digital identity and asset management. The integration with DFNS provides secure wallet management, while the Bridge API integration enables financial operations and compliance.","title":"Conclusion"}]}