{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gemforce Documentation \u00b6 Welcome to the official documentation for the Gemforce blockchain platform - a comprehensive solution for digital identity, asset management, and carbon credit tracking. About Gemforce \u00b6 Gemforce is a powerful blockchain-based platform that combines on-chain smart contracts with off-chain cloud services to provide: Digital Identity Management - Secure, verifiable digital identities with claims and attestations Asset Management - Creation, transfer, and management of digital assets Carbon Credit Tracking - Issuance, trading, and retirement of carbon credits Marketplace Functionality - Buy, sell, and trade digital assets securely The platform leverages the Diamond pattern (EIP-2535) for upgradeable smart contracts and integrates with DFNS for secure wallet management and the Bridge API for financial operations and compliance. Innovation Through Standards \u00b6 Gemforce has developed a comprehensive suite of Ethereum Improvement Proposals (EIPs) that standardize innovative blockchain patterns and interfaces. These EIPs represent cutting-edge solutions for: Diamond-Enhanced Marketplaces with configurable fee distribution Multi-Token Sales supporting ERC20, ERC721, and ERC1155 tokens Collateralized Trade Deals for invoice financing Enhanced Identity Systems with trusted issuer management Diamond Factory Patterns for standardized deployments Carbon Credit Standards for environmental asset tokenization These standards are designed to work together as an interconnected ecosystem, providing the foundation for next-generation decentralized applications. Documentation Overview \u00b6 This documentation is organized to serve different user roles: System Architecture \u00b6 System Architecture Technical overview of Gemforce's architecture, components, and integration points. Smart Contract Layer Cloud Service Layer Integration Points Security Considerations API Documentation \u00b6 Full API Reference Comprehensive documentation of all API endpoints, parameters, and responses. Quick Reference Concise guide to the most commonly used API endpoints and operations. EIPs (Ethereum Improvement Proposals) \u00b6 EIP Overview Comprehensive collection of Ethereum Improvement Proposals developed by the Gemforce team. Diamond-Enhanced Marketplace Multi-Token Sale Standard Collateralized Trade Deal Standard Enhanced Identity System Diamond Factory Standard Carbon Credit Standard User Guides \u00b6 Administrator Guide For system administrators managing and maintaining the Gemforce platform. Installation & Configuration User Management Monitoring & Alerts Security Management Deployer Guide For DevOps and technical teams deploying and updating Gemforce. Smart Contract Deployment Cloud Functions Deployment Upgrade Procedures Testing & Verification Integrator Guide For developers integrating external systems with Gemforce. Authentication & Authorization REST API Integration Smart Contract Integration Webhook Implementation Additional Resources \u00b6 External Services Documentation for third-party services integrated with Gemforce. DFNS Wallet Service Bridge API Plaid Integration Getting Started \u00b6 New to Gemforce? Here's how to get started: Read the System Architecture to understand the platform's components Explore the EIPs to understand the innovative standards and patterns Choose the appropriate guide based on your role: System administrators: Administrator Guide DevOps engineers: Deployer Guide Integration developers: Integrator Guide Explore the API Documentation for detailed endpoint information Support \u00b6 If you need assistance with the Gemforce platform, please contact: Technical Support : support@gemforce.io Documentation Issues : docs@gemforce.io General Inquiries : info@gemforce.io Gemforce Documentation \u00a9 2025 Gemforce Team. All rights reserved. .grid-container { display: flex; flex-wrap: wrap; gap: 20px; margin: 20px 0; } .grid-item { flex: 1 1 300px; border: 1px solid #e0e0e0; border-radius: 5px; padding: 15px; background-color: #f9f9f9; } .grid-item h4 { margin-top: 0; } .footer-note { margin-top: 40px; border-top: 1px solid #e0e0e0; padding-top: 10px; font-size: 0.9em; color: #666; }","title":"Home"},{"location":"#gemforce-documentation","text":"Welcome to the official documentation for the Gemforce blockchain platform - a comprehensive solution for digital identity, asset management, and carbon credit tracking.","title":"Gemforce Documentation"},{"location":"#about-gemforce","text":"Gemforce is a powerful blockchain-based platform that combines on-chain smart contracts with off-chain cloud services to provide: Digital Identity Management - Secure, verifiable digital identities with claims and attestations Asset Management - Creation, transfer, and management of digital assets Carbon Credit Tracking - Issuance, trading, and retirement of carbon credits Marketplace Functionality - Buy, sell, and trade digital assets securely The platform leverages the Diamond pattern (EIP-2535) for upgradeable smart contracts and integrates with DFNS for secure wallet management and the Bridge API for financial operations and compliance.","title":"About Gemforce"},{"location":"#innovation-through-standards","text":"Gemforce has developed a comprehensive suite of Ethereum Improvement Proposals (EIPs) that standardize innovative blockchain patterns and interfaces. These EIPs represent cutting-edge solutions for: Diamond-Enhanced Marketplaces with configurable fee distribution Multi-Token Sales supporting ERC20, ERC721, and ERC1155 tokens Collateralized Trade Deals for invoice financing Enhanced Identity Systems with trusted issuer management Diamond Factory Patterns for standardized deployments Carbon Credit Standards for environmental asset tokenization These standards are designed to work together as an interconnected ecosystem, providing the foundation for next-generation decentralized applications.","title":"Innovation Through Standards"},{"location":"#documentation-overview","text":"This documentation is organized to serve different user roles:","title":"Documentation Overview"},{"location":"#system-architecture","text":"","title":"System Architecture"},{"location":"#api-documentation","text":"","title":"API Documentation"},{"location":"#eips-ethereum-improvement-proposals","text":"","title":"EIPs (Ethereum Improvement Proposals)"},{"location":"#user-guides","text":"","title":"User Guides"},{"location":"#additional-resources","text":"","title":"Additional Resources"},{"location":"#getting-started","text":"New to Gemforce? Here's how to get started: Read the System Architecture to understand the platform's components Explore the EIPs to understand the innovative standards and patterns Choose the appropriate guide based on your role: System administrators: Administrator Guide DevOps engineers: Deployer Guide Integration developers: Integrator Guide Explore the API Documentation for detailed endpoint information","title":"Getting Started"},{"location":"#support","text":"If you need assistance with the Gemforce platform, please contact: Technical Support : support@gemforce.io Documentation Issues : docs@gemforce.io General Inquiries : info@gemforce.io Gemforce Documentation \u00a9 2025 Gemforce Team. All rights reserved. .grid-container { display: flex; flex-wrap: wrap; gap: 20px; margin: 20px 0; } .grid-item { flex: 1 1 300px; border: 1px solid #e0e0e0; border-radius: 5px; padding: 15px; background-color: #f9f9f9; } .grid-item h4 { margin-top: 0; } .footer-note { margin-top: 40px; border-top: 1px solid #e0e0e0; padding-top: 10px; font-size: 0.9em; color: #666; }","title":"Support"},{"location":"developer-setup-guide/","text":"Developer Setup Guide \u00b6 Overview \u00b6 This guide provides step-by-step instructions for setting up a complete Gemforce development environment. Follow these instructions to get the platform running locally for development, testing, and integration work. Prerequisites \u00b6 System Requirements \u00b6 Node.js : Version 18.x or higher npm : Version 8.x or higher (comes with Node.js) Git : Latest version MongoDB : Version 5.0 or higher (local or cloud) Operating System : macOS, Linux, or Windows with WSL2 Required Accounts \u00b6 Infura Account : For Ethereum network access MongoDB Atlas Account : For cloud database (optional) DFNS Account : For wallet services (optional for basic setup) Bridge API Account : For financial services (optional) Installation Steps \u00b6 1. Clone the Repository \u00b6 # Clone the main repository git clone https://github.com/your-org/gem-base.git cd gem-base # Install dependencies npm install 2. Environment Configuration \u00b6 Create environment configuration files: # Copy environment template cp .env.example .env # Edit environment variables nano .env Required Environment Variables \u00b6 # Parse Server Configuration APP_ID = your_unique_app_id MASTER_KEY = your_secure_master_key JAVASCRIPT_KEY = your_javascript_key SERVER_URL = https://localhost:8337/parse VERCEL_URL = https://localhost:8337/parse # Database Configuration MONGODB_URL = mongodb://localhost:27017/gemforce_dev MONGODB_EVENTSOURCE_URL = mongodb://localhost:27017/gemforce_indexer # Network Configuration NETWORK_HOST = 127 .0.0.1 NETWORK_PORT = 8337 HTTPS_ENABLED = true HTTPS_PORT = 443 # SSL Certificates (for HTTPS) KEY_FILE = ./privatekey.pem CERT_FILE = ./certificate.pem # Blockchain Network URLs ETH_NODE_URI_SEPOLIA = https://sepolia.infura.io/v3/YOUR_INFURA_KEY ETH_NODE_URI_BASESEP = https://base-sepolia.infura.io/v3/YOUR_INFURA_KEY ETH_NODE_URI_OPTSEP = https://optimism-sepolia.infura.io/v3/YOUR_INFURA_KEY # Dashboard Configuration DASHBOARD_PASSWORD = your_secure_password DASHBOARD_ALLOW_INSECURE_HTTP = true # External Services (Optional) DFNS_API_KEY = your_dfns_api_key BRIDGE_API_KEY = your_bridge_api_key SENDGRID_API_KEY = your_sendgrid_api_key PERSONA_WEBHOOK_SECRET = your_persona_webhook_secret 3. SSL Certificate Setup \u00b6 For HTTPS development (recommended): # Generate self-signed certificates openssl req -x509 -newkey rsa:4096 -keyout privatekey.pem -out certificate.pem -days 365 -nodes # Follow prompts, use 'localhost' as Common Name 4. Database Setup \u00b6 Option A: Local MongoDB \u00b6 # Install MongoDB (macOS with Homebrew) brew tap mongodb/brew brew install mongodb-community # Start MongoDB service brew services start mongodb-community # Create databases mongosh > use gemforce_dev > use gemforce_indexer > exit Option B: MongoDB Atlas (Cloud) \u00b6 Create account at MongoDB Atlas Create a new cluster Get connection string and update MONGODB_URL in .env 5. Blockchain Network Setup \u00b6 Local Hardhat Network \u00b6 # Start local blockchain (in separate terminal) npx hardhat node # This starts a local network on http://127.0.0.1:8545 # Network ID: 1337 Testnet Configuration \u00b6 Update your .env file with Infura endpoints: Create account at Infura Create new project Copy project ID and update environment variables 6. Smart Contract Deployment \u00b6 # Compile contracts npx hardhat compile # Deploy to local network npx hardhat run scripts/deploy.ts --network localhost # Deploy to testnet (example: Sepolia) npx hardhat run scripts/deploy.ts --network sepolia 7. Start the Development Server \u00b6 # Start the main server npm start # Or use the direct command npx hardhat run src/index.ts The server will start on: - HTTP : http://localhost:8337 - HTTPS : https://localhost:8337 (if SSL configured) - Parse Dashboard : https://localhost:8337/dashboard Development Workflow \u00b6 Project Structure \u00b6 gem-base/ \u251c\u2500\u2500 contracts/ # Smart contracts \u2502 \u251c\u2500\u2500 facets/ # Diamond facets \u2502 \u251c\u2500\u2500 interfaces/ # Contract interfaces \u2502 \u251c\u2500\u2500 libraries/ # Utility libraries \u2502 \u2514\u2500\u2500 tokens/ # Token contracts \u251c\u2500\u2500 src/ # TypeScript source code \u2502 \u251c\u2500\u2500 cloud-functions/ # Parse cloud functions \u2502 \u251c\u2500\u2500 lib/ # Utility libraries \u2502 \u251c\u2500\u2500 tasks/ # CLI tasks \u2502 \u2514\u2500\u2500 indexer/ # Event indexer \u251c\u2500\u2500 docs/ # Documentation \u251c\u2500\u2500 test/ # Test files \u251c\u2500\u2500 deploy/ # Deployment scripts \u2514\u2500\u2500 ui/ # Frontend components Common Development Tasks \u00b6 Running Tasks \u00b6 # List available tasks npx hardhat run src/tasks/index.ts # Run specific task npx hardhat run src/tasks/diamond.ts # Deploy diamond contract npx hardhat run src/tasks/deploy-diamond.ts --network localhost Testing \u00b6 # Run all tests npm test # Run specific test file npx hardhat test test/Diamond.test.js # Run tests with coverage npm run test:coverage Database Management \u00b6 # Clear database (development only) npx hardhat run src/tasks/clear-database.ts # Export schemas npx hardhat run src/tasks/export-all-schemas.ts # Import test data npx hardhat run src/tasks/import-test-data.ts IDE Configuration \u00b6 Visual Studio Code \u00b6 Recommended extensions: { \"recommendations\" : [ \"ms-vscode.vscode-typescript-next\" , \"esbenp.prettier-vscode\" , \"ms-vscode.vscode-eslint\" , \"juanblanco.solidity\" , \"nomicfoundation.hardhat-solidity\" ] } Settings ( .vscode/settings.json ): { \"typescript.preferences.importModuleSpecifier\" : \"relative\" , \"editor.formatOnSave\" : true , \"editor.defaultFormatter\" : \"esbenp.prettier-vscode\" , \"solidity.defaultCompiler\" : \"remote\" , \"solidity.compileUsingRemoteVersion\" : \"v0.8.19\" } Debugging Configuration \u00b6 Launch configuration ( .vscode/launch.json ): { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Debug Gemforce Server\" , \"type\" : \"node\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/node_modules/.bin/hardhat\" , \"args\" : [ \"run\" , \"src/index.ts\" ], \"console\" : \"integratedTerminal\" , \"env\" : { \"NODE_ENV\" : \"development\" } } ] } Troubleshooting \u00b6 Common Issues \u00b6 Port Already in Use \u00b6 # Find process using port 8337 lsof -i :8337 # Kill process kill -9 <PID> SSL Certificate Issues \u00b6 # Regenerate certificates rm privatekey.pem certificate.pem openssl req -x509 -newkey rsa:4096 -keyout privatekey.pem -out certificate.pem -days 365 -nodes MongoDB Connection Issues \u00b6 # Check MongoDB status brew services list | grep mongodb # Restart MongoDB brew services restart mongodb-community # Check connection mongosh --eval \"db.adminCommand('ismaster')\" Contract Compilation Errors \u00b6 # Clean and recompile npx hardhat clean npx hardhat compile # Check Solidity version compatibility npx hardhat --version Performance Issues \u00b6 Slow Database Queries \u00b6 // Add indexes to frequently queried fields db . YourCollection . createIndex ({ \"fieldName\" : 1 }) Memory Issues \u00b6 # Increase Node.js memory limit export NODE_OPTIONS = \"--max-old-space-size=4096\" npm start Testing Your Setup \u00b6 1. Verify Server Status \u00b6 # Check server health curl -k https://localhost:8337/parse/health # Expected response: {\"status\":\"ok\"} 2. Test Cloud Functions \u00b6 # Test blockchain function curl -X POST \\ -H \"X-Parse-Application-Id: your_app_id\" \\ -H \"X-Parse-Master-Key: your_master_key\" \\ -H \"Content-Type: application/json\" \\ -d '{}' \\ https://localhost:8337/parse/functions/loadAllBlockchains 3. Test Smart Contract Interaction \u00b6 // In Node.js console or test file const { ethers } = require ( \"ethers\" ); const provider = new ethers . providers . JsonRpcProvider ( \"http://127.0.0.1:8545\" ); const blockNumber = await provider . getBlockNumber (); console . log ( \"Current block:\" , blockNumber ); 4. Access Parse Dashboard \u00b6 Navigate to https://localhost:8337/dashboard Login with credentials from .env file Verify database connection and collections Next Steps \u00b6 After completing the setup: Read the Architecture Documentation : System Architecture Explore Smart Contracts : Smart Contract Documentation Review Cloud Functions : Cloud Functions API Check Integration Guides : Integrator Guide Development Best Practices \u00b6 Code Style \u00b6 Use TypeScript for all new code Follow ESLint configuration Use Prettier for code formatting Write comprehensive JSDoc comments Git Workflow \u00b6 # Create feature branch git checkout -b feature/your-feature-name # Make changes and commit git add . git commit -m \"feat: add new feature\" # Push and create pull request git push origin feature/your-feature-name Testing Strategy \u00b6 Write unit tests for all new functions Test smart contracts thoroughly Use integration tests for cloud functions Test with multiple blockchain networks Support \u00b6 If you encounter issues during setup: Check the Troubleshooting section Review the Documentation Gap Analysis Contact the development team Create an issue in the project repository This guide covers the essential setup for Gemforce development. For advanced configuration and deployment, refer to the Deployer Guide .","title":"Developer Setup Guide"},{"location":"developer-setup-guide/#developer-setup-guide","text":"","title":"Developer Setup Guide"},{"location":"developer-setup-guide/#overview","text":"This guide provides step-by-step instructions for setting up a complete Gemforce development environment. Follow these instructions to get the platform running locally for development, testing, and integration work.","title":"Overview"},{"location":"developer-setup-guide/#prerequisites","text":"","title":"Prerequisites"},{"location":"developer-setup-guide/#system-requirements","text":"Node.js : Version 18.x or higher npm : Version 8.x or higher (comes with Node.js) Git : Latest version MongoDB : Version 5.0 or higher (local or cloud) Operating System : macOS, Linux, or Windows with WSL2","title":"System Requirements"},{"location":"developer-setup-guide/#required-accounts","text":"Infura Account : For Ethereum network access MongoDB Atlas Account : For cloud database (optional) DFNS Account : For wallet services (optional for basic setup) Bridge API Account : For financial services (optional)","title":"Required Accounts"},{"location":"developer-setup-guide/#installation-steps","text":"","title":"Installation Steps"},{"location":"developer-setup-guide/#1-clone-the-repository","text":"# Clone the main repository git clone https://github.com/your-org/gem-base.git cd gem-base # Install dependencies npm install","title":"1. Clone the Repository"},{"location":"developer-setup-guide/#2-environment-configuration","text":"Create environment configuration files: # Copy environment template cp .env.example .env # Edit environment variables nano .env","title":"2. Environment Configuration"},{"location":"developer-setup-guide/#required-environment-variables","text":"# Parse Server Configuration APP_ID = your_unique_app_id MASTER_KEY = your_secure_master_key JAVASCRIPT_KEY = your_javascript_key SERVER_URL = https://localhost:8337/parse VERCEL_URL = https://localhost:8337/parse # Database Configuration MONGODB_URL = mongodb://localhost:27017/gemforce_dev MONGODB_EVENTSOURCE_URL = mongodb://localhost:27017/gemforce_indexer # Network Configuration NETWORK_HOST = 127 .0.0.1 NETWORK_PORT = 8337 HTTPS_ENABLED = true HTTPS_PORT = 443 # SSL Certificates (for HTTPS) KEY_FILE = ./privatekey.pem CERT_FILE = ./certificate.pem # Blockchain Network URLs ETH_NODE_URI_SEPOLIA = https://sepolia.infura.io/v3/YOUR_INFURA_KEY ETH_NODE_URI_BASESEP = https://base-sepolia.infura.io/v3/YOUR_INFURA_KEY ETH_NODE_URI_OPTSEP = https://optimism-sepolia.infura.io/v3/YOUR_INFURA_KEY # Dashboard Configuration DASHBOARD_PASSWORD = your_secure_password DASHBOARD_ALLOW_INSECURE_HTTP = true # External Services (Optional) DFNS_API_KEY = your_dfns_api_key BRIDGE_API_KEY = your_bridge_api_key SENDGRID_API_KEY = your_sendgrid_api_key PERSONA_WEBHOOK_SECRET = your_persona_webhook_secret","title":"Required Environment Variables"},{"location":"developer-setup-guide/#3-ssl-certificate-setup","text":"For HTTPS development (recommended): # Generate self-signed certificates openssl req -x509 -newkey rsa:4096 -keyout privatekey.pem -out certificate.pem -days 365 -nodes # Follow prompts, use 'localhost' as Common Name","title":"3. SSL Certificate Setup"},{"location":"developer-setup-guide/#4-database-setup","text":"","title":"4. Database Setup"},{"location":"developer-setup-guide/#option-a-local-mongodb","text":"# Install MongoDB (macOS with Homebrew) brew tap mongodb/brew brew install mongodb-community # Start MongoDB service brew services start mongodb-community # Create databases mongosh > use gemforce_dev > use gemforce_indexer > exit","title":"Option A: Local MongoDB"},{"location":"developer-setup-guide/#option-b-mongodb-atlas-cloud","text":"Create account at MongoDB Atlas Create a new cluster Get connection string and update MONGODB_URL in .env","title":"Option B: MongoDB Atlas (Cloud)"},{"location":"developer-setup-guide/#5-blockchain-network-setup","text":"","title":"5. Blockchain Network Setup"},{"location":"developer-setup-guide/#local-hardhat-network","text":"# Start local blockchain (in separate terminal) npx hardhat node # This starts a local network on http://127.0.0.1:8545 # Network ID: 1337","title":"Local Hardhat Network"},{"location":"developer-setup-guide/#testnet-configuration","text":"Update your .env file with Infura endpoints: Create account at Infura Create new project Copy project ID and update environment variables","title":"Testnet Configuration"},{"location":"developer-setup-guide/#6-smart-contract-deployment","text":"# Compile contracts npx hardhat compile # Deploy to local network npx hardhat run scripts/deploy.ts --network localhost # Deploy to testnet (example: Sepolia) npx hardhat run scripts/deploy.ts --network sepolia","title":"6. Smart Contract Deployment"},{"location":"developer-setup-guide/#7-start-the-development-server","text":"# Start the main server npm start # Or use the direct command npx hardhat run src/index.ts The server will start on: - HTTP : http://localhost:8337 - HTTPS : https://localhost:8337 (if SSL configured) - Parse Dashboard : https://localhost:8337/dashboard","title":"7. Start the Development Server"},{"location":"developer-setup-guide/#development-workflow","text":"","title":"Development Workflow"},{"location":"developer-setup-guide/#project-structure","text":"gem-base/ \u251c\u2500\u2500 contracts/ # Smart contracts \u2502 \u251c\u2500\u2500 facets/ # Diamond facets \u2502 \u251c\u2500\u2500 interfaces/ # Contract interfaces \u2502 \u251c\u2500\u2500 libraries/ # Utility libraries \u2502 \u2514\u2500\u2500 tokens/ # Token contracts \u251c\u2500\u2500 src/ # TypeScript source code \u2502 \u251c\u2500\u2500 cloud-functions/ # Parse cloud functions \u2502 \u251c\u2500\u2500 lib/ # Utility libraries \u2502 \u251c\u2500\u2500 tasks/ # CLI tasks \u2502 \u2514\u2500\u2500 indexer/ # Event indexer \u251c\u2500\u2500 docs/ # Documentation \u251c\u2500\u2500 test/ # Test files \u251c\u2500\u2500 deploy/ # Deployment scripts \u2514\u2500\u2500 ui/ # Frontend components","title":"Project Structure"},{"location":"developer-setup-guide/#common-development-tasks","text":"","title":"Common Development Tasks"},{"location":"developer-setup-guide/#running-tasks","text":"# List available tasks npx hardhat run src/tasks/index.ts # Run specific task npx hardhat run src/tasks/diamond.ts # Deploy diamond contract npx hardhat run src/tasks/deploy-diamond.ts --network localhost","title":"Running Tasks"},{"location":"developer-setup-guide/#testing","text":"# Run all tests npm test # Run specific test file npx hardhat test test/Diamond.test.js # Run tests with coverage npm run test:coverage","title":"Testing"},{"location":"developer-setup-guide/#database-management","text":"# Clear database (development only) npx hardhat run src/tasks/clear-database.ts # Export schemas npx hardhat run src/tasks/export-all-schemas.ts # Import test data npx hardhat run src/tasks/import-test-data.ts","title":"Database Management"},{"location":"developer-setup-guide/#ide-configuration","text":"","title":"IDE Configuration"},{"location":"developer-setup-guide/#visual-studio-code","text":"Recommended extensions: { \"recommendations\" : [ \"ms-vscode.vscode-typescript-next\" , \"esbenp.prettier-vscode\" , \"ms-vscode.vscode-eslint\" , \"juanblanco.solidity\" , \"nomicfoundation.hardhat-solidity\" ] } Settings ( .vscode/settings.json ): { \"typescript.preferences.importModuleSpecifier\" : \"relative\" , \"editor.formatOnSave\" : true , \"editor.defaultFormatter\" : \"esbenp.prettier-vscode\" , \"solidity.defaultCompiler\" : \"remote\" , \"solidity.compileUsingRemoteVersion\" : \"v0.8.19\" }","title":"Visual Studio Code"},{"location":"developer-setup-guide/#debugging-configuration","text":"Launch configuration ( .vscode/launch.json ): { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Debug Gemforce Server\" , \"type\" : \"node\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/node_modules/.bin/hardhat\" , \"args\" : [ \"run\" , \"src/index.ts\" ], \"console\" : \"integratedTerminal\" , \"env\" : { \"NODE_ENV\" : \"development\" } } ] }","title":"Debugging Configuration"},{"location":"developer-setup-guide/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"developer-setup-guide/#common-issues","text":"","title":"Common Issues"},{"location":"developer-setup-guide/#port-already-in-use","text":"# Find process using port 8337 lsof -i :8337 # Kill process kill -9 <PID>","title":"Port Already in Use"},{"location":"developer-setup-guide/#ssl-certificate-issues","text":"# Regenerate certificates rm privatekey.pem certificate.pem openssl req -x509 -newkey rsa:4096 -keyout privatekey.pem -out certificate.pem -days 365 -nodes","title":"SSL Certificate Issues"},{"location":"developer-setup-guide/#mongodb-connection-issues","text":"# Check MongoDB status brew services list | grep mongodb # Restart MongoDB brew services restart mongodb-community # Check connection mongosh --eval \"db.adminCommand('ismaster')\"","title":"MongoDB Connection Issues"},{"location":"developer-setup-guide/#contract-compilation-errors","text":"# Clean and recompile npx hardhat clean npx hardhat compile # Check Solidity version compatibility npx hardhat --version","title":"Contract Compilation Errors"},{"location":"developer-setup-guide/#performance-issues","text":"","title":"Performance Issues"},{"location":"developer-setup-guide/#slow-database-queries","text":"// Add indexes to frequently queried fields db . YourCollection . createIndex ({ \"fieldName\" : 1 })","title":"Slow Database Queries"},{"location":"developer-setup-guide/#memory-issues","text":"# Increase Node.js memory limit export NODE_OPTIONS = \"--max-old-space-size=4096\" npm start","title":"Memory Issues"},{"location":"developer-setup-guide/#testing-your-setup","text":"","title":"Testing Your Setup"},{"location":"developer-setup-guide/#1-verify-server-status","text":"# Check server health curl -k https://localhost:8337/parse/health # Expected response: {\"status\":\"ok\"}","title":"1. Verify Server Status"},{"location":"developer-setup-guide/#2-test-cloud-functions","text":"# Test blockchain function curl -X POST \\ -H \"X-Parse-Application-Id: your_app_id\" \\ -H \"X-Parse-Master-Key: your_master_key\" \\ -H \"Content-Type: application/json\" \\ -d '{}' \\ https://localhost:8337/parse/functions/loadAllBlockchains","title":"2. Test Cloud Functions"},{"location":"developer-setup-guide/#3-test-smart-contract-interaction","text":"// In Node.js console or test file const { ethers } = require ( \"ethers\" ); const provider = new ethers . providers . JsonRpcProvider ( \"http://127.0.0.1:8545\" ); const blockNumber = await provider . getBlockNumber (); console . log ( \"Current block:\" , blockNumber );","title":"3. Test Smart Contract Interaction"},{"location":"developer-setup-guide/#4-access-parse-dashboard","text":"Navigate to https://localhost:8337/dashboard Login with credentials from .env file Verify database connection and collections","title":"4. Access Parse Dashboard"},{"location":"developer-setup-guide/#next-steps","text":"After completing the setup: Read the Architecture Documentation : System Architecture Explore Smart Contracts : Smart Contract Documentation Review Cloud Functions : Cloud Functions API Check Integration Guides : Integrator Guide","title":"Next Steps"},{"location":"developer-setup-guide/#development-best-practices","text":"","title":"Development Best Practices"},{"location":"developer-setup-guide/#code-style","text":"Use TypeScript for all new code Follow ESLint configuration Use Prettier for code formatting Write comprehensive JSDoc comments","title":"Code Style"},{"location":"developer-setup-guide/#git-workflow","text":"# Create feature branch git checkout -b feature/your-feature-name # Make changes and commit git add . git commit -m \"feat: add new feature\" # Push and create pull request git push origin feature/your-feature-name","title":"Git Workflow"},{"location":"developer-setup-guide/#testing-strategy","text":"Write unit tests for all new functions Test smart contracts thoroughly Use integration tests for cloud functions Test with multiple blockchain networks","title":"Testing Strategy"},{"location":"developer-setup-guide/#support","text":"If you encounter issues during setup: Check the Troubleshooting section Review the Documentation Gap Analysis Contact the development team Create an issue in the project repository This guide covers the essential setup for Gemforce development. For advanced configuration and deployment, refer to the Deployer Guide .","title":"Support"},{"location":"documentation-plan/","text":"Gemforce Documentation Expansion Plan \u00b6 This plan outlines the additional documentation needed for the Gemforce system, focusing on administrator, deployer, and integrator perspectives. 1. Administrator's Guide \u00b6 Purpose: Provide system administrators with comprehensive instructions for managing, monitoring, and maintaining the Gemforce platform. Target audience: System administrators, operations teams, support staff Filename: gemforce-administrator-guide.md Content structure: System Overview \u00b6 Architecture recap (brief) Component relationships Infrastructure requirements Security model overview Installation and Configuration \u00b6 Prerequisites Environment variables Network settings Database configuration External service connections Security settings User Management \u00b6 User roles and permissions Adding/removing users Role assignment Identity verification processes Managing trusted issuers Monitoring and Alerts \u00b6 System health checks Performance metrics Log management Alert configuration Common warning signs Dashboards setup Backup and Recovery \u00b6 Backup procedures Database backups Configuration backups Recovery procedures Disaster recovery planning Security Management \u00b6 Access control API key rotation Audit logging Security incident response Compliance considerations Troubleshooting \u00b6 Common issues and solutions Diagnostic tools Error codes explanation Support escalation procedures Service dependencies Maintenance Procedures \u00b6 Routine maintenance tasks Update procedures Database optimization Cache management System scaling procedures Performance Optimization \u00b6 Database tuning Cache configuration Rate limiting configuration Resource allocation guidelines 2. Deployer's Guide \u00b6 Purpose: Provide technical teams with detailed instructions for deploying, updating, and managing the Gemforce system in various environments. Target audience: DevOps engineers, blockchain developers, backend developers Filename: gemforce-deployer-guide.md Content structure: Deployment Prerequisites \u00b6 Development environment setup Required tools and software Network access requirements Key management setup Environment preparation Smart Contract Deployment \u00b6 Contract compilation Diamond pattern deployment workflow Facet deployment process Contract initialization Contract verification Gas optimization strategies Cloud Functions Deployment \u00b6 Parse Server deployment Cloud function deployment Environment configuration Database migration WebSocket setup Environment Configuration \u00b6 Development environment Testing environment Staging environment Production environment Environment-specific settings Deployment Automation \u00b6 CI/CD pipeline setup Automated testing Deployment scripts Infrastructure as code Continuous monitoring Upgrade Procedures \u00b6 Smart contract upgrades Cloud function updates Database schema migrations Backward compatibility considerations Feature flagging Rollback Procedures \u00b6 Smart contract rollbacks Cloud function rollbacks Database rollbacks Emergency procedures Data integrity verification Testing and Verification \u00b6 Unit testing Integration testing Contract verification Load testing Security testing Network Management \u00b6 Blockchain node management RPC endpoint configuration Transaction monitoring Gas price management Network upgrades handling Version Control \u00b6 Repository structure Branching strategy Release management Tagging conventions Documentation versioning 3. Integrator's Guide \u00b6 Purpose: Provide third-party developers and partners with comprehensive guidance for integrating their systems with the Gemforce platform. Target audience: External developers, partners, system integrators Filename: gemforce-integrator-guide.md Content structure: Integration Overview \u00b6 System capabilities Integration options Authentication methods Typical integration flows Integration architecture patterns Authentication and Authorization \u00b6 OAuth2 implementation API key management JWT token handling Permission scopes Session management REST API Integration \u00b6 Endpoint documentation Request/response formats Rate limiting Pagination Filtering and sorting Versioning strategy Smart Contract Integration \u00b6 Contract ABIs Transaction construction Gas estimation Event listening Error handling DFNS Wallet Integration \u00b6 Authentication flow Wallet creation Transaction signing Error handling Security best practices Webhook Implementation \u00b6 Available webhooks Webhook configuration Payload format Retry mechanisms Webhook validation Error Handling and Logging \u00b6 Error codes Retry strategies Idempotency Logging best practices Debugging tools Sample Integration Code \u00b6 Authentication examples API call examples Webhook handling Event subscription Error handling Common Integration Patterns \u00b6 User onboarding flow Transaction processing Identity verification Asset management Carbon credit retirement Testing and Sandbox \u00b6 Sandbox environment access Test credentials Mocking responses Integration testing Load testing considerations Security Considerations \u00b6 TLS requirements API key security Input validation Output encoding Rate limiting IP restrictions Compliance Integration \u00b6 KYC/AML considerations Audit logging Compliance reporting Data privacy Regulatory requirements Timeline and Dependencies \u00b6 Phase 1: Research and Content Gathering \u00b6 Review existing documentation Identify missing information Interview stakeholders Collect code examples Document common workflows Phase 2: Content Creation \u00b6 Administrator's Guide (5-7 days) Deployer's Guide (5-7 days) Integrator's Guide (5-7 days) Phase 3: Review and Refinement \u00b6 Internal technical review Stakeholder review User testing Content refinement Phase 4: Publication and Distribution \u00b6 Format for multiple platforms Create PDF versions Add to documentation repository Announce to stakeholders Success Criteria \u00b6 The documentation will be considered successful if it: Enables administrators to confidently manage the Gemforce system Allows deployers to successfully deploy and update the system Helps integrators build reliable integrations with minimal support Reduces support tickets and questions related to common tasks Receives positive feedback from target audiences","title":"Documentation Plan"},{"location":"documentation-plan/#gemforce-documentation-expansion-plan","text":"This plan outlines the additional documentation needed for the Gemforce system, focusing on administrator, deployer, and integrator perspectives.","title":"Gemforce Documentation Expansion Plan"},{"location":"documentation-plan/#1-administrators-guide","text":"Purpose: Provide system administrators with comprehensive instructions for managing, monitoring, and maintaining the Gemforce platform. Target audience: System administrators, operations teams, support staff Filename: gemforce-administrator-guide.md Content structure:","title":"1. Administrator's Guide"},{"location":"documentation-plan/#system-overview","text":"Architecture recap (brief) Component relationships Infrastructure requirements Security model overview","title":"System Overview"},{"location":"documentation-plan/#installation-and-configuration","text":"Prerequisites Environment variables Network settings Database configuration External service connections Security settings","title":"Installation and Configuration"},{"location":"documentation-plan/#user-management","text":"User roles and permissions Adding/removing users Role assignment Identity verification processes Managing trusted issuers","title":"User Management"},{"location":"documentation-plan/#monitoring-and-alerts","text":"System health checks Performance metrics Log management Alert configuration Common warning signs Dashboards setup","title":"Monitoring and Alerts"},{"location":"documentation-plan/#backup-and-recovery","text":"Backup procedures Database backups Configuration backups Recovery procedures Disaster recovery planning","title":"Backup and Recovery"},{"location":"documentation-plan/#security-management","text":"Access control API key rotation Audit logging Security incident response Compliance considerations","title":"Security Management"},{"location":"documentation-plan/#troubleshooting","text":"Common issues and solutions Diagnostic tools Error codes explanation Support escalation procedures Service dependencies","title":"Troubleshooting"},{"location":"documentation-plan/#maintenance-procedures","text":"Routine maintenance tasks Update procedures Database optimization Cache management System scaling procedures","title":"Maintenance Procedures"},{"location":"documentation-plan/#performance-optimization","text":"Database tuning Cache configuration Rate limiting configuration Resource allocation guidelines","title":"Performance Optimization"},{"location":"documentation-plan/#2-deployers-guide","text":"Purpose: Provide technical teams with detailed instructions for deploying, updating, and managing the Gemforce system in various environments. Target audience: DevOps engineers, blockchain developers, backend developers Filename: gemforce-deployer-guide.md Content structure:","title":"2. Deployer's Guide"},{"location":"documentation-plan/#deployment-prerequisites","text":"Development environment setup Required tools and software Network access requirements Key management setup Environment preparation","title":"Deployment Prerequisites"},{"location":"documentation-plan/#smart-contract-deployment","text":"Contract compilation Diamond pattern deployment workflow Facet deployment process Contract initialization Contract verification Gas optimization strategies","title":"Smart Contract Deployment"},{"location":"documentation-plan/#cloud-functions-deployment","text":"Parse Server deployment Cloud function deployment Environment configuration Database migration WebSocket setup","title":"Cloud Functions Deployment"},{"location":"documentation-plan/#environment-configuration","text":"Development environment Testing environment Staging environment Production environment Environment-specific settings","title":"Environment Configuration"},{"location":"documentation-plan/#deployment-automation","text":"CI/CD pipeline setup Automated testing Deployment scripts Infrastructure as code Continuous monitoring","title":"Deployment Automation"},{"location":"documentation-plan/#upgrade-procedures","text":"Smart contract upgrades Cloud function updates Database schema migrations Backward compatibility considerations Feature flagging","title":"Upgrade Procedures"},{"location":"documentation-plan/#rollback-procedures","text":"Smart contract rollbacks Cloud function rollbacks Database rollbacks Emergency procedures Data integrity verification","title":"Rollback Procedures"},{"location":"documentation-plan/#testing-and-verification","text":"Unit testing Integration testing Contract verification Load testing Security testing","title":"Testing and Verification"},{"location":"documentation-plan/#network-management","text":"Blockchain node management RPC endpoint configuration Transaction monitoring Gas price management Network upgrades handling","title":"Network Management"},{"location":"documentation-plan/#version-control","text":"Repository structure Branching strategy Release management Tagging conventions Documentation versioning","title":"Version Control"},{"location":"documentation-plan/#3-integrators-guide","text":"Purpose: Provide third-party developers and partners with comprehensive guidance for integrating their systems with the Gemforce platform. Target audience: External developers, partners, system integrators Filename: gemforce-integrator-guide.md Content structure:","title":"3. Integrator's Guide"},{"location":"documentation-plan/#integration-overview","text":"System capabilities Integration options Authentication methods Typical integration flows Integration architecture patterns","title":"Integration Overview"},{"location":"documentation-plan/#authentication-and-authorization","text":"OAuth2 implementation API key management JWT token handling Permission scopes Session management","title":"Authentication and Authorization"},{"location":"documentation-plan/#rest-api-integration","text":"Endpoint documentation Request/response formats Rate limiting Pagination Filtering and sorting Versioning strategy","title":"REST API Integration"},{"location":"documentation-plan/#smart-contract-integration","text":"Contract ABIs Transaction construction Gas estimation Event listening Error handling","title":"Smart Contract Integration"},{"location":"documentation-plan/#dfns-wallet-integration","text":"Authentication flow Wallet creation Transaction signing Error handling Security best practices","title":"DFNS Wallet Integration"},{"location":"documentation-plan/#webhook-implementation","text":"Available webhooks Webhook configuration Payload format Retry mechanisms Webhook validation","title":"Webhook Implementation"},{"location":"documentation-plan/#error-handling-and-logging","text":"Error codes Retry strategies Idempotency Logging best practices Debugging tools","title":"Error Handling and Logging"},{"location":"documentation-plan/#sample-integration-code","text":"Authentication examples API call examples Webhook handling Event subscription Error handling","title":"Sample Integration Code"},{"location":"documentation-plan/#common-integration-patterns","text":"User onboarding flow Transaction processing Identity verification Asset management Carbon credit retirement","title":"Common Integration Patterns"},{"location":"documentation-plan/#testing-and-sandbox","text":"Sandbox environment access Test credentials Mocking responses Integration testing Load testing considerations","title":"Testing and Sandbox"},{"location":"documentation-plan/#security-considerations","text":"TLS requirements API key security Input validation Output encoding Rate limiting IP restrictions","title":"Security Considerations"},{"location":"documentation-plan/#compliance-integration","text":"KYC/AML considerations Audit logging Compliance reporting Data privacy Regulatory requirements","title":"Compliance Integration"},{"location":"documentation-plan/#timeline-and-dependencies","text":"","title":"Timeline and Dependencies"},{"location":"documentation-plan/#phase-1-research-and-content-gathering","text":"Review existing documentation Identify missing information Interview stakeholders Collect code examples Document common workflows","title":"Phase 1: Research and Content Gathering"},{"location":"documentation-plan/#phase-2-content-creation","text":"Administrator's Guide (5-7 days) Deployer's Guide (5-7 days) Integrator's Guide (5-7 days)","title":"Phase 2: Content Creation"},{"location":"documentation-plan/#phase-3-review-and-refinement","text":"Internal technical review Stakeholder review User testing Content refinement","title":"Phase 3: Review and Refinement"},{"location":"documentation-plan/#phase-4-publication-and-distribution","text":"Format for multiple platforms Create PDF versions Add to documentation repository Announce to stakeholders","title":"Phase 4: Publication and Distribution"},{"location":"documentation-plan/#success-criteria","text":"The documentation will be considered successful if it: Enables administrators to confidently manage the Gemforce system Allows deployers to successfully deploy and update the system Helps integrators build reliable integrations with minimal support Reduces support tickets and questions related to common tasks Receives positive feedback from target audiences","title":"Success Criteria"},{"location":"documentation-progress-summary/","text":"Documentation Progress Summary \u00b6 Overview \u00b6 This document summarizes the significant progress made in expanding the Gemforce documentation based on the comprehensive gap analysis. We have systematically addressed the highest priority documentation needs and established a solid foundation for continued documentation development. Completed Documentation \u00b6 \ud83c\udfaf High Priority Items Completed \u00b6 1. Smart Contract Documentation \u00b6 \u2705 Smart Contract Overview ( smart-contracts/index.md ) Comprehensive architecture overview Contract categorization and organization Integration patterns and security considerations \u2705 Diamond Contract Documentation ( smart-contracts/diamond.md ) Complete EIP-2535 implementation details Function-by-function documentation Integration examples and security considerations Gas optimization strategies \u2705 MarketplaceFacet Documentation ( smart-contracts/facets/marketplace-facet.md ) Comprehensive facet functionality Fee distribution system documentation Payment processing workflows Security and access control details \u2705 TradeDealManagementFacet Documentation ( smart-contracts/facets/trade-deal-management-facet.md ) Complete trade deal lifecycle management Collateralized finance instrument documentation Participant management and claim verification Invoice NFT integration and security features \u2705 CarbonCreditFacet Documentation ( smart-contracts/facets/carbon-credit-facet.md ) Environmental asset tokenization and management Carbon credit lifecycle and retirement system ERC721 integration for environmental NFTs Compliance and audit trail documentation \u2705 IdentityRegistryFacet Documentation ( smart-contracts/facets/identity-registry-facet.md ) Decentralized identity management system Claims-based verification and attestation Trusted issuer integration and access control Comprehensive identity lifecycle management \u2705 TrustedIssuersRegistryFacet Documentation ( smart-contracts/facets/trusted-issuers-registry-facet.md ) Trusted issuer authorization and management Granular claim topic permissions Registry operations and access control Integration with identity verification system 2. Cloud Functions API Documentation \u00b6 \u2705 Cloud Functions Overview ( cloud-functions/index.md ) Complete API architecture overview Authentication and security patterns Common usage patterns and best practices Error handling and performance considerations \u2705 Blockchain Functions ( cloud-functions/blockchain.md ) Network configuration management Provider and WebSocket URL handling Multi-network operation patterns Integration examples and error handling \u2705 DFNS Functions ( cloud-functions/dfns.md ) Wallet-as-a-Service integration Secure transaction signing and key management Multi-network wallet operations Authentication and security patterns \u2705 Contract Functions ( cloud-functions/contracts.md ) Smart contract interaction and deployment Diamond facet management operations Generic contract method calling Multi-network contract loading and configuration 3. Developer Resources \u00b6 \u2705 Developer Setup Guide ( developer-setup-guide.md ) Complete environment setup instructions Prerequisites and system requirements Step-by-step installation process Troubleshooting and best practices 4. EIP Documentation Enhancement \u00b6 \u2705 Enhanced EIP Overview ( eips/index.md ) Comprehensive EIP collection overview Ecosystem integration diagrams Implementation status and roadmap Developer and integrator guidance 5. Gap Analysis and Planning \u00b6 \u2705 Documentation Gap Analysis ( gemforce-documentation-gap-analysis.md ) Comprehensive analysis of 200+ missing documentation items Priority-based roadmap Resource requirements and timeline estimates Systematic categorization of gaps Documentation Statistics \u00b6 Created Documentation Files \u00b6 Total New Files : 12 major documentation files Smart Contract Docs : 7 files (overview + diamond + 5 facets) Cloud Function Docs : 4 files (overview + 3 function modules) Developer Resources : 1 comprehensive setup guide Analysis Documents : 1 gap analysis document Documentation Coverage Improvement \u00b6 Before : ~15% coverage (basic guides + EIPs) After : ~55% coverage (expanded with comprehensive technical docs) Improvement : +40% documentation coverage Lines of Documentation Added \u00b6 Total Lines : ~4,200+ lines of comprehensive documentation Smart Contracts : ~2,100 lines (overview + diamond + 5 facets) Cloud Functions : ~1,400 lines (overview + 3 modules) Developer Setup : ~360 lines Analysis : ~350 lines Architecture Improvements \u00b6 Navigation Structure Enhancement \u00b6 Updated MkDocs navigation to include: - Prominent Developer Setup Guide placement - Organized Smart Contract documentation section - Dedicated Cloud Functions section - Logical flow from setup \u2192 architecture \u2192 implementation Documentation Organization \u00b6 Hierarchical Structure : Clear categorization by function Cross-References : Extensive linking between related documents Code Examples : Practical implementation examples throughout Error Handling : Comprehensive error scenarios and solutions Quality Standards Established \u00b6 Documentation Standards \u00b6 Comprehensive Coverage : Each document covers overview, details, examples, and troubleshooting Code Examples : Real-world usage patterns and integration examples Security Focus : Security considerations in every technical document Error Handling : Detailed error conditions and resolution strategies Technical Accuracy \u00b6 Source Code Analysis : Documentation based on actual contract and function analysis Implementation Details : Accurate parameter descriptions and return values Integration Patterns : Tested and validated usage examples Immediate Impact \u00b6 Developer Experience \u00b6 Faster Onboarding : Comprehensive setup guide reduces setup time from days to hours Better Understanding : Detailed smart contract docs enable faster integration Reduced Support : Self-service documentation reduces support ticket volume Platform Adoption \u00b6 Lower Barrier to Entry : Clear documentation makes platform more accessible Professional Presentation : Comprehensive docs improve platform credibility Integration Confidence : Detailed examples give developers confidence to integrate Next Phase Priorities \u00b6 Immediate Next Steps (Next 2 Weeks) \u00b6 Based on the gap analysis, the following should be prioritized: 1. Additional Smart Contract Documentation \u00b6 \u2705 TradeDealManagementFacet - Critical business logic facet (COMPLETED) \u2705 CarbonCreditFacet - Environmental asset management (COMPLETED) \u2705 IdentityRegistryFacet - Identity system core (COMPLETED) \u2705 TrustedIssuersRegistryFacet - Identity issuer management (COMPLETED) Core Interfaces - IDiamond, IMarketplace, ITradeDeal Additional Facets - Remaining 15+ facets in the system 2. Additional Cloud Function Documentation \u00b6 \u2705 DFNS Functions - Wallet-as-a-Service integration (COMPLETED) \u2705 Contract Functions - Smart contract deployment and interaction (COMPLETED) Authentication Functions - User authentication and session management Bridge Functions - Financial services integration Project Functions - Project management operations 3. Integration Guides \u00b6 DFNS Integration Guide - Wallet service setup and usage Bridge API Integration Guide - Financial services integration Testing Guide - Comprehensive testing procedures Medium-Term Goals (Next 4 Weeks) \u00b6 Complete Facet Documentation - All 20+ facets documented Library Documentation - All utility libraries documented Task System Documentation - All 40+ task modules documented Security Documentation - Comprehensive security architecture Long-Term Goals (Next 8 Weeks) \u00b6 End-User Documentation - User guides and tutorials Business Process Documentation - Operational procedures Advanced Integration Patterns - Complex use cases Performance Optimization Guides - Advanced optimization techniques Resource Allocation Recommendations \u00b6 Documentation Team Structure \u00b6 Technical Writer Lead : 1 person to coordinate and maintain standards Smart Contract Specialist : 1 person focused on contract documentation API Documentation Specialist : 1 person for cloud functions and APIs Developer SMEs : 2-3 developers for technical review and validation Tools and Process \u00b6 Documentation Platform : MkDocs working well, continue with current setup Review Process : Establish technical review workflow for accuracy Update Process : Regular updates as code evolves Quality Assurance : Regular audits of documentation accuracy Success Metrics \u00b6 Quantitative Metrics \u00b6 Documentation Coverage : Target 80% by end of Phase 2 Developer Setup Time : Reduce from 2-3 days to 4-6 hours Support Ticket Reduction : Target 40% reduction in setup-related tickets Integration Time : Reduce average integration time by 50% Qualitative Metrics \u00b6 Developer Feedback : Regular surveys on documentation quality Platform Adoption : Track new developer onboarding success Community Engagement : Monitor documentation usage and feedback Lessons Learned \u00b6 What Worked Well \u00b6 Gap Analysis First : Starting with comprehensive analysis provided clear roadmap Priority-Based Approach : Focusing on high-impact items first maximized value Real Code Analysis : Basing documentation on actual code ensured accuracy Comprehensive Examples : Including practical examples improved usability Areas for Improvement \u00b6 Automated Documentation : Consider tools for auto-generating API docs from code Version Control : Establish process for keeping docs in sync with code changes Community Contribution : Create process for community documentation contributions Conclusion \u00b6 The documentation expansion effort has successfully addressed the most critical gaps identified in the analysis. We have: Established Foundation : Created comprehensive documentation structure and standards Addressed High-Priority Gaps : Completed developer setup, core smart contracts, and essential cloud functions Improved Developer Experience : Significantly reduced barriers to platform adoption Created Roadmap : Established clear path for continued documentation development Achieved Major Milestone : Completed 5 critical smart contract facets and 3 cloud function modules The platform now has robust documentation covering the core functionality that supports developer onboarding, integration, and ongoing development. The systematic approach and quality standards established provide a proven template for completing the remaining documentation gaps. Next Actions \u00b6 Continue with Phase 2 : Begin documenting additional facets and cloud functions Establish Review Process : Implement technical review workflow Monitor Usage : Track documentation usage and gather developer feedback Iterate and Improve : Continuously improve based on user feedback and needs This summary represents significant progress toward comprehensive Gemforce platform documentation. The foundation is now in place for rapid completion of the remaining documentation gaps. Total Progress : 55% complete (up from 15%) Estimated Time to 80% Complete : 8-12 weeks with dedicated team Immediate Value : Dramatically improved developer onboarding and platform accessibility Recent Session Achievements \u00b6 5 Smart Contract Facets Documented : TradeDealManagement, CarbonCredit, IdentityRegistry, TrustedIssuersRegistry 3 Cloud Function Modules Documented : DFNS, Contracts Navigation Structure Enhanced : Complete integration of new documentation Documentation Quality Maintained : Consistent high-quality standards across all new docs","title":"Documentation Progress Summary"},{"location":"documentation-progress-summary/#documentation-progress-summary","text":"","title":"Documentation Progress Summary"},{"location":"documentation-progress-summary/#overview","text":"This document summarizes the significant progress made in expanding the Gemforce documentation based on the comprehensive gap analysis. We have systematically addressed the highest priority documentation needs and established a solid foundation for continued documentation development.","title":"Overview"},{"location":"documentation-progress-summary/#completed-documentation","text":"","title":"Completed Documentation"},{"location":"documentation-progress-summary/#high-priority-items-completed","text":"","title":"\ud83c\udfaf High Priority Items Completed"},{"location":"documentation-progress-summary/#1-smart-contract-documentation","text":"\u2705 Smart Contract Overview ( smart-contracts/index.md ) Comprehensive architecture overview Contract categorization and organization Integration patterns and security considerations \u2705 Diamond Contract Documentation ( smart-contracts/diamond.md ) Complete EIP-2535 implementation details Function-by-function documentation Integration examples and security considerations Gas optimization strategies \u2705 MarketplaceFacet Documentation ( smart-contracts/facets/marketplace-facet.md ) Comprehensive facet functionality Fee distribution system documentation Payment processing workflows Security and access control details \u2705 TradeDealManagementFacet Documentation ( smart-contracts/facets/trade-deal-management-facet.md ) Complete trade deal lifecycle management Collateralized finance instrument documentation Participant management and claim verification Invoice NFT integration and security features \u2705 CarbonCreditFacet Documentation ( smart-contracts/facets/carbon-credit-facet.md ) Environmental asset tokenization and management Carbon credit lifecycle and retirement system ERC721 integration for environmental NFTs Compliance and audit trail documentation \u2705 IdentityRegistryFacet Documentation ( smart-contracts/facets/identity-registry-facet.md ) Decentralized identity management system Claims-based verification and attestation Trusted issuer integration and access control Comprehensive identity lifecycle management \u2705 TrustedIssuersRegistryFacet Documentation ( smart-contracts/facets/trusted-issuers-registry-facet.md ) Trusted issuer authorization and management Granular claim topic permissions Registry operations and access control Integration with identity verification system","title":"1. Smart Contract Documentation"},{"location":"documentation-progress-summary/#2-cloud-functions-api-documentation","text":"\u2705 Cloud Functions Overview ( cloud-functions/index.md ) Complete API architecture overview Authentication and security patterns Common usage patterns and best practices Error handling and performance considerations \u2705 Blockchain Functions ( cloud-functions/blockchain.md ) Network configuration management Provider and WebSocket URL handling Multi-network operation patterns Integration examples and error handling \u2705 DFNS Functions ( cloud-functions/dfns.md ) Wallet-as-a-Service integration Secure transaction signing and key management Multi-network wallet operations Authentication and security patterns \u2705 Contract Functions ( cloud-functions/contracts.md ) Smart contract interaction and deployment Diamond facet management operations Generic contract method calling Multi-network contract loading and configuration","title":"2. Cloud Functions API Documentation"},{"location":"documentation-progress-summary/#3-developer-resources","text":"\u2705 Developer Setup Guide ( developer-setup-guide.md ) Complete environment setup instructions Prerequisites and system requirements Step-by-step installation process Troubleshooting and best practices","title":"3. Developer Resources"},{"location":"documentation-progress-summary/#4-eip-documentation-enhancement","text":"\u2705 Enhanced EIP Overview ( eips/index.md ) Comprehensive EIP collection overview Ecosystem integration diagrams Implementation status and roadmap Developer and integrator guidance","title":"4. EIP Documentation Enhancement"},{"location":"documentation-progress-summary/#5-gap-analysis-and-planning","text":"\u2705 Documentation Gap Analysis ( gemforce-documentation-gap-analysis.md ) Comprehensive analysis of 200+ missing documentation items Priority-based roadmap Resource requirements and timeline estimates Systematic categorization of gaps","title":"5. Gap Analysis and Planning"},{"location":"documentation-progress-summary/#documentation-statistics","text":"","title":"Documentation Statistics"},{"location":"documentation-progress-summary/#created-documentation-files","text":"Total New Files : 12 major documentation files Smart Contract Docs : 7 files (overview + diamond + 5 facets) Cloud Function Docs : 4 files (overview + 3 function modules) Developer Resources : 1 comprehensive setup guide Analysis Documents : 1 gap analysis document","title":"Created Documentation Files"},{"location":"documentation-progress-summary/#documentation-coverage-improvement","text":"Before : ~15% coverage (basic guides + EIPs) After : ~55% coverage (expanded with comprehensive technical docs) Improvement : +40% documentation coverage","title":"Documentation Coverage Improvement"},{"location":"documentation-progress-summary/#lines-of-documentation-added","text":"Total Lines : ~4,200+ lines of comprehensive documentation Smart Contracts : ~2,100 lines (overview + diamond + 5 facets) Cloud Functions : ~1,400 lines (overview + 3 modules) Developer Setup : ~360 lines Analysis : ~350 lines","title":"Lines of Documentation Added"},{"location":"documentation-progress-summary/#architecture-improvements","text":"","title":"Architecture Improvements"},{"location":"documentation-progress-summary/#navigation-structure-enhancement","text":"Updated MkDocs navigation to include: - Prominent Developer Setup Guide placement - Organized Smart Contract documentation section - Dedicated Cloud Functions section - Logical flow from setup \u2192 architecture \u2192 implementation","title":"Navigation Structure Enhancement"},{"location":"documentation-progress-summary/#documentation-organization","text":"Hierarchical Structure : Clear categorization by function Cross-References : Extensive linking between related documents Code Examples : Practical implementation examples throughout Error Handling : Comprehensive error scenarios and solutions","title":"Documentation Organization"},{"location":"documentation-progress-summary/#quality-standards-established","text":"","title":"Quality Standards Established"},{"location":"documentation-progress-summary/#documentation-standards","text":"Comprehensive Coverage : Each document covers overview, details, examples, and troubleshooting Code Examples : Real-world usage patterns and integration examples Security Focus : Security considerations in every technical document Error Handling : Detailed error conditions and resolution strategies","title":"Documentation Standards"},{"location":"documentation-progress-summary/#technical-accuracy","text":"Source Code Analysis : Documentation based on actual contract and function analysis Implementation Details : Accurate parameter descriptions and return values Integration Patterns : Tested and validated usage examples","title":"Technical Accuracy"},{"location":"documentation-progress-summary/#immediate-impact","text":"","title":"Immediate Impact"},{"location":"documentation-progress-summary/#developer-experience","text":"Faster Onboarding : Comprehensive setup guide reduces setup time from days to hours Better Understanding : Detailed smart contract docs enable faster integration Reduced Support : Self-service documentation reduces support ticket volume","title":"Developer Experience"},{"location":"documentation-progress-summary/#platform-adoption","text":"Lower Barrier to Entry : Clear documentation makes platform more accessible Professional Presentation : Comprehensive docs improve platform credibility Integration Confidence : Detailed examples give developers confidence to integrate","title":"Platform Adoption"},{"location":"documentation-progress-summary/#next-phase-priorities","text":"","title":"Next Phase Priorities"},{"location":"documentation-progress-summary/#immediate-next-steps-next-2-weeks","text":"Based on the gap analysis, the following should be prioritized:","title":"Immediate Next Steps (Next 2 Weeks)"},{"location":"documentation-progress-summary/#1-additional-smart-contract-documentation","text":"\u2705 TradeDealManagementFacet - Critical business logic facet (COMPLETED) \u2705 CarbonCreditFacet - Environmental asset management (COMPLETED) \u2705 IdentityRegistryFacet - Identity system core (COMPLETED) \u2705 TrustedIssuersRegistryFacet - Identity issuer management (COMPLETED) Core Interfaces - IDiamond, IMarketplace, ITradeDeal Additional Facets - Remaining 15+ facets in the system","title":"1. Additional Smart Contract Documentation"},{"location":"documentation-progress-summary/#2-additional-cloud-function-documentation","text":"\u2705 DFNS Functions - Wallet-as-a-Service integration (COMPLETED) \u2705 Contract Functions - Smart contract deployment and interaction (COMPLETED) Authentication Functions - User authentication and session management Bridge Functions - Financial services integration Project Functions - Project management operations","title":"2. Additional Cloud Function Documentation"},{"location":"documentation-progress-summary/#3-integration-guides","text":"DFNS Integration Guide - Wallet service setup and usage Bridge API Integration Guide - Financial services integration Testing Guide - Comprehensive testing procedures","title":"3. Integration Guides"},{"location":"documentation-progress-summary/#medium-term-goals-next-4-weeks","text":"Complete Facet Documentation - All 20+ facets documented Library Documentation - All utility libraries documented Task System Documentation - All 40+ task modules documented Security Documentation - Comprehensive security architecture","title":"Medium-Term Goals (Next 4 Weeks)"},{"location":"documentation-progress-summary/#long-term-goals-next-8-weeks","text":"End-User Documentation - User guides and tutorials Business Process Documentation - Operational procedures Advanced Integration Patterns - Complex use cases Performance Optimization Guides - Advanced optimization techniques","title":"Long-Term Goals (Next 8 Weeks)"},{"location":"documentation-progress-summary/#resource-allocation-recommendations","text":"","title":"Resource Allocation Recommendations"},{"location":"documentation-progress-summary/#documentation-team-structure","text":"Technical Writer Lead : 1 person to coordinate and maintain standards Smart Contract Specialist : 1 person focused on contract documentation API Documentation Specialist : 1 person for cloud functions and APIs Developer SMEs : 2-3 developers for technical review and validation","title":"Documentation Team Structure"},{"location":"documentation-progress-summary/#tools-and-process","text":"Documentation Platform : MkDocs working well, continue with current setup Review Process : Establish technical review workflow for accuracy Update Process : Regular updates as code evolves Quality Assurance : Regular audits of documentation accuracy","title":"Tools and Process"},{"location":"documentation-progress-summary/#success-metrics","text":"","title":"Success Metrics"},{"location":"documentation-progress-summary/#quantitative-metrics","text":"Documentation Coverage : Target 80% by end of Phase 2 Developer Setup Time : Reduce from 2-3 days to 4-6 hours Support Ticket Reduction : Target 40% reduction in setup-related tickets Integration Time : Reduce average integration time by 50%","title":"Quantitative Metrics"},{"location":"documentation-progress-summary/#qualitative-metrics","text":"Developer Feedback : Regular surveys on documentation quality Platform Adoption : Track new developer onboarding success Community Engagement : Monitor documentation usage and feedback","title":"Qualitative Metrics"},{"location":"documentation-progress-summary/#lessons-learned","text":"","title":"Lessons Learned"},{"location":"documentation-progress-summary/#what-worked-well","text":"Gap Analysis First : Starting with comprehensive analysis provided clear roadmap Priority-Based Approach : Focusing on high-impact items first maximized value Real Code Analysis : Basing documentation on actual code ensured accuracy Comprehensive Examples : Including practical examples improved usability","title":"What Worked Well"},{"location":"documentation-progress-summary/#areas-for-improvement","text":"Automated Documentation : Consider tools for auto-generating API docs from code Version Control : Establish process for keeping docs in sync with code changes Community Contribution : Create process for community documentation contributions","title":"Areas for Improvement"},{"location":"documentation-progress-summary/#conclusion","text":"The documentation expansion effort has successfully addressed the most critical gaps identified in the analysis. We have: Established Foundation : Created comprehensive documentation structure and standards Addressed High-Priority Gaps : Completed developer setup, core smart contracts, and essential cloud functions Improved Developer Experience : Significantly reduced barriers to platform adoption Created Roadmap : Established clear path for continued documentation development Achieved Major Milestone : Completed 5 critical smart contract facets and 3 cloud function modules The platform now has robust documentation covering the core functionality that supports developer onboarding, integration, and ongoing development. The systematic approach and quality standards established provide a proven template for completing the remaining documentation gaps.","title":"Conclusion"},{"location":"documentation-progress-summary/#next-actions","text":"Continue with Phase 2 : Begin documenting additional facets and cloud functions Establish Review Process : Implement technical review workflow Monitor Usage : Track documentation usage and gather developer feedback Iterate and Improve : Continuously improve based on user feedback and needs This summary represents significant progress toward comprehensive Gemforce platform documentation. The foundation is now in place for rapid completion of the remaining documentation gaps. Total Progress : 55% complete (up from 15%) Estimated Time to 80% Complete : 8-12 weeks with dedicated team Immediate Value : Dramatically improved developer onboarding and platform accessibility","title":"Next Actions"},{"location":"documentation-progress-summary/#recent-session-achievements","text":"5 Smart Contract Facets Documented : TradeDealManagement, CarbonCredit, IdentityRegistry, TrustedIssuersRegistry 3 Cloud Function Modules Documented : DFNS, Contracts Navigation Structure Enhanced : Complete integration of new documentation Documentation Quality Maintained : Consistent high-quality standards across all new docs","title":"Recent Session Achievements"},{"location":"gemforce-administrator-guide/","text":"Gemforce Administrator Guide \u00b6 Table of Contents \u00b6 System Overview Installation and Configuration User Management Monitoring and Alerts Backup and Recovery Security Management Troubleshooting Maintenance Procedures Performance Optimization System Overview \u00b6 Architecture Components \u00b6 The Gemforce platform consists of the following major components: Blockchain Smart Contracts Diamond contracts (EIP-2535 implementation) Identity management contracts Token management contracts Carbon credit contracts Cloud Services Parse Server backend Database (MongoDB) File storage Cloud functions External Service Integrations DFNS wallet-as-a-service Bridge API SendGrid email service Blockchain RPC providers Client Applications Web applications Mobile applications API integrations Component Relationships \u00b6 The Gemforce system follows a layered architecture: Client Applications \u2193\u2191 Cloud Services (Parse Server) \u2193\u2191 External Services \u27f7 Blockchain Contracts Client applications interact with the Parse Server via REST API Parse Server executes cloud functions that interact with blockchain contracts and external services External services provide specialized functionality (wallet management, financial operations, etc.) Blockchain contracts store and manage on-chain data and logic Infrastructure Requirements \u00b6 Blockchain Nodes : Access to Ethereum-compatible blockchain nodes Server Hardware : Minimum: 4 CPU cores, 8GB RAM, 100GB SSD Recommended: 8 CPU cores, 16GB RAM, 250GB SSD Database : MongoDB 4.4+ Network : Reliable internet connection with low latency to blockchain nodes SSL Certificate : Valid SSL certificate for secure API access Security Model Overview \u00b6 Gemforce implements a multi-layered security approach: Authentication and Authorization User authentication via Parse Server Role-based access control API key authentication for B2B integrations DFNS WebAuthn for wallet operations Smart Contract Security Role-based access control Function-level permissions Upgradeability via Diamond pattern Data Protection Encrypted data at rest TLS for data in transit Private key management via DFNS Monitoring and Auditing Comprehensive logging Activity tracking Alert systems Installation and Configuration \u00b6 Prerequisites \u00b6 Before installing Gemforce, ensure you have: Node.js 16.x or higher MongoDB 4.4 or higher Access to blockchain nodes (RPC endpoints) API keys for external services Domain name with SSL certificate Git access to the Gemforce repositories Environment Variables \u00b6 The Gemforce system requires several environment variables to be set. Create a .env file with the following variables: # Parse Server Configuration APP_ID=your_app_id MASTER_KEY=your_master_key DATABASE_URI=mongodb://username:password@host:port/database SERVER_URL=https://your-server-url.com/parse PROJECT_WIZARD_URL=https://your-server-url.com # Blockchain Configuration ETH_NODE_URI_MAINNET=https://mainnet.infura.io/v3/your-key ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=base-sepolia METADATA_BASE_URI=https://your-metadata-url.com/ # DFNS Configuration DFNS_APP_ID=your_dfns_app_id DFNS_API_URL=https://api.dfns.io DFNS_CRED_ID=your_dfns_credential_id DFNS_AUTH_TOKEN=your_dfns_auth_token # Bridge API Configuration BASE_BRIDGE_URL=https://api.bridge-api.com BRIDGE_API_KEY=your_bridge_api_key # Email Configuration SENDGRID_API_KEY=your_sendgrid_key FROM_EMAIL=noreply@your-domain.com # Security Configuration AUTH_SECRET_KEY=your_auth_secret_key Network Settings \u00b6 Firewall Configuration : Allow inbound connections on ports 80 (HTTP), 443 (HTTPS), and your Parse Server port Allow outbound connections to MongoDB, blockchain nodes, and external APIs Load Balancer Configuration (if applicable): Configure health checks to the Parse Server health endpoint Set appropriate timeouts (at least 30 seconds for blockchain operations) Enable SSL termination DNS Configuration : Set up A records for your domain Configure CNAME records for subdomains if needed Database Configuration \u00b6 MongoDB Setup : bash # Create a MongoDB user for the Gemforce database mongo admin -u admin -p admin use gemforce db.createUser({ user: \"gemforce_user\", pwd: \"secure_password\", roles: [{ role: \"readWrite\", db: \"gemforce\" }] }) Indexes : Ensure the following indexes are created for optimal performance: ```javascript // User collection indexes db.User.createIndex({ email: 1 }, { unique: true }) db.User.createIndex({ username: 1 }, { unique: true }) db.User.createIndex({ walletAddress: 1 }) // Identity collection indexes db.Identity.createIndex({ walletAddress: 1 }, { unique: true }) // Transaction collection indexes db.Transaction.createIndex({ hash: 1 }, { unique: true }) db.Transaction.createIndex({ user: 1 }) db.Transaction.createIndex({ createdAt: 1 }) ``` External Service Connections \u00b6 DFNS Setup : Create a DFNS account at https://dashboard.dfns.io Create an application and credential Copy the App ID and Credential ID to your environment variables Store the private key in dfns_private.key Bridge API Setup : Obtain API credentials from Bridge API Configure webhooks for notifications (if needed) Set rate limiting based on expected traffic SendGrid Setup : Create a SendGrid account Set up sender authentication for your domain Create email templates for verification, password reset, etc. Generate API key and add to environment variables Security Settings \u00b6 API Key Management : Rotate API keys periodically (recommended every 90 days) Store API keys securely using environment variables Never expose API keys in client-side code Cross-Origin Resource Sharing (CORS) : Configure CORS settings in the Parse Server configuration: javascript const corsConfig = { allowOrigin: ['https://your-domain.com', 'https://app.your-domain.com'], allowHeaders: ['X-Parse-Application-Id', 'X-Parse-REST-API-Key', 'Content-Type'], allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'] }; Rate Limiting : Configure rate limiting to prevent abuse: javascript const rateLimitConfig = { rateLimit: 1000, // requests per minute burstLimit: 50, // concurrent requests expiration: 60 // seconds until reset }; User Management \u00b6 User Roles and Permissions \u00b6 Gemforce implements role-based access control with the following default roles: Admin : Full access to all functions Can manage users and roles Can deploy and update contracts CentralAuthority : Can manage trusted issuers Can add claim topics Can manage identities TrustedIssuer : Can issue claims to identities Can verify identities Limited access to identity management User : Can manage own wallet Can view own transactions Can participate in marketplace Adding and Removing Users \u00b6 Adding Users \u00b6 Via Admin Dashboard : Navigate to User Management Click \"Add User\" Enter user details (email, name, role) System will send invitation email Via API : ```javascript // Example using Parse JavaScript SDK const user = new Parse.User(); user.set(\"username\", \"user@example.com\"); user.set(\"password\", \"securePassword\"); user.set(\"email\", \"user@example.com\"); user.set(\"firstName\", \"John\"); user.set(\"lastName\", \"Doe\"); await user.signUp(); ``` Via Cloud Function : javascript // Using the registerUser cloud function Parse.Cloud.run(\"registerUser\", { username: \"user@example.com\", password: \"securePassword\", email: \"user@example.com\", firstName: \"John\", lastName: \"Doe\", company: \"Example Inc\" }); Removing Users \u00b6 Via Admin Dashboard : Navigate to User Management Select user(s) to remove Click \"Delete\" or \"Deactivate\" Via API : javascript // Example using Parse JavaScript SDK const query = new Parse.Query(Parse.User); query.equalTo(\"email\", \"user@example.com\"); const user = await query.first({ useMasterKey: true }); await user.destroy({ useMasterKey: true }); Role Assignment \u00b6 Assigning Roles to Users : ```javascript // Example using Parse JavaScript SDK const userQuery = new Parse.Query(Parse.User); userQuery.equalTo(\"email\", \"user@example.com\"); const user = await userQuery.first({ useMasterKey: true }); const roleQuery = new Parse.Query(Parse.Role); roleQuery.equalTo(\"name\", \"TrustedIssuer\"); const role = await roleQuery.first({ useMasterKey: true }); role.getUsers().add(user); await role.save(null, { useMasterKey: true }); ``` Creating New Roles : ```javascript // Example using Parse JavaScript SDK const acl = new Parse.ACL(); acl.setPublicReadAccess(true); const role = new Parse.Role(\"CustomRole\", acl); await role.save(null, { useMasterKey: true }); ``` Identity Verification Processes \u00b6 KYC Verification : Initiate via generateKycLink cloud function User completes KYC via Bridge API Webhook notification sent back to Gemforce Identity status updated accordingly Trusted Issuer Verification : Trusted Issuer reviews identity information Issues verification claim to user identity Claim is written to blockchain Identity state is updated to \"verified\" Managing Trusted Issuers \u00b6 Adding a Trusted Issuer : ```javascript // Using the dfnsAddTrustedIssuerInit/Complete cloud functions const { challenge, requestBody } = await Parse.Cloud.run(\"dfnsAddTrustedIssuerInit\", { trustedIssuer: \"0x1234...\", // Issuer wallet address claimTopics: [1, 2, 3], // Claim topics this issuer can verify walletId: \"wallet_id\", dfns_token: \"dfns_token\" }); // Sign the challenge client-side const signedChallenge = await signChallenge(challenge); // Complete the transaction await Parse.Cloud.run(\"dfnsAddTrustedIssuerComplete\", { walletId: \"wallet_id\", dfns_token: \"dfns_token\", signedChallenge: signedChallenge, requestBody: requestBody }); ``` Removing a Trusted Issuer : Use the dfnsRemoveTrustedIssuerInit/Complete cloud functions following the same pattern as above. Updating Trusted Issuer Claim Topics : Use the dfnsUpdateIssuerClaimTopicsInit/Complete cloud functions. Monitoring and Alerts \u00b6 System Health Checks \u00b6 Parse Server Health Check : Endpoint: /parse/health Expected response: {\"status\":\"ok\"} Monitor response time (should be < 200ms) Database Health Check : Query execution time Connection pool status Replica set status (if applicable) Blockchain Connectivity : RPC endpoint response time Block height synchronization Transaction submission success rate Performance Metrics \u00b6 Key metrics to monitor: API Performance : Request latency (avg, p95, p99) Request throughput Error rate Database Performance : Query execution time Index usage Connection count Blockchain Performance : Gas costs per transaction type Transaction confirmation time Failed transaction rate Log Management \u00b6 Log Aggregation : Implement centralized logging (e.g., ELK Stack, Splunk) Include correlation IDs across service boundaries Implement structured logging for easier querying Log Levels : ERROR: Issues requiring immediate attention WARN: Potential issues to investigate INFO: Normal operations DEBUG: Detailed information for troubleshooting Key Events to Log : Authentication events User management operations Blockchain transactions External API calls Alert Configuration \u00b6 Configure alerts for the following scenarios: Critical Alerts (immediate action required): Parse Server unavailability Database connection failures High error rates (>5%) Failed blockchain transactions Warning Alerts (investigation needed): Elevated API latency (>500ms) Increased error rates (>1%) Low disk space (<20%) Delayed blockchain confirmations Notification Channels : Email SMS/Text Slack/Teams PagerDuty or similar service Common Warning Signs \u00b6 Watch for these indicators of potential issues: Increasing API Latency : May indicate database issues or resource constraints Growing Database Size : May require indexing or cleanup Increasing Error Rates : May indicate bugs or external service issues Blockchain Transaction Failures : May indicate gas price issues or contract bugs Declining User Activity : May indicate UX issues or service degradation Dashboards Setup \u00b6 Implement monitoring dashboards that show: System Overview : Overall health status Current alert status Key metrics summary API Performance : Request volume Response time by endpoint Error rate by endpoint User Activity : Active users Registration rate Transaction volume Blockchain Activity : Transaction success rate Gas costs Contract interactions Backup and Recovery \u00b6 Backup Procedures \u00b6 Database Backups : ```bash # MongoDB backup command mongodump --uri=\"mongodb://username:password@host:port/database\" --out=/backup/path/$(date +%Y-%m-%d) # Compress the backup tar -zcvf /backup/path/$(date +%Y-%m-%d).tar.gz /backup/path/$(date +%Y-%m-%d) ``` Schedule : - Full backup: Daily - Incremental backup: Hourly Configuration Backups : bash # Back up environment variables and config files cp .env /backup/config/$(date +%Y-%m-%d)-env cp gemforce.config.ts /backup/config/$(date +%Y-%m-%d)-gemforce-config.ts Schedule : After any configuration change Contract Deployment Records : bash # Back up deployment records cp ./deployments /backup/deployments/$(date +%Y-%m-%d) -r cp deployed.json /backup/deployments/$(date +%Y-%m-%d)-deployed.json Schedule : After any contract deployment Recovery Procedures \u00b6 Database Recovery : bash # Restore MongoDB database mongorestore --uri=\"mongodb://username:password@host:port/database\" --drop /backup/path/YYYY-MM-DD Configuration Recovery : bash # Restore configuration files cp /backup/config/YYYY-MM-DD-env .env cp /backup/config/YYYY-MM-DD-gemforce-config.ts gemforce.config.ts Contract Redeployment : Restore deployment records Use the DiamondFactory to recreate diamonds if needed Verify contract states Disaster Recovery Planning \u00b6 Disaster Recovery Scenarios : Database corruption Server hardware failure Cloud provider outage Security breach Recovery Time Objectives (RTO) : Critical systems: 4 hours Non-critical systems: 24 hours Recovery Point Objectives (RPO) : Database: 1 hour Configuration: 24 hours Disaster Recovery Runbook : Maintain up-to-date documentation Conduct periodic recovery tests Automate recovery procedures where possible Security Management \u00b6 Access Control \u00b6 API Key Management : Generate strong API keys (min 32 characters) Store securely (environment variables, secret management service) Implement key rotation (90-day cycle) Revoke compromised keys immediately User Authentication Controls : Enforce strong password policies Implement account lockout after failed attempts Consider implementing MFA for admin accounts Session timeout (default: 24 hours) Role-Based Access Control : Limit permissions to minimum required Regularly audit role assignments Implement principle of least privilege API Key Rotation \u00b6 Implement a process for rotating API keys: // Example: Rotate Bridge API key async function rotateBridgeAPIKey () { // Generate a new API key (provider-specific) const newKey = await generateNewBridgeAPIKey (); // Update environment variable process . env . BRIDGE_API_KEY = newKey ; // Update configuration in database const config = await Config . get ( \"bridgeAPIKey\" ); config . set ( \"value\" , newKey ); await config . save ( null , { useMasterKey : true }); // Log the rotation console . log ( `Bridge API key rotated at ${ new Date (). toISOString () } ` ); } Audit Logging \u00b6 Security Events to Log : Authentication attempts (successful and failed) Authorization changes User creation/deletion Role assignment API key usage Admin actions Log Format : json { \"timestamp\": \"2025-02-25T13:51:49.123Z\", \"event\": \"user.login\", \"success\": true, \"userId\": \"user123\", \"ipAddress\": \"192.168.1.1\", \"userAgent\": \"Mozilla/5.0...\", \"additionalDetails\": {} } Log Retention : Security logs: 12 months minimum Normal operation logs: 3 months Security Incident Response \u00b6 Incident Classification : P1: Critical (data breach, service unavailable) P2: High (limited breach, partial service degradation) P3: Medium (minor security issue, limited impact) P4: Low (potential vulnerability, no active exploitation) Response Procedure : Identify and classify the incident Contain the incident Eradicate the cause Recover systems Conduct post-incident analysis Contact List : Security team IT operations Legal department Executive leadership External security consultants (if applicable) Compliance Considerations \u00b6 Data Privacy : Identify personal data stored in the system Implement data minimization Configure data retention policies Provide data export/deletion capabilities Regulatory Compliance : KYC/AML requirements Financial regulations Industry-specific regulations Cross-border data transfer requirements Troubleshooting \u00b6 Common Issues and Solutions \u00b6 API Request Failures : Symptom : HTTP 400/500 errors Check : API logs, request parameters Solution : Verify request format, check server logs for details Blockchain Transaction Failures : Symptom : Transaction hash returned but transaction fails Check : Gas price, contract state, transaction parameters Solution : Adjust gas price, verify contract accepts the transaction Database Connection Issues : Symptom : Cannot connect to database error Check : MongoDB status, network connectivity Solution : Restart MongoDB, check firewall rules DFNS Integration Issues : Symptom : \"Cannot sign transaction\" errors Check : DFNS credentials, WebAuthn support Solution : Verify DFNS credentials, ensure browser supports WebAuthn Diagnostic Tools \u00b6 Log Analysis : ```bash # Search for errors in logs grep \"ERROR\" /var/log/gemforce/app.log # Find recent activity for a specific user grep \"userId\\\":\\\"user123\" /var/log/gemforce/app.log ``` Database Queries : ```javascript // Check user status db.User.findOne({ email: \"user@example.com\" }) // Look for recent errors db.ErrorLog.find().sort({ createdAt: -1 }).limit(10) ``` Blockchain Explorers : Use block explorers to verify transaction status Check contract events for expected emissions Verify contract state after transactions Error Codes Explanation \u00b6 HTTP Status Codes : 400: Bad Request (invalid parameters) 401: Unauthorized (missing/invalid authentication) 403: Forbidden (insufficient permissions) 404: Not Found (resource doesn't exist) 429: Too Many Requests (rate limit exceeded) 500: Internal Server Error (server-side issue) Parse Error Codes : 101: Object not found 141: Missing required field 209: Invalid session token Blockchain Error Codes : \"gas required exceeds allowance\": Insufficient gas \"execution reverted\": Contract condition not met \"nonce too low\": Transaction nonce issue Support Escalation Procedures \u00b6 Tier 1 Support : Initial triage Common issue resolution Escalation timeframe: 30 minutes Tier 2 Support : Technical investigation Complex issue resolution Escalation timeframe: 2 hours Tier 3 Support : Engineering team involvement Critical issue resolution Escalation timeframe: 4 hours Escalation Contact Information : Tier 1: support@gemforce.com Tier 2: tech-support@gemforce.com Tier 3: engineering@gemforce.com Emergency: +1-555-123-4567 Service Dependencies \u00b6 Map of service dependencies to check during outages: Parse Server depends on : MongoDB File storage DFNS API Bridge API Blockchain RPC nodes Blockchain operations depend on : RPC node availability Gas price oracle Contract state User authentication depends on : Parse Server Email service DFNS (for wallet operations) Maintenance Procedures \u00b6 Routine Maintenance Tasks \u00b6 Daily Tasks : Review error logs Check backup status Monitor system performance Weekly Tasks : Analyze API usage patterns Review security logs Check disk space usage Monthly Tasks : User access review API key rotation Performance optimization Database maintenance Update Procedures \u00b6 Parse Server Updates : ```bash # Update Parse Server npm update parse-server # Restart Parse Server pm2 restart parse-server ``` Node.js Updates : ```bash # Update Node.js using NVM nvm install 16.x nvm use 16.x # Verify version node -v ``` Cloud Function Updates : ```bash # Pull latest changes git pull origin main # Install dependencies npm install # Build the project npm run build # Restart the server pm2 restart gemforce ``` Database Optimization \u00b6 Index Optimization : ```javascript // Analyze query performance db.User.find({ walletAddress: { $exists: true } }).explain(\"executionStats\") // Add missing indexes db.User.createIndex({ walletAddress: 1 }) ``` Data Archiving : ```javascript // Move old logs to archive collection db.SystemLog.aggregate([ { $match: { createdAt: { $lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) } } }, { $out: \"SystemLogArchive\" } ]) // Remove archived logs db.SystemLog.deleteMany({ createdAt: { $lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) } }) ``` Database Maintenance : ```javascript // Repair database db.repairDatabase() // Compact collections db.runCommand({ compact: \"User\" }) ``` Cache Management \u00b6 Redis Cache Configuration (if applicable): javascript // Example cache configuration const redisCache = { host: \"localhost\", port: 6379, ttl: 600 // 10 minutes }; Cache Invalidation : ```javascript // Invalidate specific keys redisClient.del(\"user_123_profile\") // Invalidate pattern redisClient.keys(\"user_*_profile\", (err, keys) => { if (keys.length > 0) redisClient.del(keys); }) ``` Cache Monitoring : ```bash # Check Redis info redis-cli info # Monitor cache hit rate redis-cli info stats | grep hit_rate ``` System Scaling Procedures \u00b6 Horizontal Scaling : Add more Parse Server instances Configure load balancer Update DNS if needed Vertical Scaling : Upgrade server resources Schedule downtime for migration Verify performance after upgrade Database Scaling : Implement MongoDB replica set Consider sharding for large deployments Optimize query patterns Performance Optimization \u00b6 Database Tuning \u00b6 Query Optimization : Use explain plan to analyze queries Ensure proper indexes are in place Limit returned fields using projection Use aggregation pipeline for complex queries Connection Pooling : javascript // Example MongoDB connection pool configuration const mongoConfig = { uri: process.env.DATABASE_URI, options: { maxPoolSize: 50, minPoolSize: 10, socketTimeoutMS: 30000, connectTimeoutMS: 30000 } }; Index Analysis : ```javascript // Check index usage db.User.aggregate([ { $indexStats: {} } ]) // Remove unused indexes db.User.dropIndex(\"unusedIndex\") ``` Cache Configuration \u00b6 Cacheable Data Types : User profiles Contract metadata Configuration settings Static content Cache Strategy : Cache-aside: Application checks cache before database TTL-based expiration Event-based invalidation Example Redis Configuration : javascript // Redis cache configuration const redisOptions = { host: process.env.REDIS_HOST || \"localhost\", port: process.env.REDIS_PORT || 6379, password: process.env.REDIS_PASSWORD, db: 0, ttl: 3600 // 1 hour }; Rate Limiting Configuration \u00b6 API Rate Limits : javascript // Example rate limiting configuration const rateLimits = { global: { windowMs: 60 * 1000, // 1 minute max: 1000 // limit each IP to 1000 requests per minute }, login: { windowMs: 60 * 1000, // 1 minute max: 10 // limit each IP to 10 login attempts per minute }, createUser: { windowMs: 60 * 60 * 1000, // 1 hour max: 50 // limit each IP to 50 user creations per hour } }; Rate Limit Response : javascript // Example rate limit exceeded response { \"status\": \"error\", \"code\": 429, \"message\": \"Rate limit exceeded. Try again in X seconds.\", \"retryAfter\": 30 } Rate Limit Monitoring : Track rate limit hits Alert on sustained high rejection rates Analyze traffic patterns to adjust limits Resource Allocation Guidelines \u00b6 Server Resources : Guidelines for allocating resources based on load: Load Level Users API Requests/min CPU Cores RAM Disk Small <1k <100 2 4GB 20GB Medium <10k <1k 4 8GB 50GB Large <100k <10k 8 16GB 100GB X-Large >100k >10k 16+ 32GB+ 200GB+ Database Resources : Guidelines for MongoDB resources: Load Level Documents Indexes RAM Disk Small <1M <20 2GB 10GB Medium <10M <50 4GB 50GB Large <100M <100 16GB 200GB X-Large >100M >100 32GB+ 500GB+ Blockchain Node Resources : Consider using managed node providers for production environments. If running your own nodes: Network Disk RAM Notes Ethereum >2TB 16GB Full node, growing rapidly BaseSepolia >100GB 8GB Testnet, moderate growth Resource Scaling Triggers : CPU usage consistently >70% RAM usage consistently >80% Disk usage >85% Response time increasing trend Error rate increasing trend","title":"Administrator Guide"},{"location":"gemforce-administrator-guide/#gemforce-administrator-guide","text":"","title":"Gemforce Administrator Guide"},{"location":"gemforce-administrator-guide/#table-of-contents","text":"System Overview Installation and Configuration User Management Monitoring and Alerts Backup and Recovery Security Management Troubleshooting Maintenance Procedures Performance Optimization","title":"Table of Contents"},{"location":"gemforce-administrator-guide/#system-overview","text":"","title":"System Overview"},{"location":"gemforce-administrator-guide/#architecture-components","text":"The Gemforce platform consists of the following major components: Blockchain Smart Contracts Diamond contracts (EIP-2535 implementation) Identity management contracts Token management contracts Carbon credit contracts Cloud Services Parse Server backend Database (MongoDB) File storage Cloud functions External Service Integrations DFNS wallet-as-a-service Bridge API SendGrid email service Blockchain RPC providers Client Applications Web applications Mobile applications API integrations","title":"Architecture Components"},{"location":"gemforce-administrator-guide/#component-relationships","text":"The Gemforce system follows a layered architecture: Client Applications \u2193\u2191 Cloud Services (Parse Server) \u2193\u2191 External Services \u27f7 Blockchain Contracts Client applications interact with the Parse Server via REST API Parse Server executes cloud functions that interact with blockchain contracts and external services External services provide specialized functionality (wallet management, financial operations, etc.) Blockchain contracts store and manage on-chain data and logic","title":"Component Relationships"},{"location":"gemforce-administrator-guide/#infrastructure-requirements","text":"Blockchain Nodes : Access to Ethereum-compatible blockchain nodes Server Hardware : Minimum: 4 CPU cores, 8GB RAM, 100GB SSD Recommended: 8 CPU cores, 16GB RAM, 250GB SSD Database : MongoDB 4.4+ Network : Reliable internet connection with low latency to blockchain nodes SSL Certificate : Valid SSL certificate for secure API access","title":"Infrastructure Requirements"},{"location":"gemforce-administrator-guide/#security-model-overview","text":"Gemforce implements a multi-layered security approach: Authentication and Authorization User authentication via Parse Server Role-based access control API key authentication for B2B integrations DFNS WebAuthn for wallet operations Smart Contract Security Role-based access control Function-level permissions Upgradeability via Diamond pattern Data Protection Encrypted data at rest TLS for data in transit Private key management via DFNS Monitoring and Auditing Comprehensive logging Activity tracking Alert systems","title":"Security Model Overview"},{"location":"gemforce-administrator-guide/#installation-and-configuration","text":"","title":"Installation and Configuration"},{"location":"gemforce-administrator-guide/#prerequisites","text":"Before installing Gemforce, ensure you have: Node.js 16.x or higher MongoDB 4.4 or higher Access to blockchain nodes (RPC endpoints) API keys for external services Domain name with SSL certificate Git access to the Gemforce repositories","title":"Prerequisites"},{"location":"gemforce-administrator-guide/#environment-variables","text":"The Gemforce system requires several environment variables to be set. Create a .env file with the following variables: # Parse Server Configuration APP_ID=your_app_id MASTER_KEY=your_master_key DATABASE_URI=mongodb://username:password@host:port/database SERVER_URL=https://your-server-url.com/parse PROJECT_WIZARD_URL=https://your-server-url.com # Blockchain Configuration ETH_NODE_URI_MAINNET=https://mainnet.infura.io/v3/your-key ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=base-sepolia METADATA_BASE_URI=https://your-metadata-url.com/ # DFNS Configuration DFNS_APP_ID=your_dfns_app_id DFNS_API_URL=https://api.dfns.io DFNS_CRED_ID=your_dfns_credential_id DFNS_AUTH_TOKEN=your_dfns_auth_token # Bridge API Configuration BASE_BRIDGE_URL=https://api.bridge-api.com BRIDGE_API_KEY=your_bridge_api_key # Email Configuration SENDGRID_API_KEY=your_sendgrid_key FROM_EMAIL=noreply@your-domain.com # Security Configuration AUTH_SECRET_KEY=your_auth_secret_key","title":"Environment Variables"},{"location":"gemforce-administrator-guide/#network-settings","text":"Firewall Configuration : Allow inbound connections on ports 80 (HTTP), 443 (HTTPS), and your Parse Server port Allow outbound connections to MongoDB, blockchain nodes, and external APIs Load Balancer Configuration (if applicable): Configure health checks to the Parse Server health endpoint Set appropriate timeouts (at least 30 seconds for blockchain operations) Enable SSL termination DNS Configuration : Set up A records for your domain Configure CNAME records for subdomains if needed","title":"Network Settings"},{"location":"gemforce-administrator-guide/#database-configuration","text":"MongoDB Setup : bash # Create a MongoDB user for the Gemforce database mongo admin -u admin -p admin use gemforce db.createUser({ user: \"gemforce_user\", pwd: \"secure_password\", roles: [{ role: \"readWrite\", db: \"gemforce\" }] }) Indexes : Ensure the following indexes are created for optimal performance: ```javascript // User collection indexes db.User.createIndex({ email: 1 }, { unique: true }) db.User.createIndex({ username: 1 }, { unique: true }) db.User.createIndex({ walletAddress: 1 }) // Identity collection indexes db.Identity.createIndex({ walletAddress: 1 }, { unique: true }) // Transaction collection indexes db.Transaction.createIndex({ hash: 1 }, { unique: true }) db.Transaction.createIndex({ user: 1 }) db.Transaction.createIndex({ createdAt: 1 }) ```","title":"Database Configuration"},{"location":"gemforce-administrator-guide/#external-service-connections","text":"DFNS Setup : Create a DFNS account at https://dashboard.dfns.io Create an application and credential Copy the App ID and Credential ID to your environment variables Store the private key in dfns_private.key Bridge API Setup : Obtain API credentials from Bridge API Configure webhooks for notifications (if needed) Set rate limiting based on expected traffic SendGrid Setup : Create a SendGrid account Set up sender authentication for your domain Create email templates for verification, password reset, etc. Generate API key and add to environment variables","title":"External Service Connections"},{"location":"gemforce-administrator-guide/#security-settings","text":"API Key Management : Rotate API keys periodically (recommended every 90 days) Store API keys securely using environment variables Never expose API keys in client-side code Cross-Origin Resource Sharing (CORS) : Configure CORS settings in the Parse Server configuration: javascript const corsConfig = { allowOrigin: ['https://your-domain.com', 'https://app.your-domain.com'], allowHeaders: ['X-Parse-Application-Id', 'X-Parse-REST-API-Key', 'Content-Type'], allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'] }; Rate Limiting : Configure rate limiting to prevent abuse: javascript const rateLimitConfig = { rateLimit: 1000, // requests per minute burstLimit: 50, // concurrent requests expiration: 60 // seconds until reset };","title":"Security Settings"},{"location":"gemforce-administrator-guide/#user-management","text":"","title":"User Management"},{"location":"gemforce-administrator-guide/#user-roles-and-permissions","text":"Gemforce implements role-based access control with the following default roles: Admin : Full access to all functions Can manage users and roles Can deploy and update contracts CentralAuthority : Can manage trusted issuers Can add claim topics Can manage identities TrustedIssuer : Can issue claims to identities Can verify identities Limited access to identity management User : Can manage own wallet Can view own transactions Can participate in marketplace","title":"User Roles and Permissions"},{"location":"gemforce-administrator-guide/#adding-and-removing-users","text":"","title":"Adding and Removing Users"},{"location":"gemforce-administrator-guide/#adding-users","text":"Via Admin Dashboard : Navigate to User Management Click \"Add User\" Enter user details (email, name, role) System will send invitation email Via API : ```javascript // Example using Parse JavaScript SDK const user = new Parse.User(); user.set(\"username\", \"user@example.com\"); user.set(\"password\", \"securePassword\"); user.set(\"email\", \"user@example.com\"); user.set(\"firstName\", \"John\"); user.set(\"lastName\", \"Doe\"); await user.signUp(); ``` Via Cloud Function : javascript // Using the registerUser cloud function Parse.Cloud.run(\"registerUser\", { username: \"user@example.com\", password: \"securePassword\", email: \"user@example.com\", firstName: \"John\", lastName: \"Doe\", company: \"Example Inc\" });","title":"Adding Users"},{"location":"gemforce-administrator-guide/#removing-users","text":"Via Admin Dashboard : Navigate to User Management Select user(s) to remove Click \"Delete\" or \"Deactivate\" Via API : javascript // Example using Parse JavaScript SDK const query = new Parse.Query(Parse.User); query.equalTo(\"email\", \"user@example.com\"); const user = await query.first({ useMasterKey: true }); await user.destroy({ useMasterKey: true });","title":"Removing Users"},{"location":"gemforce-administrator-guide/#role-assignment","text":"Assigning Roles to Users : ```javascript // Example using Parse JavaScript SDK const userQuery = new Parse.Query(Parse.User); userQuery.equalTo(\"email\", \"user@example.com\"); const user = await userQuery.first({ useMasterKey: true }); const roleQuery = new Parse.Query(Parse.Role); roleQuery.equalTo(\"name\", \"TrustedIssuer\"); const role = await roleQuery.first({ useMasterKey: true }); role.getUsers().add(user); await role.save(null, { useMasterKey: true }); ``` Creating New Roles : ```javascript // Example using Parse JavaScript SDK const acl = new Parse.ACL(); acl.setPublicReadAccess(true); const role = new Parse.Role(\"CustomRole\", acl); await role.save(null, { useMasterKey: true }); ```","title":"Role Assignment"},{"location":"gemforce-administrator-guide/#identity-verification-processes","text":"KYC Verification : Initiate via generateKycLink cloud function User completes KYC via Bridge API Webhook notification sent back to Gemforce Identity status updated accordingly Trusted Issuer Verification : Trusted Issuer reviews identity information Issues verification claim to user identity Claim is written to blockchain Identity state is updated to \"verified\"","title":"Identity Verification Processes"},{"location":"gemforce-administrator-guide/#managing-trusted-issuers","text":"Adding a Trusted Issuer : ```javascript // Using the dfnsAddTrustedIssuerInit/Complete cloud functions const { challenge, requestBody } = await Parse.Cloud.run(\"dfnsAddTrustedIssuerInit\", { trustedIssuer: \"0x1234...\", // Issuer wallet address claimTopics: [1, 2, 3], // Claim topics this issuer can verify walletId: \"wallet_id\", dfns_token: \"dfns_token\" }); // Sign the challenge client-side const signedChallenge = await signChallenge(challenge); // Complete the transaction await Parse.Cloud.run(\"dfnsAddTrustedIssuerComplete\", { walletId: \"wallet_id\", dfns_token: \"dfns_token\", signedChallenge: signedChallenge, requestBody: requestBody }); ``` Removing a Trusted Issuer : Use the dfnsRemoveTrustedIssuerInit/Complete cloud functions following the same pattern as above. Updating Trusted Issuer Claim Topics : Use the dfnsUpdateIssuerClaimTopicsInit/Complete cloud functions.","title":"Managing Trusted Issuers"},{"location":"gemforce-administrator-guide/#monitoring-and-alerts","text":"","title":"Monitoring and Alerts"},{"location":"gemforce-administrator-guide/#system-health-checks","text":"Parse Server Health Check : Endpoint: /parse/health Expected response: {\"status\":\"ok\"} Monitor response time (should be < 200ms) Database Health Check : Query execution time Connection pool status Replica set status (if applicable) Blockchain Connectivity : RPC endpoint response time Block height synchronization Transaction submission success rate","title":"System Health Checks"},{"location":"gemforce-administrator-guide/#performance-metrics","text":"Key metrics to monitor: API Performance : Request latency (avg, p95, p99) Request throughput Error rate Database Performance : Query execution time Index usage Connection count Blockchain Performance : Gas costs per transaction type Transaction confirmation time Failed transaction rate","title":"Performance Metrics"},{"location":"gemforce-administrator-guide/#log-management","text":"Log Aggregation : Implement centralized logging (e.g., ELK Stack, Splunk) Include correlation IDs across service boundaries Implement structured logging for easier querying Log Levels : ERROR: Issues requiring immediate attention WARN: Potential issues to investigate INFO: Normal operations DEBUG: Detailed information for troubleshooting Key Events to Log : Authentication events User management operations Blockchain transactions External API calls","title":"Log Management"},{"location":"gemforce-administrator-guide/#alert-configuration","text":"Configure alerts for the following scenarios: Critical Alerts (immediate action required): Parse Server unavailability Database connection failures High error rates (>5%) Failed blockchain transactions Warning Alerts (investigation needed): Elevated API latency (>500ms) Increased error rates (>1%) Low disk space (<20%) Delayed blockchain confirmations Notification Channels : Email SMS/Text Slack/Teams PagerDuty or similar service","title":"Alert Configuration"},{"location":"gemforce-administrator-guide/#common-warning-signs","text":"Watch for these indicators of potential issues: Increasing API Latency : May indicate database issues or resource constraints Growing Database Size : May require indexing or cleanup Increasing Error Rates : May indicate bugs or external service issues Blockchain Transaction Failures : May indicate gas price issues or contract bugs Declining User Activity : May indicate UX issues or service degradation","title":"Common Warning Signs"},{"location":"gemforce-administrator-guide/#dashboards-setup","text":"Implement monitoring dashboards that show: System Overview : Overall health status Current alert status Key metrics summary API Performance : Request volume Response time by endpoint Error rate by endpoint User Activity : Active users Registration rate Transaction volume Blockchain Activity : Transaction success rate Gas costs Contract interactions","title":"Dashboards Setup"},{"location":"gemforce-administrator-guide/#backup-and-recovery","text":"","title":"Backup and Recovery"},{"location":"gemforce-administrator-guide/#backup-procedures","text":"Database Backups : ```bash # MongoDB backup command mongodump --uri=\"mongodb://username:password@host:port/database\" --out=/backup/path/$(date +%Y-%m-%d) # Compress the backup tar -zcvf /backup/path/$(date +%Y-%m-%d).tar.gz /backup/path/$(date +%Y-%m-%d) ``` Schedule : - Full backup: Daily - Incremental backup: Hourly Configuration Backups : bash # Back up environment variables and config files cp .env /backup/config/$(date +%Y-%m-%d)-env cp gemforce.config.ts /backup/config/$(date +%Y-%m-%d)-gemforce-config.ts Schedule : After any configuration change Contract Deployment Records : bash # Back up deployment records cp ./deployments /backup/deployments/$(date +%Y-%m-%d) -r cp deployed.json /backup/deployments/$(date +%Y-%m-%d)-deployed.json Schedule : After any contract deployment","title":"Backup Procedures"},{"location":"gemforce-administrator-guide/#recovery-procedures","text":"Database Recovery : bash # Restore MongoDB database mongorestore --uri=\"mongodb://username:password@host:port/database\" --drop /backup/path/YYYY-MM-DD Configuration Recovery : bash # Restore configuration files cp /backup/config/YYYY-MM-DD-env .env cp /backup/config/YYYY-MM-DD-gemforce-config.ts gemforce.config.ts Contract Redeployment : Restore deployment records Use the DiamondFactory to recreate diamonds if needed Verify contract states","title":"Recovery Procedures"},{"location":"gemforce-administrator-guide/#disaster-recovery-planning","text":"Disaster Recovery Scenarios : Database corruption Server hardware failure Cloud provider outage Security breach Recovery Time Objectives (RTO) : Critical systems: 4 hours Non-critical systems: 24 hours Recovery Point Objectives (RPO) : Database: 1 hour Configuration: 24 hours Disaster Recovery Runbook : Maintain up-to-date documentation Conduct periodic recovery tests Automate recovery procedures where possible","title":"Disaster Recovery Planning"},{"location":"gemforce-administrator-guide/#security-management","text":"","title":"Security Management"},{"location":"gemforce-administrator-guide/#access-control","text":"API Key Management : Generate strong API keys (min 32 characters) Store securely (environment variables, secret management service) Implement key rotation (90-day cycle) Revoke compromised keys immediately User Authentication Controls : Enforce strong password policies Implement account lockout after failed attempts Consider implementing MFA for admin accounts Session timeout (default: 24 hours) Role-Based Access Control : Limit permissions to minimum required Regularly audit role assignments Implement principle of least privilege","title":"Access Control"},{"location":"gemforce-administrator-guide/#api-key-rotation","text":"Implement a process for rotating API keys: // Example: Rotate Bridge API key async function rotateBridgeAPIKey () { // Generate a new API key (provider-specific) const newKey = await generateNewBridgeAPIKey (); // Update environment variable process . env . BRIDGE_API_KEY = newKey ; // Update configuration in database const config = await Config . get ( \"bridgeAPIKey\" ); config . set ( \"value\" , newKey ); await config . save ( null , { useMasterKey : true }); // Log the rotation console . log ( `Bridge API key rotated at ${ new Date (). toISOString () } ` ); }","title":"API Key Rotation"},{"location":"gemforce-administrator-guide/#audit-logging","text":"Security Events to Log : Authentication attempts (successful and failed) Authorization changes User creation/deletion Role assignment API key usage Admin actions Log Format : json { \"timestamp\": \"2025-02-25T13:51:49.123Z\", \"event\": \"user.login\", \"success\": true, \"userId\": \"user123\", \"ipAddress\": \"192.168.1.1\", \"userAgent\": \"Mozilla/5.0...\", \"additionalDetails\": {} } Log Retention : Security logs: 12 months minimum Normal operation logs: 3 months","title":"Audit Logging"},{"location":"gemforce-administrator-guide/#security-incident-response","text":"Incident Classification : P1: Critical (data breach, service unavailable) P2: High (limited breach, partial service degradation) P3: Medium (minor security issue, limited impact) P4: Low (potential vulnerability, no active exploitation) Response Procedure : Identify and classify the incident Contain the incident Eradicate the cause Recover systems Conduct post-incident analysis Contact List : Security team IT operations Legal department Executive leadership External security consultants (if applicable)","title":"Security Incident Response"},{"location":"gemforce-administrator-guide/#compliance-considerations","text":"Data Privacy : Identify personal data stored in the system Implement data minimization Configure data retention policies Provide data export/deletion capabilities Regulatory Compliance : KYC/AML requirements Financial regulations Industry-specific regulations Cross-border data transfer requirements","title":"Compliance Considerations"},{"location":"gemforce-administrator-guide/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"gemforce-administrator-guide/#common-issues-and-solutions","text":"API Request Failures : Symptom : HTTP 400/500 errors Check : API logs, request parameters Solution : Verify request format, check server logs for details Blockchain Transaction Failures : Symptom : Transaction hash returned but transaction fails Check : Gas price, contract state, transaction parameters Solution : Adjust gas price, verify contract accepts the transaction Database Connection Issues : Symptom : Cannot connect to database error Check : MongoDB status, network connectivity Solution : Restart MongoDB, check firewall rules DFNS Integration Issues : Symptom : \"Cannot sign transaction\" errors Check : DFNS credentials, WebAuthn support Solution : Verify DFNS credentials, ensure browser supports WebAuthn","title":"Common Issues and Solutions"},{"location":"gemforce-administrator-guide/#diagnostic-tools","text":"Log Analysis : ```bash # Search for errors in logs grep \"ERROR\" /var/log/gemforce/app.log # Find recent activity for a specific user grep \"userId\\\":\\\"user123\" /var/log/gemforce/app.log ``` Database Queries : ```javascript // Check user status db.User.findOne({ email: \"user@example.com\" }) // Look for recent errors db.ErrorLog.find().sort({ createdAt: -1 }).limit(10) ``` Blockchain Explorers : Use block explorers to verify transaction status Check contract events for expected emissions Verify contract state after transactions","title":"Diagnostic Tools"},{"location":"gemforce-administrator-guide/#error-codes-explanation","text":"HTTP Status Codes : 400: Bad Request (invalid parameters) 401: Unauthorized (missing/invalid authentication) 403: Forbidden (insufficient permissions) 404: Not Found (resource doesn't exist) 429: Too Many Requests (rate limit exceeded) 500: Internal Server Error (server-side issue) Parse Error Codes : 101: Object not found 141: Missing required field 209: Invalid session token Blockchain Error Codes : \"gas required exceeds allowance\": Insufficient gas \"execution reverted\": Contract condition not met \"nonce too low\": Transaction nonce issue","title":"Error Codes Explanation"},{"location":"gemforce-administrator-guide/#support-escalation-procedures","text":"Tier 1 Support : Initial triage Common issue resolution Escalation timeframe: 30 minutes Tier 2 Support : Technical investigation Complex issue resolution Escalation timeframe: 2 hours Tier 3 Support : Engineering team involvement Critical issue resolution Escalation timeframe: 4 hours Escalation Contact Information : Tier 1: support@gemforce.com Tier 2: tech-support@gemforce.com Tier 3: engineering@gemforce.com Emergency: +1-555-123-4567","title":"Support Escalation Procedures"},{"location":"gemforce-administrator-guide/#service-dependencies","text":"Map of service dependencies to check during outages: Parse Server depends on : MongoDB File storage DFNS API Bridge API Blockchain RPC nodes Blockchain operations depend on : RPC node availability Gas price oracle Contract state User authentication depends on : Parse Server Email service DFNS (for wallet operations)","title":"Service Dependencies"},{"location":"gemforce-administrator-guide/#maintenance-procedures","text":"","title":"Maintenance Procedures"},{"location":"gemforce-administrator-guide/#routine-maintenance-tasks","text":"Daily Tasks : Review error logs Check backup status Monitor system performance Weekly Tasks : Analyze API usage patterns Review security logs Check disk space usage Monthly Tasks : User access review API key rotation Performance optimization Database maintenance","title":"Routine Maintenance Tasks"},{"location":"gemforce-administrator-guide/#update-procedures","text":"Parse Server Updates : ```bash # Update Parse Server npm update parse-server # Restart Parse Server pm2 restart parse-server ``` Node.js Updates : ```bash # Update Node.js using NVM nvm install 16.x nvm use 16.x # Verify version node -v ``` Cloud Function Updates : ```bash # Pull latest changes git pull origin main # Install dependencies npm install # Build the project npm run build # Restart the server pm2 restart gemforce ```","title":"Update Procedures"},{"location":"gemforce-administrator-guide/#database-optimization","text":"Index Optimization : ```javascript // Analyze query performance db.User.find({ walletAddress: { $exists: true } }).explain(\"executionStats\") // Add missing indexes db.User.createIndex({ walletAddress: 1 }) ``` Data Archiving : ```javascript // Move old logs to archive collection db.SystemLog.aggregate([ { $match: { createdAt: { $lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) } } }, { $out: \"SystemLogArchive\" } ]) // Remove archived logs db.SystemLog.deleteMany({ createdAt: { $lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) } }) ``` Database Maintenance : ```javascript // Repair database db.repairDatabase() // Compact collections db.runCommand({ compact: \"User\" }) ```","title":"Database Optimization"},{"location":"gemforce-administrator-guide/#cache-management","text":"Redis Cache Configuration (if applicable): javascript // Example cache configuration const redisCache = { host: \"localhost\", port: 6379, ttl: 600 // 10 minutes }; Cache Invalidation : ```javascript // Invalidate specific keys redisClient.del(\"user_123_profile\") // Invalidate pattern redisClient.keys(\"user_*_profile\", (err, keys) => { if (keys.length > 0) redisClient.del(keys); }) ``` Cache Monitoring : ```bash # Check Redis info redis-cli info # Monitor cache hit rate redis-cli info stats | grep hit_rate ```","title":"Cache Management"},{"location":"gemforce-administrator-guide/#system-scaling-procedures","text":"Horizontal Scaling : Add more Parse Server instances Configure load balancer Update DNS if needed Vertical Scaling : Upgrade server resources Schedule downtime for migration Verify performance after upgrade Database Scaling : Implement MongoDB replica set Consider sharding for large deployments Optimize query patterns","title":"System Scaling Procedures"},{"location":"gemforce-administrator-guide/#performance-optimization","text":"","title":"Performance Optimization"},{"location":"gemforce-administrator-guide/#database-tuning","text":"Query Optimization : Use explain plan to analyze queries Ensure proper indexes are in place Limit returned fields using projection Use aggregation pipeline for complex queries Connection Pooling : javascript // Example MongoDB connection pool configuration const mongoConfig = { uri: process.env.DATABASE_URI, options: { maxPoolSize: 50, minPoolSize: 10, socketTimeoutMS: 30000, connectTimeoutMS: 30000 } }; Index Analysis : ```javascript // Check index usage db.User.aggregate([ { $indexStats: {} } ]) // Remove unused indexes db.User.dropIndex(\"unusedIndex\") ```","title":"Database Tuning"},{"location":"gemforce-administrator-guide/#cache-configuration","text":"Cacheable Data Types : User profiles Contract metadata Configuration settings Static content Cache Strategy : Cache-aside: Application checks cache before database TTL-based expiration Event-based invalidation Example Redis Configuration : javascript // Redis cache configuration const redisOptions = { host: process.env.REDIS_HOST || \"localhost\", port: process.env.REDIS_PORT || 6379, password: process.env.REDIS_PASSWORD, db: 0, ttl: 3600 // 1 hour };","title":"Cache Configuration"},{"location":"gemforce-administrator-guide/#rate-limiting-configuration","text":"API Rate Limits : javascript // Example rate limiting configuration const rateLimits = { global: { windowMs: 60 * 1000, // 1 minute max: 1000 // limit each IP to 1000 requests per minute }, login: { windowMs: 60 * 1000, // 1 minute max: 10 // limit each IP to 10 login attempts per minute }, createUser: { windowMs: 60 * 60 * 1000, // 1 hour max: 50 // limit each IP to 50 user creations per hour } }; Rate Limit Response : javascript // Example rate limit exceeded response { \"status\": \"error\", \"code\": 429, \"message\": \"Rate limit exceeded. Try again in X seconds.\", \"retryAfter\": 30 } Rate Limit Monitoring : Track rate limit hits Alert on sustained high rejection rates Analyze traffic patterns to adjust limits","title":"Rate Limiting Configuration"},{"location":"gemforce-administrator-guide/#resource-allocation-guidelines","text":"Server Resources : Guidelines for allocating resources based on load: Load Level Users API Requests/min CPU Cores RAM Disk Small <1k <100 2 4GB 20GB Medium <10k <1k 4 8GB 50GB Large <100k <10k 8 16GB 100GB X-Large >100k >10k 16+ 32GB+ 200GB+ Database Resources : Guidelines for MongoDB resources: Load Level Documents Indexes RAM Disk Small <1M <20 2GB 10GB Medium <10M <50 4GB 50GB Large <100M <100 16GB 200GB X-Large >100M >100 32GB+ 500GB+ Blockchain Node Resources : Consider using managed node providers for production environments. If running your own nodes: Network Disk RAM Notes Ethereum >2TB 16GB Full node, growing rapidly BaseSepolia >100GB 8GB Testnet, moderate growth Resource Scaling Triggers : CPU usage consistently >70% RAM usage consistently >80% Disk usage >85% Response time increasing trend Error rate increasing trend","title":"Resource Allocation Guidelines"},{"location":"gemforce-api-documentation/","text":"Gemforce API Documentation \u00b6 This document provides a comprehensive overview of the Gemforce API, detailing both the smart contract interfaces and cloud functions that power the system. Table of Contents \u00b6 Introduction Smart Contract APIs Diamond Pattern DiamondFactory Identity Management Token and Asset Management Marketplace Carbon Credits Cloud Function APIs Authentication Functions Blockchain Management Contract Interaction DFNS Wallet Management Bridge API Integration Project Management Introduction \u00b6 Gemforce is a blockchain-powered platform that implements a Diamond pattern (EIP-2535) for upgradeable smart contracts, digital identity management, and token management. The platform combines on-chain smart contracts with off-chain cloud functions to provide a comprehensive solution for issuing, managing, and trading digital assets with verifiable claims. Smart Contract APIs \u00b6 Diamond Pattern \u00b6 The Diamond pattern is the foundation of Gemforce's smart contract architecture. It provides a way to create upgradeable contracts that can be extended with new functionality without breaking existing functionality. Diamond.sol \u00b6 The Diamond contract is the main contract that implements the Diamond pattern. Key functions: initialize(address _owner, DiamondSettings memory params, IDiamondCut.FacetCut[] memory _facets, address diamondInit, bytes calldata _calldata) : Initialize the diamond with owner, settings, and facets. diamondCut(IDiamondCut.FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) : Add, replace, or remove functions from the diamond. facets() : Get all facets and their selectors. facetFunctionSelectors(address _facet) : Get all function selectors for a facet. facetAddresses() : Get all facet addresses used by a diamond. facetAddress(bytes4 _functionSelector) : Get the facet that supports a given selector. transferOwnership(address _newOwner) : Transfer ownership of the diamond. owner() : Get the owner of the diamond. DiamondFactory \u00b6 The DiamondFactory contract is used to create new Diamond contracts. Key functions: initialize(DiamondFactoryInit memory initData) : Initialize the factory with a set of facets. getFacets(string memory facetSet) : Get the facets for a facet set. setFacet(string memory facetSet, uint256 idx, IDiamondCut.FacetCut memory facetAddress) : Set a facet in a facet set. setFacets(string memory facetSet, IDiamondCut.FacetCut[] memory facetAddress) : Set multiple facets in a facet set. removeFacets(string memory facetSet) : Remove a facet set. getDiamondAddress(string memory symbol) : Get the address of a diamond by symbol. create(DiamondSettings memory params, address diamondInit, bytes calldata _calldata, IDiamondCut.FacetCut[] memory facets) : Create a new diamond with custom facets. createFromSet(DiamondSettings memory params, address diamondInit, bytes calldata _calldata, string memory facets) : Create a new diamond from a predefined facet set. add(string memory symbol, address payable diamondAddress) : Add an existing diamond to the factory. remove(string memory symbol) : Remove a diamond from the factory. exists(string memory symbol) : Check if a diamond exists. symbols() : Get all diamond symbols in the factory. Identity Management \u00b6 Gemforce includes a digital identity system that allows for claims to be made about identities. Identity.sol \u00b6 The Identity contract represents a digital identity for a user. Key functions: initialize(address _owner, address _identityRegistry, address _trustedIssuerRegistry) : Initialize the identity with an owner, identity registry, and trusted issuer registry. getAttribute(string memory _key) : Get an attribute for a token ID keyed by string. setAttribute(string memory key, AttributeType attributeType, string memory value) : Set an attribute for a token ID. addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) : Add a key to the identity. removeKey(bytes32 _key, uint256 _purpose) : Remove a key from the identity. getKey(bytes32 _key) : Get a key from the identity. addClaim(uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) : Add a claim to the identity. removeClaim(bytes32 _claimId) : Remove a claim from the identity. getClaim(bytes32 _claimId) : Get a claim by ID. getClaimIdsByTopic(uint256 _topic) : Get claim IDs by topic. getClaimTopics() : Get all claim topics for the identity. isVerified() : Check if the identity is verified. IdentityFactory.sol \u00b6 The IdentityFactory contract creates new Identity contracts. Key functions: initialize(address identityRegistry, address trustedIssuerRegistry) : Initialize the factory with identity and trusted issuer registries. createIdentity(address ownerAddress) : Create a new identity for an owner. removeIdentity(address ownerAddress) : Remove an identity for an owner. getIdentity(address identityOwner) : Get the identity of an owner. getIdentityUsers() : Get all identity users. ClaimTopicsRegistryFacet.sol \u00b6 Manages claim topics that can be used to make claims about identities. Key functions: addClaimTopic(uint256 _claimTopic) : Add a claim topic to the registry. removeClaimTopic(uint256 _claimTopic) : Remove a claim topic from the registry. getClaimTopics() : Get all claim topics. TrustedIssuersRegistryFacet.sol \u00b6 Manages trusted issuers that can make claims about identities. Key functions: addTrustedIssuer(address _trustedIssuer, uint256[] calldata _claimTopics) : Add a trusted issuer with claim topics. removeTrustedIssuer(address _trustedIssuer) : Remove a trusted issuer. updateIssuerClaimTopics(address _trustedIssuer, uint256[] calldata _claimTopics) : Update claim topics for a trusted issuer. getTrustedIssuers() : Get all trusted issuers. getTrustedIssuerClaimTopics(address _trustedIssuer) : Get claim topics for a trusted issuer. isTrustedIssuer(address _issuer) : Check if an address is a trusted issuer. hasClaimTopic(address _trustedIssuer, uint256 _claimTopic) : Check if a trusted issuer has a claim topic. Token and Asset Management \u00b6 GemforceMinterFacet.sol \u00b6 The GemforceMinterFacet contract is used to mint tokens and set attributes. Key functions: gemforceMint(Attribute[] memory metadata) : Mint a new token with metadata. Marketplace \u00b6 MarketplaceFacet.sol \u00b6 The MarketplaceFacet contract provides functionality for buying and selling tokens. Key functions: purchaseItem(address contract, uint256 tokenId) : Purchase a token. Carbon Credits \u00b6 CarbonCreditFacet.sol \u00b6 The CarbonCreditFacet contract provides functionality for managing carbon credits. Key functions: retireCarbonCredits(uint256 tokenId, uint256 amount) : Retire carbon credits for a token. Cloud Function APIs \u00b6 Gemforce provides a set of cloud functions built on Parse Server that bridge the gap between client applications and the blockchain. Authentication Functions \u00b6 User Registration and Management \u00b6 registerUser : Register a new user with username, password, email, company, and name. verifyEmail : Verify a user's email with a token. retrieveEmailFromToken : Get the email associated with a token. requestPasswordReset : Request a password reset for a user. resetPassword : Reset a user's password with a token. updateUserByEmail : Update a user's profile by email. isUserOnboarded : Check if a user has completed onboarding. getUsersWithIdentityWallets : Get users who have identity wallets. Blockchain Management \u00b6 Network and Provider Management \u00b6 loadAllBlockchains : Get all configured blockchains. loadProviderUrl : Get the RPC endpoint for a network ID. loadProviderWebSocketUrl : Get the WebSocket endpoint for a network ID. loadAllProviderUrls : Get all provider URLs. loadBlockchainDataForNetwork : Get blockchain data (signer, provider, wallet) for a network. Contract Interaction \u00b6 Generic Contract Interaction \u00b6 addDiamondFacet : Add a facet to a diamond. callMethod : Call a method on a contract. viewMethod : View a method on a contract. callContractMethod : Call a method on a contract with custom parameters. viewContractMethod : View a method on a contract with custom parameters. loadSmartContractForNetwork : Load a smart contract for a network. loadSmartContractsForNetwork : Load all smart contracts for a network. DFNS Wallet Management \u00b6 DFNS is a wallet-as-a-service solution integrated with Gemforce for managing user wallets. User Registration and Authentication \u00b6 registerInit : Initialize DFNS user registration. registerComplete : Complete DFNS user registration. login : Login to DFNS. recoverInit : Initialize account recovery for DFNS. recoverComplete : Complete account recovery for DFNS. Wallet Management \u00b6 listWallets : List DFNS wallets. signaturesInit : Initialize a signature. signaturesComplete : Complete a signature. dfnsGetWallet : Get a DFNS wallet by ID. dfnsGetUSDC : Get USDC balance for a wallet. Transaction Management \u00b6 dfnsInitApproval / dfnsCompleteApproval : Approve tokens for spending. dfnsInitTransferUSDC / dfnsCompleteTransferUSDC : Transfer USDC. dfnsInitWithdraw / dfnsCompleteWithdraw : Withdraw tokens from the treasury. dfnsInitiatePurchase / dfnsCompletePurchase : Purchase an item from the marketplace. dfnsInitRetireCredits / dfnsCompleteRetireCredits : Retire carbon credits. Identity Management \u00b6 dfnsAddClaimTopicInit / dfnsAddClaimTopicComplete : Add a claim topic. dfnsAddTrustedIssuerInit / dfnsAddTrustedIssuerComplete : Add a trusted issuer. dfnsRemoveTrustedIssuerInit / dfnsRemoveTrustedIssuerComplete : Remove a trusted issuer. dfnsUpdateIssuerClaimTopicsInit / dfnsUpdateIssuerClaimTopicsComplete : Update claim topics for an issuer. dfnsCreateIdentityInit / dfnsCreateIdentityComplete : Create a digital identity. dfnsAddIdentityInit / dfnsAddIdentityComplete : Add an identity to the registry. dfnsRemoveIdentityInit / dfnsRemoveIdentityComplete : Remove an identity from the factory. dfnsUnregisterIdentityInit / dfnsUnregisterIdentityComplete : Remove an identity from the registry. dfnsSetClaimsInit / dfnsSetClaimsComplete : Set claims for an identity. dfnsAddClaimInit / dfnsAddClaimComplete : Add a claim to an identity. dfnsRemoveClaimInit / dfnsRemoveClaimComplete : Remove a claim from an identity. dfnsGetIdentity : Get the identity for an owner address. Asset Management \u00b6 dfnsGemforceMintInit / dfnsGemforceMintComplete : Mint a new token with metadata. Bridge API Integration \u00b6 Gemforce integrates with a Bridge API for handling financial operations. External Accounts \u00b6 createExternalAccount : Create an external account for a customer. getExternalAccounts : Get all external accounts for a customer. getExternalAccount : Get a specific external account for a customer. deleteExternalAccount : Delete an external account. Transfers \u00b6 createTransfer : Create a transfer between accounts. getCustomerTransfers : Get all transfers for a customer. KYC Management \u00b6 generateKycLink : Generate a KYC link for a user. getKycLinkStatus : Get the status of a KYC link. Plaid Integration \u00b6 getPlaidLinkToken : Get a Plaid link token for a customer. exchangePlaidPublicToken : Exchange a Plaid public token for access. Project Management \u00b6 getProjectMetadata : Get metadata for a project.","title":"Gemforce API Documentation"},{"location":"gemforce-api-documentation/#gemforce-api-documentation","text":"This document provides a comprehensive overview of the Gemforce API, detailing both the smart contract interfaces and cloud functions that power the system.","title":"Gemforce API Documentation"},{"location":"gemforce-api-documentation/#table-of-contents","text":"Introduction Smart Contract APIs Diamond Pattern DiamondFactory Identity Management Token and Asset Management Marketplace Carbon Credits Cloud Function APIs Authentication Functions Blockchain Management Contract Interaction DFNS Wallet Management Bridge API Integration Project Management","title":"Table of Contents"},{"location":"gemforce-api-documentation/#introduction","text":"Gemforce is a blockchain-powered platform that implements a Diamond pattern (EIP-2535) for upgradeable smart contracts, digital identity management, and token management. The platform combines on-chain smart contracts with off-chain cloud functions to provide a comprehensive solution for issuing, managing, and trading digital assets with verifiable claims.","title":"Introduction"},{"location":"gemforce-api-documentation/#smart-contract-apis","text":"","title":"Smart Contract APIs"},{"location":"gemforce-api-documentation/#diamond-pattern","text":"The Diamond pattern is the foundation of Gemforce's smart contract architecture. It provides a way to create upgradeable contracts that can be extended with new functionality without breaking existing functionality.","title":"Diamond Pattern"},{"location":"gemforce-api-documentation/#diamondsol","text":"The Diamond contract is the main contract that implements the Diamond pattern. Key functions: initialize(address _owner, DiamondSettings memory params, IDiamondCut.FacetCut[] memory _facets, address diamondInit, bytes calldata _calldata) : Initialize the diamond with owner, settings, and facets. diamondCut(IDiamondCut.FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) : Add, replace, or remove functions from the diamond. facets() : Get all facets and their selectors. facetFunctionSelectors(address _facet) : Get all function selectors for a facet. facetAddresses() : Get all facet addresses used by a diamond. facetAddress(bytes4 _functionSelector) : Get the facet that supports a given selector. transferOwnership(address _newOwner) : Transfer ownership of the diamond. owner() : Get the owner of the diamond.","title":"Diamond.sol"},{"location":"gemforce-api-documentation/#diamondfactory","text":"The DiamondFactory contract is used to create new Diamond contracts. Key functions: initialize(DiamondFactoryInit memory initData) : Initialize the factory with a set of facets. getFacets(string memory facetSet) : Get the facets for a facet set. setFacet(string memory facetSet, uint256 idx, IDiamondCut.FacetCut memory facetAddress) : Set a facet in a facet set. setFacets(string memory facetSet, IDiamondCut.FacetCut[] memory facetAddress) : Set multiple facets in a facet set. removeFacets(string memory facetSet) : Remove a facet set. getDiamondAddress(string memory symbol) : Get the address of a diamond by symbol. create(DiamondSettings memory params, address diamondInit, bytes calldata _calldata, IDiamondCut.FacetCut[] memory facets) : Create a new diamond with custom facets. createFromSet(DiamondSettings memory params, address diamondInit, bytes calldata _calldata, string memory facets) : Create a new diamond from a predefined facet set. add(string memory symbol, address payable diamondAddress) : Add an existing diamond to the factory. remove(string memory symbol) : Remove a diamond from the factory. exists(string memory symbol) : Check if a diamond exists. symbols() : Get all diamond symbols in the factory.","title":"DiamondFactory"},{"location":"gemforce-api-documentation/#identity-management","text":"Gemforce includes a digital identity system that allows for claims to be made about identities.","title":"Identity Management"},{"location":"gemforce-api-documentation/#identitysol","text":"The Identity contract represents a digital identity for a user. Key functions: initialize(address _owner, address _identityRegistry, address _trustedIssuerRegistry) : Initialize the identity with an owner, identity registry, and trusted issuer registry. getAttribute(string memory _key) : Get an attribute for a token ID keyed by string. setAttribute(string memory key, AttributeType attributeType, string memory value) : Set an attribute for a token ID. addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) : Add a key to the identity. removeKey(bytes32 _key, uint256 _purpose) : Remove a key from the identity. getKey(bytes32 _key) : Get a key from the identity. addClaim(uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) : Add a claim to the identity. removeClaim(bytes32 _claimId) : Remove a claim from the identity. getClaim(bytes32 _claimId) : Get a claim by ID. getClaimIdsByTopic(uint256 _topic) : Get claim IDs by topic. getClaimTopics() : Get all claim topics for the identity. isVerified() : Check if the identity is verified.","title":"Identity.sol"},{"location":"gemforce-api-documentation/#identityfactorysol","text":"The IdentityFactory contract creates new Identity contracts. Key functions: initialize(address identityRegistry, address trustedIssuerRegistry) : Initialize the factory with identity and trusted issuer registries. createIdentity(address ownerAddress) : Create a new identity for an owner. removeIdentity(address ownerAddress) : Remove an identity for an owner. getIdentity(address identityOwner) : Get the identity of an owner. getIdentityUsers() : Get all identity users.","title":"IdentityFactory.sol"},{"location":"gemforce-api-documentation/#claimtopicsregistryfacetsol","text":"Manages claim topics that can be used to make claims about identities. Key functions: addClaimTopic(uint256 _claimTopic) : Add a claim topic to the registry. removeClaimTopic(uint256 _claimTopic) : Remove a claim topic from the registry. getClaimTopics() : Get all claim topics.","title":"ClaimTopicsRegistryFacet.sol"},{"location":"gemforce-api-documentation/#trustedissuersregistryfacetsol","text":"Manages trusted issuers that can make claims about identities. Key functions: addTrustedIssuer(address _trustedIssuer, uint256[] calldata _claimTopics) : Add a trusted issuer with claim topics. removeTrustedIssuer(address _trustedIssuer) : Remove a trusted issuer. updateIssuerClaimTopics(address _trustedIssuer, uint256[] calldata _claimTopics) : Update claim topics for a trusted issuer. getTrustedIssuers() : Get all trusted issuers. getTrustedIssuerClaimTopics(address _trustedIssuer) : Get claim topics for a trusted issuer. isTrustedIssuer(address _issuer) : Check if an address is a trusted issuer. hasClaimTopic(address _trustedIssuer, uint256 _claimTopic) : Check if a trusted issuer has a claim topic.","title":"TrustedIssuersRegistryFacet.sol"},{"location":"gemforce-api-documentation/#token-and-asset-management","text":"","title":"Token and Asset Management"},{"location":"gemforce-api-documentation/#gemforceminterfacetsol","text":"The GemforceMinterFacet contract is used to mint tokens and set attributes. Key functions: gemforceMint(Attribute[] memory metadata) : Mint a new token with metadata.","title":"GemforceMinterFacet.sol"},{"location":"gemforce-api-documentation/#marketplace","text":"","title":"Marketplace"},{"location":"gemforce-api-documentation/#marketplacefacetsol","text":"The MarketplaceFacet contract provides functionality for buying and selling tokens. Key functions: purchaseItem(address contract, uint256 tokenId) : Purchase a token.","title":"MarketplaceFacet.sol"},{"location":"gemforce-api-documentation/#carbon-credits","text":"","title":"Carbon Credits"},{"location":"gemforce-api-documentation/#carboncreditfacetsol","text":"The CarbonCreditFacet contract provides functionality for managing carbon credits. Key functions: retireCarbonCredits(uint256 tokenId, uint256 amount) : Retire carbon credits for a token.","title":"CarbonCreditFacet.sol"},{"location":"gemforce-api-documentation/#cloud-function-apis","text":"Gemforce provides a set of cloud functions built on Parse Server that bridge the gap between client applications and the blockchain.","title":"Cloud Function APIs"},{"location":"gemforce-api-documentation/#authentication-functions","text":"","title":"Authentication Functions"},{"location":"gemforce-api-documentation/#user-registration-and-management","text":"registerUser : Register a new user with username, password, email, company, and name. verifyEmail : Verify a user's email with a token. retrieveEmailFromToken : Get the email associated with a token. requestPasswordReset : Request a password reset for a user. resetPassword : Reset a user's password with a token. updateUserByEmail : Update a user's profile by email. isUserOnboarded : Check if a user has completed onboarding. getUsersWithIdentityWallets : Get users who have identity wallets.","title":"User Registration and Management"},{"location":"gemforce-api-documentation/#blockchain-management","text":"","title":"Blockchain Management"},{"location":"gemforce-api-documentation/#network-and-provider-management","text":"loadAllBlockchains : Get all configured blockchains. loadProviderUrl : Get the RPC endpoint for a network ID. loadProviderWebSocketUrl : Get the WebSocket endpoint for a network ID. loadAllProviderUrls : Get all provider URLs. loadBlockchainDataForNetwork : Get blockchain data (signer, provider, wallet) for a network.","title":"Network and Provider Management"},{"location":"gemforce-api-documentation/#contract-interaction","text":"","title":"Contract Interaction"},{"location":"gemforce-api-documentation/#generic-contract-interaction","text":"addDiamondFacet : Add a facet to a diamond. callMethod : Call a method on a contract. viewMethod : View a method on a contract. callContractMethod : Call a method on a contract with custom parameters. viewContractMethod : View a method on a contract with custom parameters. loadSmartContractForNetwork : Load a smart contract for a network. loadSmartContractsForNetwork : Load all smart contracts for a network.","title":"Generic Contract Interaction"},{"location":"gemforce-api-documentation/#dfns-wallet-management","text":"DFNS is a wallet-as-a-service solution integrated with Gemforce for managing user wallets.","title":"DFNS Wallet Management"},{"location":"gemforce-api-documentation/#user-registration-and-authentication","text":"registerInit : Initialize DFNS user registration. registerComplete : Complete DFNS user registration. login : Login to DFNS. recoverInit : Initialize account recovery for DFNS. recoverComplete : Complete account recovery for DFNS.","title":"User Registration and Authentication"},{"location":"gemforce-api-documentation/#wallet-management","text":"listWallets : List DFNS wallets. signaturesInit : Initialize a signature. signaturesComplete : Complete a signature. dfnsGetWallet : Get a DFNS wallet by ID. dfnsGetUSDC : Get USDC balance for a wallet.","title":"Wallet Management"},{"location":"gemforce-api-documentation/#transaction-management","text":"dfnsInitApproval / dfnsCompleteApproval : Approve tokens for spending. dfnsInitTransferUSDC / dfnsCompleteTransferUSDC : Transfer USDC. dfnsInitWithdraw / dfnsCompleteWithdraw : Withdraw tokens from the treasury. dfnsInitiatePurchase / dfnsCompletePurchase : Purchase an item from the marketplace. dfnsInitRetireCredits / dfnsCompleteRetireCredits : Retire carbon credits.","title":"Transaction Management"},{"location":"gemforce-api-documentation/#identity-management_1","text":"dfnsAddClaimTopicInit / dfnsAddClaimTopicComplete : Add a claim topic. dfnsAddTrustedIssuerInit / dfnsAddTrustedIssuerComplete : Add a trusted issuer. dfnsRemoveTrustedIssuerInit / dfnsRemoveTrustedIssuerComplete : Remove a trusted issuer. dfnsUpdateIssuerClaimTopicsInit / dfnsUpdateIssuerClaimTopicsComplete : Update claim topics for an issuer. dfnsCreateIdentityInit / dfnsCreateIdentityComplete : Create a digital identity. dfnsAddIdentityInit / dfnsAddIdentityComplete : Add an identity to the registry. dfnsRemoveIdentityInit / dfnsRemoveIdentityComplete : Remove an identity from the factory. dfnsUnregisterIdentityInit / dfnsUnregisterIdentityComplete : Remove an identity from the registry. dfnsSetClaimsInit / dfnsSetClaimsComplete : Set claims for an identity. dfnsAddClaimInit / dfnsAddClaimComplete : Add a claim to an identity. dfnsRemoveClaimInit / dfnsRemoveClaimComplete : Remove a claim from an identity. dfnsGetIdentity : Get the identity for an owner address.","title":"Identity Management"},{"location":"gemforce-api-documentation/#asset-management","text":"dfnsGemforceMintInit / dfnsGemforceMintComplete : Mint a new token with metadata.","title":"Asset Management"},{"location":"gemforce-api-documentation/#bridge-api-integration","text":"Gemforce integrates with a Bridge API for handling financial operations.","title":"Bridge API Integration"},{"location":"gemforce-api-documentation/#external-accounts","text":"createExternalAccount : Create an external account for a customer. getExternalAccounts : Get all external accounts for a customer. getExternalAccount : Get a specific external account for a customer. deleteExternalAccount : Delete an external account.","title":"External Accounts"},{"location":"gemforce-api-documentation/#transfers","text":"createTransfer : Create a transfer between accounts. getCustomerTransfers : Get all transfers for a customer.","title":"Transfers"},{"location":"gemforce-api-documentation/#kyc-management","text":"generateKycLink : Generate a KYC link for a user. getKycLinkStatus : Get the status of a KYC link.","title":"KYC Management"},{"location":"gemforce-api-documentation/#plaid-integration","text":"getPlaidLinkToken : Get a Plaid link token for a customer. exchangePlaidPublicToken : Exchange a Plaid public token for access.","title":"Plaid Integration"},{"location":"gemforce-api-documentation/#project-management","text":"getProjectMetadata : Get metadata for a project.","title":"Project Management"},{"location":"gemforce-api-quick-reference/","text":"Gemforce API Quick Reference \u00b6 This document provides a concise reference for developers who need to interact with the Gemforce API, including smart contract calls and cloud function endpoints. Smart Contract Interactions \u00b6 Diamond Pattern \u00b6 The Diamond pattern allows for modular and upgradeable smart contracts. All functionality is implemented through facets. // Get the diamond address by symbol address diamondAddress = diamondFactory . getDiamondAddress ( \"GEM\" ); // Check if a diamond exists bool exists = diamondFactory . exists ( \"GEM\" ); // Create a new diamond DiamondSettings memory settings = DiamondSettings ({ name : \"Gemforce\" , symbol : \"GEM\" , // Other settings... }); address newDiamond = diamondFactory . createFromSet ( settings , initializer , initData , \"defaultFacetSet\" ); Identity Management \u00b6 // Create a new identity identityFactory . createIdentity ( userAddress ); // Get an identity address identityAddress = identityFactory . getIdentity ( userAddress ); // Add a claim topic claimTopicsRegistry . addClaimTopic ( 1 ); // e.g., KYC claim // Add a trusted issuer uint256 [] memory topics = new uint256 []( 1 ); topics [ 0 ] = 1 ; // KYC claim topic trustedIssuersRegistry . addTrustedIssuer ( issuerAddress , topics ); // Add a claim identity . addClaim ( 1 , // topic 1 , // scheme issuerAddress , signature , data , \"https://example.com/claim\" ); // Check if an identity has a claim bool hasKYC = identity . getClaim ( claimId ) != 0 ; Token Management \u00b6 // Mint a new token Attribute [] memory attributes = new Attribute []( 2 ); attributes [ 0 ] = Attribute ( \"name\" , AttributeType . String , \"Carbon Credit\" ); attributes [ 1 ] = Attribute ( \"amount\" , AttributeType . Number , \"100\" ); uint256 tokenId = gemforceMinter . gemforceMint ( attributes ); // Purchase a token marketplace . purchaseItem ( diamondAddress , tokenId ); // Retire carbon credits carbonCredits . retireCarbonCredits ( tokenId , 50 ); Cloud Function APIs \u00b6 Authentication \u00b6 // Register a user Parse . Cloud . run ( \"registerUser\" , { username : \"user@example.com\" , password : \"password123\" , email : \"user@example.com\" , company : \"Example Corp\" , firstName : \"John\" , lastName : \"Doe\" }). then ( result => { console . log ( \"User registered:\" , result ); }); // Login (using Parse SDK) Parse . User . logIn ( \"username\" , \"password\" ). then ( user => { console . log ( \"Logged in:\" , user ); }); DFNS Wallet Management \u00b6 // Register with DFNS Parse . Cloud . run ( \"registerInit\" , { username : \"user@example.com\" }). then ( challenge => { // Handle challenge with WebAuthn // Then complete registration return Parse . Cloud . run ( \"registerComplete\" , { signedChallenge : signedChallenge , temporaryAuthenticationToken : tempToken }); }). then ( result => { console . log ( \"DFNS registration complete:\" , result ); }); // Login to DFNS Parse . Cloud . run ( \"login\" , { username : \"user@example.com\" }). then ( result => { const dfnsToken = result . token ; // Store DFNS token for future operations }); // List wallets Parse . Cloud . run ( \"listWallets\" , { authToken : dfnsToken }). then ( wallets => { console . log ( \"User wallets:\" , wallets ); }); Contract Interactions via DFNS \u00b6 This pattern is used for all blockchain interactions through DFNS: 1. Initialize the transaction 2. Sign the challenge client-side 3. Complete the transaction with the signed challenge // Example: Purchase an item Parse . Cloud . run ( \"dfnsInitiatePurchase\" , { tokenId : \"123\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side using DFNS SDK const signedChallenge = await signChallenge ( challenge ); // Complete the purchase return Parse . Cloud . run ( \"dfnsCompletePurchase\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Purchase complete:\" , result ); }); Identity Management via DFNS \u00b6 // Create an identity Parse . Cloud . run ( \"dfnsCreateIdentityInit\" , { ownerAddress : \"0x123...\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete the identity creation return Parse . Cloud . run ( \"dfnsCreateIdentityComplete\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Identity created:\" , result ); }); // Add a claim topic Parse . Cloud . run ( \"dfnsAddClaimTopicInit\" , { claimTopic : 1 , // e.g., KYC claim walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete adding claim topic return Parse . Cloud . run ( \"dfnsAddClaimTopicComplete\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Claim topic added:\" , result ); }); Carbon Credit Management \u00b6 // Retire carbon credits Parse . Cloud . run ( \"dfnsInitRetireCredits\" , { tokenId : \"123\" , amount : \"50\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete retirement return Parse . Cloud . run ( \"dfnsCompleteRetireCredits\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Credits retired:\" , result ); }); Bridge API Integration \u00b6 // Create an external account Parse . Cloud . run ( \"createExternalAccount\" , { customer_id : \"cust_123\" , currency : \"usd\" , account_owner_name : \"John Doe\" , account_type : \"us\" , account : { account_number : \"123456789\" , routing_number : \"123456789\" , checking_or_savings : \"checking\" } }). then ( result => { console . log ( \"External account created:\" , result ); }); // Create a transfer Parse . Cloud . run ( \"createTransfer\" , { amount : \"100.00\" , on_behalf_of : \"cust_123\" , source : { currency : \"usd\" , payment_rail : \"ach\" , external_account_id : \"ext_acct_123\" }, destination : { currency : \"usdc\" , payment_rail : \"ethereum\" , to_address : \"0x123...\" } }). then ( result => { console . log ( \"Transfer created:\" , result ); }); Plaid Integration \u00b6 // Get a Plaid link token Parse . Cloud . run ( \"getPlaidLinkToken\" , { customerId : \"cust_123\" }). then ( result => { const linkToken = result . link_token ; // Use linkToken with Plaid Link }); // Exchange a Plaid public token Parse . Cloud . run ( \"exchangePlaidPublicToken\" , { customerId : \"cust_123\" , linkToken : \"link-123\" , publicToken : \"public-123\" }). then ( result => { console . log ( \"Plaid token exchanged:\" , result ); }); Common Patterns \u00b6 Two-Step Transaction Pattern \u00b6 Most blockchain interactions follow this pattern: Initialization Step : Call the *Init function with required parameters Receive a challenge and request body Completion Step : Sign the challenge client-side (typically with WebAuthn) Call the *Complete function with the signed challenge and request body Receive transaction result Error Handling \u00b6 Parse . Cloud . run ( \"someFunction\" , params ) . then ( result => { // Handle success }) . catch ( error => { // Parse Server error codes if ( error . code === Parse . Error . VALIDATION_ERROR ) { console . error ( \"Validation error:\" , error . message ); } else if ( error . code === Parse . Error . SCRIPT_FAILED ) { console . error ( \"Script error:\" , error . message ); } else { console . error ( \"Unknown error:\" , error ); } }); Important Considerations \u00b6 Authentication : Always ensure users are authenticated before accessing protected endpoints. DFNS Token Management : Store the DFNS token securely and refresh it when needed. Transaction Monitoring : Monitor transaction status after submission as blockchain transactions can take time to confirm. Gas Management : Be mindful of gas costs for transactions, especially for operations like minting tokens. Error Handling : Implement robust error handling for both client-side and server-side errors. Idempotency : Use idempotency keys for financial operations to prevent duplicate transactions. Wallet Address Validation : Validate Ethereum addresses before sending transactions. Testing : Test all interactions on test networks before moving to production.","title":"Gemforce API Quick Reference"},{"location":"gemforce-api-quick-reference/#gemforce-api-quick-reference","text":"This document provides a concise reference for developers who need to interact with the Gemforce API, including smart contract calls and cloud function endpoints.","title":"Gemforce API Quick Reference"},{"location":"gemforce-api-quick-reference/#smart-contract-interactions","text":"","title":"Smart Contract Interactions"},{"location":"gemforce-api-quick-reference/#diamond-pattern","text":"The Diamond pattern allows for modular and upgradeable smart contracts. All functionality is implemented through facets. // Get the diamond address by symbol address diamondAddress = diamondFactory . getDiamondAddress ( \"GEM\" ); // Check if a diamond exists bool exists = diamondFactory . exists ( \"GEM\" ); // Create a new diamond DiamondSettings memory settings = DiamondSettings ({ name : \"Gemforce\" , symbol : \"GEM\" , // Other settings... }); address newDiamond = diamondFactory . createFromSet ( settings , initializer , initData , \"defaultFacetSet\" );","title":"Diamond Pattern"},{"location":"gemforce-api-quick-reference/#identity-management","text":"// Create a new identity identityFactory . createIdentity ( userAddress ); // Get an identity address identityAddress = identityFactory . getIdentity ( userAddress ); // Add a claim topic claimTopicsRegistry . addClaimTopic ( 1 ); // e.g., KYC claim // Add a trusted issuer uint256 [] memory topics = new uint256 []( 1 ); topics [ 0 ] = 1 ; // KYC claim topic trustedIssuersRegistry . addTrustedIssuer ( issuerAddress , topics ); // Add a claim identity . addClaim ( 1 , // topic 1 , // scheme issuerAddress , signature , data , \"https://example.com/claim\" ); // Check if an identity has a claim bool hasKYC = identity . getClaim ( claimId ) != 0 ;","title":"Identity Management"},{"location":"gemforce-api-quick-reference/#token-management","text":"// Mint a new token Attribute [] memory attributes = new Attribute []( 2 ); attributes [ 0 ] = Attribute ( \"name\" , AttributeType . String , \"Carbon Credit\" ); attributes [ 1 ] = Attribute ( \"amount\" , AttributeType . Number , \"100\" ); uint256 tokenId = gemforceMinter . gemforceMint ( attributes ); // Purchase a token marketplace . purchaseItem ( diamondAddress , tokenId ); // Retire carbon credits carbonCredits . retireCarbonCredits ( tokenId , 50 );","title":"Token Management"},{"location":"gemforce-api-quick-reference/#cloud-function-apis","text":"","title":"Cloud Function APIs"},{"location":"gemforce-api-quick-reference/#authentication","text":"// Register a user Parse . Cloud . run ( \"registerUser\" , { username : \"user@example.com\" , password : \"password123\" , email : \"user@example.com\" , company : \"Example Corp\" , firstName : \"John\" , lastName : \"Doe\" }). then ( result => { console . log ( \"User registered:\" , result ); }); // Login (using Parse SDK) Parse . User . logIn ( \"username\" , \"password\" ). then ( user => { console . log ( \"Logged in:\" , user ); });","title":"Authentication"},{"location":"gemforce-api-quick-reference/#dfns-wallet-management","text":"// Register with DFNS Parse . Cloud . run ( \"registerInit\" , { username : \"user@example.com\" }). then ( challenge => { // Handle challenge with WebAuthn // Then complete registration return Parse . Cloud . run ( \"registerComplete\" , { signedChallenge : signedChallenge , temporaryAuthenticationToken : tempToken }); }). then ( result => { console . log ( \"DFNS registration complete:\" , result ); }); // Login to DFNS Parse . Cloud . run ( \"login\" , { username : \"user@example.com\" }). then ( result => { const dfnsToken = result . token ; // Store DFNS token for future operations }); // List wallets Parse . Cloud . run ( \"listWallets\" , { authToken : dfnsToken }). then ( wallets => { console . log ( \"User wallets:\" , wallets ); });","title":"DFNS Wallet Management"},{"location":"gemforce-api-quick-reference/#contract-interactions-via-dfns","text":"This pattern is used for all blockchain interactions through DFNS: 1. Initialize the transaction 2. Sign the challenge client-side 3. Complete the transaction with the signed challenge // Example: Purchase an item Parse . Cloud . run ( \"dfnsInitiatePurchase\" , { tokenId : \"123\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side using DFNS SDK const signedChallenge = await signChallenge ( challenge ); // Complete the purchase return Parse . Cloud . run ( \"dfnsCompletePurchase\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Purchase complete:\" , result ); });","title":"Contract Interactions via DFNS"},{"location":"gemforce-api-quick-reference/#identity-management-via-dfns","text":"// Create an identity Parse . Cloud . run ( \"dfnsCreateIdentityInit\" , { ownerAddress : \"0x123...\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete the identity creation return Parse . Cloud . run ( \"dfnsCreateIdentityComplete\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Identity created:\" , result ); }); // Add a claim topic Parse . Cloud . run ( \"dfnsAddClaimTopicInit\" , { claimTopic : 1 , // e.g., KYC claim walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete adding claim topic return Parse . Cloud . run ( \"dfnsAddClaimTopicComplete\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Claim topic added:\" , result ); });","title":"Identity Management via DFNS"},{"location":"gemforce-api-quick-reference/#carbon-credit-management","text":"// Retire carbon credits Parse . Cloud . run ( \"dfnsInitRetireCredits\" , { tokenId : \"123\" , amount : \"50\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete retirement return Parse . Cloud . run ( \"dfnsCompleteRetireCredits\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Credits retired:\" , result ); });","title":"Carbon Credit Management"},{"location":"gemforce-api-quick-reference/#bridge-api-integration","text":"// Create an external account Parse . Cloud . run ( \"createExternalAccount\" , { customer_id : \"cust_123\" , currency : \"usd\" , account_owner_name : \"John Doe\" , account_type : \"us\" , account : { account_number : \"123456789\" , routing_number : \"123456789\" , checking_or_savings : \"checking\" } }). then ( result => { console . log ( \"External account created:\" , result ); }); // Create a transfer Parse . Cloud . run ( \"createTransfer\" , { amount : \"100.00\" , on_behalf_of : \"cust_123\" , source : { currency : \"usd\" , payment_rail : \"ach\" , external_account_id : \"ext_acct_123\" }, destination : { currency : \"usdc\" , payment_rail : \"ethereum\" , to_address : \"0x123...\" } }). then ( result => { console . log ( \"Transfer created:\" , result ); });","title":"Bridge API Integration"},{"location":"gemforce-api-quick-reference/#plaid-integration","text":"// Get a Plaid link token Parse . Cloud . run ( \"getPlaidLinkToken\" , { customerId : \"cust_123\" }). then ( result => { const linkToken = result . link_token ; // Use linkToken with Plaid Link }); // Exchange a Plaid public token Parse . Cloud . run ( \"exchangePlaidPublicToken\" , { customerId : \"cust_123\" , linkToken : \"link-123\" , publicToken : \"public-123\" }). then ( result => { console . log ( \"Plaid token exchanged:\" , result ); });","title":"Plaid Integration"},{"location":"gemforce-api-quick-reference/#common-patterns","text":"","title":"Common Patterns"},{"location":"gemforce-api-quick-reference/#two-step-transaction-pattern","text":"Most blockchain interactions follow this pattern: Initialization Step : Call the *Init function with required parameters Receive a challenge and request body Completion Step : Sign the challenge client-side (typically with WebAuthn) Call the *Complete function with the signed challenge and request body Receive transaction result","title":"Two-Step Transaction Pattern"},{"location":"gemforce-api-quick-reference/#error-handling","text":"Parse . Cloud . run ( \"someFunction\" , params ) . then ( result => { // Handle success }) . catch ( error => { // Parse Server error codes if ( error . code === Parse . Error . VALIDATION_ERROR ) { console . error ( \"Validation error:\" , error . message ); } else if ( error . code === Parse . Error . SCRIPT_FAILED ) { console . error ( \"Script error:\" , error . message ); } else { console . error ( \"Unknown error:\" , error ); } });","title":"Error Handling"},{"location":"gemforce-api-quick-reference/#important-considerations","text":"Authentication : Always ensure users are authenticated before accessing protected endpoints. DFNS Token Management : Store the DFNS token securely and refresh it when needed. Transaction Monitoring : Monitor transaction status after submission as blockchain transactions can take time to confirm. Gas Management : Be mindful of gas costs for transactions, especially for operations like minting tokens. Error Handling : Implement robust error handling for both client-side and server-side errors. Idempotency : Use idempotency keys for financial operations to prevent duplicate transactions. Wallet Address Validation : Validate Ethereum addresses before sending transactions. Testing : Test all interactions on test networks before moving to production.","title":"Important Considerations"},{"location":"gemforce-deployer-guide/","text":"Gemforce Deployer Guide \u00b6 Table of Contents \u00b6 Deployment Prerequisites Smart Contract Deployment Cloud Functions Deployment Environment Configuration Deployment Automation Upgrade Procedures Rollback Procedures Testing and Verification Network Management Version Control Deployment Prerequisites \u00b6 Development Environment Setup \u00b6 To deploy the Gemforce platform, you'll need the following tools and software: Node.js and npm : Node.js v16 or later npm v7 or later ```bash # Install using nvm (recommended) nvm install 16 nvm use 16 # Verify installation node -v npm -v ``` Hardhat : Used for smart contract development and deployment ```bash # Install hardhat npm install --save-dev hardhat # Verify installation npx hardhat --version ``` MongoDB : Version 4.4 or later Required for Parse Server ```bash # Installation varies by OS # macOS (using Homebrew) brew install mongodb-community # Verify installation mongod --version ``` Git : For version control bash # Verify installation git --version TypeScript : Latest version ```bash # Install TypeScript npm install -g typescript # Verify installation tsc --version ``` Required Tools and Software \u00b6 Development IDE : Visual Studio Code (recommended) Plugins: Solidity TypeScript ESLint Prettier Blockchain Tools : MetaMask or similar wallet Etherscan account (for contract verification) Infura or Alchemy account (for RPC endpoints) Deployment Tools : PM2 (for process management) Docker (optional, for containerized deployment) ```bash # Install PM2 npm install -g pm2 # Verify installation pm2 --version ``` Database Tools : MongoDB Compass (GUI for MongoDB) MongoDB Database Tools (mongodump, mongorestore) Network Access Requirements \u00b6 Ensure your deployment environment has access to: Blockchain Networks : Ethereum Mainnet (if deploying to production) BaseSepolia (for testing) Other EVM-compatible networks as needed External APIs : DFNS API Bridge API SendGrid API Database Access : MongoDB server (local or hosted) Redis (if using for caching) Github/Version Control : Access to Gemforce repositories Key Management Setup \u00b6 Create a secure key management strategy : bash # Create a directory for keys (outside of repository) mkdir -p ~/.gemforce/keys chmod 700 ~/.gemforce/keys Generate deployment keys : ```bash # Generate a private key for deployment openssl genpkey -algorithm RSA -out ~/.gemforce/keys/deployment_key.pem -pkeyopt rsa_keygen_bits:2048 chmod 600 ~/.gemforce/keys/deployment_key.pem # Generate a DFNS private key openssl genpkey -algorithm RSA -out ~/.gemforce/keys/dfns_private.key -pkeyopt rsa_keygen_bits:2048 chmod 600 ~/.gemforce/keys/dfns_private.key ``` Use environment files for sensitive data : ```bash # Create a .env file for local development cp .env.example .env # Edit to add your keys and endpoints nano .env ``` Environment Preparation \u00b6 Clone the repository : bash git clone https://github.com/your-org/gemforce.git cd gemforce Install dependencies : bash npm install Set up environment files : ```bash # Copy sample environment files cp .env.example .env cp gemforce.config.example.ts gemforce.config.ts # Edit the files with your configuration nano .env nano gemforce.config.ts ``` Create deployment directories : bash mkdir -p deployments Smart Contract Deployment \u00b6 Contract Compilation \u00b6 Compile contracts using Hardhat : bash npx hardhat compile Verify compilation output : Check for successful compilation in artifacts/ directory Resolve any compilation errors Configuration for different networks : javascript // hardhat.config.ts module.exports = { solidity: { version: \"0.8.17\", settings: { optimizer: { enabled: true, runs: 200 } } }, networks: { hardhat: { chainId: 31337 }, baseSepolia: { url: `https://sepolia.base.org`, accounts: [process.env.PRIVATE_KEY], chainId: 84532 }, mainnet: { url: `https://mainnet.infura.io/v3/${process.env.INFURA_KEY}`, accounts: [process.env.PRIVATE_KEY], chainId: 1 } } }; Diamond Pattern Deployment Workflow \u00b6 The Gemforce platform uses the Diamond pattern (EIP-2535) for smart contract deployment: Deploy libraries first : bash npx hardhat deploy --tags Libraries --network baseSepolia Deploy facets : bash npx hardhat deploy --tags Facets --network baseSepolia Deploy Diamond contract : bash npx hardhat deploy --tags Diamond --network baseSepolia Verify the deployment : bash npx hardhat verify --network baseSepolia <DIAMOND_ADDRESS> Facet Deployment Process \u00b6 Develop new facets in the /contracts/facets directory Add to deployment scripts in /deploy directory Set up facet cut data for the Diamond contract: javascript // Example facet cut data const facetCuts = [ { facetAddress: newFacetAddress, action: FacetCutAction.Add, functionSelectors: selectors } ]; Update the Diamond with new facets: javascript // Using the DiamondFactory await diamondFactory.setFacets(setName, facetCuts); Contract Initialization \u00b6 Prepare initialization data : javascript // Example initialization data const initData = diamondInit.interface.encodeFunctionData(\"init\", [ [ // Initial parameters tokenName, tokenSymbol, baseURI, // ...other params ] ]); Initialize the Diamond : ```javascript const settings = { name: \"Gemforce Token\", symbol: \"GEM\", // other settings }; await diamondFactory.createFromSet( settings, diamondInit.address, initData, \"defaultFacetSet\" ); ``` Contract Verification \u00b6 Verify Diamond contract on Etherscan/Basescan : bash npx hardhat verify --network baseSepolia <DIAMOND_ADDRESS> Verify individual facets : bash npx hardhat verify --network baseSepolia <FACET_ADDRESS> Manual verification (if automatic verification fails): Flatten the contract using Hardhat Upload the flattened contract to the block explorer Verify with the correct compiler settings Gas Optimization Strategies \u00b6 Use optimized Solidity patterns : Minimize storage operations Batch operations where possible Use efficient data structures Configure gas prices for deployment : javascript // Example configuration for gas const tx = await contract.functionName(params, { gasPrice: (await ethers.provider.getGasPrice()).mul(2), // 2x current gas price gasLimit: 5000000 }); Monitor gas usage during testing : javascript // Add gas reporter to Hardhat config gasReporter: { enabled: true, currency: 'USD', gasPrice: 100, coinmarketcap: process.env.COINMARKETCAP_API_KEY } Cloud Functions Deployment \u00b6 Parse Server Deployment \u00b6 Prepare Parse Server configuration : javascript // Example Parse Server configuration const parseServerConfig = { appId: process.env.APP_ID, masterKey: process.env.MASTER_KEY, databaseURI: process.env.DATABASE_URI, serverURL: process.env.SERVER_URL, cloud: \"./dist/src/cloud-functions.js\", allowClientClassCreation: false, enableAnonymousUsers: false, maxUploadSize: \"20mb\", // ... other configuration }; Deploy Parse Server : Using PM2: ```bash # Start Parse Server with PM2 pm2 start app.js --name gemforce-server # Save PM2 configuration pm2 save # Set up PM2 to start on system boot pm2 startup ``` Using Docker: ```bash # Build Docker image docker build -t gemforce-server . # Run container docker run -d -p 1337:1337 \\ --env-file .env \\ --name gemforce-server \\ gemforce-server ``` Verify Parse Server deployment : ```bash # Check server status curl https://your-server-url.com/parse/health # Expected response: {\"status\":\"ok\"} ``` Cloud Function Deployment \u00b6 Compile TypeScript files : bash # Build the project npm run build Deploy cloud functions : If using PM2: bash # Restart the server to apply changes pm2 restart gemforce-server If using Docker: bash # Rebuild and redeploy docker build -t gemforce-server . docker stop gemforce-server docker rm gemforce-server docker run -d -p 1337:1337 \\ --env-file .env \\ --name gemforce-server \\ gemforce-server Verify cloud function deployment : bash # Test a simple cloud function curl -X POST \\ -H \"X-Parse-Application-Id: ${APP_ID}\" \\ -H \"Content-Type: application/json\" \\ -d '{}' \\ https://your-server-url.com/parse/functions/loadAllBlockchains Environment Configuration \u00b6 Set environment variables : ```bash # Set environment variables in .env file cat > .env << EOL # Parse Server APP_ID=your_app_id MASTER_KEY=your_master_key DATABASE_URI=mongodb://username:password@host:port/database SERVER_URL=https://your-server-url.com/parse # Blockchain ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=base-sepolia PRIVATE_KEY=your_private_key # External Services DFNS_APP_ID=your_dfns_app_id DFNS_API_URL=https://api.dfns.io DFNS_CRED_ID=your_dfns_credential_id # Additional Configuration METADATA_BASE_URI=https://metadata.gemforce.com/ EOL ``` Configure database : Set up MongoDB Create database user Configure connection string Set up web server (nginx example): ```nginx # /etc/nginx/sites-available/gemforce server { listen 80; server_name api.gemforce.com; location / { return 301 https://$host$request_uri; } } server { listen 443 ssl; server_name api.gemforce.com; ssl_certificate /etc/letsencrypt/live/api.gemforce.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/api.gemforce.com/privkey.pem; location / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } ``` Database Migration \u00b6 Create database migrations : ```javascript // Example migration script (migrations/001_add_indexes.js) async function up(db) { await db.collection('User').createIndex({ walletAddress: 1 }); await db.collection('Identity').createIndex({ walletAddress: 1 }, { unique: true }); await db.collection('Transaction').createIndex({ hash: 1 }, { unique: true }); } async function down(db) { await db.collection('User').dropIndex({ walletAddress: 1 }); await db.collection('Identity').dropIndex({ walletAddress: 1 }); await db.collection('Transaction').dropIndex({ hash: 1 }); } module.exports = { up, down }; ``` Run migrations : bash # Example using a simple migration tool npx migrate-mongo up Verify migrations : javascript // Check indexes db.User.getIndexes() db.Identity.getIndexes() db.Transaction.getIndexes() WebSocket Setup \u00b6 Configure WebSocket endpoints : ```javascript // Example WebSocket server setup const wss = new WebSocketServer({ server: httpServer, path: \"/ws\" }); wss.on('connection', (ws) => { // Handle connection ws.on('message', (message) => { // Handle message }); ws.on('close', () => { // Handle disconnection }); }); ``` Set up blockchain event listeners : ```javascript // Example blockchain event listener function setupEventListeners(provider, diamondAddress) { const diamond = new ethers.Contract( diamondAddress, DiamondABI, provider ); diamond.on(\"Transfer\", (from, to, tokenId) => { // Handle transfer event // Broadcast to connected WebSocket clients wss.clients.forEach((client) => { if (client.readyState === WebSocket.OPEN) { client.send(JSON.stringify({ event: \"Transfer\", data: { from, to, tokenId: tokenId.toString() } })); } }); }); } ``` Environment Configuration \u00b6 Development Environment \u00b6 Local environment setup : ```bash # Start local hardhat node npx hardhat node # Deploy contracts to local node npx hardhat deploy --network localhost # Start Parse Server locally npm run dev ``` Environment configuration file for development : ``` # .env.development APP_ID=gemforce_dev MASTER_KEY=your_dev_master_key DATABASE_URI=mongodb://localhost:27017/gemforce_dev SERVER_URL=http://localhost:1337/parse # Use local hardhat node ETH_NODE_URI_LOCAL=http://localhost:8545 CHAIN_ID=31337 # Development keys PRIVATE_KEY=your_dev_private_key ``` Development database setup : ```bash # Start MongoDB locally mongod --dbpath ./data # Create database and user mongo use gemforce_dev db.createUser({ user: \"gemforce_user\", pwd: \"password\", roles: [{ role: \"readWrite\", db: \"gemforce_dev\" }] }) ``` Testing Environment \u00b6 Testing environment configuration : ``` # .env.test APP_ID=gemforce_test MASTER_KEY=your_test_master_key DATABASE_URI=mongodb://localhost:27017/gemforce_test SERVER_URL=http://localhost:1337/parse # Use BaseSepolia for testing ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=84532 # Test keys PRIVATE_KEY=your_test_private_key ``` Automated testing setup : ```bash # Run tests npm test # Run specific tests npx mocha test/specific-test.js ``` Test database initialization : javascript // Initialize test database before(async () => { const client = await MongoClient.connect(process.env.DATABASE_URI); const db = client.db(); await db.collection('User').deleteMany({}); await db.collection('Identity').deleteMany({}); // Seed with test data await db.collection('User').insertMany(testUsers); }); Staging Environment \u00b6 Staging environment configuration : ``` # .env.staging APP_ID=gemforce_staging MASTER_KEY=your_staging_master_key DATABASE_URI=mongodb://user:password@staging-db:27017/gemforce_staging SERVER_URL=https://staging-api.gemforce.com/parse # Use BaseSepolia for staging ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=84532 # Staging keys PRIVATE_KEY=your_staging_private_key ``` Staging deployment : ```bash # Deploy to staging npm run deploy:staging # Run database migrations npm run migrate:staging ``` Staging verification : bash # Verify staging deployment curl https://staging-api.gemforce.com/parse/health Production Environment \u00b6 Production environment configuration : ``` # .env.production APP_ID=gemforce_prod MASTER_KEY=your_production_master_key DATABASE_URI=mongodb://user:password@production-db:27017/gemforce_production SERVER_URL=https://api.gemforce.com/parse # Use production endpoints ETH_NODE_URI_MAINNET=https://mainnet.infura.io/v3/your_infura_key CHAIN_ID=1 # Production keys stored securely # PRIVATE_KEY should be handled with extra security ``` Production deployment steps : ```bash # Deploy to production npm run deploy:production # Run database migrations npm run migrate:production ``` Production verification : ```bash # Verify production deployment curl https://api.gemforce.com/parse/health # Monitor logs pm2 logs gemforce-server ``` Environment-Specific Settings \u00b6 Configuration management : ``javascript // Load environment-specific configuration const envConfig = require( ./config/${process.env.NODE_ENV || 'development'}`); module.exports = { // Base configuration appName: 'Gemforce', // Merge with environment-specific config ...envConfig }; ``` Feature flags : ```javascript // Example feature flags configuration const featureFlags = { development: { enableNewMarketplace: true, enableCarbonCredits: true }, staging: { enableNewMarketplace: true, enableCarbonCredits: false }, production: { enableNewMarketplace: false, enableCarbonCredits: false } }; // Usage if (featureFlags[process.env.NODE_ENV].enableNewMarketplace) { // Initialize new marketplace } ``` Deployment Automation \u00b6 CI/CD Pipeline Setup \u00b6 GitHub Actions workflow : ```yaml # .github/workflows/deploy.yml name: Deploy Gemforce on: push: branches: [ main, staging ] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: '16' - name: Install dependencies run: npm ci - name: Run tests run: npm test build: needs: test runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: '16' - name: Install dependencies run: npm ci - name: Build project run: npm run build - name: Upload build artifacts uses: actions/upload-artifact@v2 with: name: build path: dist/ deploy: needs: build runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Download build artifacts uses: actions/download-artifact@v2 with: name: build path: dist/ - name: Deploy to server uses: appleboy/ssh-action@master with: host: ${{ secrets.SERVER_HOST }} username: ${{ secrets.SERVER_USERNAME }} key: ${{ secrets.SSH_PRIVATE_KEY }} script: | cd /var/www/gemforce git pull npm ci cp -r ${{ github.workspace }}/dist/* ./dist/ pm2 restart gemforce-server ``` Automatic testing : ```yaml # .github/workflows/test.yml name: Test Gemforce on: pull_request: branches: [ main, staging ] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: '16' - name: Install dependencies run: npm ci - name: Run linting run: npm run lint - name: Run tests run: npm test ``` Automated Testing \u00b6 Unit tests for smart contracts : ```javascript // test/GemforceMinter.test.ts describe(\"GemforceMinter\", function() { let owner, user; let diamond, gemforceMinter; beforeEach(async function() { [owner, user] = await ethers.getSigners(); // Deploy diamond with GemforceMinterFacet // ...deployment code gemforceMinter = await ethers.getContractAt(\"GemforceMinterFacet\", diamond.address); }); it(\"should mint a token with metadata\", async function() { const metadata = [ { key: \"name\", attributeType: 0, value: \"Carbon Credit\" }, { key: \"amount\", attributeType: 1, value: \"100\" } ]; await expect(gemforceMinter.connect(owner).gemforceMint(metadata)) .to.emit(gemforceMinter, \"GemforceMinted\") .withArgs(0, owner.address, metadata); }); }); ``` API endpoint tests : ```javascript // test/cloud-functions.test.js describe(\"Cloud Functions\", function() { before(async function() { // Initialize Parse Server for testing Parse.initialize(\"test_app_id\", \"test_js_key\", \"test_master_key\"); Parse.serverURL = \"http://localhost:1337/parse\"; }); it(\"should retrieve blockchain data\", async function() { const result = await Parse.Cloud.run(\"loadAllBlockchains\"); expect(result).to.be.an(\"array\"); }); }); ``` End-to-end tests : ```javascript // test/e2e/user-flow.test.js describe(\"User Flow\", function() { it(\"should register, create identity, and mint token\", async function() { // Register user const user = await registerUser(\"test@example.com\", \"password\"); // Create DFNS wallet const { walletId } = await createDFNSWallet(user); // Create identity const { identityAddress } = await createIdentity(user, walletId); // Mint token const { tokenId } = await mintToken(user, walletId); // Verify token ownership const owner = await getTokenOwner(tokenId); expect(owner).to.equal(user.get(\"walletAddress\")); }); }); ``` Deployment Scripts \u00b6 Smart contract deployment script : ```javascript // scripts/deploy-contracts.js async function main() { // Get deployer const [deployer] = await ethers.getSigners(); console.log(\"Deploying contracts with account:\", deployer.address); // Deploy libraries const LibraryA = await ethers.getContractFactory(\"LibraryA\"); const libraryA = await LibraryA.deploy(); await libraryA.deployed(); console.log(\"LibraryA deployed to:\", libraryA.address); // Deploy facets with libraries const FacetA = await ethers.getContractFactory(\"FacetA\", { libraries: { LibraryA: libraryA.address } }); const facetA = await FacetA.deploy(); await facetA.deployed(); console.log(\"FacetA deployed to:\", facetA.address); // More deployments... } main() .then(() => process.exit(0)) .catch(error => { console.error(error); process.exit(1); }); ``` Parse Server deployment script : ```bash #!/bin/bash # scripts/deploy-parse.sh # Load environment variables source .env.${NODE_ENV:-production} # Build the project echo \"Building project...\" npm run build # Deploy to server echo \"Deploying to server...\" rsync -avz --exclude node_modules --exclude .git . user@server:/var/www/gemforce/ # SSH into server and restart ssh user@server << EOF cd /var/www/gemforce npm ci --production pm2 restart gemforce-server EOF echo \"Deployment complete!\" ``` Infrastructure as Code \u00b6 Terraform configuration : ```hcl # main.tf provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"gemforce_server\" { ami = \"ami-0c55b159cbfafe1f0\" instance_type = \"t2.medium\" key_name = \"gemforce-key\" tags = { Name = \"gemforce-server\" Environment = var.environment } root_block_device { volume_size = 50 volume_type = \"gp2\" } vpc_security_group_ids = [aws_security_group.gemforce_sg.id] } resource \"aws_security_group\" \"gemforce_sg\" { name = \"gemforce-sg\" description = \"Allow web and SSH traffic\" ingress { from_port = 80 to_port = 80 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } ingress { from_port = 443 to_port = 443 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } ingress { from_port = 22 to_port = 22 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } egress { from_port = 0 to_port = 0 protocol = \"-1\" cidr_blocks = [\"0.0.0.0/0\"] } } output \"server_ip\" { value = aws_instance.gemforce_server.public_ip } ``` Docker Compose setup : ```yaml # docker-compose.yml version: '3' services: mongodb: image: mongo:4.4 ports: - \"27017:27017\" volumes: - mongo-data:/data/db environment: MONGO_INITDB_ROOT_USERNAME: ${MONGO_USERNAME} MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD} restart: always parse-server: build: . ports: - \"1337:1337\" environment: - APP_ID=${APP_ID} - MASTER_KEY=${MASTER_KEY} - DATABASE_URI=mongodb://${MONGO_USERNAME}:${MONGO_PASSWORD}@mongodb:27017/${DATABASE_NAME}?authSource=admin - SERVER_URL=${SERVER_URL} - CLOUD_PATH=/parse-server/cloud/main.js volumes: - ./cloud:/parse-server/cloud depends_on: - mongodb restart: always nginx: image: nginx:latest ports: - \"80:80\" - \"443:443\" volumes: - ./nginx/conf.d:/etc/nginx/conf.d - ./nginx/ssl:/etc/nginx/ssl - ./nginx/www:/var/www/html depends_on: - parse-server restart: always volumes: mongo-data: ``` Continuous Monitoring \u00b6 Setup monitoring tools : ```javascript // Monitoring setup in app.js const prometheus = require('prom-client'); const collectDefaultMetrics = prometheus.collectDefaultMetrics; // Enable default metrics collectDefaultMetrics({ timeout: 5000 }); // Custom metrics const httpRequestDurationMicroseconds = new prometheus.Histogram({ name: 'http_request_duration_ms', help: 'Duration of HTTP requests in ms', labelNames: ['method', 'route', 'status_code'], buckets: [0.1, 5, 15, 50, 100, 500] }); // Endpoint for metrics app.get('/metrics', (req, res) => { res.set('Content-Type', prometheus.register.contentType); res.end(prometheus.register.metrics()); }); ``` Logging configuration : ```javascript // Logging setup in app.js const winston = require('winston'); const logger = winston.createLogger({ level: process.env.LOG_LEVEL || 'info', format: winston.format.combine( winston.format.timestamp(), winston.format.json() ), transports: [ new winston.transports.Console(), new winston.transports.File({ filename: 'error.log', level: 'error' }), new winston.transports.File({ filename: 'combined.log' }) ] }); // Use in application logger.info('Server started', { port: 1337 }); ``` Upgrade Procedures \u00b6 Smart Contract Upgrades \u00b6 Upgrading a facet : ```javascript // scripts/upgrade-facet.js async function main() { // Get signer const [signer] = await ethers.getSigners(); // Deploy new version of the facet const NewFacet = await ethers.getContractFactory(\"NewFacetV2\"); const newFacet = await NewFacet.deploy(); await newFacet.deployed(); console.log(\"New facet deployed to:\", newFacet.address); // Get diamond contract const diamond = await ethers.getContractAt(\"Diamond\", DIAMOND_ADDRESS); // Get selectors for the facet const selectors = getSelectors(newFacet); // Create facet cut const facetCut = { facetAddress: newFacet.address, action: FacetCutAction.Replace, // Replace existing facet functionSelectors: selectors }; // Perform the upgrade const tx = await diamond.diamondCut( [facetCut], ethers.constants.AddressZero, // No initialization \"0x\" ); await tx.wait(); console.log(\"Facet upgraded successfully\"); } main() .then(() => process.exit(0)) .catch(error => { console.error(error); process.exit(1); }); ``` Adding a new facet : ```javascript // scripts/add-facet.js async function main() { // Get signer const [signer] = await ethers.getSigners(); // Deploy new facet const NewFacet = await ethers.getContractFactory(\"NewFacet\"); const newFacet = await NewFacet.deploy(); await newFacet.deployed(); console.log(\"New facet deployed to:\", newFacet.address); // Get diamond contract const diamond = await ethers.getContractAt(\"Diamond\", DIAMOND_ADDRESS); // Get selectors for the facet const selectors = getSelectors(newFacet); // Create facet cut const facetCut = { facetAddress: newFacet.address, action: FacetCutAction.Add, // Add new facet functionSelectors: selectors }; // Perform the upgrade const tx = await diamond.diamondCut( [facetCut], ethers.constants.AddressZero, // No initialization \"0x\" ); await tx.wait(); console.log(\"Facet added successfully\"); } ``` Upgrading Diamond implementation : ```javascript // scripts/upgrade-diamond.js async function main() { // Get diamond factory const diamondFactory = await ethers.getContractAt(\"DiamondFactory\", FACTORY_ADDRESS); // Get existing diamond const diamond = await ethers.getContractAt(\"Diamond\", DIAMOND_ADDRESS); // Deploy new facets const newFacets = await deployNewFacets(); // Create facet cuts const facetCuts = createFacetCuts(newFacets); // Set new facet set on factory await diamondFactory.setFacets(\"newFacetSet\", facetCuts); // Deploy new diamond initializer if needed const diamondInit = await deployDiamondInit(); // Prepare initialization data const initData = diamondInit.interface.encodeFunctionData(\"init\", [ /* initialization parameters */ ]); // Upgrade diamond const tx = await diamond.diamondCut( facetCuts, diamondInit.address, initData ); await tx.wait(); console.log(\"Diamond upgraded successfully\"); } ``` Cloud Function Updates \u00b6 Updating cloud functions : ```bash # Update cloud functions git pull origin main npm install npm run build # Restart Parse Server pm2 restart gemforce-server ``` Testing cloud function updates : javascript // test/cloud-functions/updated-function.test.js describe(\"Updated Cloud Function\", function() { it(\"should handle new functionality\", async function() { const result = await Parse.Cloud.run(\"updatedFunction\", { param: \"value\" }); expect(result).to.have.property(\"newProperty\"); }); }); Deploying specific cloud function changes : ```bash # Deploy specific cloud function changes scp dist/src/cloud-functions/specific-function.js user@server:/var/www/gemforce/dist/src/cloud-functions/ # Restart Parse Server ssh user@server \"cd /var/www/gemforce && pm2 restart gemforce-server\" ``` Database Schema Migrations \u00b6 Creating a migration : ```javascript // migrations/1625000000000_add_new_field.js exports.up = async (db) => { // Add new field to all documents in a collection await db.collection('User').updateMany( { newField: { $exists: false } }, { $set: { newField: \"\" } } ); // Create new index await db.collection('User').createIndex({ newField: 1 }); }; exports.down = async (db) => { // Remove the field await db.collection('User').updateMany( {}, { $unset: { newField: \"\" } } ); // Remove the index await db.collection('User').dropIndex({ newField: 1 }); }; ``` Running migrations : ```bash # Run migrations npx migrate-mongo up # Check migration status npx migrate-mongo status ``` Rolling back migrations : ```bash # Roll back last migration npx migrate-mongo down # Roll back to specific migration npx migrate-mongo down 1625000000000 ``` Backward Compatibility Considerations \u00b6 API versioning : ```javascript // Example API versioning app.use('/api/v1', v1Routes); app.use('/api/v2', v2Routes); // Redirect old routes app.use('/api/legacy/:resource', (req, res) => { res.redirect( /api/v1/${req.params.resource} ); }); ``` Smart contract compatibility : Never remove storage variables Add new functions rather than changing existing ones Use new facets for significant changes Use feature flags to control access to new features Client compatibility : ```javascript // Check client version and provide appropriate response Parse.Cloud.define(\"getFeatures\", async (request) => { const clientVersion = request.params.clientVersion; if (semver.lt(clientVersion, \"2.0.0\")) { return legacyFeatureList; } else { return newFeatureList; } }); ``` Feature Flagging \u00b6 Implementing feature flags : ```javascript // Feature flag configuration const featureFlags = { newMarketplace: process.env.ENABLE_NEW_MARKETPLACE === \"true\", carbonCredits: process.env.ENABLE_CARBON_CREDITS === \"true\", nftFractionalization: process.env.ENABLE_NFT_FRACTIONALIZATION === \"true\" }; // Using feature flags Parse.Cloud.define(\"getMarketplace\", async (request) => { if (featureFlags.newMarketplace) { return getNewMarketplace(); } else { return getLegacyMarketplace(); } }); ``` Controlling access to new features : ```javascript // Progressive rollout Parse.Cloud.define(\"checkFeatureAccess\", async (request) => { const { feature, userId } = request.params; // Check if feature is enabled globally if (!featureFlags[feature]) { return { hasAccess: false }; } // Check if user is in beta group const user = await new Parse.Query(Parse.User) .get(userId, { useMasterKey: true }); const isBetaTester = user.get(\"betaTester\") === true; // Calculate percentage-based rollout const rolloutPercentage = 25; // 25% of users const userIdNumber = parseInt(userId.substring(0, 8), 16); const userPercentile = userIdNumber % 100; return { hasAccess: isBetaTester || userPercentile < rolloutPercentage }; }); ``` Rollback Procedures \u00b6 Smart Contract Rollbacks \u00b6 Rollback strategy for facets : ```javascript // scripts/rollback-facet.js async function main() { // Get diamond contract const diamond = await ethers.getContractAt(\"Diamond\", DIAMOND_ADDRESS); // Get previous version of the facet const previousFacetAddress = PREVIOUS_FACET_ADDRESS; // Get selectors for the facet const selectors = SELECTORS; // Create facet cut for rollback const facetCut = { facetAddress: previousFacetAddress, action: FacetCutAction.Replace, functionSelectors: selectors }; // Perform the rollback const tx = await diamond.diamondCut( [facetCut], ethers.constants.AddressZero, \"0x\" ); await tx.wait(); console.log(\"Facet rolled back successfully\"); } ``` Diamond upgrade rollback : ```javascript // scripts/rollback-diamond.js async function main() { // Get diamond factory const diamondFactory = await ethers.getContractAt(\"DiamondFactory\", FACTORY_ADDRESS); // Get diamond to rollback const diamond = await ethers.getContractAt(\"Diamond\", DIAMOND_ADDRESS); // Use previous facet set const previousFacetSet = \"previousFacetSet\"; // Get facets from the set const facets = await diamondFactory.getFacets(previousFacetSet); // Rollback diamond const tx = await diamond.diamondCut( facets, ethers.constants.AddressZero, \"0x\" ); await tx.wait(); console.log(\"Diamond rolled back successfully\"); } ``` Emergency pause : ```javascript // scripts/emergency-pause.js async function main() { // Get contract const contract = await ethers.getContractAt(\"PausableFacet\", DIAMOND_ADDRESS); // Pause the contract const tx = await contract.pause(); await tx.wait(); console.log(\"Contract paused successfully\"); } ``` Cloud Function Rollbacks \u00b6 Rolling back with Git : ```bash # Rollback to previous commit git reset --hard HEAD~1 npm install npm run build # Restart server pm2 restart gemforce-server ``` Using deployment tags : ```bash # List tags git tag -l # Checkout specific version git checkout v1.2.3 npm install npm run build # Restart server pm2 restart gemforce-server ``` Specific file rollback : ```bash # Revert specific file git checkout HEAD~1 -- src/cloud-functions/specific-file.ts npm run build # Restart server pm2 restart gemforce-server ``` Database Rollbacks \u00b6 Restoring from backup : bash # Restore MongoDB from backup mongorestore --uri=\"mongodb://username:password@host:port/database\" --drop /backup/path/YYYY-MM-DD Rolling back a migration : bash # Roll back the last migration npx migrate-mongo down Manual data correction script : ```javascript // scripts/correct-data.js async function main() { const MongoClient = require('mongodb').MongoClient; const client = await MongoClient.connect(process.env.DATABASE_URI); const db = client.db(); try { // Correct data issues await db.collection('User').updateMany( { incorrectField: { $exists: true } }, { $rename: { \"incorrectField\": \"correctField\" } } ); console.log(\"Data correction complete\"); } catch (error) { console.error(\"Error correcting data:\", error); } finally { await client.close(); } } main().catch(console.error); ``` Emergency Procedures \u00b6 Complete service rollback : ```bash # Emergency rollback script #!/bin/bash # scripts/emergency-rollback.sh # Stop the current service pm2 stop gemforce-server # Restore code from known good state git checkout v1.2.3 npm install npm run build # Restore database mongorestore --uri=\"$DATABASE_URI\" --drop /backups/latest # Restart the service pm2 start gemforce-server # Notify team curl -X POST -H \"Content-Type: application/json\" \\ -d '{\"text\":\"Emergency rollback performed to v1.2.3\"}' \\ $SLACK_WEBHOOK_URL ``` Read-only mode : ```javascript // Enable read-only mode Parse.Cloud.beforeSave(\"*\", async () => { if (process.env.READONLY_MODE === \"true\") { throw new Parse.Error( Parse.Error.OPERATION_FORBIDDEN, \"System is currently in read-only mode for maintenance.\" ); } }); Parse.Cloud.beforeDelete(\"*\", async () => { if (process.env.READONLY_MODE === \"true\") { throw new Parse.Error( Parse.Error.OPERATION_FORBIDDEN, \"System is currently in read-only mode for maintenance.\" ); } }); ``` Data Integrity Verification \u00b6 Verifying contract state : ```javascript // scripts/verify-contract-state.js async function main() { // Get contract const contract = await ethers.getContractAt(\"DiamondLoupe\", DIAMOND_ADDRESS); // Get all facets const facets = await contract.facets(); // Verify each facet for (const facet of facets) { console.log(`Verifying facet at ${facet.facetAddress}`); // Get facet code const code = await ethers.provider.getCode(facet.facetAddress); // Check code is not empty if (code === \"0x\" || code === \"0x0\") { throw new Error(`Facet at ${facet.facetAddress} has no code!`); } // Verify selectors for (const selector of facet.functionSelectors) { const result = await contract.facetAddress(selector); if (result !== facet.facetAddress) { throw new Error(`Selector ${selector} points to wrong facet!`); } } } console.log(\"Contract state verification successful\"); } main().catch(console.error); ``` Database integrity check : ```javascript // scripts/verify-database.js async function main() { const MongoClient = require('mongodb').MongoClient; const client = await MongoClient.connect(process.env.DATABASE_URI); const db = client.db(); try { // Check User collection integrity const userCount = await db.collection('User').countDocuments(); console.log(`User count: ${userCount}`); // Check for duplicate emails const duplicateEmails = await db.collection('User').aggregate([ { $group: { _id: \"$email\", count: { $sum: 1 } } }, { $match: { count: { $gt: 1 } } } ]).toArray(); if (duplicateEmails.length > 0) { console.error(`Found ${duplicateEmails.length} duplicate emails!`); console.error(duplicateEmails); } // Verify indexes const indexes = await db.collection('User').indexes(); console.log(\"Indexes:\", indexes); // More integrity checks... console.log(\"Database integrity check complete\"); } finally { await client.close(); } } main().catch(console.error); ``` Testing and Verification \u00b6 Unit Testing \u00b6 Smart contract unit tests : ```javascript // test/unit/GemforceMinter.test.ts describe(\"GemforceMinter\", function() { let owner, user1, user2; let diamond, gemforceMinter; beforeEach(async function() { [owner, user1, user2] = await ethers.getSigners(); // Deploy diamond with facets // ...deployment code gemforceMinter = await ethers.getContractAt(\"GemforceMinterFacet\", diamond.address); }); it(\"should allow owner to mint\", async function() { const metadata = [ { key: \"name\", attributeType: 0, value: \"Carbon Credit\" } ]; const tx = await gemforceMinter.connect(owner).gemforceMint(metadata); const receipt = await tx.wait(); // Check events const event = receipt.events.find(e => e.event === \"GemforceMinted\"); expect(event).to.exist; expect(event.args.tokenId).to.equal(0); expect(event.args.minter).to.equal(owner.address); }); it(\"should revert when non-owner tries to mint\", async function() { const metadata = [ { key: \"name\", attributeType: 0, value: \"Carbon Credit\" } ]; await expect( gemforceMinter.connect(user1).gemforceMint(metadata) ).to.be.revertedWith(\"Only contract owner\"); }); }); ``` Cloud function unit tests : ```javascript // test/unit/cloud-functions.test.js describe(\"Cloud Functions Unit Tests\", function() { before(function() { // Mock Parse this.originalParse = global.Parse; global.Parse = { Cloud: { define: (name, handler) => { this.cloudFunctions[name] = handler; } }, Error: { INVALID_PARAMS: 141 } }; // Load cloud functions this.cloudFunctions = {}; require(\"../../src/cloud-functions/contracts\"); }); after(function() { global.Parse = this.originalParse; }); it(\"should validate parameters in addDiamondFacet\", async function() { const handler = this.cloudFunctions.addDiamondFacet; // Missing parameters try { await handler({ params: {} }); assert.fail(\"Should have thrown an error\"); } catch (e) { expect(e.code).to.equal(Parse.Error.INVALID_PARAMS); } // With valid parameters (mocked) const mockResult = { success: true }; this.addDiamondFacet = sinon.stub().resolves(mockResult); const result = await handler({ params: { networkId: \"1\", diamondAddress: \"0x123\", facetName: \"TestFacet\" } }); expect(result).to.deep.equal(mockResult); }); }); ``` Integration Testing \u00b6 Smart contract integration tests : ```javascript // test/integration/marketplace-flow.test.ts describe(\"Marketplace Integration\", function() { let owner, seller, buyer; let diamond, marketplace, gem, treasury; before(async function() { [owner, seller, buyer] = await ethers.getSigners(); // Deploy all contracts // ...deployment code // Get contract instances diamond = await ethers.getContractAt(\"Diamond\", diamondAddress); marketplace = await ethers.getContractAt(\"MarketplaceFacet\", diamondAddress); gem = await ethers.getContractAt(\"GemforceMinterFacet\", diamondAddress); treasury = await ethers.getContractAt(\"Treasury\", treasuryAddress); }); it(\"should support full marketplace flow\", async function() { // Mint token const metadata = [{ key: \"test\", attributeType: 0, value: \"value\" }]; await gem.connect(owner).gemforceMint(metadata); // List token await marketplace.connect(owner).listItem(0, ethers.utils.parseEther(\"1.0\")); // Check listing const listing = await marketplace.getListing(0); expect(listing.price).to.equal(ethers.utils.parseEther(\"1.0\")); // Purchase token await marketplace.connect(buyer).purchaseItem(diamondAddress, 0, { value: ethers.utils.parseEther(\"1.0\") }); // Check ownership const newOwner = await diamond.ownerOf(0); expect(newOwner).to.equal(buyer.address); // Check treasury balance const balance = await treasury.getBalance(); expect(balance).to.be.gt(0); }); }); ``` API integration tests : ```javascript // test/integration/api-flow.test.js describe(\"API Integration\", function() { let user; before(async function() { // Initialize Parse Parse.initialize(\"test_app_id\", \"test_js_key\", \"test_master_key\"); Parse.serverURL = \"http://localhost:1337/parse\"; // Create test user user = new Parse.User(); user.set(\"username\", \"test@example.com\"); user.set(\"password\", \"password\"); user.set(\"email\", \"test@example.com\"); await user.signUp(); }); it(\"should handle user blockchain operations\", async function() { // Get blockchains const blockchains = await Parse.Cloud.run(\"loadAllBlockchains\"); expect(blockchains).to.be.an(\"array\"); // Create DFNS wallet (mocked) const walletResult = await Parse.Cloud.run(\"registerInit\", { username: user.get(\"email\") }); expect(walletResult).to.have.property(\"challenge\"); // Complete registration (mocked) const registrationResult = await Parse.Cloud.run(\"registerComplete\", { signedChallenge: \"mocked_challenge\", temporaryAuthenticationToken: \"mocked_token\" }); expect(registrationResult).to.have.property(\"token\"); // List wallets const wallets = await Parse.Cloud.run(\"listWallets\", { authToken: registrationResult.token }); expect(wallets).to.have.property(\"wallets\"); }); }); ``` Contract Verification \u00b6 Verifying contracts on block explorer : ```bash # Verify contract on Etherscan or Basescan npx hardhat verify --network baseSepolia # Verify contract with libraries npx hardhat verify --network baseSepolia \\ --libraries Library1=0x123... Library2=0x456... ``` Automated verification script : ```javascript // scripts/verify-contracts.js async function main() { // Get deployment data const deployments = require('../deployments.json'); const network = process.env.NETWORK || 'baseSepolia'; const networkId = hre.config.networks[network].chainId; // Verify Diamond contract const diamondAddress = deployments[networkId].diamondAddress; console.log(`Verifying Diamond at ${diamondAddress}`); try { await hre.run(\"verify:verify\", { address: diamondAddress, constructorArguments: [] }); } catch (e) { console.log(`Error verifying Diamond: ${e.message}`); } // Verify Facets const facets = deployments[networkId].facets || []; for (const facet of facets) { console.log(`Verifying facet ${facet.name} at ${facet.address}`); try { await hre.run(\"verify:verify\", { address: facet.address, constructorArguments: [] }); } catch (e) { console.log(`Error verifying ${facet.name}: ${e.message}`); } } } main().catch(console.error); ``` Load Testing \u00b6 Smart contract load testing : ```javascript // test/load/contract-load.test.js describe(\"Contract Load Test\", function() { // Increase timeout for load tests this.timeout(300000); let diamond, minter; let signers; before(async function() { // Get signers signers = await ethers.getSigners(); // Deploy contracts // ...deployment code diamond = await ethers.getContractAt(\"Diamond\", diamondAddress); minter = await ethers.getContractAt(\"GemforceMinterFacet\", diamondAddress); }); it(\"should handle concurrent minting\", async function() { const concurrentMints = 50; const mintPromises = []; // Create concurrent mint operations for (let i = 0; i < concurrentMints; i++) { const metadata = [ { key: \"name\", attributeType: 0, value: `Token ${i}` }, { key: \"value\", attributeType: 1, value: i.toString() } ]; mintPromises.push(minter.connect(signers[0]).gemforceMint(metadata)); } // Wait for all mints to complete const results = await Promise.allSettled(mintPromises); // Count successful mints const successfulMints = results.filter(r => r.status === \"fulfilled\").length; console.log(`Successfully minted ${successfulMints} of ${concurrentMints} tokens`); // Analyze failures const failures = results.filter(r => r.status === \"rejected\"); for (const failure of failures) { console.log(`Failure reason: ${failure.reason}`); } expect(successfulMints).to.be.gt(0); }); }); ``` API load testing with Artillery : ```yaml # load-tests/api-load.yml config: target: \"https://api.gemforce.com\" phases: - duration: 60 arrivalRate: 5 rampTo: 50 name: \"Warm up phase\" - duration: 120 arrivalRate: 50 name: \"Sustained load\" - duration: 60 arrivalRate: 50 rampTo: 100 name: \"Peak load\" defaults: headers: X-Parse-Application-Id: \"{{APP_ID}}\" Content-Type: \"application/json\" scenarios: - name: \"Load test API endpoints\" flow: - post: url: \"/parse/functions/loadAllBlockchains\" json: {} expect: - statusCode: 200 - post: url: \"/parse/functions/loadProviderUrl\" json: networkId: \"84532\" expect: - statusCode: 200 - post: url: \"/parse/functions/loadSmartContractsForNetwork\" json: networkId: \"84532\" expect: - statusCode: 200 ``` Run with: bash npx artillery run load-tests/api-load.yml --environment production Security Testing \u00b6 Smart contract security testing : ```bash # Run Slither security analyzer slither contracts/ # Run Mythril myth analyze contracts/Diamond.sol ``` Penetration testing for API : bash # Run OWASP ZAP scan zap-cli quick-scan -s xss,sqli -r report.html https://api.gemforce.com Authentication security tests : ```javascript // test/security/auth.test.js describe(\"Authentication Security\", function() { it(\"should reject invalid authentication\", async function() { // Try with invalid app ID try { Parse.initialize(\"invalid_app_id\", \"test_js_key\"); await Parse.Cloud.run(\"loadAllBlockchains\"); assert.fail(\"Should have thrown an error\"); } catch (e) { expect(e.code).to.equal(Parse.Error.INVALID_APP_ID); } // Try with invalid master key try { Parse.initialize(\"test_app_id\", \"test_js_key\", \"invalid_master_key\"); const user = new Parse.User(); await user.fetch({ useMasterKey: true }); assert.fail(\"Should have thrown an error\"); } catch (e) { expect(e.code).to.equal(Parse.Error.INVALID_MASTER_KEY); } }); }); ``` Network Management \u00b6 Blockchain Node Management \u00b6 Connecting to blockchain nodes : ```javascript // src/lib/blockchain.js const { ethers } = require(\"ethers\"); // Get provider for network function getProvider(networkId) { const networks = { \"1\": process.env.ETH_NODE_URI_MAINNET, \"84532\": process.env.ETH_NODE_URI_BASESEP }; const nodeUrl = networks[networkId]; if (!nodeUrl) { throw new Error(`No RPC endpoint configured for network ${networkId}`); } return new ethers.providers.JsonRpcProvider(nodeUrl); } // Get WebSocket provider for network function getWebSocketProvider(networkId) { const networks = { \"1\": process.env.ETH_WSS_URI_MAINNET, \"84532\": process.env.ETH_WSS_URI_BASESEP }; const nodeUrl = networks[networkId]; if (!nodeUrl) { throw new Error(`No WebSocket endpoint configured for network ${networkId}`); } return new ethers.providers.WebSocketProvider(nodeUrl); } module.exports = { getProvider, getWebSocketProvider }; ``` Monitoring node health : ```javascript // src/lib/node-monitor.js const { getProvider } = require(\"./blockchain\"); async function checkNodeHealth(networkId) { try { const provider = getProvider(networkId); // Check if node is responding const blockNumber = await provider.getBlockNumber(); // Check if node is synced const syncStatus = await provider.send(\"eth_syncing\", []); const isSynced = syncStatus === false; // Check chain ID const chainId = await provider.getNetwork().then(net => net.chainId); const isCorrectChain = chainId.toString() === networkId; // Check peers const peerCount = await provider.send(\"net_peerCount\", []); const peers = parseInt(peerCount, 16); const hasPeers = peers > 0; return { isHealthy: isSynced && isCorrectChain && hasPeers, blockNumber, isSynced, isCorrectChain, peers }; } catch (error) { return { isHealthy: false, error: error.message }; } } ``` Node failover : ```javascript // src/lib/node-failover.js const { ethers } = require(\"ethers\"); class FailoverProvider extends ethers.providers.StaticJsonRpcProvider { constructor(urls, network) { super(urls[0], network); this.urls = urls; this.currentUrlIndex = 0; } async send(method, params) { try { return await super.send(method, params); } catch (error) { // Try failover if (this.urls.length > 1) { this.currentUrlIndex = (this.currentUrlIndex + 1) % this.urls.length; this.connection.url = this.urls[this.currentUrlIndex]; console.log(`Failing over to ${this.connection.url}`); return await super.send(method, params); } throw error; } } } function getFailoverProvider(networkId) { const networks = { \"1\": [ process.env.ETH_NODE_URI_MAINNET_1, process.env.ETH_NODE_URI_MAINNET_2, process.env.ETH_NODE_URI_MAINNET_3 ], \"84532\": [ process.env.ETH_NODE_URI_BASESEP_1, process.env.ETH_NODE_URI_BASESEP_2 ] }; const urls = networks[networkId].filter(Boolean); if (urls.length === 0) { throw new Error(`No RPC endpoints configured for network ${networkId}`); } return new FailoverProvider(urls, parseInt(networkId)); } ``` RPC Endpoint Configuration \u00b6 Configuration file for RPC endpoints : javascript // config/networks.js module.exports = { mainnet: { chainId: 1, name: \"Ethereum Mainnet\", rpcEndpoints: [ { url: process.env.ETH_NODE_URI_MAINNET_1, provider: \"Infura\", weight: 10 }, { url: process.env.ETH_NODE_URI_MAINNET_2, provider: \"Alchemy\", weight: 5 }, { url: process.env.ETH_NODE_URI_MAINNET_3, provider: \"Custom\", weight: 1 } ], wsEndpoints: [ { url: process.env.ETH_WSS_URI_MAINNET, provider: \"Infura\" } ], explorerUrl: \"https://etherscan.io\" }, baseSepolia: { chainId: 84532, name: \"Base Sepolia\", rpcEndpoints: [ { url: process.env.ETH_NODE_URI_BASESEP_1, provider: \"Base\", weight: 10 }, { url: process.env.ETH_NODE_URI_BASESEP_2, provider: \"Alchemy\", weight: 5 } ], wsEndpoints: [ { url: process.env.ETH_WSS_URI_BASESEP, provider: \"Base\" } ], explorerUrl: \"https://sepolia.basescan.org\" } }; RPC endpoint selection logic : ```javascript // src/lib/rpc-manager.js const networks = require(\"../../config/networks\"); function selectRpcEndpoint(networkId) { const network = Object.values(networks).find(n => n.chainId === parseInt(networkId)); if (!network) { throw new Error( Network ${networkId} not found in configuration ); } // Use weighted selection const endpoints = network.rpcEndpoints.filter(e => e.url); if (endpoints.length === 0) { throw new Error(`No RPC endpoints configured for network ${networkId}`); } // Simple random selection for now // Could be expanded to use performance metrics or more complex selection const totalWeight = endpoints.reduce((sum, e) => sum + e.weight, 0); let random = Math.random() * totalWeight; for (const endpoint of endpoints) { random -= endpoint.weight; if (random <= 0) { return endpoint.url; } } // Fallback to first endpoint return endpoints[0].url; } ``` Environment-specific configuration : ```javascript // src/lib/network-config.js const networks = require(\"../../config/networks\"); function getNetworkConfig(networkId, environment = process.env.NODE_ENV) { const network = Object.values(networks).find(n => n.chainId === parseInt(networkId)); if (!network) { throw new Error( Network ${networkId} not found in configuration ); } // Apply environment-specific overrides const envOverrides = { development: { rpcEndpoints: [ { url: \"http://localhost:8545\", provider: \"Local\", weight: 100 } ] }, test: { // Test environment might use special endpoints }, // production uses default configuration }; if (envOverrides[environment]) { return { ...network, ...envOverrides[environment] }; } return network; } ``` Transaction Monitoring \u00b6 Monitoring transaction status : ```javascript // src/lib/transaction-monitor.js const { getProvider } = require(\"./blockchain\"); const db = require(\"./db\"); async function monitorTransaction(txHash, networkId) { const provider = getProvider(networkId); // Store the transaction in the database await db.collection(\"Transaction\").insertOne({ hash: txHash, networkId, status: \"pending\", createdAt: new Date(), attempts: 0 }); // Get initial transaction receipt let receipt = await provider.getTransactionReceipt(txHash); // Transaction is still pending if (!receipt) { // Schedule check for later setTimeout(() => checkTransaction(txHash, networkId), 15000); return { status: \"pending\" }; } // Transaction is mined updateTransactionStatus(txHash, receipt); return { status: receipt.status ? \"confirmed\" : \"failed\", receipt }; } async function checkTransaction(txHash, networkId) { try { const provider = getProvider(networkId); const receipt = await provider.getTransactionReceipt(txHash); if (!receipt) { // Still pending, check if it's been too long const tx = await db.collection(\"Transaction\").findOne({ hash: txHash }); const age = Date.now() - tx.createdAt.getTime(); const attempts = tx.attempts + 1; await db.collection(\"Transaction\").updateOne( { hash: txHash }, { $set: { attempts }, $currentDate: { lastChecked: true } } ); if (age > 3600000) { // 1 hour // Transaction has been pending too long await db.collection(\"Transaction\").updateOne( { hash: txHash }, { $set: { status: \"stalled\" } } ); // Could notify an admin here } else { // Check again later setTimeout(() => checkTransaction(txHash, networkId), 30000); } return; } // Transaction is mined, update status updateTransactionStatus(txHash, receipt); } catch (error) { console.error(`Error checking transaction ${txHash}:`, error); } } async function updateTransactionStatus(txHash, receipt) { const status = receipt.status ? \"confirmed\" : \"failed\"; await db.collection(\"Transaction\").updateOne( { hash: txHash }, { $set: { status, blockNumber: receipt.blockNumber, gasUsed: receipt.gasUsed.toString(), effectiveGasPrice: receipt.effectiveGasPrice.toString() } } ); } ``` Transaction event listener : ```javascript // src/lib/event-listener.js const { getWebSocketProvider } = require(\"./blockchain\"); const db = require(\"./db\"); class TransactionEventListener { constructor(networkId) { this.networkId = networkId; this.provider = getWebSocketProvider(networkId); this.contracts = new Map(); } addContract(address, abi, name) { const contract = new ethers.Contract(address, abi, this.provider); this.contracts.set(address, { contract, name }); console.log(`Added contract ${name} at ${address} for event monitoring`); return contract; } startListening() { // Listen for new blocks this.provider.on(\"block\", this.handleNewBlock.bind(this)); // Listen for specific events on each contract for (const [address, { contract, name }] of this.contracts.entries()) { contract.on(\"*\", (...args) => { const event = args[args.length - 1]; this.handleContractEvent(name, event); }); } } async handleNewBlock(blockNumber) { console.log(`New block: ${blockNumber} on network ${this.networkId}`); // Check pending transactions const pendingTxs = await db.collection(\"Transaction\").find({ networkId: this.networkId, status: \"pending\" }).toArray(); for (const tx of pendingTxs) { try { const receipt = await this.provider.getTransactionReceipt(tx.hash); if (receipt) { const status = receipt.status ? \"confirmed\" : \"failed\"; await db.collection(\"Transaction\").updateOne( { hash: tx.hash }, { $set: { status, blockNumber: receipt.blockNumber, gasUsed: receipt.gasUsed.toString(), effectiveGasPrice: receipt.effectiveGasPrice.toString() } } ); console.log(`Transaction ${tx.hash} ${status} in block ${receipt.blockNumber}`); } } catch (error) { console.error(`Error checking transaction ${tx.hash}:`, error); } } } async handleContractEvent(contractName, event) { console.log(`Event from ${contractName}: ${event.event}`); // Store event in database await db.collection(\"ContractEvent\").insertOne({ contractName, eventName: event.event, transactionHash: event.transactionHash, blockNumber: event.blockNumber, args: JSON.parse(JSON.stringify(event.args)), // Convert BigNumber to string timestamp: new Date() }); // Emit event for WebSocket clients if needed } stop() { this.provider.removeAllListeners(); for (const [address, { contract }] of this.contracts.entries()) { contract.removeAllListeners(); } console.log(`Stopped event listener for network ${this.networkId}`); } } ``` Gas Price Management \u00b6 Gas price estimation : ```javascript // src/lib/gas-price.js const { ethers } = require(\"ethers\"); const { getProvider } = require(\"./blockchain\"); async function estimateGasPrice(networkId, priority = \"medium\") { try { const provider = getProvider(networkId); // Get current gas price from provider const gasPrice = await provider.getGasPrice(); // Apply multipliers based on priority const multipliers = { low: 0.8, medium: 1.0, high: 1.5, urgent: 2.0 }; const multiplier = multipliers[priority] || 1.0; return gasPrice.mul(Math.floor(multiplier * 100)).div(100); } catch (error) { console.error(`Error estimating gas price:`, error); // Fallback gas prices (in gwei) const fallbackPrices = { 1: { low: 20, medium: 30, high: 50, urgent: 80 }, // Mainnet 84532: { low: 1, medium: 1.5, high: 2, urgent: 3 } // BaseSepolia }; const gweiPrice = fallbackPrices[networkId]?.[priority] || 10; return ethers.utils.parseUnits(gweiPrice.toString(), \"gwei\"); } } async function getGasSettings(networkId, priority = \"medium\") { const gasPrice = await estimateGasPrice(networkId, priority); // For EIP-1559 compatible networks, use maxFeePerGas and maxPriorityFeePerGas const provider = getProvider(networkId); const network = await provider.getNetwork(); // Check if network supports EIP-1559 const block = await provider.getBlock(\"latest\"); const eip1559Support = block && block.baseFeePerGas !== undefined; if (eip1559Support) { const baseFeePerGas = block.baseFeePerGas; // Priority fee multipliers const priorityFeeMultipliers = { low: 1.0, medium: 1.5, high: 2.0, urgent: 3.0 }; const multiplier = priorityFeeMultipliers[priority] || 1.5; const maxPriorityFeePerGas = ethers.utils.parseUnits(\"1\", \"gwei\").mul(multiplier); // maxFeePerGas = (baseFeePerGas * 2) + maxPriorityFeePerGas const maxFeePerGas = baseFeePerGas.mul(2).add(maxPriorityFeePerGas); return { maxFeePerGas, maxPriorityFeePerGas }; } // Fallback to regular gasPrice for non-EIP-1559 networks return { gasPrice }; } ``` Transaction submission with gas management : ```javascript // src/lib/transaction.js const { getProvider } = require(\"./blockchain\"); const { getGasSettings } = require(\"./gas-price\"); async function sendTransaction(networkId, txData, priority = \"medium\") { const provider = getProvider(networkId); const signer = new ethers.Wallet(process.env.PRIVATE_KEY, provider); // Get gas settings based on network and priority const gasSettings = await getGasSettings(networkId, priority); // Estimate gas limit const gasLimit = await provider.estimateGas({ from: signer.address, to: txData.to, data: txData.data, value: txData.value || 0 }); // Add buffer to gas limit const gasLimitWithBuffer = gasLimit.mul(120).div(100); // 20% buffer // Construct transaction const transaction = { from: signer.address, to: txData.to, data: txData.data, value: txData.value || 0, gasLimit: gasLimitWithBuffer, ...gasSettings }; // Send transaction const tx = await signer.sendTransaction(transaction); console.log(`Transaction sent: ${tx.hash}`); return tx; } ``` Network Upgrades Handling \u00b6 Network upgrade detector : ```javascript // src/lib/network-upgrade.js const { getProvider } = require(\"./blockchain\"); async function checkNetworkUpgrade(networkId) { try { const provider = getProvider(networkId); // Get current block const block = await provider.getBlock(\"latest\"); // Check for fork identifier or other upgrade indicators const isEIP1559 = block && block.baseFeePerGas !== undefined; // Check for upcoming network upgrades const upgrades = { 1: [ // Ethereum Mainnet { name: \"Cancun\", block: 19000000, active: block.number >= 19000000 } ], 84532: [ // BaseSepolia { name: \"Future Upgrade\", block: 5000000, active: block.number >= 5000000 } ] }; const networkUpgrades = upgrades[networkId] || []; const upcomingUpgrades = networkUpgrades.filter(u => !u.active); const activeUpgrades = networkUpgrades.filter(u => u.active); return { currentBlock: block.number, features: { eip1559: isEIP1559 }, activeUpgrades, upcomingUpgrades }; } catch (error) { console.error(`Error checking network upgrade:`, error); return { error: error.message }; } } ``` Handling network forks : ```javascript // src/lib/fork-handler.js const { getProvider } = require(\"./blockchain\"); class ForkHandler { constructor(networkId) { this.networkId = networkId; this.provider = getProvider(networkId); this.forkBlocks = { 1: { // Ethereum Mainnet \"Cancun\": 19000000 }, 84532: { // BaseSepolia \"FutureUpgrade\": 5000000 } }; } async detectFork() { const currentBlock = await this.provider.getBlockNumber(); const networkForks = this.forkBlocks[this.networkId] || {}; const activeForks = []; const pendingForks = []; for (const [name, blockNumber] of Object.entries(networkForks)) { if (currentBlock >= blockNumber) { activeForks.push({ name, blockNumber }); } else { pendingForks.push({ name, blockNumber, blocksRemaining: blockNumber - currentBlock }); } } return { currentBlock, activeForks, pendingForks }; } async adjustForFork(txParams) { const forkStatus = await this.detectFork(); const newParams = { ...txParams }; // Adjust transaction parameters based on active forks for (const fork of forkStatus.activeForks) { if (fork.name === \"Cancun\" || fork.name === \"London\") { // EIP-1559 transaction type delete newParams.gasPrice; if (!newParams.maxFeePerGas) { const block = await this.provider.getBlock(\"latest\"); const baseFeePerGas = block.baseFeePerGas; newParams.maxPriorityFeePerGas = ethers.utils.parseUnits(\"1.5\", \"gwei\"); newParams.maxFeePerGas = baseFeePerGas.mul(2).add(newParams.maxPriorityFeePerGas); } // Set type 2 transaction (EIP-1559) newParams.type = 2; } } return newParams; } } ``` Version Control \u00b6 Repository Structure \u00b6 Recommended repository structure : gemforce/ \u251c\u2500\u2500 .github/ # GitHub workflows and templates \u251c\u2500\u2500 contracts/ # Smart contracts \u2502 \u251c\u2500\u2500 facets/ # Diamond facets \u2502 \u251c\u2500\u2500 interfaces/ # Contract interfaces \u2502 \u251c\u2500\u2500 libraries/ # Contract libraries \u2502 \u251c\u2500\u2500 upgradeInitializers/ # Initializers for upgrades \u251c\u2500\u2500 deploy/ # Deployment scripts \u251c\u2500\u2500 deployments/ # Deployment artifacts \u251c\u2500\u2500 docs/ # Documentation \u251c\u2500\u2500 scripts/ # Utility scripts \u251c\u2500\u2500 src/ # Source code \u2502 \u251c\u2500\u2500 cloud-functions/ # Parse cloud functions \u2502 \u251c\u2500\u2500 lib/ # Shared libraries \u2502 \u251c\u2500\u2500 indexer/ # Blockchain indexer \u2502 \u251c\u2500\u2500 triggers/ # Parse triggers \u251c\u2500\u2500 test/ # Tests \u2502 \u251c\u2500\u2500 unit/ # Unit tests \u2502 \u251c\u2500\u2500 integration/ # Integration tests \u2502 \u251c\u2500\u2500 fixtures/ # Test fixtures \u251c\u2500\u2500 .env.example # Example environment variables \u251c\u2500\u2500 hardhat.config.ts # Hardhat configuration \u251c\u2500\u2500 package.json # Project metadata and dependencies \u251c\u2500\u2500 tsconfig.json # TypeScript configuration \u2514\u2500\u2500 README.md # Project documentation Repository organization best practices : Separate smart contracts from off-chain code Organize contracts by functionality Use descriptive folder names Keep tests close to the code they test Include documentation for each component Branching Strategy \u00b6 Git Flow branching model : main \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500 (production releases) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 staging \u2502 \u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500 (pre-production testing) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 develop \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500 (integration branch) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 feature/xyz \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf \u2502 \u2502 (feature branches) \u2502 \u2502 \u2502 feature/abc \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u25cf \u2502 (feature branches) \u2502 hotfix/123 \u25cf\u2500\u2500\u2500\u2500\u2500 (hotfix branches) main : Production code, tagged with version numbers staging : Pre-production testing develop : Integration branch for feature development feature/ *: Feature branches for new development hotfix/ *: Urgent fixes for production issues Branching guidelines : ```bash # Create a new feature branch from develop git checkout develop git pull git checkout -b feature/new-feature # Work on the feature, committing changes git add . git commit -m \"Implement new feature\" # Push feature branch to remote git push -u origin feature/new-feature # When feature is complete, merge to develop git checkout develop git pull git merge --no-ff feature/new-feature git push origin develop # Create a hotfix branch from main git checkout main git pull git checkout -b hotfix/critical-fix # Fix the issue, commit changes git add . git commit -m \"Fix critical issue\" # Push hotfix branch git push -u origin hotfix/critical-fix # When hotfix is complete, merge to main and develop git checkout main git pull git merge --no-ff hotfix/critical-fix git push origin main git checkout develop git pull git merge --no-ff hotfix/critical-fix git push origin develop ``` Release Management \u00b6 Semantic versioning : MAJOR.MINOR.PATCH MAJOR : Breaking changes MINOR : New features, backwards compatible PATCH : Bug fixes, backwards compatible Release process : ```bash # Prepare release from develop git checkout develop git pull git checkout -b release/1.2.0 # Update version numbers npm version minor --no-git-tag-version # Make final adjustments git add . git commit -m \"Prepare release 1.2.0\" # Merge to staging for testing git checkout staging git pull git merge --no-ff release/1.2.0 git push origin staging # Deploy to staging environment npm run deploy:staging # After testing, merge to main git checkout main git pull git merge --no-ff release/1.2.0 git tag -a v1.2.0 -m \"Release 1.2.0\" git push origin main --tags # Update develop with any changes git checkout develop git pull git merge --no-ff release/1.2.0 git push origin develop # Delete release branch git branch -d release/1.2.0 ``` Changelog management : ```markdown # Changelog All notable changes to this project will be documented in this file. ## [1.2.0] - 2025-02-25 ### Added - New carbon credit retirement feature - Support for multiple wallet providers ### Changed - Improved marketplace performance - Updated identity verification flow ### Fixed - Fixed issue with token minting - Resolved WebSocket connection stability ## [1.1.0] - 2025-01-15 ### Added - Identity management system - DFNS wallet integration ### Changed - Upgraded Parse Server to latest version - Improved error handling ### Deprecated - Legacy API endpoints (to be removed in 2.0) ``` Tagging Conventions \u00b6 Version tags : ```bash # Create an annotated version tag git tag -a v1.2.0 -m \"Release 1.2.0\" # Push tags to remote git push origin --tags ``` Environment tags : ```bash # Create a tag for production deployment git tag -a prod-2025-02-25 -m \"Production deployment on Feb 25, 2025\" # Create a tag for staging deployment git tag -a staging-2025-02-20 -m \"Staging deployment on Feb 20, 2025\" ``` Contract deployment tags : ```bash # Create a tag for contract deployment git tag -a deploy-mainnet-1.2.0 -m \"Mainnet contract deployment v1.2.0\" # Create a tag for facet upgrade git tag -a upgrade-marketplace-1.2.1 -m \"Marketplace facet upgrade to v1.2.1\" ``` Documentation Versioning \u00b6 Documentation directory structure : docs/ \u251c\u2500\u2500 latest/ # Latest documentation (symlink to current version) \u251c\u2500\u2500 v1.2.0/ # Documentation for v1.2.0 \u2502 \u251c\u2500\u2500 admin-guide.md # Administrator guide \u2502 \u251c\u2500\u2500 api-reference.md # API reference \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 v1.1.0/ # Documentation for v1.1.0 \u2502 \u251c\u2500\u2500 admin-guide.md # Administrator guide \u2502 \u251c\u2500\u2500 api-reference.md # API reference \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 ... Version-specific documentation : ```bash # Create a new documentation version mkdir -p docs/v1.2.0 cp -r docs/v1.1.0/* docs/v1.2.0/ # Update documentation for new version # Edit files in docs/v1.2.0/ # Update the latest symlink rm docs/latest ln -s v1.2.0 docs/latest ``` Documentation in the codebase : ```solidity // contracts/facets/MarketplaceFacet.sol /* * @title MarketplaceFacet * @dev Implements marketplace functionality for the Diamond * @notice This facet handles listing, buying, and selling tokens * @version 1.2.0 / contract MarketplaceFacet is Modifiers { // ... ``` ```javascript // src/cloud-functions/marketplace.js /* * @api {post} /parse/functions/listItem List an item for sale * @apiVersion 1.2.0 * @apiName ListItem * @apiGroup Marketplace * @apiDescription Lists a token for sale in the marketplace * * @apiParam {String} tokenId The ID of the token to list * @apiParam {String} price The price in ETH * * @apiSuccess {Object} result The result of the operation * @apiSuccess {Boolean} result.success Whether the operation was successful * @apiSuccess {String} result.transactionHash The transaction hash / Parse.Cloud.define(\"listItem\", async (request) => { // ... });","title":"Deployer Guide"},{"location":"gemforce-deployer-guide/#gemforce-deployer-guide","text":"","title":"Gemforce Deployer Guide"},{"location":"gemforce-deployer-guide/#table-of-contents","text":"Deployment Prerequisites Smart Contract Deployment Cloud Functions Deployment Environment Configuration Deployment Automation Upgrade Procedures Rollback Procedures Testing and Verification Network Management Version Control","title":"Table of Contents"},{"location":"gemforce-deployer-guide/#deployment-prerequisites","text":"","title":"Deployment Prerequisites"},{"location":"gemforce-deployer-guide/#development-environment-setup","text":"To deploy the Gemforce platform, you'll need the following tools and software: Node.js and npm : Node.js v16 or later npm v7 or later ```bash # Install using nvm (recommended) nvm install 16 nvm use 16 # Verify installation node -v npm -v ``` Hardhat : Used for smart contract development and deployment ```bash # Install hardhat npm install --save-dev hardhat # Verify installation npx hardhat --version ``` MongoDB : Version 4.4 or later Required for Parse Server ```bash # Installation varies by OS # macOS (using Homebrew) brew install mongodb-community # Verify installation mongod --version ``` Git : For version control bash # Verify installation git --version TypeScript : Latest version ```bash # Install TypeScript npm install -g typescript # Verify installation tsc --version ```","title":"Development Environment Setup"},{"location":"gemforce-deployer-guide/#required-tools-and-software","text":"Development IDE : Visual Studio Code (recommended) Plugins: Solidity TypeScript ESLint Prettier Blockchain Tools : MetaMask or similar wallet Etherscan account (for contract verification) Infura or Alchemy account (for RPC endpoints) Deployment Tools : PM2 (for process management) Docker (optional, for containerized deployment) ```bash # Install PM2 npm install -g pm2 # Verify installation pm2 --version ``` Database Tools : MongoDB Compass (GUI for MongoDB) MongoDB Database Tools (mongodump, mongorestore)","title":"Required Tools and Software"},{"location":"gemforce-deployer-guide/#network-access-requirements","text":"Ensure your deployment environment has access to: Blockchain Networks : Ethereum Mainnet (if deploying to production) BaseSepolia (for testing) Other EVM-compatible networks as needed External APIs : DFNS API Bridge API SendGrid API Database Access : MongoDB server (local or hosted) Redis (if using for caching) Github/Version Control : Access to Gemforce repositories","title":"Network Access Requirements"},{"location":"gemforce-deployer-guide/#key-management-setup","text":"Create a secure key management strategy : bash # Create a directory for keys (outside of repository) mkdir -p ~/.gemforce/keys chmod 700 ~/.gemforce/keys Generate deployment keys : ```bash # Generate a private key for deployment openssl genpkey -algorithm RSA -out ~/.gemforce/keys/deployment_key.pem -pkeyopt rsa_keygen_bits:2048 chmod 600 ~/.gemforce/keys/deployment_key.pem # Generate a DFNS private key openssl genpkey -algorithm RSA -out ~/.gemforce/keys/dfns_private.key -pkeyopt rsa_keygen_bits:2048 chmod 600 ~/.gemforce/keys/dfns_private.key ``` Use environment files for sensitive data : ```bash # Create a .env file for local development cp .env.example .env # Edit to add your keys and endpoints nano .env ```","title":"Key Management Setup"},{"location":"gemforce-deployer-guide/#environment-preparation","text":"Clone the repository : bash git clone https://github.com/your-org/gemforce.git cd gemforce Install dependencies : bash npm install Set up environment files : ```bash # Copy sample environment files cp .env.example .env cp gemforce.config.example.ts gemforce.config.ts # Edit the files with your configuration nano .env nano gemforce.config.ts ``` Create deployment directories : bash mkdir -p deployments","title":"Environment Preparation"},{"location":"gemforce-deployer-guide/#smart-contract-deployment","text":"","title":"Smart Contract Deployment"},{"location":"gemforce-deployer-guide/#contract-compilation","text":"Compile contracts using Hardhat : bash npx hardhat compile Verify compilation output : Check for successful compilation in artifacts/ directory Resolve any compilation errors Configuration for different networks : javascript // hardhat.config.ts module.exports = { solidity: { version: \"0.8.17\", settings: { optimizer: { enabled: true, runs: 200 } } }, networks: { hardhat: { chainId: 31337 }, baseSepolia: { url: `https://sepolia.base.org`, accounts: [process.env.PRIVATE_KEY], chainId: 84532 }, mainnet: { url: `https://mainnet.infura.io/v3/${process.env.INFURA_KEY}`, accounts: [process.env.PRIVATE_KEY], chainId: 1 } } };","title":"Contract Compilation"},{"location":"gemforce-deployer-guide/#diamond-pattern-deployment-workflow","text":"The Gemforce platform uses the Diamond pattern (EIP-2535) for smart contract deployment: Deploy libraries first : bash npx hardhat deploy --tags Libraries --network baseSepolia Deploy facets : bash npx hardhat deploy --tags Facets --network baseSepolia Deploy Diamond contract : bash npx hardhat deploy --tags Diamond --network baseSepolia Verify the deployment : bash npx hardhat verify --network baseSepolia <DIAMOND_ADDRESS>","title":"Diamond Pattern Deployment Workflow"},{"location":"gemforce-deployer-guide/#facet-deployment-process","text":"Develop new facets in the /contracts/facets directory Add to deployment scripts in /deploy directory Set up facet cut data for the Diamond contract: javascript // Example facet cut data const facetCuts = [ { facetAddress: newFacetAddress, action: FacetCutAction.Add, functionSelectors: selectors } ]; Update the Diamond with new facets: javascript // Using the DiamondFactory await diamondFactory.setFacets(setName, facetCuts);","title":"Facet Deployment Process"},{"location":"gemforce-deployer-guide/#contract-initialization","text":"Prepare initialization data : javascript // Example initialization data const initData = diamondInit.interface.encodeFunctionData(\"init\", [ [ // Initial parameters tokenName, tokenSymbol, baseURI, // ...other params ] ]); Initialize the Diamond : ```javascript const settings = { name: \"Gemforce Token\", symbol: \"GEM\", // other settings }; await diamondFactory.createFromSet( settings, diamondInit.address, initData, \"defaultFacetSet\" ); ```","title":"Contract Initialization"},{"location":"gemforce-deployer-guide/#contract-verification","text":"Verify Diamond contract on Etherscan/Basescan : bash npx hardhat verify --network baseSepolia <DIAMOND_ADDRESS> Verify individual facets : bash npx hardhat verify --network baseSepolia <FACET_ADDRESS> Manual verification (if automatic verification fails): Flatten the contract using Hardhat Upload the flattened contract to the block explorer Verify with the correct compiler settings","title":"Contract Verification"},{"location":"gemforce-deployer-guide/#gas-optimization-strategies","text":"Use optimized Solidity patterns : Minimize storage operations Batch operations where possible Use efficient data structures Configure gas prices for deployment : javascript // Example configuration for gas const tx = await contract.functionName(params, { gasPrice: (await ethers.provider.getGasPrice()).mul(2), // 2x current gas price gasLimit: 5000000 }); Monitor gas usage during testing : javascript // Add gas reporter to Hardhat config gasReporter: { enabled: true, currency: 'USD', gasPrice: 100, coinmarketcap: process.env.COINMARKETCAP_API_KEY }","title":"Gas Optimization Strategies"},{"location":"gemforce-deployer-guide/#cloud-functions-deployment","text":"","title":"Cloud Functions Deployment"},{"location":"gemforce-deployer-guide/#parse-server-deployment","text":"Prepare Parse Server configuration : javascript // Example Parse Server configuration const parseServerConfig = { appId: process.env.APP_ID, masterKey: process.env.MASTER_KEY, databaseURI: process.env.DATABASE_URI, serverURL: process.env.SERVER_URL, cloud: \"./dist/src/cloud-functions.js\", allowClientClassCreation: false, enableAnonymousUsers: false, maxUploadSize: \"20mb\", // ... other configuration }; Deploy Parse Server : Using PM2: ```bash # Start Parse Server with PM2 pm2 start app.js --name gemforce-server # Save PM2 configuration pm2 save # Set up PM2 to start on system boot pm2 startup ``` Using Docker: ```bash # Build Docker image docker build -t gemforce-server . # Run container docker run -d -p 1337:1337 \\ --env-file .env \\ --name gemforce-server \\ gemforce-server ``` Verify Parse Server deployment : ```bash # Check server status curl https://your-server-url.com/parse/health # Expected response: {\"status\":\"ok\"} ```","title":"Parse Server Deployment"},{"location":"gemforce-deployer-guide/#cloud-function-deployment","text":"Compile TypeScript files : bash # Build the project npm run build Deploy cloud functions : If using PM2: bash # Restart the server to apply changes pm2 restart gemforce-server If using Docker: bash # Rebuild and redeploy docker build -t gemforce-server . docker stop gemforce-server docker rm gemforce-server docker run -d -p 1337:1337 \\ --env-file .env \\ --name gemforce-server \\ gemforce-server Verify cloud function deployment : bash # Test a simple cloud function curl -X POST \\ -H \"X-Parse-Application-Id: ${APP_ID}\" \\ -H \"Content-Type: application/json\" \\ -d '{}' \\ https://your-server-url.com/parse/functions/loadAllBlockchains","title":"Cloud Function Deployment"},{"location":"gemforce-deployer-guide/#environment-configuration","text":"Set environment variables : ```bash # Set environment variables in .env file cat > .env << EOL # Parse Server APP_ID=your_app_id MASTER_KEY=your_master_key DATABASE_URI=mongodb://username:password@host:port/database SERVER_URL=https://your-server-url.com/parse # Blockchain ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=base-sepolia PRIVATE_KEY=your_private_key # External Services DFNS_APP_ID=your_dfns_app_id DFNS_API_URL=https://api.dfns.io DFNS_CRED_ID=your_dfns_credential_id # Additional Configuration METADATA_BASE_URI=https://metadata.gemforce.com/ EOL ``` Configure database : Set up MongoDB Create database user Configure connection string Set up web server (nginx example): ```nginx # /etc/nginx/sites-available/gemforce server { listen 80; server_name api.gemforce.com; location / { return 301 https://$host$request_uri; } } server { listen 443 ssl; server_name api.gemforce.com; ssl_certificate /etc/letsencrypt/live/api.gemforce.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/api.gemforce.com/privkey.pem; location / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } ```","title":"Environment Configuration"},{"location":"gemforce-deployer-guide/#database-migration","text":"Create database migrations : ```javascript // Example migration script (migrations/001_add_indexes.js) async function up(db) { await db.collection('User').createIndex({ walletAddress: 1 }); await db.collection('Identity').createIndex({ walletAddress: 1 }, { unique: true }); await db.collection('Transaction').createIndex({ hash: 1 }, { unique: true }); } async function down(db) { await db.collection('User').dropIndex({ walletAddress: 1 }); await db.collection('Identity').dropIndex({ walletAddress: 1 }); await db.collection('Transaction').dropIndex({ hash: 1 }); } module.exports = { up, down }; ``` Run migrations : bash # Example using a simple migration tool npx migrate-mongo up Verify migrations : javascript // Check indexes db.User.getIndexes() db.Identity.getIndexes() db.Transaction.getIndexes()","title":"Database Migration"},{"location":"gemforce-deployer-guide/#websocket-setup","text":"Configure WebSocket endpoints : ```javascript // Example WebSocket server setup const wss = new WebSocketServer({ server: httpServer, path: \"/ws\" }); wss.on('connection', (ws) => { // Handle connection ws.on('message', (message) => { // Handle message }); ws.on('close', () => { // Handle disconnection }); }); ``` Set up blockchain event listeners : ```javascript // Example blockchain event listener function setupEventListeners(provider, diamondAddress) { const diamond = new ethers.Contract( diamondAddress, DiamondABI, provider ); diamond.on(\"Transfer\", (from, to, tokenId) => { // Handle transfer event // Broadcast to connected WebSocket clients wss.clients.forEach((client) => { if (client.readyState === WebSocket.OPEN) { client.send(JSON.stringify({ event: \"Transfer\", data: { from, to, tokenId: tokenId.toString() } })); } }); }); } ```","title":"WebSocket Setup"},{"location":"gemforce-deployer-guide/#environment-configuration_1","text":"","title":"Environment Configuration"},{"location":"gemforce-deployer-guide/#development-environment","text":"Local environment setup : ```bash # Start local hardhat node npx hardhat node # Deploy contracts to local node npx hardhat deploy --network localhost # Start Parse Server locally npm run dev ``` Environment configuration file for development : ``` # .env.development APP_ID=gemforce_dev MASTER_KEY=your_dev_master_key DATABASE_URI=mongodb://localhost:27017/gemforce_dev SERVER_URL=http://localhost:1337/parse # Use local hardhat node ETH_NODE_URI_LOCAL=http://localhost:8545 CHAIN_ID=31337 # Development keys PRIVATE_KEY=your_dev_private_key ``` Development database setup : ```bash # Start MongoDB locally mongod --dbpath ./data # Create database and user mongo use gemforce_dev db.createUser({ user: \"gemforce_user\", pwd: \"password\", roles: [{ role: \"readWrite\", db: \"gemforce_dev\" }] }) ```","title":"Development Environment"},{"location":"gemforce-deployer-guide/#testing-environment","text":"Testing environment configuration : ``` # .env.test APP_ID=gemforce_test MASTER_KEY=your_test_master_key DATABASE_URI=mongodb://localhost:27017/gemforce_test SERVER_URL=http://localhost:1337/parse # Use BaseSepolia for testing ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=84532 # Test keys PRIVATE_KEY=your_test_private_key ``` Automated testing setup : ```bash # Run tests npm test # Run specific tests npx mocha test/specific-test.js ``` Test database initialization : javascript // Initialize test database before(async () => { const client = await MongoClient.connect(process.env.DATABASE_URI); const db = client.db(); await db.collection('User').deleteMany({}); await db.collection('Identity').deleteMany({}); // Seed with test data await db.collection('User').insertMany(testUsers); });","title":"Testing Environment"},{"location":"gemforce-deployer-guide/#staging-environment","text":"Staging environment configuration : ``` # .env.staging APP_ID=gemforce_staging MASTER_KEY=your_staging_master_key DATABASE_URI=mongodb://user:password@staging-db:27017/gemforce_staging SERVER_URL=https://staging-api.gemforce.com/parse # Use BaseSepolia for staging ETH_NODE_URI_BASESEP=https://sepolia.base.org CHAIN_ID=84532 # Staging keys PRIVATE_KEY=your_staging_private_key ``` Staging deployment : ```bash # Deploy to staging npm run deploy:staging # Run database migrations npm run migrate:staging ``` Staging verification : bash # Verify staging deployment curl https://staging-api.gemforce.com/parse/health","title":"Staging Environment"},{"location":"gemforce-deployer-guide/#production-environment","text":"Production environment configuration : ``` # .env.production APP_ID=gemforce_prod MASTER_KEY=your_production_master_key DATABASE_URI=mongodb://user:password@production-db:27017/gemforce_production SERVER_URL=https://api.gemforce.com/parse # Use production endpoints ETH_NODE_URI_MAINNET=https://mainnet.infura.io/v3/your_infura_key CHAIN_ID=1 # Production keys stored securely # PRIVATE_KEY should be handled with extra security ``` Production deployment steps : ```bash # Deploy to production npm run deploy:production # Run database migrations npm run migrate:production ``` Production verification : ```bash # Verify production deployment curl https://api.gemforce.com/parse/health # Monitor logs pm2 logs gemforce-server ```","title":"Production Environment"},{"location":"gemforce-deployer-guide/#environment-specific-settings","text":"Configuration management : ``javascript // Load environment-specific configuration const envConfig = require( ./config/${process.env.NODE_ENV || 'development'}`); module.exports = { // Base configuration appName: 'Gemforce', // Merge with environment-specific config ...envConfig }; ``` Feature flags : ```javascript // Example feature flags configuration const featureFlags = { development: { enableNewMarketplace: true, enableCarbonCredits: true }, staging: { enableNewMarketplace: true, enableCarbonCredits: false }, production: { enableNewMarketplace: false, enableCarbonCredits: false } }; // Usage if (featureFlags[process.env.NODE_ENV].enableNewMarketplace) { // Initialize new marketplace } ```","title":"Environment-Specific Settings"},{"location":"gemforce-deployer-guide/#deployment-automation","text":"","title":"Deployment Automation"},{"location":"gemforce-deployer-guide/#cicd-pipeline-setup","text":"GitHub Actions workflow : ```yaml # .github/workflows/deploy.yml name: Deploy Gemforce on: push: branches: [ main, staging ] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: '16' - name: Install dependencies run: npm ci - name: Run tests run: npm test build: needs: test runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: '16' - name: Install dependencies run: npm ci - name: Build project run: npm run build - name: Upload build artifacts uses: actions/upload-artifact@v2 with: name: build path: dist/ deploy: needs: build runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Download build artifacts uses: actions/download-artifact@v2 with: name: build path: dist/ - name: Deploy to server uses: appleboy/ssh-action@master with: host: ${{ secrets.SERVER_HOST }} username: ${{ secrets.SERVER_USERNAME }} key: ${{ secrets.SSH_PRIVATE_KEY }} script: | cd /var/www/gemforce git pull npm ci cp -r ${{ github.workspace }}/dist/* ./dist/ pm2 restart gemforce-server ``` Automatic testing : ```yaml # .github/workflows/test.yml name: Test Gemforce on: pull_request: branches: [ main, staging ] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: '16' - name: Install dependencies run: npm ci - name: Run linting run: npm run lint - name: Run tests run: npm test ```","title":"CI/CD Pipeline Setup"},{"location":"gemforce-deployer-guide/#automated-testing","text":"Unit tests for smart contracts : ```javascript // test/GemforceMinter.test.ts describe(\"GemforceMinter\", function() { let owner, user; let diamond, gemforceMinter; beforeEach(async function() { [owner, user] = await ethers.getSigners(); // Deploy diamond with GemforceMinterFacet // ...deployment code gemforceMinter = await ethers.getContractAt(\"GemforceMinterFacet\", diamond.address); }); it(\"should mint a token with metadata\", async function() { const metadata = [ { key: \"name\", attributeType: 0, value: \"Carbon Credit\" }, { key: \"amount\", attributeType: 1, value: \"100\" } ]; await expect(gemforceMinter.connect(owner).gemforceMint(metadata)) .to.emit(gemforceMinter, \"GemforceMinted\") .withArgs(0, owner.address, metadata); }); }); ``` API endpoint tests : ```javascript // test/cloud-functions.test.js describe(\"Cloud Functions\", function() { before(async function() { // Initialize Parse Server for testing Parse.initialize(\"test_app_id\", \"test_js_key\", \"test_master_key\"); Parse.serverURL = \"http://localhost:1337/parse\"; }); it(\"should retrieve blockchain data\", async function() { const result = await Parse.Cloud.run(\"loadAllBlockchains\"); expect(result).to.be.an(\"array\"); }); }); ``` End-to-end tests : ```javascript // test/e2e/user-flow.test.js describe(\"User Flow\", function() { it(\"should register, create identity, and mint token\", async function() { // Register user const user = await registerUser(\"test@example.com\", \"password\"); // Create DFNS wallet const { walletId } = await createDFNSWallet(user); // Create identity const { identityAddress } = await createIdentity(user, walletId); // Mint token const { tokenId } = await mintToken(user, walletId); // Verify token ownership const owner = await getTokenOwner(tokenId); expect(owner).to.equal(user.get(\"walletAddress\")); }); }); ```","title":"Automated Testing"},{"location":"gemforce-deployer-guide/#deployment-scripts","text":"Smart contract deployment script : ```javascript // scripts/deploy-contracts.js async function main() { // Get deployer const [deployer] = await ethers.getSigners(); console.log(\"Deploying contracts with account:\", deployer.address); // Deploy libraries const LibraryA = await ethers.getContractFactory(\"LibraryA\"); const libraryA = await LibraryA.deploy(); await libraryA.deployed(); console.log(\"LibraryA deployed to:\", libraryA.address); // Deploy facets with libraries const FacetA = await ethers.getContractFactory(\"FacetA\", { libraries: { LibraryA: libraryA.address } }); const facetA = await FacetA.deploy(); await facetA.deployed(); console.log(\"FacetA deployed to:\", facetA.address); // More deployments... } main() .then(() => process.exit(0)) .catch(error => { console.error(error); process.exit(1); }); ``` Parse Server deployment script : ```bash #!/bin/bash # scripts/deploy-parse.sh # Load environment variables source .env.${NODE_ENV:-production} # Build the project echo \"Building project...\" npm run build # Deploy to server echo \"Deploying to server...\" rsync -avz --exclude node_modules --exclude .git . user@server:/var/www/gemforce/ # SSH into server and restart ssh user@server << EOF cd /var/www/gemforce npm ci --production pm2 restart gemforce-server EOF echo \"Deployment complete!\" ```","title":"Deployment Scripts"},{"location":"gemforce-deployer-guide/#infrastructure-as-code","text":"Terraform configuration : ```hcl # main.tf provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"gemforce_server\" { ami = \"ami-0c55b159cbfafe1f0\" instance_type = \"t2.medium\" key_name = \"gemforce-key\" tags = { Name = \"gemforce-server\" Environment = var.environment } root_block_device { volume_size = 50 volume_type = \"gp2\" } vpc_security_group_ids = [aws_security_group.gemforce_sg.id] } resource \"aws_security_group\" \"gemforce_sg\" { name = \"gemforce-sg\" description = \"Allow web and SSH traffic\" ingress { from_port = 80 to_port = 80 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } ingress { from_port = 443 to_port = 443 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } ingress { from_port = 22 to_port = 22 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } egress { from_port = 0 to_port = 0 protocol = \"-1\" cidr_blocks = [\"0.0.0.0/0\"] } } output \"server_ip\" { value = aws_instance.gemforce_server.public_ip } ``` Docker Compose setup : ```yaml # docker-compose.yml version: '3' services: mongodb: image: mongo:4.4 ports: - \"27017:27017\" volumes: - mongo-data:/data/db environment: MONGO_INITDB_ROOT_USERNAME: ${MONGO_USERNAME} MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD} restart: always parse-server: build: . ports: - \"1337:1337\" environment: - APP_ID=${APP_ID} - MASTER_KEY=${MASTER_KEY} - DATABASE_URI=mongodb://${MONGO_USERNAME}:${MONGO_PASSWORD}@mongodb:27017/${DATABASE_NAME}?authSource=admin - SERVER_URL=${SERVER_URL} - CLOUD_PATH=/parse-server/cloud/main.js volumes: - ./cloud:/parse-server/cloud depends_on: - mongodb restart: always nginx: image: nginx:latest ports: - \"80:80\" - \"443:443\" volumes: - ./nginx/conf.d:/etc/nginx/conf.d - ./nginx/ssl:/etc/nginx/ssl - ./nginx/www:/var/www/html depends_on: - parse-server restart: always volumes: mongo-data: ```","title":"Infrastructure as Code"},{"location":"gemforce-deployer-guide/#continuous-monitoring","text":"Setup monitoring tools : ```javascript // Monitoring setup in app.js const prometheus = require('prom-client'); const collectDefaultMetrics = prometheus.collectDefaultMetrics; // Enable default metrics collectDefaultMetrics({ timeout: 5000 }); // Custom metrics const httpRequestDurationMicroseconds = new prometheus.Histogram({ name: 'http_request_duration_ms', help: 'Duration of HTTP requests in ms', labelNames: ['method', 'route', 'status_code'], buckets: [0.1, 5, 15, 50, 100, 500] }); // Endpoint for metrics app.get('/metrics', (req, res) => { res.set('Content-Type', prometheus.register.contentType); res.end(prometheus.register.metrics()); }); ``` Logging configuration : ```javascript // Logging setup in app.js const winston = require('winston'); const logger = winston.createLogger({ level: process.env.LOG_LEVEL || 'info', format: winston.format.combine( winston.format.timestamp(), winston.format.json() ), transports: [ new winston.transports.Console(), new winston.transports.File({ filename: 'error.log', level: 'error' }), new winston.transports.File({ filename: 'combined.log' }) ] }); // Use in application logger.info('Server started', { port: 1337 }); ```","title":"Continuous Monitoring"},{"location":"gemforce-deployer-guide/#upgrade-procedures","text":"","title":"Upgrade Procedures"},{"location":"gemforce-deployer-guide/#smart-contract-upgrades","text":"Upgrading a facet : ```javascript // scripts/upgrade-facet.js async function main() { // Get signer const [signer] = await ethers.getSigners(); // Deploy new version of the facet const NewFacet = await ethers.getContractFactory(\"NewFacetV2\"); const newFacet = await NewFacet.deploy(); await newFacet.deployed(); console.log(\"New facet deployed to:\", newFacet.address); // Get diamond contract const diamond = await ethers.getContractAt(\"Diamond\", DIAMOND_ADDRESS); // Get selectors for the facet const selectors = getSelectors(newFacet); // Create facet cut const facetCut = { facetAddress: newFacet.address, action: FacetCutAction.Replace, // Replace existing facet functionSelectors: selectors }; // Perform the upgrade const tx = await diamond.diamondCut( [facetCut], ethers.constants.AddressZero, // No initialization \"0x\" ); await tx.wait(); console.log(\"Facet upgraded successfully\"); } main() .then(() => process.exit(0)) .catch(error => { console.error(error); process.exit(1); }); ``` Adding a new facet : ```javascript // scripts/add-facet.js async function main() { // Get signer const [signer] = await ethers.getSigners(); // Deploy new facet const NewFacet = await ethers.getContractFactory(\"NewFacet\"); const newFacet = await NewFacet.deploy(); await newFacet.deployed(); console.log(\"New facet deployed to:\", newFacet.address); // Get diamond contract const diamond = await ethers.getContractAt(\"Diamond\", DIAMOND_ADDRESS); // Get selectors for the facet const selectors = getSelectors(newFacet); // Create facet cut const facetCut = { facetAddress: newFacet.address, action: FacetCutAction.Add, // Add new facet functionSelectors: selectors }; // Perform the upgrade const tx = await diamond.diamondCut( [facetCut], ethers.constants.AddressZero, // No initialization \"0x\" ); await tx.wait(); console.log(\"Facet added successfully\"); } ``` Upgrading Diamond implementation : ```javascript // scripts/upgrade-diamond.js async function main() { // Get diamond factory const diamondFactory = await ethers.getContractAt(\"DiamondFactory\", FACTORY_ADDRESS); // Get existing diamond const diamond = await ethers.getContractAt(\"Diamond\", DIAMOND_ADDRESS); // Deploy new facets const newFacets = await deployNewFacets(); // Create facet cuts const facetCuts = createFacetCuts(newFacets); // Set new facet set on factory await diamondFactory.setFacets(\"newFacetSet\", facetCuts); // Deploy new diamond initializer if needed const diamondInit = await deployDiamondInit(); // Prepare initialization data const initData = diamondInit.interface.encodeFunctionData(\"init\", [ /* initialization parameters */ ]); // Upgrade diamond const tx = await diamond.diamondCut( facetCuts, diamondInit.address, initData ); await tx.wait(); console.log(\"Diamond upgraded successfully\"); } ```","title":"Smart Contract Upgrades"},{"location":"gemforce-deployer-guide/#cloud-function-updates","text":"Updating cloud functions : ```bash # Update cloud functions git pull origin main npm install npm run build # Restart Parse Server pm2 restart gemforce-server ``` Testing cloud function updates : javascript // test/cloud-functions/updated-function.test.js describe(\"Updated Cloud Function\", function() { it(\"should handle new functionality\", async function() { const result = await Parse.Cloud.run(\"updatedFunction\", { param: \"value\" }); expect(result).to.have.property(\"newProperty\"); }); }); Deploying specific cloud function changes : ```bash # Deploy specific cloud function changes scp dist/src/cloud-functions/specific-function.js user@server:/var/www/gemforce/dist/src/cloud-functions/ # Restart Parse Server ssh user@server \"cd /var/www/gemforce && pm2 restart gemforce-server\" ```","title":"Cloud Function Updates"},{"location":"gemforce-deployer-guide/#database-schema-migrations","text":"Creating a migration : ```javascript // migrations/1625000000000_add_new_field.js exports.up = async (db) => { // Add new field to all documents in a collection await db.collection('User').updateMany( { newField: { $exists: false } }, { $set: { newField: \"\" } } ); // Create new index await db.collection('User').createIndex({ newField: 1 }); }; exports.down = async (db) => { // Remove the field await db.collection('User').updateMany( {}, { $unset: { newField: \"\" } } ); // Remove the index await db.collection('User').dropIndex({ newField: 1 }); }; ``` Running migrations : ```bash # Run migrations npx migrate-mongo up # Check migration status npx migrate-mongo status ``` Rolling back migrations : ```bash # Roll back last migration npx migrate-mongo down # Roll back to specific migration npx migrate-mongo down 1625000000000 ```","title":"Database Schema Migrations"},{"location":"gemforce-deployer-guide/#backward-compatibility-considerations","text":"API versioning : ```javascript // Example API versioning app.use('/api/v1', v1Routes); app.use('/api/v2', v2Routes); // Redirect old routes app.use('/api/legacy/:resource', (req, res) => { res.redirect( /api/v1/${req.params.resource} ); }); ``` Smart contract compatibility : Never remove storage variables Add new functions rather than changing existing ones Use new facets for significant changes Use feature flags to control access to new features Client compatibility : ```javascript // Check client version and provide appropriate response Parse.Cloud.define(\"getFeatures\", async (request) => { const clientVersion = request.params.clientVersion; if (semver.lt(clientVersion, \"2.0.0\")) { return legacyFeatureList; } else { return newFeatureList; } }); ```","title":"Backward Compatibility Considerations"},{"location":"gemforce-deployer-guide/#feature-flagging","text":"Implementing feature flags : ```javascript // Feature flag configuration const featureFlags = { newMarketplace: process.env.ENABLE_NEW_MARKETPLACE === \"true\", carbonCredits: process.env.ENABLE_CARBON_CREDITS === \"true\", nftFractionalization: process.env.ENABLE_NFT_FRACTIONALIZATION === \"true\" }; // Using feature flags Parse.Cloud.define(\"getMarketplace\", async (request) => { if (featureFlags.newMarketplace) { return getNewMarketplace(); } else { return getLegacyMarketplace(); } }); ``` Controlling access to new features : ```javascript // Progressive rollout Parse.Cloud.define(\"checkFeatureAccess\", async (request) => { const { feature, userId } = request.params; // Check if feature is enabled globally if (!featureFlags[feature]) { return { hasAccess: false }; } // Check if user is in beta group const user = await new Parse.Query(Parse.User) .get(userId, { useMasterKey: true }); const isBetaTester = user.get(\"betaTester\") === true; // Calculate percentage-based rollout const rolloutPercentage = 25; // 25% of users const userIdNumber = parseInt(userId.substring(0, 8), 16); const userPercentile = userIdNumber % 100; return { hasAccess: isBetaTester || userPercentile < rolloutPercentage }; }); ```","title":"Feature Flagging"},{"location":"gemforce-deployer-guide/#rollback-procedures","text":"","title":"Rollback Procedures"},{"location":"gemforce-deployer-guide/#smart-contract-rollbacks","text":"Rollback strategy for facets : ```javascript // scripts/rollback-facet.js async function main() { // Get diamond contract const diamond = await ethers.getContractAt(\"Diamond\", DIAMOND_ADDRESS); // Get previous version of the facet const previousFacetAddress = PREVIOUS_FACET_ADDRESS; // Get selectors for the facet const selectors = SELECTORS; // Create facet cut for rollback const facetCut = { facetAddress: previousFacetAddress, action: FacetCutAction.Replace, functionSelectors: selectors }; // Perform the rollback const tx = await diamond.diamondCut( [facetCut], ethers.constants.AddressZero, \"0x\" ); await tx.wait(); console.log(\"Facet rolled back successfully\"); } ``` Diamond upgrade rollback : ```javascript // scripts/rollback-diamond.js async function main() { // Get diamond factory const diamondFactory = await ethers.getContractAt(\"DiamondFactory\", FACTORY_ADDRESS); // Get diamond to rollback const diamond = await ethers.getContractAt(\"Diamond\", DIAMOND_ADDRESS); // Use previous facet set const previousFacetSet = \"previousFacetSet\"; // Get facets from the set const facets = await diamondFactory.getFacets(previousFacetSet); // Rollback diamond const tx = await diamond.diamondCut( facets, ethers.constants.AddressZero, \"0x\" ); await tx.wait(); console.log(\"Diamond rolled back successfully\"); } ``` Emergency pause : ```javascript // scripts/emergency-pause.js async function main() { // Get contract const contract = await ethers.getContractAt(\"PausableFacet\", DIAMOND_ADDRESS); // Pause the contract const tx = await contract.pause(); await tx.wait(); console.log(\"Contract paused successfully\"); } ```","title":"Smart Contract Rollbacks"},{"location":"gemforce-deployer-guide/#cloud-function-rollbacks","text":"Rolling back with Git : ```bash # Rollback to previous commit git reset --hard HEAD~1 npm install npm run build # Restart server pm2 restart gemforce-server ``` Using deployment tags : ```bash # List tags git tag -l # Checkout specific version git checkout v1.2.3 npm install npm run build # Restart server pm2 restart gemforce-server ``` Specific file rollback : ```bash # Revert specific file git checkout HEAD~1 -- src/cloud-functions/specific-file.ts npm run build # Restart server pm2 restart gemforce-server ```","title":"Cloud Function Rollbacks"},{"location":"gemforce-deployer-guide/#database-rollbacks","text":"Restoring from backup : bash # Restore MongoDB from backup mongorestore --uri=\"mongodb://username:password@host:port/database\" --drop /backup/path/YYYY-MM-DD Rolling back a migration : bash # Roll back the last migration npx migrate-mongo down Manual data correction script : ```javascript // scripts/correct-data.js async function main() { const MongoClient = require('mongodb').MongoClient; const client = await MongoClient.connect(process.env.DATABASE_URI); const db = client.db(); try { // Correct data issues await db.collection('User').updateMany( { incorrectField: { $exists: true } }, { $rename: { \"incorrectField\": \"correctField\" } } ); console.log(\"Data correction complete\"); } catch (error) { console.error(\"Error correcting data:\", error); } finally { await client.close(); } } main().catch(console.error); ```","title":"Database Rollbacks"},{"location":"gemforce-deployer-guide/#emergency-procedures","text":"Complete service rollback : ```bash # Emergency rollback script #!/bin/bash # scripts/emergency-rollback.sh # Stop the current service pm2 stop gemforce-server # Restore code from known good state git checkout v1.2.3 npm install npm run build # Restore database mongorestore --uri=\"$DATABASE_URI\" --drop /backups/latest # Restart the service pm2 start gemforce-server # Notify team curl -X POST -H \"Content-Type: application/json\" \\ -d '{\"text\":\"Emergency rollback performed to v1.2.3\"}' \\ $SLACK_WEBHOOK_URL ``` Read-only mode : ```javascript // Enable read-only mode Parse.Cloud.beforeSave(\"*\", async () => { if (process.env.READONLY_MODE === \"true\") { throw new Parse.Error( Parse.Error.OPERATION_FORBIDDEN, \"System is currently in read-only mode for maintenance.\" ); } }); Parse.Cloud.beforeDelete(\"*\", async () => { if (process.env.READONLY_MODE === \"true\") { throw new Parse.Error( Parse.Error.OPERATION_FORBIDDEN, \"System is currently in read-only mode for maintenance.\" ); } }); ```","title":"Emergency Procedures"},{"location":"gemforce-deployer-guide/#data-integrity-verification","text":"Verifying contract state : ```javascript // scripts/verify-contract-state.js async function main() { // Get contract const contract = await ethers.getContractAt(\"DiamondLoupe\", DIAMOND_ADDRESS); // Get all facets const facets = await contract.facets(); // Verify each facet for (const facet of facets) { console.log(`Verifying facet at ${facet.facetAddress}`); // Get facet code const code = await ethers.provider.getCode(facet.facetAddress); // Check code is not empty if (code === \"0x\" || code === \"0x0\") { throw new Error(`Facet at ${facet.facetAddress} has no code!`); } // Verify selectors for (const selector of facet.functionSelectors) { const result = await contract.facetAddress(selector); if (result !== facet.facetAddress) { throw new Error(`Selector ${selector} points to wrong facet!`); } } } console.log(\"Contract state verification successful\"); } main().catch(console.error); ``` Database integrity check : ```javascript // scripts/verify-database.js async function main() { const MongoClient = require('mongodb').MongoClient; const client = await MongoClient.connect(process.env.DATABASE_URI); const db = client.db(); try { // Check User collection integrity const userCount = await db.collection('User').countDocuments(); console.log(`User count: ${userCount}`); // Check for duplicate emails const duplicateEmails = await db.collection('User').aggregate([ { $group: { _id: \"$email\", count: { $sum: 1 } } }, { $match: { count: { $gt: 1 } } } ]).toArray(); if (duplicateEmails.length > 0) { console.error(`Found ${duplicateEmails.length} duplicate emails!`); console.error(duplicateEmails); } // Verify indexes const indexes = await db.collection('User').indexes(); console.log(\"Indexes:\", indexes); // More integrity checks... console.log(\"Database integrity check complete\"); } finally { await client.close(); } } main().catch(console.error); ```","title":"Data Integrity Verification"},{"location":"gemforce-deployer-guide/#testing-and-verification","text":"","title":"Testing and Verification"},{"location":"gemforce-deployer-guide/#unit-testing","text":"Smart contract unit tests : ```javascript // test/unit/GemforceMinter.test.ts describe(\"GemforceMinter\", function() { let owner, user1, user2; let diamond, gemforceMinter; beforeEach(async function() { [owner, user1, user2] = await ethers.getSigners(); // Deploy diamond with facets // ...deployment code gemforceMinter = await ethers.getContractAt(\"GemforceMinterFacet\", diamond.address); }); it(\"should allow owner to mint\", async function() { const metadata = [ { key: \"name\", attributeType: 0, value: \"Carbon Credit\" } ]; const tx = await gemforceMinter.connect(owner).gemforceMint(metadata); const receipt = await tx.wait(); // Check events const event = receipt.events.find(e => e.event === \"GemforceMinted\"); expect(event).to.exist; expect(event.args.tokenId).to.equal(0); expect(event.args.minter).to.equal(owner.address); }); it(\"should revert when non-owner tries to mint\", async function() { const metadata = [ { key: \"name\", attributeType: 0, value: \"Carbon Credit\" } ]; await expect( gemforceMinter.connect(user1).gemforceMint(metadata) ).to.be.revertedWith(\"Only contract owner\"); }); }); ``` Cloud function unit tests : ```javascript // test/unit/cloud-functions.test.js describe(\"Cloud Functions Unit Tests\", function() { before(function() { // Mock Parse this.originalParse = global.Parse; global.Parse = { Cloud: { define: (name, handler) => { this.cloudFunctions[name] = handler; } }, Error: { INVALID_PARAMS: 141 } }; // Load cloud functions this.cloudFunctions = {}; require(\"../../src/cloud-functions/contracts\"); }); after(function() { global.Parse = this.originalParse; }); it(\"should validate parameters in addDiamondFacet\", async function() { const handler = this.cloudFunctions.addDiamondFacet; // Missing parameters try { await handler({ params: {} }); assert.fail(\"Should have thrown an error\"); } catch (e) { expect(e.code).to.equal(Parse.Error.INVALID_PARAMS); } // With valid parameters (mocked) const mockResult = { success: true }; this.addDiamondFacet = sinon.stub().resolves(mockResult); const result = await handler({ params: { networkId: \"1\", diamondAddress: \"0x123\", facetName: \"TestFacet\" } }); expect(result).to.deep.equal(mockResult); }); }); ```","title":"Unit Testing"},{"location":"gemforce-deployer-guide/#integration-testing","text":"Smart contract integration tests : ```javascript // test/integration/marketplace-flow.test.ts describe(\"Marketplace Integration\", function() { let owner, seller, buyer; let diamond, marketplace, gem, treasury; before(async function() { [owner, seller, buyer] = await ethers.getSigners(); // Deploy all contracts // ...deployment code // Get contract instances diamond = await ethers.getContractAt(\"Diamond\", diamondAddress); marketplace = await ethers.getContractAt(\"MarketplaceFacet\", diamondAddress); gem = await ethers.getContractAt(\"GemforceMinterFacet\", diamondAddress); treasury = await ethers.getContractAt(\"Treasury\", treasuryAddress); }); it(\"should support full marketplace flow\", async function() { // Mint token const metadata = [{ key: \"test\", attributeType: 0, value: \"value\" }]; await gem.connect(owner).gemforceMint(metadata); // List token await marketplace.connect(owner).listItem(0, ethers.utils.parseEther(\"1.0\")); // Check listing const listing = await marketplace.getListing(0); expect(listing.price).to.equal(ethers.utils.parseEther(\"1.0\")); // Purchase token await marketplace.connect(buyer).purchaseItem(diamondAddress, 0, { value: ethers.utils.parseEther(\"1.0\") }); // Check ownership const newOwner = await diamond.ownerOf(0); expect(newOwner).to.equal(buyer.address); // Check treasury balance const balance = await treasury.getBalance(); expect(balance).to.be.gt(0); }); }); ``` API integration tests : ```javascript // test/integration/api-flow.test.js describe(\"API Integration\", function() { let user; before(async function() { // Initialize Parse Parse.initialize(\"test_app_id\", \"test_js_key\", \"test_master_key\"); Parse.serverURL = \"http://localhost:1337/parse\"; // Create test user user = new Parse.User(); user.set(\"username\", \"test@example.com\"); user.set(\"password\", \"password\"); user.set(\"email\", \"test@example.com\"); await user.signUp(); }); it(\"should handle user blockchain operations\", async function() { // Get blockchains const blockchains = await Parse.Cloud.run(\"loadAllBlockchains\"); expect(blockchains).to.be.an(\"array\"); // Create DFNS wallet (mocked) const walletResult = await Parse.Cloud.run(\"registerInit\", { username: user.get(\"email\") }); expect(walletResult).to.have.property(\"challenge\"); // Complete registration (mocked) const registrationResult = await Parse.Cloud.run(\"registerComplete\", { signedChallenge: \"mocked_challenge\", temporaryAuthenticationToken: \"mocked_token\" }); expect(registrationResult).to.have.property(\"token\"); // List wallets const wallets = await Parse.Cloud.run(\"listWallets\", { authToken: registrationResult.token }); expect(wallets).to.have.property(\"wallets\"); }); }); ```","title":"Integration Testing"},{"location":"gemforce-deployer-guide/#contract-verification_1","text":"Verifying contracts on block explorer : ```bash # Verify contract on Etherscan or Basescan npx hardhat verify --network baseSepolia # Verify contract with libraries npx hardhat verify --network baseSepolia \\ --libraries Library1=0x123... Library2=0x456... ``` Automated verification script : ```javascript // scripts/verify-contracts.js async function main() { // Get deployment data const deployments = require('../deployments.json'); const network = process.env.NETWORK || 'baseSepolia'; const networkId = hre.config.networks[network].chainId; // Verify Diamond contract const diamondAddress = deployments[networkId].diamondAddress; console.log(`Verifying Diamond at ${diamondAddress}`); try { await hre.run(\"verify:verify\", { address: diamondAddress, constructorArguments: [] }); } catch (e) { console.log(`Error verifying Diamond: ${e.message}`); } // Verify Facets const facets = deployments[networkId].facets || []; for (const facet of facets) { console.log(`Verifying facet ${facet.name} at ${facet.address}`); try { await hre.run(\"verify:verify\", { address: facet.address, constructorArguments: [] }); } catch (e) { console.log(`Error verifying ${facet.name}: ${e.message}`); } } } main().catch(console.error); ```","title":"Contract Verification"},{"location":"gemforce-deployer-guide/#load-testing","text":"Smart contract load testing : ```javascript // test/load/contract-load.test.js describe(\"Contract Load Test\", function() { // Increase timeout for load tests this.timeout(300000); let diamond, minter; let signers; before(async function() { // Get signers signers = await ethers.getSigners(); // Deploy contracts // ...deployment code diamond = await ethers.getContractAt(\"Diamond\", diamondAddress); minter = await ethers.getContractAt(\"GemforceMinterFacet\", diamondAddress); }); it(\"should handle concurrent minting\", async function() { const concurrentMints = 50; const mintPromises = []; // Create concurrent mint operations for (let i = 0; i < concurrentMints; i++) { const metadata = [ { key: \"name\", attributeType: 0, value: `Token ${i}` }, { key: \"value\", attributeType: 1, value: i.toString() } ]; mintPromises.push(minter.connect(signers[0]).gemforceMint(metadata)); } // Wait for all mints to complete const results = await Promise.allSettled(mintPromises); // Count successful mints const successfulMints = results.filter(r => r.status === \"fulfilled\").length; console.log(`Successfully minted ${successfulMints} of ${concurrentMints} tokens`); // Analyze failures const failures = results.filter(r => r.status === \"rejected\"); for (const failure of failures) { console.log(`Failure reason: ${failure.reason}`); } expect(successfulMints).to.be.gt(0); }); }); ``` API load testing with Artillery : ```yaml # load-tests/api-load.yml config: target: \"https://api.gemforce.com\" phases: - duration: 60 arrivalRate: 5 rampTo: 50 name: \"Warm up phase\" - duration: 120 arrivalRate: 50 name: \"Sustained load\" - duration: 60 arrivalRate: 50 rampTo: 100 name: \"Peak load\" defaults: headers: X-Parse-Application-Id: \"{{APP_ID}}\" Content-Type: \"application/json\" scenarios: - name: \"Load test API endpoints\" flow: - post: url: \"/parse/functions/loadAllBlockchains\" json: {} expect: - statusCode: 200 - post: url: \"/parse/functions/loadProviderUrl\" json: networkId: \"84532\" expect: - statusCode: 200 - post: url: \"/parse/functions/loadSmartContractsForNetwork\" json: networkId: \"84532\" expect: - statusCode: 200 ``` Run with: bash npx artillery run load-tests/api-load.yml --environment production","title":"Load Testing"},{"location":"gemforce-deployer-guide/#security-testing","text":"Smart contract security testing : ```bash # Run Slither security analyzer slither contracts/ # Run Mythril myth analyze contracts/Diamond.sol ``` Penetration testing for API : bash # Run OWASP ZAP scan zap-cli quick-scan -s xss,sqli -r report.html https://api.gemforce.com Authentication security tests : ```javascript // test/security/auth.test.js describe(\"Authentication Security\", function() { it(\"should reject invalid authentication\", async function() { // Try with invalid app ID try { Parse.initialize(\"invalid_app_id\", \"test_js_key\"); await Parse.Cloud.run(\"loadAllBlockchains\"); assert.fail(\"Should have thrown an error\"); } catch (e) { expect(e.code).to.equal(Parse.Error.INVALID_APP_ID); } // Try with invalid master key try { Parse.initialize(\"test_app_id\", \"test_js_key\", \"invalid_master_key\"); const user = new Parse.User(); await user.fetch({ useMasterKey: true }); assert.fail(\"Should have thrown an error\"); } catch (e) { expect(e.code).to.equal(Parse.Error.INVALID_MASTER_KEY); } }); }); ```","title":"Security Testing"},{"location":"gemforce-deployer-guide/#network-management","text":"","title":"Network Management"},{"location":"gemforce-deployer-guide/#blockchain-node-management","text":"Connecting to blockchain nodes : ```javascript // src/lib/blockchain.js const { ethers } = require(\"ethers\"); // Get provider for network function getProvider(networkId) { const networks = { \"1\": process.env.ETH_NODE_URI_MAINNET, \"84532\": process.env.ETH_NODE_URI_BASESEP }; const nodeUrl = networks[networkId]; if (!nodeUrl) { throw new Error(`No RPC endpoint configured for network ${networkId}`); } return new ethers.providers.JsonRpcProvider(nodeUrl); } // Get WebSocket provider for network function getWebSocketProvider(networkId) { const networks = { \"1\": process.env.ETH_WSS_URI_MAINNET, \"84532\": process.env.ETH_WSS_URI_BASESEP }; const nodeUrl = networks[networkId]; if (!nodeUrl) { throw new Error(`No WebSocket endpoint configured for network ${networkId}`); } return new ethers.providers.WebSocketProvider(nodeUrl); } module.exports = { getProvider, getWebSocketProvider }; ``` Monitoring node health : ```javascript // src/lib/node-monitor.js const { getProvider } = require(\"./blockchain\"); async function checkNodeHealth(networkId) { try { const provider = getProvider(networkId); // Check if node is responding const blockNumber = await provider.getBlockNumber(); // Check if node is synced const syncStatus = await provider.send(\"eth_syncing\", []); const isSynced = syncStatus === false; // Check chain ID const chainId = await provider.getNetwork().then(net => net.chainId); const isCorrectChain = chainId.toString() === networkId; // Check peers const peerCount = await provider.send(\"net_peerCount\", []); const peers = parseInt(peerCount, 16); const hasPeers = peers > 0; return { isHealthy: isSynced && isCorrectChain && hasPeers, blockNumber, isSynced, isCorrectChain, peers }; } catch (error) { return { isHealthy: false, error: error.message }; } } ``` Node failover : ```javascript // src/lib/node-failover.js const { ethers } = require(\"ethers\"); class FailoverProvider extends ethers.providers.StaticJsonRpcProvider { constructor(urls, network) { super(urls[0], network); this.urls = urls; this.currentUrlIndex = 0; } async send(method, params) { try { return await super.send(method, params); } catch (error) { // Try failover if (this.urls.length > 1) { this.currentUrlIndex = (this.currentUrlIndex + 1) % this.urls.length; this.connection.url = this.urls[this.currentUrlIndex]; console.log(`Failing over to ${this.connection.url}`); return await super.send(method, params); } throw error; } } } function getFailoverProvider(networkId) { const networks = { \"1\": [ process.env.ETH_NODE_URI_MAINNET_1, process.env.ETH_NODE_URI_MAINNET_2, process.env.ETH_NODE_URI_MAINNET_3 ], \"84532\": [ process.env.ETH_NODE_URI_BASESEP_1, process.env.ETH_NODE_URI_BASESEP_2 ] }; const urls = networks[networkId].filter(Boolean); if (urls.length === 0) { throw new Error(`No RPC endpoints configured for network ${networkId}`); } return new FailoverProvider(urls, parseInt(networkId)); } ```","title":"Blockchain Node Management"},{"location":"gemforce-deployer-guide/#rpc-endpoint-configuration","text":"Configuration file for RPC endpoints : javascript // config/networks.js module.exports = { mainnet: { chainId: 1, name: \"Ethereum Mainnet\", rpcEndpoints: [ { url: process.env.ETH_NODE_URI_MAINNET_1, provider: \"Infura\", weight: 10 }, { url: process.env.ETH_NODE_URI_MAINNET_2, provider: \"Alchemy\", weight: 5 }, { url: process.env.ETH_NODE_URI_MAINNET_3, provider: \"Custom\", weight: 1 } ], wsEndpoints: [ { url: process.env.ETH_WSS_URI_MAINNET, provider: \"Infura\" } ], explorerUrl: \"https://etherscan.io\" }, baseSepolia: { chainId: 84532, name: \"Base Sepolia\", rpcEndpoints: [ { url: process.env.ETH_NODE_URI_BASESEP_1, provider: \"Base\", weight: 10 }, { url: process.env.ETH_NODE_URI_BASESEP_2, provider: \"Alchemy\", weight: 5 } ], wsEndpoints: [ { url: process.env.ETH_WSS_URI_BASESEP, provider: \"Base\" } ], explorerUrl: \"https://sepolia.basescan.org\" } }; RPC endpoint selection logic : ```javascript // src/lib/rpc-manager.js const networks = require(\"../../config/networks\"); function selectRpcEndpoint(networkId) { const network = Object.values(networks).find(n => n.chainId === parseInt(networkId)); if (!network) { throw new Error( Network ${networkId} not found in configuration ); } // Use weighted selection const endpoints = network.rpcEndpoints.filter(e => e.url); if (endpoints.length === 0) { throw new Error(`No RPC endpoints configured for network ${networkId}`); } // Simple random selection for now // Could be expanded to use performance metrics or more complex selection const totalWeight = endpoints.reduce((sum, e) => sum + e.weight, 0); let random = Math.random() * totalWeight; for (const endpoint of endpoints) { random -= endpoint.weight; if (random <= 0) { return endpoint.url; } } // Fallback to first endpoint return endpoints[0].url; } ``` Environment-specific configuration : ```javascript // src/lib/network-config.js const networks = require(\"../../config/networks\"); function getNetworkConfig(networkId, environment = process.env.NODE_ENV) { const network = Object.values(networks).find(n => n.chainId === parseInt(networkId)); if (!network) { throw new Error( Network ${networkId} not found in configuration ); } // Apply environment-specific overrides const envOverrides = { development: { rpcEndpoints: [ { url: \"http://localhost:8545\", provider: \"Local\", weight: 100 } ] }, test: { // Test environment might use special endpoints }, // production uses default configuration }; if (envOverrides[environment]) { return { ...network, ...envOverrides[environment] }; } return network; } ```","title":"RPC Endpoint Configuration"},{"location":"gemforce-deployer-guide/#transaction-monitoring","text":"Monitoring transaction status : ```javascript // src/lib/transaction-monitor.js const { getProvider } = require(\"./blockchain\"); const db = require(\"./db\"); async function monitorTransaction(txHash, networkId) { const provider = getProvider(networkId); // Store the transaction in the database await db.collection(\"Transaction\").insertOne({ hash: txHash, networkId, status: \"pending\", createdAt: new Date(), attempts: 0 }); // Get initial transaction receipt let receipt = await provider.getTransactionReceipt(txHash); // Transaction is still pending if (!receipt) { // Schedule check for later setTimeout(() => checkTransaction(txHash, networkId), 15000); return { status: \"pending\" }; } // Transaction is mined updateTransactionStatus(txHash, receipt); return { status: receipt.status ? \"confirmed\" : \"failed\", receipt }; } async function checkTransaction(txHash, networkId) { try { const provider = getProvider(networkId); const receipt = await provider.getTransactionReceipt(txHash); if (!receipt) { // Still pending, check if it's been too long const tx = await db.collection(\"Transaction\").findOne({ hash: txHash }); const age = Date.now() - tx.createdAt.getTime(); const attempts = tx.attempts + 1; await db.collection(\"Transaction\").updateOne( { hash: txHash }, { $set: { attempts }, $currentDate: { lastChecked: true } } ); if (age > 3600000) { // 1 hour // Transaction has been pending too long await db.collection(\"Transaction\").updateOne( { hash: txHash }, { $set: { status: \"stalled\" } } ); // Could notify an admin here } else { // Check again later setTimeout(() => checkTransaction(txHash, networkId), 30000); } return; } // Transaction is mined, update status updateTransactionStatus(txHash, receipt); } catch (error) { console.error(`Error checking transaction ${txHash}:`, error); } } async function updateTransactionStatus(txHash, receipt) { const status = receipt.status ? \"confirmed\" : \"failed\"; await db.collection(\"Transaction\").updateOne( { hash: txHash }, { $set: { status, blockNumber: receipt.blockNumber, gasUsed: receipt.gasUsed.toString(), effectiveGasPrice: receipt.effectiveGasPrice.toString() } } ); } ``` Transaction event listener : ```javascript // src/lib/event-listener.js const { getWebSocketProvider } = require(\"./blockchain\"); const db = require(\"./db\"); class TransactionEventListener { constructor(networkId) { this.networkId = networkId; this.provider = getWebSocketProvider(networkId); this.contracts = new Map(); } addContract(address, abi, name) { const contract = new ethers.Contract(address, abi, this.provider); this.contracts.set(address, { contract, name }); console.log(`Added contract ${name} at ${address} for event monitoring`); return contract; } startListening() { // Listen for new blocks this.provider.on(\"block\", this.handleNewBlock.bind(this)); // Listen for specific events on each contract for (const [address, { contract, name }] of this.contracts.entries()) { contract.on(\"*\", (...args) => { const event = args[args.length - 1]; this.handleContractEvent(name, event); }); } } async handleNewBlock(blockNumber) { console.log(`New block: ${blockNumber} on network ${this.networkId}`); // Check pending transactions const pendingTxs = await db.collection(\"Transaction\").find({ networkId: this.networkId, status: \"pending\" }).toArray(); for (const tx of pendingTxs) { try { const receipt = await this.provider.getTransactionReceipt(tx.hash); if (receipt) { const status = receipt.status ? \"confirmed\" : \"failed\"; await db.collection(\"Transaction\").updateOne( { hash: tx.hash }, { $set: { status, blockNumber: receipt.blockNumber, gasUsed: receipt.gasUsed.toString(), effectiveGasPrice: receipt.effectiveGasPrice.toString() } } ); console.log(`Transaction ${tx.hash} ${status} in block ${receipt.blockNumber}`); } } catch (error) { console.error(`Error checking transaction ${tx.hash}:`, error); } } } async handleContractEvent(contractName, event) { console.log(`Event from ${contractName}: ${event.event}`); // Store event in database await db.collection(\"ContractEvent\").insertOne({ contractName, eventName: event.event, transactionHash: event.transactionHash, blockNumber: event.blockNumber, args: JSON.parse(JSON.stringify(event.args)), // Convert BigNumber to string timestamp: new Date() }); // Emit event for WebSocket clients if needed } stop() { this.provider.removeAllListeners(); for (const [address, { contract }] of this.contracts.entries()) { contract.removeAllListeners(); } console.log(`Stopped event listener for network ${this.networkId}`); } } ```","title":"Transaction Monitoring"},{"location":"gemforce-deployer-guide/#gas-price-management","text":"Gas price estimation : ```javascript // src/lib/gas-price.js const { ethers } = require(\"ethers\"); const { getProvider } = require(\"./blockchain\"); async function estimateGasPrice(networkId, priority = \"medium\") { try { const provider = getProvider(networkId); // Get current gas price from provider const gasPrice = await provider.getGasPrice(); // Apply multipliers based on priority const multipliers = { low: 0.8, medium: 1.0, high: 1.5, urgent: 2.0 }; const multiplier = multipliers[priority] || 1.0; return gasPrice.mul(Math.floor(multiplier * 100)).div(100); } catch (error) { console.error(`Error estimating gas price:`, error); // Fallback gas prices (in gwei) const fallbackPrices = { 1: { low: 20, medium: 30, high: 50, urgent: 80 }, // Mainnet 84532: { low: 1, medium: 1.5, high: 2, urgent: 3 } // BaseSepolia }; const gweiPrice = fallbackPrices[networkId]?.[priority] || 10; return ethers.utils.parseUnits(gweiPrice.toString(), \"gwei\"); } } async function getGasSettings(networkId, priority = \"medium\") { const gasPrice = await estimateGasPrice(networkId, priority); // For EIP-1559 compatible networks, use maxFeePerGas and maxPriorityFeePerGas const provider = getProvider(networkId); const network = await provider.getNetwork(); // Check if network supports EIP-1559 const block = await provider.getBlock(\"latest\"); const eip1559Support = block && block.baseFeePerGas !== undefined; if (eip1559Support) { const baseFeePerGas = block.baseFeePerGas; // Priority fee multipliers const priorityFeeMultipliers = { low: 1.0, medium: 1.5, high: 2.0, urgent: 3.0 }; const multiplier = priorityFeeMultipliers[priority] || 1.5; const maxPriorityFeePerGas = ethers.utils.parseUnits(\"1\", \"gwei\").mul(multiplier); // maxFeePerGas = (baseFeePerGas * 2) + maxPriorityFeePerGas const maxFeePerGas = baseFeePerGas.mul(2).add(maxPriorityFeePerGas); return { maxFeePerGas, maxPriorityFeePerGas }; } // Fallback to regular gasPrice for non-EIP-1559 networks return { gasPrice }; } ``` Transaction submission with gas management : ```javascript // src/lib/transaction.js const { getProvider } = require(\"./blockchain\"); const { getGasSettings } = require(\"./gas-price\"); async function sendTransaction(networkId, txData, priority = \"medium\") { const provider = getProvider(networkId); const signer = new ethers.Wallet(process.env.PRIVATE_KEY, provider); // Get gas settings based on network and priority const gasSettings = await getGasSettings(networkId, priority); // Estimate gas limit const gasLimit = await provider.estimateGas({ from: signer.address, to: txData.to, data: txData.data, value: txData.value || 0 }); // Add buffer to gas limit const gasLimitWithBuffer = gasLimit.mul(120).div(100); // 20% buffer // Construct transaction const transaction = { from: signer.address, to: txData.to, data: txData.data, value: txData.value || 0, gasLimit: gasLimitWithBuffer, ...gasSettings }; // Send transaction const tx = await signer.sendTransaction(transaction); console.log(`Transaction sent: ${tx.hash}`); return tx; } ```","title":"Gas Price Management"},{"location":"gemforce-deployer-guide/#network-upgrades-handling","text":"Network upgrade detector : ```javascript // src/lib/network-upgrade.js const { getProvider } = require(\"./blockchain\"); async function checkNetworkUpgrade(networkId) { try { const provider = getProvider(networkId); // Get current block const block = await provider.getBlock(\"latest\"); // Check for fork identifier or other upgrade indicators const isEIP1559 = block && block.baseFeePerGas !== undefined; // Check for upcoming network upgrades const upgrades = { 1: [ // Ethereum Mainnet { name: \"Cancun\", block: 19000000, active: block.number >= 19000000 } ], 84532: [ // BaseSepolia { name: \"Future Upgrade\", block: 5000000, active: block.number >= 5000000 } ] }; const networkUpgrades = upgrades[networkId] || []; const upcomingUpgrades = networkUpgrades.filter(u => !u.active); const activeUpgrades = networkUpgrades.filter(u => u.active); return { currentBlock: block.number, features: { eip1559: isEIP1559 }, activeUpgrades, upcomingUpgrades }; } catch (error) { console.error(`Error checking network upgrade:`, error); return { error: error.message }; } } ``` Handling network forks : ```javascript // src/lib/fork-handler.js const { getProvider } = require(\"./blockchain\"); class ForkHandler { constructor(networkId) { this.networkId = networkId; this.provider = getProvider(networkId); this.forkBlocks = { 1: { // Ethereum Mainnet \"Cancun\": 19000000 }, 84532: { // BaseSepolia \"FutureUpgrade\": 5000000 } }; } async detectFork() { const currentBlock = await this.provider.getBlockNumber(); const networkForks = this.forkBlocks[this.networkId] || {}; const activeForks = []; const pendingForks = []; for (const [name, blockNumber] of Object.entries(networkForks)) { if (currentBlock >= blockNumber) { activeForks.push({ name, blockNumber }); } else { pendingForks.push({ name, blockNumber, blocksRemaining: blockNumber - currentBlock }); } } return { currentBlock, activeForks, pendingForks }; } async adjustForFork(txParams) { const forkStatus = await this.detectFork(); const newParams = { ...txParams }; // Adjust transaction parameters based on active forks for (const fork of forkStatus.activeForks) { if (fork.name === \"Cancun\" || fork.name === \"London\") { // EIP-1559 transaction type delete newParams.gasPrice; if (!newParams.maxFeePerGas) { const block = await this.provider.getBlock(\"latest\"); const baseFeePerGas = block.baseFeePerGas; newParams.maxPriorityFeePerGas = ethers.utils.parseUnits(\"1.5\", \"gwei\"); newParams.maxFeePerGas = baseFeePerGas.mul(2).add(newParams.maxPriorityFeePerGas); } // Set type 2 transaction (EIP-1559) newParams.type = 2; } } return newParams; } } ```","title":"Network Upgrades Handling"},{"location":"gemforce-deployer-guide/#version-control","text":"","title":"Version Control"},{"location":"gemforce-deployer-guide/#repository-structure","text":"Recommended repository structure : gemforce/ \u251c\u2500\u2500 .github/ # GitHub workflows and templates \u251c\u2500\u2500 contracts/ # Smart contracts \u2502 \u251c\u2500\u2500 facets/ # Diamond facets \u2502 \u251c\u2500\u2500 interfaces/ # Contract interfaces \u2502 \u251c\u2500\u2500 libraries/ # Contract libraries \u2502 \u251c\u2500\u2500 upgradeInitializers/ # Initializers for upgrades \u251c\u2500\u2500 deploy/ # Deployment scripts \u251c\u2500\u2500 deployments/ # Deployment artifacts \u251c\u2500\u2500 docs/ # Documentation \u251c\u2500\u2500 scripts/ # Utility scripts \u251c\u2500\u2500 src/ # Source code \u2502 \u251c\u2500\u2500 cloud-functions/ # Parse cloud functions \u2502 \u251c\u2500\u2500 lib/ # Shared libraries \u2502 \u251c\u2500\u2500 indexer/ # Blockchain indexer \u2502 \u251c\u2500\u2500 triggers/ # Parse triggers \u251c\u2500\u2500 test/ # Tests \u2502 \u251c\u2500\u2500 unit/ # Unit tests \u2502 \u251c\u2500\u2500 integration/ # Integration tests \u2502 \u251c\u2500\u2500 fixtures/ # Test fixtures \u251c\u2500\u2500 .env.example # Example environment variables \u251c\u2500\u2500 hardhat.config.ts # Hardhat configuration \u251c\u2500\u2500 package.json # Project metadata and dependencies \u251c\u2500\u2500 tsconfig.json # TypeScript configuration \u2514\u2500\u2500 README.md # Project documentation Repository organization best practices : Separate smart contracts from off-chain code Organize contracts by functionality Use descriptive folder names Keep tests close to the code they test Include documentation for each component","title":"Repository Structure"},{"location":"gemforce-deployer-guide/#branching-strategy","text":"Git Flow branching model : main \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500 (production releases) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 staging \u2502 \u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500 (pre-production testing) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 develop \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500 (integration branch) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 feature/xyz \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf \u2502 \u2502 (feature branches) \u2502 \u2502 \u2502 feature/abc \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u25cf \u2502 (feature branches) \u2502 hotfix/123 \u25cf\u2500\u2500\u2500\u2500\u2500 (hotfix branches) main : Production code, tagged with version numbers staging : Pre-production testing develop : Integration branch for feature development feature/ *: Feature branches for new development hotfix/ *: Urgent fixes for production issues Branching guidelines : ```bash # Create a new feature branch from develop git checkout develop git pull git checkout -b feature/new-feature # Work on the feature, committing changes git add . git commit -m \"Implement new feature\" # Push feature branch to remote git push -u origin feature/new-feature # When feature is complete, merge to develop git checkout develop git pull git merge --no-ff feature/new-feature git push origin develop # Create a hotfix branch from main git checkout main git pull git checkout -b hotfix/critical-fix # Fix the issue, commit changes git add . git commit -m \"Fix critical issue\" # Push hotfix branch git push -u origin hotfix/critical-fix # When hotfix is complete, merge to main and develop git checkout main git pull git merge --no-ff hotfix/critical-fix git push origin main git checkout develop git pull git merge --no-ff hotfix/critical-fix git push origin develop ```","title":"Branching Strategy"},{"location":"gemforce-deployer-guide/#release-management","text":"Semantic versioning : MAJOR.MINOR.PATCH MAJOR : Breaking changes MINOR : New features, backwards compatible PATCH : Bug fixes, backwards compatible Release process : ```bash # Prepare release from develop git checkout develop git pull git checkout -b release/1.2.0 # Update version numbers npm version minor --no-git-tag-version # Make final adjustments git add . git commit -m \"Prepare release 1.2.0\" # Merge to staging for testing git checkout staging git pull git merge --no-ff release/1.2.0 git push origin staging # Deploy to staging environment npm run deploy:staging # After testing, merge to main git checkout main git pull git merge --no-ff release/1.2.0 git tag -a v1.2.0 -m \"Release 1.2.0\" git push origin main --tags # Update develop with any changes git checkout develop git pull git merge --no-ff release/1.2.0 git push origin develop # Delete release branch git branch -d release/1.2.0 ``` Changelog management : ```markdown # Changelog All notable changes to this project will be documented in this file. ## [1.2.0] - 2025-02-25 ### Added - New carbon credit retirement feature - Support for multiple wallet providers ### Changed - Improved marketplace performance - Updated identity verification flow ### Fixed - Fixed issue with token minting - Resolved WebSocket connection stability ## [1.1.0] - 2025-01-15 ### Added - Identity management system - DFNS wallet integration ### Changed - Upgraded Parse Server to latest version - Improved error handling ### Deprecated - Legacy API endpoints (to be removed in 2.0) ```","title":"Release Management"},{"location":"gemforce-deployer-guide/#tagging-conventions","text":"Version tags : ```bash # Create an annotated version tag git tag -a v1.2.0 -m \"Release 1.2.0\" # Push tags to remote git push origin --tags ``` Environment tags : ```bash # Create a tag for production deployment git tag -a prod-2025-02-25 -m \"Production deployment on Feb 25, 2025\" # Create a tag for staging deployment git tag -a staging-2025-02-20 -m \"Staging deployment on Feb 20, 2025\" ``` Contract deployment tags : ```bash # Create a tag for contract deployment git tag -a deploy-mainnet-1.2.0 -m \"Mainnet contract deployment v1.2.0\" # Create a tag for facet upgrade git tag -a upgrade-marketplace-1.2.1 -m \"Marketplace facet upgrade to v1.2.1\" ```","title":"Tagging Conventions"},{"location":"gemforce-deployer-guide/#documentation-versioning","text":"Documentation directory structure : docs/ \u251c\u2500\u2500 latest/ # Latest documentation (symlink to current version) \u251c\u2500\u2500 v1.2.0/ # Documentation for v1.2.0 \u2502 \u251c\u2500\u2500 admin-guide.md # Administrator guide \u2502 \u251c\u2500\u2500 api-reference.md # API reference \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 v1.1.0/ # Documentation for v1.1.0 \u2502 \u251c\u2500\u2500 admin-guide.md # Administrator guide \u2502 \u251c\u2500\u2500 api-reference.md # API reference \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 ... Version-specific documentation : ```bash # Create a new documentation version mkdir -p docs/v1.2.0 cp -r docs/v1.1.0/* docs/v1.2.0/ # Update documentation for new version # Edit files in docs/v1.2.0/ # Update the latest symlink rm docs/latest ln -s v1.2.0 docs/latest ``` Documentation in the codebase : ```solidity // contracts/facets/MarketplaceFacet.sol /* * @title MarketplaceFacet * @dev Implements marketplace functionality for the Diamond * @notice This facet handles listing, buying, and selling tokens * @version 1.2.0 / contract MarketplaceFacet is Modifiers { // ... ``` ```javascript // src/cloud-functions/marketplace.js /* * @api {post} /parse/functions/listItem List an item for sale * @apiVersion 1.2.0 * @apiName ListItem * @apiGroup Marketplace * @apiDescription Lists a token for sale in the marketplace * * @apiParam {String} tokenId The ID of the token to list * @apiParam {String} price The price in ETH * * @apiSuccess {Object} result The result of the operation * @apiSuccess {Boolean} result.success Whether the operation was successful * @apiSuccess {String} result.transactionHash The transaction hash / Parse.Cloud.define(\"listItem\", async (request) => { // ... });","title":"Documentation Versioning"},{"location":"gemforce-documentation-gap-analysis/","text":"Gemforce Documentation Gap Analysis \u00b6 Executive Summary \u00b6 This document provides a comprehensive analysis of documentation gaps in the Gemforce platform based on a thorough examination of the /Users/sschepis/Development/gem-base project. The analysis identifies missing documentation across multiple categories including smart contracts, APIs, deployment guides, developer resources, and operational documentation. Current Documentation Status \u00b6 \u2705 Existing Documentation \u00b6 EIPs (Ethereum Improvement Proposals) - 6 comprehensive standards System Architecture overview API Documentation (basic) External Services integration guide Administrator, Deployer, and Integrator guides (basic) \u274c Major Documentation Gaps Identified \u00b6 1. Smart Contract Documentation \u00b6 1.1 Contract Reference Documentation \u00b6 Status : Missing comprehensive contract documentation Missing Elements : - Diamond Standard Implementation - Diamond.sol - Core diamond proxy contract - DiamondFactory.sol - Factory for diamond deployment - IdentityFactory.sol - Identity contract factory Facet Documentation (20+ facets missing docs): CarbonCreditFacet.sol - Carbon credit management CollateralTokenFactoryFacet.sol - Collateral token creation FeeDistributorFacet.sol - Fee distribution logic GemforceMinterFacet.sol - Token minting functionality IdentityRegistryFacet.sol - Identity management MarketplaceFacet.sol - NFT marketplace operations MultiSaleFacet.sol - Multi-token sales SVGTemplatesFacet.sol - Dynamic SVG generation TradeDealAdminFacet.sol - Trade deal administration TradeDealManagementFacet.sol - Trade deal lifecycle TradeDealOperationsFacet.sol - Trade deal operations TrustedIssuersRegistryFacet.sol - Trusted issuer management Interface Documentation (40+ interfaces missing docs): Core interfaces like IDiamond.sol , IMarketplace.sol Token interfaces: IERC721A.sol , IERC1155Mint.sol Identity interfaces: IERC734.sol , IERC735.sol Business logic interfaces: ITradeDeal.sol , ICarbonCredit.sol Library Documentation (15+ libraries missing docs): CarbonCreditLib.sol - Carbon credit utilities DiamondFactoryLib.sol - Diamond factory utilities MultiSaleLib.sol - Multi-sale utilities TradeDealLib.sol - Trade deal utilities SVGTemplatesLib.sol - SVG generation utilities 1.2 Contract Integration Guides \u00b6 Status : Missing Required Documentation : - Smart contract deployment procedures - Contract upgrade patterns and procedures - Gas optimization strategies - Security best practices for each contract type - Integration patterns for external developers 2. API and Cloud Functions Documentation \u00b6 2.1 Cloud Function APIs \u00b6 Status : Incomplete - missing detailed documentation for 10+ cloud function modules Missing Documentation : - Authentication Functions ( authFunctions.ts ) - User authentication flows - Session management - Permission systems Blockchain Functions ( blockchain.ts ) Blockchain interaction patterns Transaction management Event monitoring Bridge API Integration ( bridge.ts ) External account management KYC/AML integration Plaid connectivity Contract Management ( contracts.ts ) Contract deployment automation Contract interaction utilities State management DFNS Integration ( dfns.ts ) Wallet-as-a-Service integration Key management Transaction signing Project Management ( project.ts ) Project lifecycle management Resource allocation Configuration management Trade Deal Functions ( tradeDeal.ts ) Trade deal creation and management Collateral handling Interest calculations 2.2 Task System Documentation \u00b6 Status : Missing - 40+ task modules undocumented Critical Missing Documentation : - Core Tasks : - diamond.ts - Diamond contract management - identities.ts - Identity system management - marketplace-management.ts - Marketplace operations - carbon-credit-management.ts - Carbon credit lifecycle - trade-deal.ts - Trade deal operations Integration Tasks : integration-test.ts - System integration testing integration-test-marketplace.ts - Marketplace testing integration-test-trade-deal.ts - Trade deal testing Administrative Tasks : admin-utils.ts - Administrative utilities sync-diamond.ts - Diamond synchronization sync-events.ts - Event synchronization 3. Developer Resources and Guides \u00b6 3.1 SDK and Library Documentation \u00b6 Status : Missing Required Documentation : - Core Libraries (20+ library modules): - blockchain.ts - Blockchain interaction utilities - diamond.ts - Diamond pattern utilities - contract.ts - Contract interaction helpers - deploy.ts - Deployment utilities - validation-utils.ts - Input validation - nft-sale-utils.ts - NFT sale utilities - webhooks.ts - Webhook management 3.2 Development Environment Setup \u00b6 Status : Incomplete Missing Documentation : - Local development environment setup guide - Docker containerization guide - Testing framework documentation - Debugging procedures - Performance optimization guides 3.3 Code Examples and Tutorials \u00b6 Status : Missing Required Documentation : - Step-by-step tutorials for common use cases - Code examples for each major feature - Integration patterns and best practices - Error handling examples - Performance optimization examples 4. Operational Documentation \u00b6 4.1 Deployment and DevOps \u00b6 Status : Incomplete Missing Documentation : - Network Configuration : - Multi-network deployment guide (Localhost, Base Sepolia, OP Sepolia, Sepolia) - Network-specific configuration parameters - Cross-chain interaction patterns Infrastructure Management : MongoDB configuration and management Parse Server deployment and scaling SSL/TLS certificate management Load balancing and high availability Monitoring and Logging : Event monitoring setup Log aggregation and analysis Performance monitoring Alert configuration 4.2 Security Documentation \u00b6 Status : Missing Required Documentation : - Security architecture overview - Threat model and risk assessment - Security best practices for developers - Incident response procedures - Audit procedures and compliance 4.3 Backup and Recovery \u00b6 Status : Missing Required Documentation : - Database backup procedures - Smart contract state backup - Disaster recovery procedures - Data migration procedures 5. User and Business Documentation \u00b6 5.1 End-User Documentation \u00b6 Status : Missing Required Documentation : - User guides for different personas (traders, issuers, administrators) - Feature documentation with screenshots - Troubleshooting guides - FAQ sections 5.2 Business Process Documentation \u00b6 Status : Missing Required Documentation : - Carbon credit issuance and retirement processes - Trade deal lifecycle documentation - Marketplace operations procedures - Identity verification processes - Compliance and regulatory procedures 6. Configuration and Environment Documentation \u00b6 6.1 Configuration Management \u00b6 Status : Incomplete Missing Documentation : - Environment Configuration : - Detailed explanation of gemforce.config.ts parameters - Environment-specific configuration guides - Configuration validation procedures External Service Configuration : DFNS integration setup Bridge API configuration SendGrid email service setup Plaid integration configuration Webhook configuration and management 6.2 Database Schema Documentation \u00b6 Status : Missing Required Documentation : - Parse Server schema documentation - MongoDB collection structures - Data relationships and constraints - Migration procedures 7. Testing Documentation \u00b6 7.1 Testing Strategy \u00b6 Status : Missing Required Documentation : - Unit testing guidelines - Integration testing procedures - End-to-end testing strategies - Performance testing procedures - Security testing protocols 7.2 Test Case Documentation \u00b6 Status : Missing Required Documentation : - Test case specifications for each component - Test data management - Automated testing setup - Continuous integration procedures 8. Integration Documentation \u00b6 8.1 Third-Party Integrations \u00b6 Status : Incomplete Missing Documentation : - DFNS Wallet Service : - Advanced integration patterns - Error handling procedures - Performance optimization Bridge API : Complete API reference Integration examples Troubleshooting guide Parse Server : Custom cloud function development Database optimization Scaling procedures 8.2 External Developer Integration \u00b6 Status : Missing Required Documentation : - Partner integration guides - API rate limiting and quotas - Webhook implementation guides - SDK development guidelines 9. Maintenance and Support Documentation \u00b6 9.1 Maintenance Procedures \u00b6 Status : Missing Required Documentation : - Regular maintenance tasks - System health monitoring - Performance optimization procedures - Capacity planning guidelines 9.2 Support Documentation \u00b6 Status : Missing Required Documentation : - Support ticket procedures - Escalation procedures - Knowledge base articles - Community support guidelines Priority Recommendations \u00b6 High Priority (Immediate - Next 2 weeks) \u00b6 Smart Contract Reference Documentation - Core contracts and facets Cloud Function API Documentation - Complete API reference Developer Setup Guide - Environment configuration and setup Security Documentation - Security architecture and best practices Medium Priority (Next 4 weeks) \u00b6 Task System Documentation - All 40+ task modules Integration Guides - Third-party service integrations Testing Documentation - Comprehensive testing procedures Deployment Guides - Production deployment procedures Low Priority (Next 8 weeks) \u00b6 End-User Documentation - User guides and tutorials Business Process Documentation - Operational procedures Advanced Integration Patterns - Complex use cases Performance Optimization Guides - Advanced optimization techniques Resource Requirements \u00b6 Documentation Team \u00b6 Technical Writers : 2-3 full-time writers Developer SMEs : 4-5 developers for technical review DevOps Engineer : 1 engineer for deployment documentation Security Expert : 1 expert for security documentation Timeline Estimate \u00b6 Phase 1 (High Priority) : 4-6 weeks Phase 2 (Medium Priority) : 6-8 weeks Phase 3 (Low Priority) : 8-12 weeks Total Estimated Timeline : 18-26 weeks Tools and Infrastructure \u00b6 Documentation platform enhancement Automated documentation generation tools Code documentation standards Review and approval workflows Conclusion \u00b6 The Gemforce platform has a solid foundation with EIPs and basic architectural documentation, but requires significant expansion across all documentation categories. The identified gaps represent approximately 200+ individual documentation items that need to be created or enhanced. The most critical gaps are in smart contract documentation, cloud function APIs, and developer resources, which directly impact developer adoption and platform usability. Addressing these gaps systematically will significantly improve the platform's accessibility and reduce support overhead. Analysis completed: June 26, 2025 Total identified documentation gaps: 200+ items Estimated effort: 18-26 weeks with dedicated team","title":"Documentation Gap Analysis"},{"location":"gemforce-documentation-gap-analysis/#gemforce-documentation-gap-analysis","text":"","title":"Gemforce Documentation Gap Analysis"},{"location":"gemforce-documentation-gap-analysis/#executive-summary","text":"This document provides a comprehensive analysis of documentation gaps in the Gemforce platform based on a thorough examination of the /Users/sschepis/Development/gem-base project. The analysis identifies missing documentation across multiple categories including smart contracts, APIs, deployment guides, developer resources, and operational documentation.","title":"Executive Summary"},{"location":"gemforce-documentation-gap-analysis/#current-documentation-status","text":"","title":"Current Documentation Status"},{"location":"gemforce-documentation-gap-analysis/#existing-documentation","text":"EIPs (Ethereum Improvement Proposals) - 6 comprehensive standards System Architecture overview API Documentation (basic) External Services integration guide Administrator, Deployer, and Integrator guides (basic)","title":"\u2705 Existing Documentation"},{"location":"gemforce-documentation-gap-analysis/#major-documentation-gaps-identified","text":"","title":"\u274c Major Documentation Gaps Identified"},{"location":"gemforce-documentation-gap-analysis/#1-smart-contract-documentation","text":"","title":"1. Smart Contract Documentation"},{"location":"gemforce-documentation-gap-analysis/#11-contract-reference-documentation","text":"Status : Missing comprehensive contract documentation Missing Elements : - Diamond Standard Implementation - Diamond.sol - Core diamond proxy contract - DiamondFactory.sol - Factory for diamond deployment - IdentityFactory.sol - Identity contract factory Facet Documentation (20+ facets missing docs): CarbonCreditFacet.sol - Carbon credit management CollateralTokenFactoryFacet.sol - Collateral token creation FeeDistributorFacet.sol - Fee distribution logic GemforceMinterFacet.sol - Token minting functionality IdentityRegistryFacet.sol - Identity management MarketplaceFacet.sol - NFT marketplace operations MultiSaleFacet.sol - Multi-token sales SVGTemplatesFacet.sol - Dynamic SVG generation TradeDealAdminFacet.sol - Trade deal administration TradeDealManagementFacet.sol - Trade deal lifecycle TradeDealOperationsFacet.sol - Trade deal operations TrustedIssuersRegistryFacet.sol - Trusted issuer management Interface Documentation (40+ interfaces missing docs): Core interfaces like IDiamond.sol , IMarketplace.sol Token interfaces: IERC721A.sol , IERC1155Mint.sol Identity interfaces: IERC734.sol , IERC735.sol Business logic interfaces: ITradeDeal.sol , ICarbonCredit.sol Library Documentation (15+ libraries missing docs): CarbonCreditLib.sol - Carbon credit utilities DiamondFactoryLib.sol - Diamond factory utilities MultiSaleLib.sol - Multi-sale utilities TradeDealLib.sol - Trade deal utilities SVGTemplatesLib.sol - SVG generation utilities","title":"1.1 Contract Reference Documentation"},{"location":"gemforce-documentation-gap-analysis/#12-contract-integration-guides","text":"Status : Missing Required Documentation : - Smart contract deployment procedures - Contract upgrade patterns and procedures - Gas optimization strategies - Security best practices for each contract type - Integration patterns for external developers","title":"1.2 Contract Integration Guides"},{"location":"gemforce-documentation-gap-analysis/#2-api-and-cloud-functions-documentation","text":"","title":"2. API and Cloud Functions Documentation"},{"location":"gemforce-documentation-gap-analysis/#21-cloud-function-apis","text":"Status : Incomplete - missing detailed documentation for 10+ cloud function modules Missing Documentation : - Authentication Functions ( authFunctions.ts ) - User authentication flows - Session management - Permission systems Blockchain Functions ( blockchain.ts ) Blockchain interaction patterns Transaction management Event monitoring Bridge API Integration ( bridge.ts ) External account management KYC/AML integration Plaid connectivity Contract Management ( contracts.ts ) Contract deployment automation Contract interaction utilities State management DFNS Integration ( dfns.ts ) Wallet-as-a-Service integration Key management Transaction signing Project Management ( project.ts ) Project lifecycle management Resource allocation Configuration management Trade Deal Functions ( tradeDeal.ts ) Trade deal creation and management Collateral handling Interest calculations","title":"2.1 Cloud Function APIs"},{"location":"gemforce-documentation-gap-analysis/#22-task-system-documentation","text":"Status : Missing - 40+ task modules undocumented Critical Missing Documentation : - Core Tasks : - diamond.ts - Diamond contract management - identities.ts - Identity system management - marketplace-management.ts - Marketplace operations - carbon-credit-management.ts - Carbon credit lifecycle - trade-deal.ts - Trade deal operations Integration Tasks : integration-test.ts - System integration testing integration-test-marketplace.ts - Marketplace testing integration-test-trade-deal.ts - Trade deal testing Administrative Tasks : admin-utils.ts - Administrative utilities sync-diamond.ts - Diamond synchronization sync-events.ts - Event synchronization","title":"2.2 Task System Documentation"},{"location":"gemforce-documentation-gap-analysis/#3-developer-resources-and-guides","text":"","title":"3. Developer Resources and Guides"},{"location":"gemforce-documentation-gap-analysis/#31-sdk-and-library-documentation","text":"Status : Missing Required Documentation : - Core Libraries (20+ library modules): - blockchain.ts - Blockchain interaction utilities - diamond.ts - Diamond pattern utilities - contract.ts - Contract interaction helpers - deploy.ts - Deployment utilities - validation-utils.ts - Input validation - nft-sale-utils.ts - NFT sale utilities - webhooks.ts - Webhook management","title":"3.1 SDK and Library Documentation"},{"location":"gemforce-documentation-gap-analysis/#32-development-environment-setup","text":"Status : Incomplete Missing Documentation : - Local development environment setup guide - Docker containerization guide - Testing framework documentation - Debugging procedures - Performance optimization guides","title":"3.2 Development Environment Setup"},{"location":"gemforce-documentation-gap-analysis/#33-code-examples-and-tutorials","text":"Status : Missing Required Documentation : - Step-by-step tutorials for common use cases - Code examples for each major feature - Integration patterns and best practices - Error handling examples - Performance optimization examples","title":"3.3 Code Examples and Tutorials"},{"location":"gemforce-documentation-gap-analysis/#4-operational-documentation","text":"","title":"4. Operational Documentation"},{"location":"gemforce-documentation-gap-analysis/#41-deployment-and-devops","text":"Status : Incomplete Missing Documentation : - Network Configuration : - Multi-network deployment guide (Localhost, Base Sepolia, OP Sepolia, Sepolia) - Network-specific configuration parameters - Cross-chain interaction patterns Infrastructure Management : MongoDB configuration and management Parse Server deployment and scaling SSL/TLS certificate management Load balancing and high availability Monitoring and Logging : Event monitoring setup Log aggregation and analysis Performance monitoring Alert configuration","title":"4.1 Deployment and DevOps"},{"location":"gemforce-documentation-gap-analysis/#42-security-documentation","text":"Status : Missing Required Documentation : - Security architecture overview - Threat model and risk assessment - Security best practices for developers - Incident response procedures - Audit procedures and compliance","title":"4.2 Security Documentation"},{"location":"gemforce-documentation-gap-analysis/#43-backup-and-recovery","text":"Status : Missing Required Documentation : - Database backup procedures - Smart contract state backup - Disaster recovery procedures - Data migration procedures","title":"4.3 Backup and Recovery"},{"location":"gemforce-documentation-gap-analysis/#5-user-and-business-documentation","text":"","title":"5. User and Business Documentation"},{"location":"gemforce-documentation-gap-analysis/#51-end-user-documentation","text":"Status : Missing Required Documentation : - User guides for different personas (traders, issuers, administrators) - Feature documentation with screenshots - Troubleshooting guides - FAQ sections","title":"5.1 End-User Documentation"},{"location":"gemforce-documentation-gap-analysis/#52-business-process-documentation","text":"Status : Missing Required Documentation : - Carbon credit issuance and retirement processes - Trade deal lifecycle documentation - Marketplace operations procedures - Identity verification processes - Compliance and regulatory procedures","title":"5.2 Business Process Documentation"},{"location":"gemforce-documentation-gap-analysis/#6-configuration-and-environment-documentation","text":"","title":"6. Configuration and Environment Documentation"},{"location":"gemforce-documentation-gap-analysis/#61-configuration-management","text":"Status : Incomplete Missing Documentation : - Environment Configuration : - Detailed explanation of gemforce.config.ts parameters - Environment-specific configuration guides - Configuration validation procedures External Service Configuration : DFNS integration setup Bridge API configuration SendGrid email service setup Plaid integration configuration Webhook configuration and management","title":"6.1 Configuration Management"},{"location":"gemforce-documentation-gap-analysis/#62-database-schema-documentation","text":"Status : Missing Required Documentation : - Parse Server schema documentation - MongoDB collection structures - Data relationships and constraints - Migration procedures","title":"6.2 Database Schema Documentation"},{"location":"gemforce-documentation-gap-analysis/#7-testing-documentation","text":"","title":"7. Testing Documentation"},{"location":"gemforce-documentation-gap-analysis/#71-testing-strategy","text":"Status : Missing Required Documentation : - Unit testing guidelines - Integration testing procedures - End-to-end testing strategies - Performance testing procedures - Security testing protocols","title":"7.1 Testing Strategy"},{"location":"gemforce-documentation-gap-analysis/#72-test-case-documentation","text":"Status : Missing Required Documentation : - Test case specifications for each component - Test data management - Automated testing setup - Continuous integration procedures","title":"7.2 Test Case Documentation"},{"location":"gemforce-documentation-gap-analysis/#8-integration-documentation","text":"","title":"8. Integration Documentation"},{"location":"gemforce-documentation-gap-analysis/#81-third-party-integrations","text":"Status : Incomplete Missing Documentation : - DFNS Wallet Service : - Advanced integration patterns - Error handling procedures - Performance optimization Bridge API : Complete API reference Integration examples Troubleshooting guide Parse Server : Custom cloud function development Database optimization Scaling procedures","title":"8.1 Third-Party Integrations"},{"location":"gemforce-documentation-gap-analysis/#82-external-developer-integration","text":"Status : Missing Required Documentation : - Partner integration guides - API rate limiting and quotas - Webhook implementation guides - SDK development guidelines","title":"8.2 External Developer Integration"},{"location":"gemforce-documentation-gap-analysis/#9-maintenance-and-support-documentation","text":"","title":"9. Maintenance and Support Documentation"},{"location":"gemforce-documentation-gap-analysis/#91-maintenance-procedures","text":"Status : Missing Required Documentation : - Regular maintenance tasks - System health monitoring - Performance optimization procedures - Capacity planning guidelines","title":"9.1 Maintenance Procedures"},{"location":"gemforce-documentation-gap-analysis/#92-support-documentation","text":"Status : Missing Required Documentation : - Support ticket procedures - Escalation procedures - Knowledge base articles - Community support guidelines","title":"9.2 Support Documentation"},{"location":"gemforce-documentation-gap-analysis/#priority-recommendations","text":"","title":"Priority Recommendations"},{"location":"gemforce-documentation-gap-analysis/#high-priority-immediate-next-2-weeks","text":"Smart Contract Reference Documentation - Core contracts and facets Cloud Function API Documentation - Complete API reference Developer Setup Guide - Environment configuration and setup Security Documentation - Security architecture and best practices","title":"High Priority (Immediate - Next 2 weeks)"},{"location":"gemforce-documentation-gap-analysis/#medium-priority-next-4-weeks","text":"Task System Documentation - All 40+ task modules Integration Guides - Third-party service integrations Testing Documentation - Comprehensive testing procedures Deployment Guides - Production deployment procedures","title":"Medium Priority (Next 4 weeks)"},{"location":"gemforce-documentation-gap-analysis/#low-priority-next-8-weeks","text":"End-User Documentation - User guides and tutorials Business Process Documentation - Operational procedures Advanced Integration Patterns - Complex use cases Performance Optimization Guides - Advanced optimization techniques","title":"Low Priority (Next 8 weeks)"},{"location":"gemforce-documentation-gap-analysis/#resource-requirements","text":"","title":"Resource Requirements"},{"location":"gemforce-documentation-gap-analysis/#documentation-team","text":"Technical Writers : 2-3 full-time writers Developer SMEs : 4-5 developers for technical review DevOps Engineer : 1 engineer for deployment documentation Security Expert : 1 expert for security documentation","title":"Documentation Team"},{"location":"gemforce-documentation-gap-analysis/#timeline-estimate","text":"Phase 1 (High Priority) : 4-6 weeks Phase 2 (Medium Priority) : 6-8 weeks Phase 3 (Low Priority) : 8-12 weeks Total Estimated Timeline : 18-26 weeks","title":"Timeline Estimate"},{"location":"gemforce-documentation-gap-analysis/#tools-and-infrastructure","text":"Documentation platform enhancement Automated documentation generation tools Code documentation standards Review and approval workflows","title":"Tools and Infrastructure"},{"location":"gemforce-documentation-gap-analysis/#conclusion","text":"The Gemforce platform has a solid foundation with EIPs and basic architectural documentation, but requires significant expansion across all documentation categories. The identified gaps represent approximately 200+ individual documentation items that need to be created or enhanced. The most critical gaps are in smart contract documentation, cloud function APIs, and developer resources, which directly impact developer adoption and platform usability. Addressing these gaps systematically will significantly improve the platform's accessibility and reduce support overhead. Analysis completed: June 26, 2025 Total identified documentation gaps: 200+ items Estimated effort: 18-26 weeks with dedicated team","title":"Conclusion"},{"location":"gemforce-external-services/","text":"Gemforce External Services Integration \u00b6 This document provides detailed information about the external services and third-party integrations used by the Gemforce platform. Understanding these services is essential for developers working with the Gemforce API. DFNS Wallet-as-a-Service \u00b6 DFNS provides a secure and user-friendly wallet management system that Gemforce uses for managing blockchain transactions. Overview \u00b6 DFNS is a wallet-as-a-service platform that offers: - Non-custodial wallet management - WebAuthn-based authentication - Transaction signing without exposing private keys - Delegated transaction execution Integration Points \u00b6 Gemforce integrates with DFNS via: - DFNS API Client - DFNS Delegated API Client Key Features Used \u00b6 User Registration & Authentication WebAuthn-based registration Passwordless authentication Recovery mechanisms Wallet Management Wallet creation Asset listing Transaction history Transaction Signing Challenge-based signing Two-step transaction process (Init/Complete) Delegated transaction execution API Flow \u00b6 Client App <-> Gemforce Cloud Functions <-> DFNS API Client initiates a request to Gemforce Cloud Functions Gemforce creates a transaction payload and requests a challenge from DFNS Challenge is passed to the client for signing with WebAuthn Signed challenge is sent back to Gemforce Gemforce completes the transaction with DFNS DFNS broadcasts the transaction to the blockchain Configuration \u00b6 DFNS requires the following environment variables: - DFNS_APP_ID : Application ID for DFNS - DFNS_API_URL : Base URL for DFNS API - DFNS_CRED_ID : Credential ID for DFNS - DFNS_AUTH_TOKEN : Authentication token (for server operations) Bridge API Integration \u00b6 Bridge API provides financial services integration for Gemforce, enabling external account management, transfers, and KYC processes. Overview \u00b6 Bridge API offers: - External account management - Transfer operations between traditional finance and crypto - KYC verification - Plaid integration for banking connections Integration Points \u00b6 Gemforce integrates with Bridge API via RESTful HTTP endpoints. Key Features Used \u00b6 External Account Management Creation of external accounts Multiple account types (US, IBAN) Account listing and retrieval Account deletion Transfer Operations Cross-currency transfers Multiple payment rails (ACH, SEPA, Wire, Blockchain) Transfer status tracking Idempotent operations KYC Management KYC link generation KYC status tracking Individual and business verification Plaid Integration Link token generation Token exchange Account verification API Flow \u00b6 Client App <-> Gemforce Cloud Functions <-> Bridge API Client app calls Gemforce Cloud Functions Gemforce validates and formats the request Gemforce calls Bridge API with appropriate headers Bridge API processes the request and returns a response Gemforce processes and returns the response to the client Configuration \u00b6 Bridge API requires the following environment variables: - BASE_BRIDGE_URL : Base URL for Bridge API - BRIDGE_API_KEY : API key for authentication Parse Server \u00b6 Parse Server provides the backend infrastructure for Gemforce's cloud functions and data storage. Overview \u00b6 Parse Server offers: - User authentication and management - Cloud functions - Database operations - File storage - Push notifications Integration Points \u00b6 Gemforce uses Parse Server as the primary backend platform. Key Features Used \u00b6 User Management Registration Email verification Password reset Session management Cloud Functions Blockchain operations DFNS integration Bridge API integration Business logic Data Storage User profiles Blockchain data Identity information Transaction history Role-Based Access Control User roles Permission management Object-level ACLs Configuration \u00b6 Parse Server requires the following environment variables: - APP_ID : Parse application ID - MASTER_KEY : Parse master key - DATABASE_URI : MongoDB connection string - SERVER_URL : Parse Server URL - PROJECT_WIZARD_URL : URL for the project wizard Ethereum Blockchain Networks \u00b6 Gemforce interacts with multiple Ethereum-compatible blockchain networks. Overview \u00b6 Gemforce supports multiple blockchain networks including: - Ethereum Mainnet - BaseSepolia - Other EVM-compatible networks Integration Points \u00b6 Gemforce interacts with blockchain networks via: - JSON-RPC providers - WebSocket connections Key Features Used \u00b6 Smart Contract Deployment Diamond contract deployment Facet deployment Contract initialization Transaction Submission Method calls Value transfers Contract interactions Event Monitoring WebSocket subscriptions Event filtering Log parsing State Reading View function calls State synchronization Configuration \u00b6 Blockchain integration requires the following environment variables: - ETH_NODE_URI_[NETWORK] : JSON-RPC endpoint for each network - CHAIN_ID : ID of the default chain - METADATA_BASE_URI : Base URI for token metadata SendGrid Email Service \u00b6 SendGrid is used for transactional email communications. Overview \u00b6 SendGrid provides email delivery services for: - User verification - Password reset - Notifications - Other transactional emails Integration Points \u00b6 Gemforce uses SendGrid's Node.js SDK. Key Features Used \u00b6 Email Templates EJS templating HTML email content Dynamic content insertion Email Sending Transactional emails HTML content Attachments Configuration \u00b6 SendGrid requires the following environment variables: - SendGrid API key (configured through environment variables) - From email address Plaid (via Bridge API) \u00b6 Plaid is integrated through Bridge API to provide banking connection services. Overview \u00b6 Plaid offers: - Bank account verification - Account linking - Transaction history - Balance information Integration Points \u00b6 Gemforce interacts with Plaid through Bridge API. Key Features Used \u00b6 Link Token Creation Generated for each user session Configured for specific use cases Public Token Exchange Convert public tokens to access tokens Securely store access tokens API Flow \u00b6 Client App <-> Plaid Link <-> Client App <-> Gemforce <-> Bridge API <-> Plaid Client requests a Plaid link token from Gemforce Gemforce obtains the token through Bridge API Client uses the token with Plaid Link Plaid Link provides a public token to the client Client sends the public token to Gemforce Gemforce exchanges it via Bridge API Bridge API handles Plaid API communication Integration Diagram \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Client App \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 Parse Server \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba DFNS \u2502 \u2502 (Cloud Functions)\u2502 \u2502 Wallet-as-Service \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 Blockchain \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Networks \u2502 \u2502 \u2502 Bridge API \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - Ethereum Mainnet \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 - BaseSepolia \u2502 \u2502 \u2502 \u2502 \u2502 - Others \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Plaid \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25b2 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Smart Contracts \u2502 \u2502 \u2502 \u2502 - Diamond \u2502 \u2502 - Identity System \u2502 \u2502 - Asset Management \u2502 \u2502 - Carbon Credits \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Authentication Flows \u00b6 User Registration & Login \u00b6 User registers through Parse Server Email verification is sent via SendGrid User verifies email User logs in with username/password Parse Server creates a session token DFNS Registration \u00b6 User initiates DFNS registration Gemforce requests a registration challenge from DFNS User completes WebAuthn registration on client Signed challenge is sent to Gemforce Gemforce completes registration with DFNS DFNS creates a wallet for the user Bridge API Authentication \u00b6 Bridge API authentication is handled server-side with API keys. The client never interacts directly with Bridge API credentials. Security Considerations \u00b6 API Keys & Secrets \u00b6 All API keys and secrets are stored as environment variables API keys are never exposed to clients All external API calls are made server-side Delegated Authentication \u00b6 DFNS uses delegated authentication Client never has access to private keys WebAuthn provides phishing-resistant authentication Idempotency \u00b6 Bridge API calls use idempotency keys Prevents duplicate transactions Allows safe retries Rate Limiting \u00b6 DFNS \u00b6 DFNS imposes rate limits on API calls Gemforce implements exponential backoff for retries Bridge API \u00b6 Bridge API has rate limits based on API key Gemforce handles rate limit errors Error Handling \u00b6 DFNS Errors \u00b6 Challenge-related errors WebAuthn errors Transaction errors Bridge API Errors \u00b6 Validation errors Processing errors External account errors KYC errors Blockchain Errors \u00b6 Gas-related errors Transaction failure Network congestion Monitoring & Logging \u00b6 All external service interactions are logged for: - Debugging - Audit trails - Performance monitoring - Error tracking Conclusion \u00b6 Gemforce integrates with several external services to provide a comprehensive platform. Understanding these integrations is crucial for effectively working with the Gemforce API.","title":"Gemforce External Services Integration"},{"location":"gemforce-external-services/#gemforce-external-services-integration","text":"This document provides detailed information about the external services and third-party integrations used by the Gemforce platform. Understanding these services is essential for developers working with the Gemforce API.","title":"Gemforce External Services Integration"},{"location":"gemforce-external-services/#dfns-wallet-as-a-service","text":"DFNS provides a secure and user-friendly wallet management system that Gemforce uses for managing blockchain transactions.","title":"DFNS Wallet-as-a-Service"},{"location":"gemforce-external-services/#overview","text":"DFNS is a wallet-as-a-service platform that offers: - Non-custodial wallet management - WebAuthn-based authentication - Transaction signing without exposing private keys - Delegated transaction execution","title":"Overview"},{"location":"gemforce-external-services/#integration-points","text":"Gemforce integrates with DFNS via: - DFNS API Client - DFNS Delegated API Client","title":"Integration Points"},{"location":"gemforce-external-services/#key-features-used","text":"User Registration & Authentication WebAuthn-based registration Passwordless authentication Recovery mechanisms Wallet Management Wallet creation Asset listing Transaction history Transaction Signing Challenge-based signing Two-step transaction process (Init/Complete) Delegated transaction execution","title":"Key Features Used"},{"location":"gemforce-external-services/#api-flow","text":"Client App <-> Gemforce Cloud Functions <-> DFNS API Client initiates a request to Gemforce Cloud Functions Gemforce creates a transaction payload and requests a challenge from DFNS Challenge is passed to the client for signing with WebAuthn Signed challenge is sent back to Gemforce Gemforce completes the transaction with DFNS DFNS broadcasts the transaction to the blockchain","title":"API Flow"},{"location":"gemforce-external-services/#configuration","text":"DFNS requires the following environment variables: - DFNS_APP_ID : Application ID for DFNS - DFNS_API_URL : Base URL for DFNS API - DFNS_CRED_ID : Credential ID for DFNS - DFNS_AUTH_TOKEN : Authentication token (for server operations)","title":"Configuration"},{"location":"gemforce-external-services/#bridge-api-integration","text":"Bridge API provides financial services integration for Gemforce, enabling external account management, transfers, and KYC processes.","title":"Bridge API Integration"},{"location":"gemforce-external-services/#overview_1","text":"Bridge API offers: - External account management - Transfer operations between traditional finance and crypto - KYC verification - Plaid integration for banking connections","title":"Overview"},{"location":"gemforce-external-services/#integration-points_1","text":"Gemforce integrates with Bridge API via RESTful HTTP endpoints.","title":"Integration Points"},{"location":"gemforce-external-services/#key-features-used_1","text":"External Account Management Creation of external accounts Multiple account types (US, IBAN) Account listing and retrieval Account deletion Transfer Operations Cross-currency transfers Multiple payment rails (ACH, SEPA, Wire, Blockchain) Transfer status tracking Idempotent operations KYC Management KYC link generation KYC status tracking Individual and business verification Plaid Integration Link token generation Token exchange Account verification","title":"Key Features Used"},{"location":"gemforce-external-services/#api-flow_1","text":"Client App <-> Gemforce Cloud Functions <-> Bridge API Client app calls Gemforce Cloud Functions Gemforce validates and formats the request Gemforce calls Bridge API with appropriate headers Bridge API processes the request and returns a response Gemforce processes and returns the response to the client","title":"API Flow"},{"location":"gemforce-external-services/#configuration_1","text":"Bridge API requires the following environment variables: - BASE_BRIDGE_URL : Base URL for Bridge API - BRIDGE_API_KEY : API key for authentication","title":"Configuration"},{"location":"gemforce-external-services/#parse-server","text":"Parse Server provides the backend infrastructure for Gemforce's cloud functions and data storage.","title":"Parse Server"},{"location":"gemforce-external-services/#overview_2","text":"Parse Server offers: - User authentication and management - Cloud functions - Database operations - File storage - Push notifications","title":"Overview"},{"location":"gemforce-external-services/#integration-points_2","text":"Gemforce uses Parse Server as the primary backend platform.","title":"Integration Points"},{"location":"gemforce-external-services/#key-features-used_2","text":"User Management Registration Email verification Password reset Session management Cloud Functions Blockchain operations DFNS integration Bridge API integration Business logic Data Storage User profiles Blockchain data Identity information Transaction history Role-Based Access Control User roles Permission management Object-level ACLs","title":"Key Features Used"},{"location":"gemforce-external-services/#configuration_2","text":"Parse Server requires the following environment variables: - APP_ID : Parse application ID - MASTER_KEY : Parse master key - DATABASE_URI : MongoDB connection string - SERVER_URL : Parse Server URL - PROJECT_WIZARD_URL : URL for the project wizard","title":"Configuration"},{"location":"gemforce-external-services/#ethereum-blockchain-networks","text":"Gemforce interacts with multiple Ethereum-compatible blockchain networks.","title":"Ethereum Blockchain Networks"},{"location":"gemforce-external-services/#overview_3","text":"Gemforce supports multiple blockchain networks including: - Ethereum Mainnet - BaseSepolia - Other EVM-compatible networks","title":"Overview"},{"location":"gemforce-external-services/#integration-points_3","text":"Gemforce interacts with blockchain networks via: - JSON-RPC providers - WebSocket connections","title":"Integration Points"},{"location":"gemforce-external-services/#key-features-used_3","text":"Smart Contract Deployment Diamond contract deployment Facet deployment Contract initialization Transaction Submission Method calls Value transfers Contract interactions Event Monitoring WebSocket subscriptions Event filtering Log parsing State Reading View function calls State synchronization","title":"Key Features Used"},{"location":"gemforce-external-services/#configuration_3","text":"Blockchain integration requires the following environment variables: - ETH_NODE_URI_[NETWORK] : JSON-RPC endpoint for each network - CHAIN_ID : ID of the default chain - METADATA_BASE_URI : Base URI for token metadata","title":"Configuration"},{"location":"gemforce-external-services/#sendgrid-email-service","text":"SendGrid is used for transactional email communications.","title":"SendGrid Email Service"},{"location":"gemforce-external-services/#overview_4","text":"SendGrid provides email delivery services for: - User verification - Password reset - Notifications - Other transactional emails","title":"Overview"},{"location":"gemforce-external-services/#integration-points_4","text":"Gemforce uses SendGrid's Node.js SDK.","title":"Integration Points"},{"location":"gemforce-external-services/#key-features-used_4","text":"Email Templates EJS templating HTML email content Dynamic content insertion Email Sending Transactional emails HTML content Attachments","title":"Key Features Used"},{"location":"gemforce-external-services/#configuration_4","text":"SendGrid requires the following environment variables: - SendGrid API key (configured through environment variables) - From email address","title":"Configuration"},{"location":"gemforce-external-services/#plaid-via-bridge-api","text":"Plaid is integrated through Bridge API to provide banking connection services.","title":"Plaid (via Bridge API)"},{"location":"gemforce-external-services/#overview_5","text":"Plaid offers: - Bank account verification - Account linking - Transaction history - Balance information","title":"Overview"},{"location":"gemforce-external-services/#integration-points_5","text":"Gemforce interacts with Plaid through Bridge API.","title":"Integration Points"},{"location":"gemforce-external-services/#key-features-used_5","text":"Link Token Creation Generated for each user session Configured for specific use cases Public Token Exchange Convert public tokens to access tokens Securely store access tokens","title":"Key Features Used"},{"location":"gemforce-external-services/#api-flow_2","text":"Client App <-> Plaid Link <-> Client App <-> Gemforce <-> Bridge API <-> Plaid Client requests a Plaid link token from Gemforce Gemforce obtains the token through Bridge API Client uses the token with Plaid Link Plaid Link provides a public token to the client Client sends the public token to Gemforce Gemforce exchanges it via Bridge API Bridge API handles Plaid API communication","title":"API Flow"},{"location":"gemforce-external-services/#integration-diagram","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Client App \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 Parse Server \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba DFNS \u2502 \u2502 (Cloud Functions)\u2502 \u2502 Wallet-as-Service \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 Blockchain \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Networks \u2502 \u2502 \u2502 Bridge API \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - Ethereum Mainnet \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 - BaseSepolia \u2502 \u2502 \u2502 \u2502 \u2502 - Others \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Plaid \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25b2 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Smart Contracts \u2502 \u2502 \u2502 \u2502 - Diamond \u2502 \u2502 - Identity System \u2502 \u2502 - Asset Management \u2502 \u2502 - Carbon Credits \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Integration Diagram"},{"location":"gemforce-external-services/#authentication-flows","text":"","title":"Authentication Flows"},{"location":"gemforce-external-services/#user-registration-login","text":"User registers through Parse Server Email verification is sent via SendGrid User verifies email User logs in with username/password Parse Server creates a session token","title":"User Registration &amp; Login"},{"location":"gemforce-external-services/#dfns-registration","text":"User initiates DFNS registration Gemforce requests a registration challenge from DFNS User completes WebAuthn registration on client Signed challenge is sent to Gemforce Gemforce completes registration with DFNS DFNS creates a wallet for the user","title":"DFNS Registration"},{"location":"gemforce-external-services/#bridge-api-authentication","text":"Bridge API authentication is handled server-side with API keys. The client never interacts directly with Bridge API credentials.","title":"Bridge API Authentication"},{"location":"gemforce-external-services/#security-considerations","text":"","title":"Security Considerations"},{"location":"gemforce-external-services/#api-keys-secrets","text":"All API keys and secrets are stored as environment variables API keys are never exposed to clients All external API calls are made server-side","title":"API Keys &amp; Secrets"},{"location":"gemforce-external-services/#delegated-authentication","text":"DFNS uses delegated authentication Client never has access to private keys WebAuthn provides phishing-resistant authentication","title":"Delegated Authentication"},{"location":"gemforce-external-services/#idempotency","text":"Bridge API calls use idempotency keys Prevents duplicate transactions Allows safe retries","title":"Idempotency"},{"location":"gemforce-external-services/#rate-limiting","text":"","title":"Rate Limiting"},{"location":"gemforce-external-services/#dfns","text":"DFNS imposes rate limits on API calls Gemforce implements exponential backoff for retries","title":"DFNS"},{"location":"gemforce-external-services/#bridge-api","text":"Bridge API has rate limits based on API key Gemforce handles rate limit errors","title":"Bridge API"},{"location":"gemforce-external-services/#error-handling","text":"","title":"Error Handling"},{"location":"gemforce-external-services/#dfns-errors","text":"Challenge-related errors WebAuthn errors Transaction errors","title":"DFNS Errors"},{"location":"gemforce-external-services/#bridge-api-errors","text":"Validation errors Processing errors External account errors KYC errors","title":"Bridge API Errors"},{"location":"gemforce-external-services/#blockchain-errors","text":"Gas-related errors Transaction failure Network congestion","title":"Blockchain Errors"},{"location":"gemforce-external-services/#monitoring-logging","text":"All external service interactions are logged for: - Debugging - Audit trails - Performance monitoring - Error tracking","title":"Monitoring &amp; Logging"},{"location":"gemforce-external-services/#conclusion","text":"Gemforce integrates with several external services to provide a comprehensive platform. Understanding these integrations is crucial for effectively working with the Gemforce API.","title":"Conclusion"},{"location":"gemforce-integrator-guide/","text":"Gemforce Integrator Guide \u00b6 Table of Contents \u00b6 Integration Overview Authentication and Authorization REST API Integration Smart Contract Integration DFNS Wallet Integration Parse Server Integration Webhook Implementation Error Handling and Logging Sample Integration Code Common Integration Patterns Testing and Sandbox Security Considerations Compliance Integration","title":"Integrator Guide"},{"location":"gemforce-integrator-guide/#gemforce-integrator-guide","text":"","title":"Gemforce Integrator Guide"},{"location":"gemforce-integrator-guide/#table-of-contents","text":"Integration Overview Authentication and Authorization REST API Integration Smart Contract Integration DFNS Wallet Integration Parse Server Integration Webhook Implementation Error Handling and Logging Sample Integration Code Common Integration Patterns Testing and Sandbox Security Considerations Compliance Integration","title":"Table of Contents"},{"location":"gemforce-system-architecture/","text":"Gemforce System Architecture \u00b6 Overview \u00b6 Gemforce is a comprehensive blockchain-based platform that combines on-chain smart contracts with off-chain cloud services to provide a robust system for digital identity, asset management, and carbon credit tracking. This document provides a technical overview of the system's architecture and integration points. System Components \u00b6 Smart Contract Layer \u00b6 The smart contract layer is built on the Ethereum blockchain (with support for multiple networks) and uses the Diamond pattern (EIP-2535) for upgradeability. Key Components: \u00b6 Diamond Contract Central proxy contract that delegates calls to facet contracts Implements EIP-2535 for upgradeable contracts Supports multiple interfaces through facets Maintains common storage for all facets DiamondFactory Creates new Diamond contracts Manages facet sets for deployment Registers diamonds by symbol Identity System Identity Contract : Represents user identities IdentityFactory : Creates and manages identities IdentityRegistry : Maps addresses to identities ClaimTopicsRegistry : Manages claim topics TrustedIssuersRegistry : Manages authorized issuers Asset Management GemforceMinterFacet : Mints tokens with metadata MarketplaceFacet : Handles buying and selling Treasury : Manages funds and withdrawals CarbonCreditFacet : Handles carbon credit operations Cloud Service Layer \u00b6 The cloud service layer is built on Parse Server and provides API endpoints for interacting with the blockchain and managing user data. Key Components: \u00b6 Parse Server User authentication and management Data storage and retrieval Cloud functions for blockchain interaction Scheduled jobs for background tasks DFNS Integration Wallet management service Transaction signing Key management Recovery mechanisms Bridge API Integration External account management Transfer operations KYC/AML compliance Plaid integration for banking connections Blockchain Connection Service Provider management Contract deployment and interaction Network configuration Architecture Diagram \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Client Applications \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Parse Server API Layer \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Authentication \u2502 \u2502 Blockchain \u2502 \u2502 DFNS Wallet \u2502 \u2502 \u2502 \u2502 Functions \u2502 \u2502 Functions \u2502 \u2502 Functions \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Bridge API \u2502 \u2502 Contract \u2502 \u2502 Project \u2502 \u2502 \u2502 \u2502 Integration \u2502 \u2502 Interaction \u2502 \u2502 Management \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Blockchain Layer \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Diamond \u2502 \u2502 Identity \u2502 \u2502 Asset \u2502 \u2502 \u2502 \u2502 Contract \u2502\u25c4\u2500\u253c\u2500\u2524 System \u2502\u25c4\u2500\u253c\u2500\u2524 Management \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 DiamondFactory \u2502 \u2502 Marketplace \u2502 \u2502 Carbon Credits \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Integration Points \u00b6 Client Applications to Parse Server \u00b6 RESTful API endpoints Authentication via Parse Server DFNS wallet integration WebSocket connections for real-time updates Parse Server to Blockchain \u00b6 Contract Deployment : Deploys Diamond contracts, facets, and initializes systems Transaction Submission : Handles transaction creation, signing, and submission Event Monitoring : Listens for relevant blockchain events State Synchronization : Keeps off-chain database in sync with blockchain state Parse Server to External Services \u00b6 DFNS : API integration for wallet creation and management Bridge API : Integration for financial operations and compliance Plaid : Integration for banking connections Email Services : Notifications and verification Data Flow \u00b6 Identity Creation and Management \u00b6 User registers through Parse Server DFNS wallet is created for the user IdentityFactory creates a new Identity contract IdentityRegistry registers the Identity Claims can be added by trusted issuers Asset Management \u00b6 GemforceMinterFacet creates new tokens with metadata MarketplaceFacet handles buying and selling Treasury manages funds CarbonCreditFacet tracks and retires carbon credits Transaction Flow \u00b6 Client initiates transaction through Parse Server Parse Server creates transaction data DFNS handles transaction signing Transaction is submitted to the blockchain Events are monitored for transaction confirmation Client is notified of transaction status Security Considerations \u00b6 Smart Contract Security \u00b6 Diamond pattern for upgradeability Role-based access control Function-level permissions Reentrancy protection Cloud Service Security \u00b6 Authentication and authorization API key management Rate limiting Input validation Encrypted data storage Wallet Security (DFNS) \u00b6 Delegated transaction signing Multi-factor authentication Key recovery mechanisms Transaction approval flows Deployment Model \u00b6 Smart Contracts \u00b6 Multiple environments (development, staging, production) Network-specific deployments Facet management Upgrade paths Cloud Services \u00b6 Parse Server deployment Database configuration Cache layer API gateway Monitoring and logging Scalability Considerations \u00b6 Smart Contract Scalability \u00b6 Gas optimization State minimization L2 solutions when needed Batched operations Cloud Service Scalability \u00b6 Horizontal scaling of Parse Server Database sharding Load balancing Caching strategies Conclusion \u00b6 The Gemforce system leverages the Diamond pattern for upgradeable smart contracts, combined with a powerful cloud service layer, to create a flexible and robust platform for digital identity and asset management. The integration with DFNS provides secure wallet management, while the Bridge API integration enables financial operations and compliance.","title":"Gemforce System Architecture"},{"location":"gemforce-system-architecture/#gemforce-system-architecture","text":"","title":"Gemforce System Architecture"},{"location":"gemforce-system-architecture/#overview","text":"Gemforce is a comprehensive blockchain-based platform that combines on-chain smart contracts with off-chain cloud services to provide a robust system for digital identity, asset management, and carbon credit tracking. This document provides a technical overview of the system's architecture and integration points.","title":"Overview"},{"location":"gemforce-system-architecture/#system-components","text":"","title":"System Components"},{"location":"gemforce-system-architecture/#smart-contract-layer","text":"The smart contract layer is built on the Ethereum blockchain (with support for multiple networks) and uses the Diamond pattern (EIP-2535) for upgradeability.","title":"Smart Contract Layer"},{"location":"gemforce-system-architecture/#key-components","text":"Diamond Contract Central proxy contract that delegates calls to facet contracts Implements EIP-2535 for upgradeable contracts Supports multiple interfaces through facets Maintains common storage for all facets DiamondFactory Creates new Diamond contracts Manages facet sets for deployment Registers diamonds by symbol Identity System Identity Contract : Represents user identities IdentityFactory : Creates and manages identities IdentityRegistry : Maps addresses to identities ClaimTopicsRegistry : Manages claim topics TrustedIssuersRegistry : Manages authorized issuers Asset Management GemforceMinterFacet : Mints tokens with metadata MarketplaceFacet : Handles buying and selling Treasury : Manages funds and withdrawals CarbonCreditFacet : Handles carbon credit operations","title":"Key Components:"},{"location":"gemforce-system-architecture/#cloud-service-layer","text":"The cloud service layer is built on Parse Server and provides API endpoints for interacting with the blockchain and managing user data.","title":"Cloud Service Layer"},{"location":"gemforce-system-architecture/#key-components_1","text":"Parse Server User authentication and management Data storage and retrieval Cloud functions for blockchain interaction Scheduled jobs for background tasks DFNS Integration Wallet management service Transaction signing Key management Recovery mechanisms Bridge API Integration External account management Transfer operations KYC/AML compliance Plaid integration for banking connections Blockchain Connection Service Provider management Contract deployment and interaction Network configuration","title":"Key Components:"},{"location":"gemforce-system-architecture/#architecture-diagram","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Client Applications \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Parse Server API Layer \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Authentication \u2502 \u2502 Blockchain \u2502 \u2502 DFNS Wallet \u2502 \u2502 \u2502 \u2502 Functions \u2502 \u2502 Functions \u2502 \u2502 Functions \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Bridge API \u2502 \u2502 Contract \u2502 \u2502 Project \u2502 \u2502 \u2502 \u2502 Integration \u2502 \u2502 Interaction \u2502 \u2502 Management \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Blockchain Layer \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Diamond \u2502 \u2502 Identity \u2502 \u2502 Asset \u2502 \u2502 \u2502 \u2502 Contract \u2502\u25c4\u2500\u253c\u2500\u2524 System \u2502\u25c4\u2500\u253c\u2500\u2524 Management \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 DiamondFactory \u2502 \u2502 Marketplace \u2502 \u2502 Carbon Credits \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Architecture Diagram"},{"location":"gemforce-system-architecture/#integration-points","text":"","title":"Integration Points"},{"location":"gemforce-system-architecture/#client-applications-to-parse-server","text":"RESTful API endpoints Authentication via Parse Server DFNS wallet integration WebSocket connections for real-time updates","title":"Client Applications to Parse Server"},{"location":"gemforce-system-architecture/#parse-server-to-blockchain","text":"Contract Deployment : Deploys Diamond contracts, facets, and initializes systems Transaction Submission : Handles transaction creation, signing, and submission Event Monitoring : Listens for relevant blockchain events State Synchronization : Keeps off-chain database in sync with blockchain state","title":"Parse Server to Blockchain"},{"location":"gemforce-system-architecture/#parse-server-to-external-services","text":"DFNS : API integration for wallet creation and management Bridge API : Integration for financial operations and compliance Plaid : Integration for banking connections Email Services : Notifications and verification","title":"Parse Server to External Services"},{"location":"gemforce-system-architecture/#data-flow","text":"","title":"Data Flow"},{"location":"gemforce-system-architecture/#identity-creation-and-management","text":"User registers through Parse Server DFNS wallet is created for the user IdentityFactory creates a new Identity contract IdentityRegistry registers the Identity Claims can be added by trusted issuers","title":"Identity Creation and Management"},{"location":"gemforce-system-architecture/#asset-management","text":"GemforceMinterFacet creates new tokens with metadata MarketplaceFacet handles buying and selling Treasury manages funds CarbonCreditFacet tracks and retires carbon credits","title":"Asset Management"},{"location":"gemforce-system-architecture/#transaction-flow","text":"Client initiates transaction through Parse Server Parse Server creates transaction data DFNS handles transaction signing Transaction is submitted to the blockchain Events are monitored for transaction confirmation Client is notified of transaction status","title":"Transaction Flow"},{"location":"gemforce-system-architecture/#security-considerations","text":"","title":"Security Considerations"},{"location":"gemforce-system-architecture/#smart-contract-security","text":"Diamond pattern for upgradeability Role-based access control Function-level permissions Reentrancy protection","title":"Smart Contract Security"},{"location":"gemforce-system-architecture/#cloud-service-security","text":"Authentication and authorization API key management Rate limiting Input validation Encrypted data storage","title":"Cloud Service Security"},{"location":"gemforce-system-architecture/#wallet-security-dfns","text":"Delegated transaction signing Multi-factor authentication Key recovery mechanisms Transaction approval flows","title":"Wallet Security (DFNS)"},{"location":"gemforce-system-architecture/#deployment-model","text":"","title":"Deployment Model"},{"location":"gemforce-system-architecture/#smart-contracts","text":"Multiple environments (development, staging, production) Network-specific deployments Facet management Upgrade paths","title":"Smart Contracts"},{"location":"gemforce-system-architecture/#cloud-services","text":"Parse Server deployment Database configuration Cache layer API gateway Monitoring and logging","title":"Cloud Services"},{"location":"gemforce-system-architecture/#scalability-considerations","text":"","title":"Scalability Considerations"},{"location":"gemforce-system-architecture/#smart-contract-scalability","text":"Gas optimization State minimization L2 solutions when needed Batched operations","title":"Smart Contract Scalability"},{"location":"gemforce-system-architecture/#cloud-service-scalability","text":"Horizontal scaling of Parse Server Database sharding Load balancing Caching strategies","title":"Cloud Service Scalability"},{"location":"gemforce-system-architecture/#conclusion","text":"The Gemforce system leverages the Diamond pattern for upgradeable smart contracts, combined with a powerful cloud service layer, to create a flexible and robust platform for digital identity and asset management. The integration with DFNS provides secure wallet management, while the Bridge API integration enables financial operations and compliance.","title":"Conclusion"},{"location":"api-documentation/gemforce-api-documentation/","text":"Gemforce API Documentation \u00b6 This document provides a comprehensive overview of the Gemforce API, detailing both the smart contract interfaces and cloud functions that power the system. Table of Contents \u00b6 Introduction Smart Contract APIs Diamond Pattern DiamondFactory Identity Management Token and Asset Management Marketplace Carbon Credits Cloud Function APIs Authentication Functions Blockchain Management Contract Interaction DFNS Wallet Management Bridge API Integration Project Management Introduction \u00b6 Gemforce is a blockchain-powered platform that implements a Diamond pattern (EIP-2535) for upgradeable smart contracts, digital identity management, and token management. The platform combines on-chain smart contracts with off-chain cloud functions to provide a comprehensive solution for issuing, managing, and trading digital assets with verifiable claims. Smart Contract APIs \u00b6 Diamond Pattern \u00b6 The Diamond pattern is the foundation of Gemforce's smart contract architecture. It provides a way to create upgradeable contracts that can be extended with new functionality without breaking existing functionality. Diamond.sol \u00b6 The Diamond contract is the main contract that implements the Diamond pattern. Key functions: initialize(address _owner, DiamondSettings memory params, IDiamondCut.FacetCut[] memory _facets, address diamondInit, bytes calldata _calldata) : Initialize the diamond with owner, settings, and facets. diamondCut(IDiamondCut.FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) : Add, replace, or remove functions from the diamond. facets() : Get all facets and their selectors. facetFunctionSelectors(address _facet) : Get all function selectors for a facet. facetAddresses() : Get all facet addresses used by a diamond. facetAddress(bytes4 _functionSelector) : Get the facet that supports a given selector. transferOwnership(address _newOwner) : Transfer ownership of the diamond. owner() : Get the owner of the diamond. DiamondFactory \u00b6 The DiamondFactory contract is used to create new Diamond contracts. Key functions: initialize(DiamondFactoryInit memory initData) : Initialize the factory with a set of facets. getFacets(string memory facetSet) : Get the facets for a facet set. setFacet(string memory facetSet, uint256 idx, IDiamondCut.FacetCut memory facetAddress) : Set a facet in a facet set. setFacets(string memory facetSet, IDiamondCut.FacetCut[] memory facetAddress) : Set multiple facets in a facet set. removeFacets(string memory facetSet) : Remove a facet set. getDiamondAddress(string memory symbol) : Get the address of a diamond by symbol. create(DiamondSettings memory params, address diamondInit, bytes calldata _calldata, IDiamondCut.FacetCut[] memory facets) : Create a new diamond with custom facets. createFromSet(DiamondSettings memory params, address diamondInit, bytes calldata _calldata, string memory facets) : Create a new diamond from a predefined facet set. add(string memory symbol, address payable diamondAddress) : Add an existing diamond to the factory. remove(string memory symbol) : Remove a diamond from the factory. exists(string memory symbol) : Check if a diamond exists. symbols() : Get all diamond symbols in the factory. Identity Management \u00b6 Gemforce includes a digital identity system that allows for claims to be made about identities. Identity.sol \u00b6 The Identity contract represents a digital identity for a user. Key functions: initialize(address _owner, address _identityRegistry, address _trustedIssuerRegistry) : Initialize the identity with an owner, identity registry, and trusted issuer registry. getAttribute(string memory _key) : Get an attribute for a token ID keyed by string. setAttribute(string memory key, AttributeType attributeType, string memory value) : Set an attribute for a token ID. addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) : Add a key to the identity. removeKey(bytes32 _key, uint256 _purpose) : Remove a key from the identity. getKey(bytes32 _key) : Get a key from the identity. addClaim(uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) : Add a claim to the identity. removeClaim(bytes32 _claimId) : Remove a claim from the identity. getClaim(bytes32 _claimId) : Get a claim by ID. getClaimIdsByTopic(uint256 _topic) : Get claim IDs by topic. getClaimTopics() : Get all claim topics for the identity. isVerified() : Check if the identity is verified. IdentityFactory.sol \u00b6 The IdentityFactory contract creates new Identity contracts. Key functions: initialize(address identityRegistry, address trustedIssuerRegistry) : Initialize the factory with identity and trusted issuer registries. createIdentity(address ownerAddress) : Create a new identity for an owner. removeIdentity(address ownerAddress) : Remove an identity for an owner. getIdentity(address identityOwner) : Get the identity of an owner. getIdentityUsers() : Get all identity users. ClaimTopicsRegistryFacet.sol \u00b6 Manages claim topics that can be used to make claims about identities. Key functions: addClaimTopic(uint256 _claimTopic) : Add a claim topic to the registry. removeClaimTopic(uint256 _claimTopic) : Remove a claim topic from the registry. getClaimTopics() : Get all claim topics. TrustedIssuersRegistryFacet.sol \u00b6 Manages trusted issuers that can make claims about identities. Key functions: addTrustedIssuer(address _trustedIssuer, uint256[] calldata _claimTopics) : Add a trusted issuer with claim topics. removeTrustedIssuer(address _trustedIssuer) : Remove a trusted issuer. updateIssuerClaimTopics(address _trustedIssuer, uint256[] calldata _claimTopics) : Update claim topics for a trusted issuer. getTrustedIssuers() : Get all trusted issuers. getTrustedIssuerClaimTopics(address _trustedIssuer) : Get claim topics for a trusted issuer. isTrustedIssuer(address _issuer) : Check if an address is a trusted issuer. hasClaimTopic(address _trustedIssuer, uint256 _claimTopic) : Check if a trusted issuer has a claim topic. Token and Asset Management \u00b6 GemforceMinterFacet.sol \u00b6 The GemforceMinterFacet contract is used to mint tokens and set attributes. Key functions: gemforceMint(Attribute[] memory metadata) : Mint a new token with metadata. Marketplace \u00b6 MarketplaceFacet.sol \u00b6 The MarketplaceFacet contract provides functionality for buying and selling tokens. Key functions: purchaseItem(address contract, uint256 tokenId) : Purchase a token. Carbon Credits \u00b6 CarbonCreditFacet.sol \u00b6 The CarbonCreditFacet contract provides functionality for managing carbon credits. Key functions: retireCarbonCredits(uint256 tokenId, uint256 amount) : Retire carbon credits for a token. Cloud Function APIs \u00b6 Gemforce provides a set of cloud functions built on Parse Server that bridge the gap between client applications and the blockchain. Authentication Functions \u00b6 User Registration and Management \u00b6 registerUser : Register a new user with username, password, email, company, and name. verifyEmail : Verify a user's email with a token. retrieveEmailFromToken : Get the email associated with a token. requestPasswordReset : Request a password reset for a user. resetPassword : Reset a user's password with a token. updateUserByEmail : Update a user's profile by email. isUserOnboarded : Check if a user has completed onboarding. getUsersWithIdentityWallets : Get users who have identity wallets. Blockchain Management \u00b6 Network and Provider Management \u00b6 loadAllBlockchains : Get all configured blockchains. loadProviderUrl : Get the RPC endpoint for a network ID. loadProviderWebSocketUrl : Get the WebSocket endpoint for a network ID. loadAllProviderUrls : Get all provider URLs. loadBlockchainDataForNetwork : Get blockchain data (signer, provider, wallet) for a network. Contract Interaction \u00b6 Generic Contract Interaction \u00b6 addDiamondFacet : Add a facet to a diamond. callMethod : Call a method on a contract. viewMethod : View a method on a contract. callContractMethod : Call a method on a contract with custom parameters. viewContractMethod : View a method on a contract with custom parameters. loadSmartContractForNetwork : Load a smart contract for a network. loadSmartContractsForNetwork : Load all smart contracts for a network. DFNS Wallet Management \u00b6 DFNS is a wallet-as-a-service solution integrated with Gemforce for managing user wallets. User Registration and Authentication \u00b6 registerInit : Initialize DFNS user registration. registerComplete : Complete DFNS user registration. login : Login to DFNS. recoverInit : Initialize account recovery for DFNS. recoverComplete : Complete account recovery for DFNS. Wallet Management \u00b6 listWallets : List DFNS wallets. signaturesInit : Initialize a signature. signaturesComplete : Complete a signature. dfnsGetWallet : Get a DFNS wallet by ID. dfnsGetUSDC : Get USDC balance for a wallet. Transaction Management \u00b6 dfnsInitApproval / dfnsCompleteApproval : Approve tokens for spending. dfnsInitTransferUSDC / dfnsCompleteTransferUSDC : Transfer USDC. dfnsInitWithdraw / dfnsCompleteWithdraw : Withdraw tokens from the treasury. dfnsInitiatePurchase / dfnsCompletePurchase : Purchase an item from the marketplace. dfnsInitRetireCredits / dfnsCompleteRetireCredits : Retire carbon credits. Identity Management \u00b6 dfnsAddClaimTopicInit / dfnsAddClaimTopicComplete : Add a claim topic. dfnsAddTrustedIssuerInit / dfnsAddTrustedIssuerComplete : Add a trusted issuer. dfnsRemoveTrustedIssuerInit / dfnsRemoveTrustedIssuerComplete : Remove a trusted issuer. dfnsUpdateIssuerClaimTopicsInit / dfnsUpdateIssuerClaimTopicsComplete : Update claim topics for an issuer. dfnsCreateIdentityInit / dfnsCreateIdentityComplete : Create a digital identity. dfnsAddIdentityInit / dfnsAddIdentityComplete : Add an identity to the registry. dfnsRemoveIdentityInit / dfnsRemoveIdentityComplete : Remove an identity from the factory. dfnsUnregisterIdentityInit / dfnsUnregisterIdentityComplete : Remove an identity from the registry. dfnsSetClaimsInit / dfnsSetClaimsComplete : Set claims for an identity. dfnsAddClaimInit / dfnsAddClaimComplete : Add a claim to an identity. dfnsRemoveClaimInit / dfnsRemoveClaimComplete : Remove a claim from an identity. dfnsGetIdentity : Get the identity for an owner address. Asset Management \u00b6 dfnsGemforceMintInit / dfnsGemforceMintComplete : Mint a new token with metadata. Bridge API Integration \u00b6 Gemforce integrates with a Bridge API for handling financial operations. External Accounts \u00b6 createExternalAccount : Create an external account for a customer. getExternalAccounts : Get all external accounts for a customer. getExternalAccount : Get a specific external account for a customer. deleteExternalAccount : Delete an external account. Transfers \u00b6 createTransfer : Create a transfer between accounts. getCustomerTransfers : Get all transfers for a customer. KYC Management \u00b6 generateKycLink : Generate a KYC link for a user. getKycLinkStatus : Get the status of a KYC link. Plaid Integration \u00b6 getPlaidLinkToken : Get a Plaid link token for a customer. exchangePlaidPublicToken : Exchange a Plaid public token for access. Project Management \u00b6 getProjectMetadata : Get metadata for a project.","title":"Full API Reference"},{"location":"api-documentation/gemforce-api-documentation/#gemforce-api-documentation","text":"This document provides a comprehensive overview of the Gemforce API, detailing both the smart contract interfaces and cloud functions that power the system.","title":"Gemforce API Documentation"},{"location":"api-documentation/gemforce-api-documentation/#table-of-contents","text":"Introduction Smart Contract APIs Diamond Pattern DiamondFactory Identity Management Token and Asset Management Marketplace Carbon Credits Cloud Function APIs Authentication Functions Blockchain Management Contract Interaction DFNS Wallet Management Bridge API Integration Project Management","title":"Table of Contents"},{"location":"api-documentation/gemforce-api-documentation/#introduction","text":"Gemforce is a blockchain-powered platform that implements a Diamond pattern (EIP-2535) for upgradeable smart contracts, digital identity management, and token management. The platform combines on-chain smart contracts with off-chain cloud functions to provide a comprehensive solution for issuing, managing, and trading digital assets with verifiable claims.","title":"Introduction"},{"location":"api-documentation/gemforce-api-documentation/#smart-contract-apis","text":"","title":"Smart Contract APIs"},{"location":"api-documentation/gemforce-api-documentation/#diamond-pattern","text":"The Diamond pattern is the foundation of Gemforce's smart contract architecture. It provides a way to create upgradeable contracts that can be extended with new functionality without breaking existing functionality.","title":"Diamond Pattern"},{"location":"api-documentation/gemforce-api-documentation/#diamondsol","text":"The Diamond contract is the main contract that implements the Diamond pattern. Key functions: initialize(address _owner, DiamondSettings memory params, IDiamondCut.FacetCut[] memory _facets, address diamondInit, bytes calldata _calldata) : Initialize the diamond with owner, settings, and facets. diamondCut(IDiamondCut.FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) : Add, replace, or remove functions from the diamond. facets() : Get all facets and their selectors. facetFunctionSelectors(address _facet) : Get all function selectors for a facet. facetAddresses() : Get all facet addresses used by a diamond. facetAddress(bytes4 _functionSelector) : Get the facet that supports a given selector. transferOwnership(address _newOwner) : Transfer ownership of the diamond. owner() : Get the owner of the diamond.","title":"Diamond.sol"},{"location":"api-documentation/gemforce-api-documentation/#diamondfactory","text":"The DiamondFactory contract is used to create new Diamond contracts. Key functions: initialize(DiamondFactoryInit memory initData) : Initialize the factory with a set of facets. getFacets(string memory facetSet) : Get the facets for a facet set. setFacet(string memory facetSet, uint256 idx, IDiamondCut.FacetCut memory facetAddress) : Set a facet in a facet set. setFacets(string memory facetSet, IDiamondCut.FacetCut[] memory facetAddress) : Set multiple facets in a facet set. removeFacets(string memory facetSet) : Remove a facet set. getDiamondAddress(string memory symbol) : Get the address of a diamond by symbol. create(DiamondSettings memory params, address diamondInit, bytes calldata _calldata, IDiamondCut.FacetCut[] memory facets) : Create a new diamond with custom facets. createFromSet(DiamondSettings memory params, address diamondInit, bytes calldata _calldata, string memory facets) : Create a new diamond from a predefined facet set. add(string memory symbol, address payable diamondAddress) : Add an existing diamond to the factory. remove(string memory symbol) : Remove a diamond from the factory. exists(string memory symbol) : Check if a diamond exists. symbols() : Get all diamond symbols in the factory.","title":"DiamondFactory"},{"location":"api-documentation/gemforce-api-documentation/#identity-management","text":"Gemforce includes a digital identity system that allows for claims to be made about identities.","title":"Identity Management"},{"location":"api-documentation/gemforce-api-documentation/#identitysol","text":"The Identity contract represents a digital identity for a user. Key functions: initialize(address _owner, address _identityRegistry, address _trustedIssuerRegistry) : Initialize the identity with an owner, identity registry, and trusted issuer registry. getAttribute(string memory _key) : Get an attribute for a token ID keyed by string. setAttribute(string memory key, AttributeType attributeType, string memory value) : Set an attribute for a token ID. addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) : Add a key to the identity. removeKey(bytes32 _key, uint256 _purpose) : Remove a key from the identity. getKey(bytes32 _key) : Get a key from the identity. addClaim(uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) : Add a claim to the identity. removeClaim(bytes32 _claimId) : Remove a claim from the identity. getClaim(bytes32 _claimId) : Get a claim by ID. getClaimIdsByTopic(uint256 _topic) : Get claim IDs by topic. getClaimTopics() : Get all claim topics for the identity. isVerified() : Check if the identity is verified.","title":"Identity.sol"},{"location":"api-documentation/gemforce-api-documentation/#identityfactorysol","text":"The IdentityFactory contract creates new Identity contracts. Key functions: initialize(address identityRegistry, address trustedIssuerRegistry) : Initialize the factory with identity and trusted issuer registries. createIdentity(address ownerAddress) : Create a new identity for an owner. removeIdentity(address ownerAddress) : Remove an identity for an owner. getIdentity(address identityOwner) : Get the identity of an owner. getIdentityUsers() : Get all identity users.","title":"IdentityFactory.sol"},{"location":"api-documentation/gemforce-api-documentation/#claimtopicsregistryfacetsol","text":"Manages claim topics that can be used to make claims about identities. Key functions: addClaimTopic(uint256 _claimTopic) : Add a claim topic to the registry. removeClaimTopic(uint256 _claimTopic) : Remove a claim topic from the registry. getClaimTopics() : Get all claim topics.","title":"ClaimTopicsRegistryFacet.sol"},{"location":"api-documentation/gemforce-api-documentation/#trustedissuersregistryfacetsol","text":"Manages trusted issuers that can make claims about identities. Key functions: addTrustedIssuer(address _trustedIssuer, uint256[] calldata _claimTopics) : Add a trusted issuer with claim topics. removeTrustedIssuer(address _trustedIssuer) : Remove a trusted issuer. updateIssuerClaimTopics(address _trustedIssuer, uint256[] calldata _claimTopics) : Update claim topics for a trusted issuer. getTrustedIssuers() : Get all trusted issuers. getTrustedIssuerClaimTopics(address _trustedIssuer) : Get claim topics for a trusted issuer. isTrustedIssuer(address _issuer) : Check if an address is a trusted issuer. hasClaimTopic(address _trustedIssuer, uint256 _claimTopic) : Check if a trusted issuer has a claim topic.","title":"TrustedIssuersRegistryFacet.sol"},{"location":"api-documentation/gemforce-api-documentation/#token-and-asset-management","text":"","title":"Token and Asset Management"},{"location":"api-documentation/gemforce-api-documentation/#gemforceminterfacetsol","text":"The GemforceMinterFacet contract is used to mint tokens and set attributes. Key functions: gemforceMint(Attribute[] memory metadata) : Mint a new token with metadata.","title":"GemforceMinterFacet.sol"},{"location":"api-documentation/gemforce-api-documentation/#marketplace","text":"","title":"Marketplace"},{"location":"api-documentation/gemforce-api-documentation/#marketplacefacetsol","text":"The MarketplaceFacet contract provides functionality for buying and selling tokens. Key functions: purchaseItem(address contract, uint256 tokenId) : Purchase a token.","title":"MarketplaceFacet.sol"},{"location":"api-documentation/gemforce-api-documentation/#carbon-credits","text":"","title":"Carbon Credits"},{"location":"api-documentation/gemforce-api-documentation/#carboncreditfacetsol","text":"The CarbonCreditFacet contract provides functionality for managing carbon credits. Key functions: retireCarbonCredits(uint256 tokenId, uint256 amount) : Retire carbon credits for a token.","title":"CarbonCreditFacet.sol"},{"location":"api-documentation/gemforce-api-documentation/#cloud-function-apis","text":"Gemforce provides a set of cloud functions built on Parse Server that bridge the gap between client applications and the blockchain.","title":"Cloud Function APIs"},{"location":"api-documentation/gemforce-api-documentation/#authentication-functions","text":"","title":"Authentication Functions"},{"location":"api-documentation/gemforce-api-documentation/#user-registration-and-management","text":"registerUser : Register a new user with username, password, email, company, and name. verifyEmail : Verify a user's email with a token. retrieveEmailFromToken : Get the email associated with a token. requestPasswordReset : Request a password reset for a user. resetPassword : Reset a user's password with a token. updateUserByEmail : Update a user's profile by email. isUserOnboarded : Check if a user has completed onboarding. getUsersWithIdentityWallets : Get users who have identity wallets.","title":"User Registration and Management"},{"location":"api-documentation/gemforce-api-documentation/#blockchain-management","text":"","title":"Blockchain Management"},{"location":"api-documentation/gemforce-api-documentation/#network-and-provider-management","text":"loadAllBlockchains : Get all configured blockchains. loadProviderUrl : Get the RPC endpoint for a network ID. loadProviderWebSocketUrl : Get the WebSocket endpoint for a network ID. loadAllProviderUrls : Get all provider URLs. loadBlockchainDataForNetwork : Get blockchain data (signer, provider, wallet) for a network.","title":"Network and Provider Management"},{"location":"api-documentation/gemforce-api-documentation/#contract-interaction","text":"","title":"Contract Interaction"},{"location":"api-documentation/gemforce-api-documentation/#generic-contract-interaction","text":"addDiamondFacet : Add a facet to a diamond. callMethod : Call a method on a contract. viewMethod : View a method on a contract. callContractMethod : Call a method on a contract with custom parameters. viewContractMethod : View a method on a contract with custom parameters. loadSmartContractForNetwork : Load a smart contract for a network. loadSmartContractsForNetwork : Load all smart contracts for a network.","title":"Generic Contract Interaction"},{"location":"api-documentation/gemforce-api-documentation/#dfns-wallet-management","text":"DFNS is a wallet-as-a-service solution integrated with Gemforce for managing user wallets.","title":"DFNS Wallet Management"},{"location":"api-documentation/gemforce-api-documentation/#user-registration-and-authentication","text":"registerInit : Initialize DFNS user registration. registerComplete : Complete DFNS user registration. login : Login to DFNS. recoverInit : Initialize account recovery for DFNS. recoverComplete : Complete account recovery for DFNS.","title":"User Registration and Authentication"},{"location":"api-documentation/gemforce-api-documentation/#wallet-management","text":"listWallets : List DFNS wallets. signaturesInit : Initialize a signature. signaturesComplete : Complete a signature. dfnsGetWallet : Get a DFNS wallet by ID. dfnsGetUSDC : Get USDC balance for a wallet.","title":"Wallet Management"},{"location":"api-documentation/gemforce-api-documentation/#transaction-management","text":"dfnsInitApproval / dfnsCompleteApproval : Approve tokens for spending. dfnsInitTransferUSDC / dfnsCompleteTransferUSDC : Transfer USDC. dfnsInitWithdraw / dfnsCompleteWithdraw : Withdraw tokens from the treasury. dfnsInitiatePurchase / dfnsCompletePurchase : Purchase an item from the marketplace. dfnsInitRetireCredits / dfnsCompleteRetireCredits : Retire carbon credits.","title":"Transaction Management"},{"location":"api-documentation/gemforce-api-documentation/#identity-management_1","text":"dfnsAddClaimTopicInit / dfnsAddClaimTopicComplete : Add a claim topic. dfnsAddTrustedIssuerInit / dfnsAddTrustedIssuerComplete : Add a trusted issuer. dfnsRemoveTrustedIssuerInit / dfnsRemoveTrustedIssuerComplete : Remove a trusted issuer. dfnsUpdateIssuerClaimTopicsInit / dfnsUpdateIssuerClaimTopicsComplete : Update claim topics for an issuer. dfnsCreateIdentityInit / dfnsCreateIdentityComplete : Create a digital identity. dfnsAddIdentityInit / dfnsAddIdentityComplete : Add an identity to the registry. dfnsRemoveIdentityInit / dfnsRemoveIdentityComplete : Remove an identity from the factory. dfnsUnregisterIdentityInit / dfnsUnregisterIdentityComplete : Remove an identity from the registry. dfnsSetClaimsInit / dfnsSetClaimsComplete : Set claims for an identity. dfnsAddClaimInit / dfnsAddClaimComplete : Add a claim to an identity. dfnsRemoveClaimInit / dfnsRemoveClaimComplete : Remove a claim from an identity. dfnsGetIdentity : Get the identity for an owner address.","title":"Identity Management"},{"location":"api-documentation/gemforce-api-documentation/#asset-management","text":"dfnsGemforceMintInit / dfnsGemforceMintComplete : Mint a new token with metadata.","title":"Asset Management"},{"location":"api-documentation/gemforce-api-documentation/#bridge-api-integration","text":"Gemforce integrates with a Bridge API for handling financial operations.","title":"Bridge API Integration"},{"location":"api-documentation/gemforce-api-documentation/#external-accounts","text":"createExternalAccount : Create an external account for a customer. getExternalAccounts : Get all external accounts for a customer. getExternalAccount : Get a specific external account for a customer. deleteExternalAccount : Delete an external account.","title":"External Accounts"},{"location":"api-documentation/gemforce-api-documentation/#transfers","text":"createTransfer : Create a transfer between accounts. getCustomerTransfers : Get all transfers for a customer.","title":"Transfers"},{"location":"api-documentation/gemforce-api-documentation/#kyc-management","text":"generateKycLink : Generate a KYC link for a user. getKycLinkStatus : Get the status of a KYC link.","title":"KYC Management"},{"location":"api-documentation/gemforce-api-documentation/#plaid-integration","text":"getPlaidLinkToken : Get a Plaid link token for a customer. exchangePlaidPublicToken : Exchange a Plaid public token for access.","title":"Plaid Integration"},{"location":"api-documentation/gemforce-api-documentation/#project-management","text":"getProjectMetadata : Get metadata for a project.","title":"Project Management"},{"location":"api-documentation/gemforce-api-quick-reference/","text":"Gemforce API Quick Reference \u00b6 This document provides a concise reference for developers who need to interact with the Gemforce API, including smart contract calls and cloud function endpoints. Smart Contract Interactions \u00b6 Diamond Pattern \u00b6 The Diamond pattern allows for modular and upgradeable smart contracts. All functionality is implemented through facets. // Get the diamond address by symbol address diamondAddress = diamondFactory . getDiamondAddress ( \"GEM\" ); // Check if a diamond exists bool exists = diamondFactory . exists ( \"GEM\" ); // Create a new diamond DiamondSettings memory settings = DiamondSettings ({ name : \"Gemforce\" , symbol : \"GEM\" , // Other settings... }); address newDiamond = diamondFactory . createFromSet ( settings , initializer , initData , \"defaultFacetSet\" ); Identity Management \u00b6 // Create a new identity identityFactory . createIdentity ( userAddress ); // Get an identity address identityAddress = identityFactory . getIdentity ( userAddress ); // Add a claim topic claimTopicsRegistry . addClaimTopic ( 1 ); // e.g., KYC claim // Add a trusted issuer uint256 [] memory topics = new uint256 []( 1 ); topics [ 0 ] = 1 ; // KYC claim topic trustedIssuersRegistry . addTrustedIssuer ( issuerAddress , topics ); // Add a claim identity . addClaim ( 1 , // topic 1 , // scheme issuerAddress , signature , data , \"https://example.com/claim\" ); // Check if an identity has a claim bool hasKYC = identity . getClaim ( claimId ) != 0 ; Token Management \u00b6 // Mint a new token Attribute [] memory attributes = new Attribute []( 2 ); attributes [ 0 ] = Attribute ( \"name\" , AttributeType . String , \"Carbon Credit\" ); attributes [ 1 ] = Attribute ( \"amount\" , AttributeType . Number , \"100\" ); uint256 tokenId = gemforceMinter . gemforceMint ( attributes ); // Purchase a token marketplace . purchaseItem ( diamondAddress , tokenId ); // Retire carbon credits carbonCredits . retireCarbonCredits ( tokenId , 50 ); Cloud Function APIs \u00b6 Authentication \u00b6 // Register a user Parse . Cloud . run ( \"registerUser\" , { username : \"user@example.com\" , password : \"password123\" , email : \"user@example.com\" , company : \"Example Corp\" , firstName : \"John\" , lastName : \"Doe\" }). then ( result => { console . log ( \"User registered:\" , result ); }); // Login (using Parse SDK) Parse . User . logIn ( \"username\" , \"password\" ). then ( user => { console . log ( \"Logged in:\" , user ); }); DFNS Wallet Management \u00b6 // Register with DFNS Parse . Cloud . run ( \"registerInit\" , { username : \"user@example.com\" }). then ( challenge => { // Handle challenge with WebAuthn // Then complete registration return Parse . Cloud . run ( \"registerComplete\" , { signedChallenge : signedChallenge , temporaryAuthenticationToken : tempToken }); }). then ( result => { console . log ( \"DFNS registration complete:\" , result ); }); // Login to DFNS Parse . Cloud . run ( \"login\" , { username : \"user@example.com\" }). then ( result => { const dfnsToken = result . token ; // Store DFNS token for future operations }); // List wallets Parse . Cloud . run ( \"listWallets\" , { authToken : dfnsToken }). then ( wallets => { console . log ( \"User wallets:\" , wallets ); }); Contract Interactions via DFNS \u00b6 This pattern is used for all blockchain interactions through DFNS: 1. Initialize the transaction 2. Sign the challenge client-side 3. Complete the transaction with the signed challenge // Example: Purchase an item Parse . Cloud . run ( \"dfnsInitiatePurchase\" , { tokenId : \"123\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side using DFNS SDK const signedChallenge = await signChallenge ( challenge ); // Complete the purchase return Parse . Cloud . run ( \"dfnsCompletePurchase\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Purchase complete:\" , result ); }); Identity Management via DFNS \u00b6 // Create an identity Parse . Cloud . run ( \"dfnsCreateIdentityInit\" , { ownerAddress : \"0x123...\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete the identity creation return Parse . Cloud . run ( \"dfnsCreateIdentityComplete\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Identity created:\" , result ); }); // Add a claim topic Parse . Cloud . run ( \"dfnsAddClaimTopicInit\" , { claimTopic : 1 , // e.g., KYC claim walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete adding claim topic return Parse . Cloud . run ( \"dfnsAddClaimTopicComplete\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Claim topic added:\" , result ); }); Carbon Credit Management \u00b6 // Retire carbon credits Parse . Cloud . run ( \"dfnsInitRetireCredits\" , { tokenId : \"123\" , amount : \"50\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete retirement return Parse . Cloud . run ( \"dfnsCompleteRetireCredits\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Credits retired:\" , result ); }); Bridge API Integration \u00b6 // Create an external account Parse . Cloud . run ( \"createExternalAccount\" , { customer_id : \"cust_123\" , currency : \"usd\" , account_owner_name : \"John Doe\" , account_type : \"us\" , account : { account_number : \"123456789\" , routing_number : \"123456789\" , checking_or_savings : \"checking\" } }). then ( result => { console . log ( \"External account created:\" , result ); }); // Create a transfer Parse . Cloud . run ( \"createTransfer\" , { amount : \"100.00\" , on_behalf_of : \"cust_123\" , source : { currency : \"usd\" , payment_rail : \"ach\" , external_account_id : \"ext_acct_123\" }, destination : { currency : \"usdc\" , payment_rail : \"ethereum\" , to_address : \"0x123...\" } }). then ( result => { console . log ( \"Transfer created:\" , result ); }); Plaid Integration \u00b6 // Get a Plaid link token Parse . Cloud . run ( \"getPlaidLinkToken\" , { customerId : \"cust_123\" }). then ( result => { const linkToken = result . link_token ; // Use linkToken with Plaid Link }); // Exchange a Plaid public token Parse . Cloud . run ( \"exchangePlaidPublicToken\" , { customerId : \"cust_123\" , linkToken : \"link-123\" , publicToken : \"public-123\" }). then ( result => { console . log ( \"Plaid token exchanged:\" , result ); }); Common Patterns \u00b6 Two-Step Transaction Pattern \u00b6 Most blockchain interactions follow this pattern: Initialization Step : Call the *Init function with required parameters Receive a challenge and request body Completion Step : Sign the challenge client-side (typically with WebAuthn) Call the *Complete function with the signed challenge and request body Receive transaction result Error Handling \u00b6 Parse . Cloud . run ( \"someFunction\" , params ) . then ( result => { // Handle success }) . catch ( error => { // Parse Server error codes if ( error . code === Parse . Error . VALIDATION_ERROR ) { console . error ( \"Validation error:\" , error . message ); } else if ( error . code === Parse . Error . SCRIPT_FAILED ) { console . error ( \"Script error:\" , error . message ); } else { console . error ( \"Unknown error:\" , error ); } }); Important Considerations \u00b6 Authentication : Always ensure users are authenticated before accessing protected endpoints. DFNS Token Management : Store the DFNS token securely and refresh it when needed. Transaction Monitoring : Monitor transaction status after submission as blockchain transactions can take time to confirm. Gas Management : Be mindful of gas costs for transactions, especially for operations like minting tokens. Error Handling : Implement robust error handling for both client-side and server-side errors. Idempotency : Use idempotency keys for financial operations to prevent duplicate transactions. Wallet Address Validation : Validate Ethereum addresses before sending transactions. Testing : Test all interactions on test networks before moving to production.","title":"Quick Reference"},{"location":"api-documentation/gemforce-api-quick-reference/#gemforce-api-quick-reference","text":"This document provides a concise reference for developers who need to interact with the Gemforce API, including smart contract calls and cloud function endpoints.","title":"Gemforce API Quick Reference"},{"location":"api-documentation/gemforce-api-quick-reference/#smart-contract-interactions","text":"","title":"Smart Contract Interactions"},{"location":"api-documentation/gemforce-api-quick-reference/#diamond-pattern","text":"The Diamond pattern allows for modular and upgradeable smart contracts. All functionality is implemented through facets. // Get the diamond address by symbol address diamondAddress = diamondFactory . getDiamondAddress ( \"GEM\" ); // Check if a diamond exists bool exists = diamondFactory . exists ( \"GEM\" ); // Create a new diamond DiamondSettings memory settings = DiamondSettings ({ name : \"Gemforce\" , symbol : \"GEM\" , // Other settings... }); address newDiamond = diamondFactory . createFromSet ( settings , initializer , initData , \"defaultFacetSet\" );","title":"Diamond Pattern"},{"location":"api-documentation/gemforce-api-quick-reference/#identity-management","text":"// Create a new identity identityFactory . createIdentity ( userAddress ); // Get an identity address identityAddress = identityFactory . getIdentity ( userAddress ); // Add a claim topic claimTopicsRegistry . addClaimTopic ( 1 ); // e.g., KYC claim // Add a trusted issuer uint256 [] memory topics = new uint256 []( 1 ); topics [ 0 ] = 1 ; // KYC claim topic trustedIssuersRegistry . addTrustedIssuer ( issuerAddress , topics ); // Add a claim identity . addClaim ( 1 , // topic 1 , // scheme issuerAddress , signature , data , \"https://example.com/claim\" ); // Check if an identity has a claim bool hasKYC = identity . getClaim ( claimId ) != 0 ;","title":"Identity Management"},{"location":"api-documentation/gemforce-api-quick-reference/#token-management","text":"// Mint a new token Attribute [] memory attributes = new Attribute []( 2 ); attributes [ 0 ] = Attribute ( \"name\" , AttributeType . String , \"Carbon Credit\" ); attributes [ 1 ] = Attribute ( \"amount\" , AttributeType . Number , \"100\" ); uint256 tokenId = gemforceMinter . gemforceMint ( attributes ); // Purchase a token marketplace . purchaseItem ( diamondAddress , tokenId ); // Retire carbon credits carbonCredits . retireCarbonCredits ( tokenId , 50 );","title":"Token Management"},{"location":"api-documentation/gemforce-api-quick-reference/#cloud-function-apis","text":"","title":"Cloud Function APIs"},{"location":"api-documentation/gemforce-api-quick-reference/#authentication","text":"// Register a user Parse . Cloud . run ( \"registerUser\" , { username : \"user@example.com\" , password : \"password123\" , email : \"user@example.com\" , company : \"Example Corp\" , firstName : \"John\" , lastName : \"Doe\" }). then ( result => { console . log ( \"User registered:\" , result ); }); // Login (using Parse SDK) Parse . User . logIn ( \"username\" , \"password\" ). then ( user => { console . log ( \"Logged in:\" , user ); });","title":"Authentication"},{"location":"api-documentation/gemforce-api-quick-reference/#dfns-wallet-management","text":"// Register with DFNS Parse . Cloud . run ( \"registerInit\" , { username : \"user@example.com\" }). then ( challenge => { // Handle challenge with WebAuthn // Then complete registration return Parse . Cloud . run ( \"registerComplete\" , { signedChallenge : signedChallenge , temporaryAuthenticationToken : tempToken }); }). then ( result => { console . log ( \"DFNS registration complete:\" , result ); }); // Login to DFNS Parse . Cloud . run ( \"login\" , { username : \"user@example.com\" }). then ( result => { const dfnsToken = result . token ; // Store DFNS token for future operations }); // List wallets Parse . Cloud . run ( \"listWallets\" , { authToken : dfnsToken }). then ( wallets => { console . log ( \"User wallets:\" , wallets ); });","title":"DFNS Wallet Management"},{"location":"api-documentation/gemforce-api-quick-reference/#contract-interactions-via-dfns","text":"This pattern is used for all blockchain interactions through DFNS: 1. Initialize the transaction 2. Sign the challenge client-side 3. Complete the transaction with the signed challenge // Example: Purchase an item Parse . Cloud . run ( \"dfnsInitiatePurchase\" , { tokenId : \"123\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side using DFNS SDK const signedChallenge = await signChallenge ( challenge ); // Complete the purchase return Parse . Cloud . run ( \"dfnsCompletePurchase\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Purchase complete:\" , result ); });","title":"Contract Interactions via DFNS"},{"location":"api-documentation/gemforce-api-quick-reference/#identity-management-via-dfns","text":"// Create an identity Parse . Cloud . run ( \"dfnsCreateIdentityInit\" , { ownerAddress : \"0x123...\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete the identity creation return Parse . Cloud . run ( \"dfnsCreateIdentityComplete\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Identity created:\" , result ); }); // Add a claim topic Parse . Cloud . run ( \"dfnsAddClaimTopicInit\" , { claimTopic : 1 , // e.g., KYC claim walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete adding claim topic return Parse . Cloud . run ( \"dfnsAddClaimTopicComplete\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Claim topic added:\" , result ); });","title":"Identity Management via DFNS"},{"location":"api-documentation/gemforce-api-quick-reference/#carbon-credit-management","text":"// Retire carbon credits Parse . Cloud . run ( \"dfnsInitRetireCredits\" , { tokenId : \"123\" , amount : \"50\" , walletId : \"wallet_123\" , dfns_token : dfnsToken }). then ( async ({ challenge , requestBody }) => { // Sign the challenge client-side const signedChallenge = await signChallenge ( challenge ); // Complete retirement return Parse . Cloud . run ( \"dfnsCompleteRetireCredits\" , { walletId : \"wallet_123\" , dfns_token : dfnsToken , signedChallenge : signedChallenge , requestBody : requestBody }); }). then ( result => { console . log ( \"Credits retired:\" , result ); });","title":"Carbon Credit Management"},{"location":"api-documentation/gemforce-api-quick-reference/#bridge-api-integration","text":"// Create an external account Parse . Cloud . run ( \"createExternalAccount\" , { customer_id : \"cust_123\" , currency : \"usd\" , account_owner_name : \"John Doe\" , account_type : \"us\" , account : { account_number : \"123456789\" , routing_number : \"123456789\" , checking_or_savings : \"checking\" } }). then ( result => { console . log ( \"External account created:\" , result ); }); // Create a transfer Parse . Cloud . run ( \"createTransfer\" , { amount : \"100.00\" , on_behalf_of : \"cust_123\" , source : { currency : \"usd\" , payment_rail : \"ach\" , external_account_id : \"ext_acct_123\" }, destination : { currency : \"usdc\" , payment_rail : \"ethereum\" , to_address : \"0x123...\" } }). then ( result => { console . log ( \"Transfer created:\" , result ); });","title":"Bridge API Integration"},{"location":"api-documentation/gemforce-api-quick-reference/#plaid-integration","text":"// Get a Plaid link token Parse . Cloud . run ( \"getPlaidLinkToken\" , { customerId : \"cust_123\" }). then ( result => { const linkToken = result . link_token ; // Use linkToken with Plaid Link }); // Exchange a Plaid public token Parse . Cloud . run ( \"exchangePlaidPublicToken\" , { customerId : \"cust_123\" , linkToken : \"link-123\" , publicToken : \"public-123\" }). then ( result => { console . log ( \"Plaid token exchanged:\" , result ); });","title":"Plaid Integration"},{"location":"api-documentation/gemforce-api-quick-reference/#common-patterns","text":"","title":"Common Patterns"},{"location":"api-documentation/gemforce-api-quick-reference/#two-step-transaction-pattern","text":"Most blockchain interactions follow this pattern: Initialization Step : Call the *Init function with required parameters Receive a challenge and request body Completion Step : Sign the challenge client-side (typically with WebAuthn) Call the *Complete function with the signed challenge and request body Receive transaction result","title":"Two-Step Transaction Pattern"},{"location":"api-documentation/gemforce-api-quick-reference/#error-handling","text":"Parse . Cloud . run ( \"someFunction\" , params ) . then ( result => { // Handle success }) . catch ( error => { // Parse Server error codes if ( error . code === Parse . Error . VALIDATION_ERROR ) { console . error ( \"Validation error:\" , error . message ); } else if ( error . code === Parse . Error . SCRIPT_FAILED ) { console . error ( \"Script error:\" , error . message ); } else { console . error ( \"Unknown error:\" , error ); } });","title":"Error Handling"},{"location":"api-documentation/gemforce-api-quick-reference/#important-considerations","text":"Authentication : Always ensure users are authenticated before accessing protected endpoints. DFNS Token Management : Store the DFNS token securely and refresh it when needed. Transaction Monitoring : Monitor transaction status after submission as blockchain transactions can take time to confirm. Gas Management : Be mindful of gas costs for transactions, especially for operations like minting tokens. Error Handling : Implement robust error handling for both client-side and server-side errors. Idempotency : Use idempotency keys for financial operations to prevent duplicate transactions. Wallet Address Validation : Validate Ethereum addresses before sending transactions. Testing : Test all interactions on test networks before moving to production.","title":"Important Considerations"},{"location":"cloud-functions/","text":"Cloud Functions API Documentation \u00b6 Overview \u00b6 The Gemforce platform provides a comprehensive set of cloud functions built on Parse Server that handle blockchain interactions, user authentication, external service integrations, and business logic operations. These cloud functions serve as the bridge between the frontend applications and the underlying blockchain infrastructure. Architecture \u00b6 The cloud functions are organized into several modules: Authentication Functions - User authentication and session management Blockchain Functions - Blockchain network interactions and provider management Bridge API Functions - External financial service integrations Contract Functions - Smart contract deployment and interaction DFNS Functions - Wallet-as-a-Service integration Project Functions - Project lifecycle management Trade Deal Functions - Trade deal operations and management Function Categories \u00b6 Core Infrastructure \u00b6 Blockchain Functions - Network provider management and blockchain interactions Authentication Functions - User authentication and authorization Contract Functions - Smart contract deployment and management External Integrations \u00b6 DFNS Functions - Wallet-as-a-Service integration Bridge API Functions - Financial services and KYC integration Project Functions - Project management and configuration Business Logic \u00b6 Trade Deal Functions - Trade deal lifecycle management Deploy Functions - Automated deployment operations Authentication & Security \u00b6 API Authentication \u00b6 All cloud functions require proper authentication: // Client-side authentication Parse . User . logIn ( username , password ). then (( user ) => { // User is authenticated, can call cloud functions return Parse . Cloud . run ( \"functionName\" , parameters ); }); Session Management \u00b6 Session tokens are automatically managed by Parse SDK Sessions expire based on configuration settings Master key access for administrative functions Access Control \u00b6 Role-based access control through Parse roles Function-level permissions Parameter validation and sanitization Common Usage Patterns \u00b6 Calling Cloud Functions \u00b6 From JavaScript/TypeScript \u00b6 // Basic cloud function call const result = await Parse . Cloud . run ( \"functionName\" , { parameter1 : \"value1\" , parameter2 : \"value2\" }); // With error handling try { const result = await Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId : 1337 }); console . log ( \"Blockchain data:\" , result ); } catch ( error ) { console . error ( \"Error:\" , error . message ); } From REST API \u00b6 # POST request to cloud function curl -X POST \\ -H \"X-Parse-Application-Id: YOUR_APP_ID\" \\ -H \"X-Parse-Session-Token: USER_SESSION_TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"parameter1\":\"value1\",\"parameter2\":\"value2\"}' \\ https://your-server.com/parse/functions/functionName Error Handling \u00b6 Cloud functions use consistent error handling: // Function implementation with error handling Parse . Cloud . define ( \"exampleFunction\" , async ( request ) => { try { // Validate parameters if ( ! request . params . requiredParam ) { throw new Error ( \"Missing required parameter: requiredParam\" ); } // Perform operation const result = await someOperation ( request . params ); return result ; } catch ( error ) { // Log error for debugging console . error ( \"Error in exampleFunction:\" , error ); throw new Error ( `Operation failed: ${ error . message } ` ); } }); Response Formats \u00b6 Success Response \u00b6 { \"result\" : { \"data\" : \"function-specific-data\" , \"status\" : \"success\" } } Error Response \u00b6 { \"code\" : 141 , \"error\" : \"Error message describing what went wrong\" } Rate Limiting & Performance \u00b6 Rate Limiting \u00b6 Functions are subject to Parse Server rate limiting Implement client-side throttling for high-frequency calls Use batch operations where possible Performance Optimization \u00b6 Functions are cached where appropriate Database queries are optimized with proper indexing Async/await patterns for non-blocking operations Environment Configuration \u00b6 Required Environment Variables \u00b6 # Parse Server Configuration APP_ID = your_app_id MASTER_KEY = your_master_key SERVER_URL = https://your-server.com/parse # Blockchain Configuration ETH_NODE_URI_SEPOLIA = https://sepolia.infura.io/v3/your-key ETH_NODE_URI_BASESEP = https://base-sepolia.infura.io/v3/your-key # External Service Keys DFNS_API_KEY = your_dfns_key BRIDGE_API_KEY = your_bridge_key SENDGRID_API_KEY = your_sendgrid_key Network Configuration \u00b6 The system supports multiple blockchain networks: - Localhost (networkId: 1337) - Development - Sepolia (networkId: 11155111) - Ethereum testnet - Base Sepolia (networkId: 84532) - Base testnet - OP Sepolia (networkId: 11155420) - Optimism testnet Monitoring & Logging \u00b6 Function Logging \u00b6 Parse . Cloud . define ( \"exampleFunction\" , async ( request ) => { // Log function entry console . log ( `Function called: exampleFunction` , request . params ); try { const result = await operation (); // Log success console . log ( `Function completed: exampleFunction` , result ); return result ; } catch ( error ) { // Log error with context console . error ( `Function error: exampleFunction` , { error : error . message , params : request . params , stack : error . stack }); throw error ; } }); Performance Monitoring \u00b6 Function execution times are logged Database query performance is monitored External API call latencies are tracked Development Guidelines \u00b6 Function Structure \u00b6 Parse . Cloud . define ( \"functionName\" , async ( request ) => { // 1. Parameter validation const { param1 , param2 } = request . params ; if ( ! param1 ) { throw new Error ( \"Missing required parameter: param1\" ); } // 2. Authentication/authorization checks if ( ! request . user ) { throw new Error ( \"Authentication required\" ); } // 3. Business logic const result = await performOperation ( param1 , param2 ); // 4. Return result return result ; }); Best Practices \u00b6 Always validate input parameters Use try-catch blocks for error handling Log important operations and errors Return consistent response formats Implement proper access control Use async/await for asynchronous operations Testing \u00b6 Unit Testing \u00b6 // Test cloud function describe ( \"Cloud Function Tests\" , () => { it ( \"should return blockchain data\" , async () => { const result = await Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId : 1337 }); expect ( result ). toHaveProperty ( \"provider\" ); expect ( result ). toHaveProperty ( \"signer\" ); expect ( result ). toHaveProperty ( \"wallet\" ); }); }); Integration Testing \u00b6 Test with real blockchain networks Validate external service integrations Test error conditions and edge cases Deployment \u00b6 Local Development \u00b6 # Start Parse Server with cloud functions npm start # Functions are automatically loaded from src/cloud-functions.ts Production Deployment \u00b6 Functions are deployed with Parse Server Environment variables must be configured Database migrations may be required Related Documentation \u00b6 Parse Server Documentation Blockchain Integration Guide DFNS Integration Guide Bridge API Integration Guide For detailed information about specific cloud functions, navigate to the individual function documentation pages.","title":"Overview"},{"location":"cloud-functions/#cloud-functions-api-documentation","text":"","title":"Cloud Functions API Documentation"},{"location":"cloud-functions/#overview","text":"The Gemforce platform provides a comprehensive set of cloud functions built on Parse Server that handle blockchain interactions, user authentication, external service integrations, and business logic operations. These cloud functions serve as the bridge between the frontend applications and the underlying blockchain infrastructure.","title":"Overview"},{"location":"cloud-functions/#architecture","text":"The cloud functions are organized into several modules: Authentication Functions - User authentication and session management Blockchain Functions - Blockchain network interactions and provider management Bridge API Functions - External financial service integrations Contract Functions - Smart contract deployment and interaction DFNS Functions - Wallet-as-a-Service integration Project Functions - Project lifecycle management Trade Deal Functions - Trade deal operations and management","title":"Architecture"},{"location":"cloud-functions/#function-categories","text":"","title":"Function Categories"},{"location":"cloud-functions/#core-infrastructure","text":"Blockchain Functions - Network provider management and blockchain interactions Authentication Functions - User authentication and authorization Contract Functions - Smart contract deployment and management","title":"Core Infrastructure"},{"location":"cloud-functions/#external-integrations","text":"DFNS Functions - Wallet-as-a-Service integration Bridge API Functions - Financial services and KYC integration Project Functions - Project management and configuration","title":"External Integrations"},{"location":"cloud-functions/#business-logic","text":"Trade Deal Functions - Trade deal lifecycle management Deploy Functions - Automated deployment operations","title":"Business Logic"},{"location":"cloud-functions/#authentication-security","text":"","title":"Authentication &amp; Security"},{"location":"cloud-functions/#api-authentication","text":"All cloud functions require proper authentication: // Client-side authentication Parse . User . logIn ( username , password ). then (( user ) => { // User is authenticated, can call cloud functions return Parse . Cloud . run ( \"functionName\" , parameters ); });","title":"API Authentication"},{"location":"cloud-functions/#session-management","text":"Session tokens are automatically managed by Parse SDK Sessions expire based on configuration settings Master key access for administrative functions","title":"Session Management"},{"location":"cloud-functions/#access-control","text":"Role-based access control through Parse roles Function-level permissions Parameter validation and sanitization","title":"Access Control"},{"location":"cloud-functions/#common-usage-patterns","text":"","title":"Common Usage Patterns"},{"location":"cloud-functions/#calling-cloud-functions","text":"","title":"Calling Cloud Functions"},{"location":"cloud-functions/#from-javascripttypescript","text":"// Basic cloud function call const result = await Parse . Cloud . run ( \"functionName\" , { parameter1 : \"value1\" , parameter2 : \"value2\" }); // With error handling try { const result = await Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId : 1337 }); console . log ( \"Blockchain data:\" , result ); } catch ( error ) { console . error ( \"Error:\" , error . message ); }","title":"From JavaScript/TypeScript"},{"location":"cloud-functions/#from-rest-api","text":"# POST request to cloud function curl -X POST \\ -H \"X-Parse-Application-Id: YOUR_APP_ID\" \\ -H \"X-Parse-Session-Token: USER_SESSION_TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"parameter1\":\"value1\",\"parameter2\":\"value2\"}' \\ https://your-server.com/parse/functions/functionName","title":"From REST API"},{"location":"cloud-functions/#error-handling","text":"Cloud functions use consistent error handling: // Function implementation with error handling Parse . Cloud . define ( \"exampleFunction\" , async ( request ) => { try { // Validate parameters if ( ! request . params . requiredParam ) { throw new Error ( \"Missing required parameter: requiredParam\" ); } // Perform operation const result = await someOperation ( request . params ); return result ; } catch ( error ) { // Log error for debugging console . error ( \"Error in exampleFunction:\" , error ); throw new Error ( `Operation failed: ${ error . message } ` ); } });","title":"Error Handling"},{"location":"cloud-functions/#response-formats","text":"","title":"Response Formats"},{"location":"cloud-functions/#success-response","text":"{ \"result\" : { \"data\" : \"function-specific-data\" , \"status\" : \"success\" } }","title":"Success Response"},{"location":"cloud-functions/#error-response","text":"{ \"code\" : 141 , \"error\" : \"Error message describing what went wrong\" }","title":"Error Response"},{"location":"cloud-functions/#rate-limiting-performance","text":"","title":"Rate Limiting &amp; Performance"},{"location":"cloud-functions/#rate-limiting","text":"Functions are subject to Parse Server rate limiting Implement client-side throttling for high-frequency calls Use batch operations where possible","title":"Rate Limiting"},{"location":"cloud-functions/#performance-optimization","text":"Functions are cached where appropriate Database queries are optimized with proper indexing Async/await patterns for non-blocking operations","title":"Performance Optimization"},{"location":"cloud-functions/#environment-configuration","text":"","title":"Environment Configuration"},{"location":"cloud-functions/#required-environment-variables","text":"# Parse Server Configuration APP_ID = your_app_id MASTER_KEY = your_master_key SERVER_URL = https://your-server.com/parse # Blockchain Configuration ETH_NODE_URI_SEPOLIA = https://sepolia.infura.io/v3/your-key ETH_NODE_URI_BASESEP = https://base-sepolia.infura.io/v3/your-key # External Service Keys DFNS_API_KEY = your_dfns_key BRIDGE_API_KEY = your_bridge_key SENDGRID_API_KEY = your_sendgrid_key","title":"Required Environment Variables"},{"location":"cloud-functions/#network-configuration","text":"The system supports multiple blockchain networks: - Localhost (networkId: 1337) - Development - Sepolia (networkId: 11155111) - Ethereum testnet - Base Sepolia (networkId: 84532) - Base testnet - OP Sepolia (networkId: 11155420) - Optimism testnet","title":"Network Configuration"},{"location":"cloud-functions/#monitoring-logging","text":"","title":"Monitoring &amp; Logging"},{"location":"cloud-functions/#function-logging","text":"Parse . Cloud . define ( \"exampleFunction\" , async ( request ) => { // Log function entry console . log ( `Function called: exampleFunction` , request . params ); try { const result = await operation (); // Log success console . log ( `Function completed: exampleFunction` , result ); return result ; } catch ( error ) { // Log error with context console . error ( `Function error: exampleFunction` , { error : error . message , params : request . params , stack : error . stack }); throw error ; } });","title":"Function Logging"},{"location":"cloud-functions/#performance-monitoring","text":"Function execution times are logged Database query performance is monitored External API call latencies are tracked","title":"Performance Monitoring"},{"location":"cloud-functions/#development-guidelines","text":"","title":"Development Guidelines"},{"location":"cloud-functions/#function-structure","text":"Parse . Cloud . define ( \"functionName\" , async ( request ) => { // 1. Parameter validation const { param1 , param2 } = request . params ; if ( ! param1 ) { throw new Error ( \"Missing required parameter: param1\" ); } // 2. Authentication/authorization checks if ( ! request . user ) { throw new Error ( \"Authentication required\" ); } // 3. Business logic const result = await performOperation ( param1 , param2 ); // 4. Return result return result ; });","title":"Function Structure"},{"location":"cloud-functions/#best-practices","text":"Always validate input parameters Use try-catch blocks for error handling Log important operations and errors Return consistent response formats Implement proper access control Use async/await for asynchronous operations","title":"Best Practices"},{"location":"cloud-functions/#testing","text":"","title":"Testing"},{"location":"cloud-functions/#unit-testing","text":"// Test cloud function describe ( \"Cloud Function Tests\" , () => { it ( \"should return blockchain data\" , async () => { const result = await Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId : 1337 }); expect ( result ). toHaveProperty ( \"provider\" ); expect ( result ). toHaveProperty ( \"signer\" ); expect ( result ). toHaveProperty ( \"wallet\" ); }); });","title":"Unit Testing"},{"location":"cloud-functions/#integration-testing","text":"Test with real blockchain networks Validate external service integrations Test error conditions and edge cases","title":"Integration Testing"},{"location":"cloud-functions/#deployment","text":"","title":"Deployment"},{"location":"cloud-functions/#local-development","text":"# Start Parse Server with cloud functions npm start # Functions are automatically loaded from src/cloud-functions.ts","title":"Local Development"},{"location":"cloud-functions/#production-deployment","text":"Functions are deployed with Parse Server Environment variables must be configured Database migrations may be required","title":"Production Deployment"},{"location":"cloud-functions/#related-documentation","text":"Parse Server Documentation Blockchain Integration Guide DFNS Integration Guide Bridge API Integration Guide For detailed information about specific cloud functions, navigate to the individual function documentation pages.","title":"Related Documentation"},{"location":"cloud-functions/auth-functions/","text":"Authentication Functions \u00b6 The Authentication Functions module provides comprehensive user authentication, registration, and session management capabilities for the Gemforce platform. It handles user lifecycle management, password security, and integration with external authentication providers. Overview \u00b6 The Authentication Functions provide: User Registration : Create new user accounts with validation Login/Logout : Secure authentication and session management Password Management : Password reset and change functionality Session Management : JWT token generation and validation Multi-Factor Authentication : Optional MFA support Social Authentication : Integration with external providers Key Features \u00b6 User Management \u00b6 Registration : Email-based user registration with verification Profile Management : User profile creation and updates Account Verification : Email verification workflows Account Recovery : Password reset and account recovery Authentication Security \u00b6 Password Hashing : Secure password storage using bcrypt JWT Tokens : Stateless authentication with JSON Web Tokens Session Management : Secure session handling Rate Limiting : Protection against brute force attacks Integration Support \u00b6 DFNS Integration : Wallet creation during registration Parse Server : User management through Parse Server External Providers : Support for OAuth providers Webhook Integration : Authentication event notifications Core Functions \u00b6 registerUser() \u00b6 Creates a new user account with email verification. Parameters: interface RegisterUserRequest { email : string ; password : string ; username? : string ; firstName? : string ; lastName? : string ; acceptTerms : boolean ; } Returns: interface RegisterUserResponse { success : boolean ; userId? : string ; message : string ; verificationRequired? : boolean ; } Usage: const result = await Parse . Cloud . run ( 'registerUser' , { email : 'user@example.com' , password : 'securePassword123' , username : 'johndoe' , firstName : 'John' , lastName : 'Doe' , acceptTerms : true }); loginUser() \u00b6 Authenticates a user and returns session information. Parameters: interface LoginUserRequest { email : string ; password : string ; rememberMe? : boolean ; } Returns: interface LoginUserResponse { success : boolean ; sessionToken? : string ; user ?: { id : string ; email : string ; username : string ; walletAddress? : string ; }; message : string ; } Usage: const result = await Parse . Cloud . run ( 'loginUser' , { email : 'user@example.com' , password : 'securePassword123' , rememberMe : true }); resetPassword() \u00b6 Initiates password reset process via email. Parameters: interface ResetPasswordRequest { email : string ; } Returns: interface ResetPasswordResponse { success : boolean ; message : string ; } changePassword() \u00b6 Changes user password with current password verification. Parameters: interface ChangePasswordRequest { currentPassword : string ; newPassword : string ; } Returns: interface ChangePasswordResponse { success : boolean ; message : string ; } verifyEmail() \u00b6 Verifies user email address using verification token. Parameters: interface VerifyEmailRequest { token : string ; email : string ; } Returns: interface VerifyEmailResponse { success : boolean ; message : string ; } Implementation Example \u00b6 User Registration with DFNS Integration \u00b6 Parse . Cloud . define ( 'registerUser' , async ( request ) => { const { email , password , username , firstName , lastName , acceptTerms } = request . params ; try { // Validate input if ( ! email || ! password || ! acceptTerms ) { throw new Error ( 'Missing required fields' ); } // Check if user already exists const existingUser = await new Parse . Query ( Parse . User ) . equalTo ( 'email' , email . toLowerCase ()) . first ({ useMasterKey : true }); if ( existingUser ) { throw new Error ( 'User already exists' ); } // Create new user const user = new Parse . User (); user . set ( 'email' , email . toLowerCase ()); user . set ( 'username' , username || email . toLowerCase ()); user . set ( 'password' , password ); user . set ( 'firstName' , firstName ); user . set ( 'lastName' , lastName ); user . set ( 'emailVerified' , false ); user . set ( 'acceptedTerms' , acceptTerms ); user . set ( 'acceptedTermsDate' , new Date ()); // Save user await user . signUp (); // Create DFNS wallet try { const walletResult = await Parse . Cloud . run ( 'createUserWallet' , { userId : user.id , email : email.toLowerCase () }); if ( walletResult . success ) { user . set ( 'walletAddress' , walletResult . walletAddress ); user . set ( 'dfnsWalletId' , walletResult . walletId ); await user . save ( null , { useMasterKey : true }); } } catch ( walletError ) { console . error ( 'Wallet creation failed:' , walletError ); // Continue with registration even if wallet creation fails } // Send verification email await sendVerificationEmail ( user ); return { success : true , userId : user.id , message : 'Registration successful. Please check your email for verification.' , verificationRequired : true }; } catch ( error ) { console . error ( 'Registration error:' , error ); return { success : false , message : error.message || 'Registration failed' }; } }); Secure Login with Rate Limiting \u00b6 Parse . Cloud . define ( 'loginUser' , async ( request ) => { const { email , password , rememberMe } = request . params ; try { // Rate limiting check const rateLimitKey = `login_attempts_ ${ email . toLowerCase () } ` ; const attempts = await getFromCache ( rateLimitKey ) || 0 ; if ( attempts >= 5 ) { throw new Error ( 'Too many login attempts. Please try again later.' ); } // Attempt login const user = await Parse . User . logIn ( email . toLowerCase (), password ); // Clear rate limiting on successful login await clearFromCache ( rateLimitKey ); // Check if email is verified if ( ! user . get ( 'emailVerified' )) { await Parse . User . logOut (); throw new Error ( 'Please verify your email before logging in' ); } // Update last login user . set ( 'lastLogin' , new Date ()); user . set ( 'loginCount' , ( user . get ( 'loginCount' ) || 0 ) + 1 ); await user . save ( null , { useMasterKey : true }); // Generate session token const sessionToken = user . getSessionToken (); return { success : true , sessionToken , user : { id : user.id , email : user.get ( 'email' ), username : user.get ( 'username' ), walletAddress : user.get ( 'walletAddress' ) }, message : 'Login successful' }; } catch ( error ) { // Increment rate limiting counter const rateLimitKey = `login_attempts_ ${ email . toLowerCase () } ` ; const attempts = await getFromCache ( rateLimitKey ) || 0 ; await setInCache ( rateLimitKey , attempts + 1 , 900 ); // 15 minutes console . error ( 'Login error:' , error ); return { success : false , message : error.message || 'Login failed' }; } }); Password Reset with Email \u00b6 Parse . Cloud . define ( 'resetPassword' , async ( request ) => { const { email } = request . params ; try { // Find user const user = await new Parse . Query ( Parse . User ) . equalTo ( 'email' , email . toLowerCase ()) . first ({ useMasterKey : true }); if ( ! user ) { // Don't reveal if user exists or not return { success : true , message : 'If an account with that email exists, a reset link has been sent.' }; } // Generate reset token const resetToken = generateSecureToken (); const resetExpiry = new Date ( Date . now () + 3600000 ); // 1 hour user . set ( 'passwordResetToken' , resetToken ); user . set ( 'passwordResetExpiry' , resetExpiry ); await user . save ( null , { useMasterKey : true }); // Send reset email await sendPasswordResetEmail ( user , resetToken ); return { success : true , message : 'If an account with that email exists, a reset link has been sent.' }; } catch ( error ) { console . error ( 'Password reset error:' , error ); return { success : false , message : 'Password reset failed' }; } }); Security Features \u00b6 Password Security \u00b6 // Password validation function validatePassword ( password : string ) : { valid : boolean ; message? : string } { if ( password . length < 8 ) { return { valid : false , message : 'Password must be at least 8 characters long' }; } if ( ! /(?=.*[a-z])/ . test ( password )) { return { valid : false , message : 'Password must contain at least one lowercase letter' }; } if ( ! /(?=.*[A-Z])/ . test ( password )) { return { valid : false , message : 'Password must contain at least one uppercase letter' }; } if ( ! /(?=.*\\d)/ . test ( password )) { return { valid : false , message : 'Password must contain at least one number' }; } if ( ! /(?=.*[@$!%*?&])/ . test ( password )) { return { valid : false , message : 'Password must contain at least one special character' }; } return { valid : true }; } Session Management \u00b6 Parse . Cloud . define ( 'validateSession' , async ( request ) => { try { const user = request . user ; if ( ! user ) { throw new Error ( 'Invalid session' ); } // Check if session is still valid const sessionQuery = new Parse . Query ( Parse . Session ); sessionQuery . equalTo ( 'user' , user ); sessionQuery . equalTo ( 'sessionToken' , request . headers [ 'x-parse-session-token' ]); const session = await sessionQuery . first ({ useMasterKey : true }); if ( ! session ) { throw new Error ( 'Session not found' ); } // Check session expiry const expiresAt = session . get ( 'expiresAt' ); if ( expiresAt && new Date () > expiresAt ) { await session . destroy ({ useMasterKey : true }); throw new Error ( 'Session expired' ); } return { success : true , user : { id : user.id , email : user.get ( 'email' ), username : user.get ( 'username' ) } }; } catch ( error ) { return { success : false , message : error.message }; } }); Multi-Factor Authentication \u00b6 Parse . Cloud . define ( 'enableMFA' , async ( request ) => { const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Generate TOTP secret const secret = generateTOTPSecret (); // Store secret (encrypted) user . set ( 'mfaSecret' , encryptSecret ( secret )); user . set ( 'mfaEnabled' , false ); // Will be enabled after verification await user . save ( null , { useMasterKey : true }); // Generate QR code for authenticator app const qrCode = generateQRCode ( user . get ( 'email' ), secret ); return { success : true , secret , qrCode , message : 'Scan the QR code with your authenticator app' }; } catch ( error ) { console . error ( 'MFA setup error:' , error ); throw new Error ( 'Failed to setup MFA' ); } }); Integration Patterns \u00b6 Frontend Integration \u00b6 class AuthService { async register ( userData : RegisterUserRequest ) : Promise < RegisterUserResponse > { return await Parse . Cloud . run ( 'registerUser' , userData ); } async login ( credentials : LoginUserRequest ) : Promise < LoginUserResponse > { return await Parse . Cloud . run ( 'loginUser' , credentials ); } async logout () : Promise < void > { await Parse . User . logOut (); } async resetPassword ( email : string ) : Promise < ResetPasswordResponse > { return await Parse . Cloud . run ( 'resetPassword' , { email }); } async changePassword ( passwords : ChangePasswordRequest ) : Promise < ChangePasswordResponse > { return await Parse . Cloud . run ( 'changePassword' , passwords ); } getCurrentUser () : Parse . User | null { return Parse . User . current (); } isAuthenticated () : boolean { return Parse . User . current () !== null ; } } React Hook Integration \u00b6 export function useAuth () { const [ user , setUser ] = useState < Parse . User | null > ( null ); const [ loading , setLoading ] = useState ( true ); useEffect (() => { const currentUser = Parse . User . current (); setUser ( currentUser ); setLoading ( false ); }, []); const login = async ( email : string , password : string ) => { const result = await Parse . Cloud . run ( 'loginUser' , { email , password }); if ( result . success ) { setUser ( Parse . User . current ()); } return result ; }; const logout = async () => { await Parse . User . logOut (); setUser ( null ); }; const register = async ( userData : RegisterUserRequest ) => { return await Parse . Cloud . run ( 'registerUser' , userData ); }; return { user , loading , login , logout , register , isAuthenticated : !! user }; } Error Handling \u00b6 Common Errors \u00b6 \"User already exists\" : Email already registered \"Invalid credentials\" : Wrong email/password combination \"Email not verified\" : Account requires email verification \"Too many attempts\" : Rate limiting triggered \"Session expired\" : Authentication session has expired Error Response Format \u00b6 interface ErrorResponse { success : false ; message : string ; code? : string ; details? : any ; } Best Practices \u00b6 Security Guidelines \u00b6 Password Strength : Enforce strong password requirements Rate Limiting : Implement login attempt rate limiting Session Management : Use secure session handling Email Verification : Require email verification for new accounts Development Guidelines \u00b6 Input Validation : Validate all input parameters Error Handling : Provide meaningful error messages Logging : Log authentication events for security monitoring Testing : Comprehensive testing of authentication flows Related Documentation \u00b6 DFNS Integration User Management Guide Security Guide Parse Server Integration Security Considerations \u00b6 Password Storage : Passwords are hashed using bcrypt Session Security : JWT tokens with expiration Rate Limiting : Protection against brute force attacks Email Verification : Required for account activation MFA Support : Optional multi-factor authentication Audit Logging : All authentication events are logged","title":"Auth Functions"},{"location":"cloud-functions/auth-functions/#authentication-functions","text":"The Authentication Functions module provides comprehensive user authentication, registration, and session management capabilities for the Gemforce platform. It handles user lifecycle management, password security, and integration with external authentication providers.","title":"Authentication Functions"},{"location":"cloud-functions/auth-functions/#overview","text":"The Authentication Functions provide: User Registration : Create new user accounts with validation Login/Logout : Secure authentication and session management Password Management : Password reset and change functionality Session Management : JWT token generation and validation Multi-Factor Authentication : Optional MFA support Social Authentication : Integration with external providers","title":"Overview"},{"location":"cloud-functions/auth-functions/#key-features","text":"","title":"Key Features"},{"location":"cloud-functions/auth-functions/#user-management","text":"Registration : Email-based user registration with verification Profile Management : User profile creation and updates Account Verification : Email verification workflows Account Recovery : Password reset and account recovery","title":"User Management"},{"location":"cloud-functions/auth-functions/#authentication-security","text":"Password Hashing : Secure password storage using bcrypt JWT Tokens : Stateless authentication with JSON Web Tokens Session Management : Secure session handling Rate Limiting : Protection against brute force attacks","title":"Authentication Security"},{"location":"cloud-functions/auth-functions/#integration-support","text":"DFNS Integration : Wallet creation during registration Parse Server : User management through Parse Server External Providers : Support for OAuth providers Webhook Integration : Authentication event notifications","title":"Integration Support"},{"location":"cloud-functions/auth-functions/#core-functions","text":"","title":"Core Functions"},{"location":"cloud-functions/auth-functions/#registeruser","text":"Creates a new user account with email verification. Parameters: interface RegisterUserRequest { email : string ; password : string ; username? : string ; firstName? : string ; lastName? : string ; acceptTerms : boolean ; } Returns: interface RegisterUserResponse { success : boolean ; userId? : string ; message : string ; verificationRequired? : boolean ; } Usage: const result = await Parse . Cloud . run ( 'registerUser' , { email : 'user@example.com' , password : 'securePassword123' , username : 'johndoe' , firstName : 'John' , lastName : 'Doe' , acceptTerms : true });","title":"registerUser()"},{"location":"cloud-functions/auth-functions/#loginuser","text":"Authenticates a user and returns session information. Parameters: interface LoginUserRequest { email : string ; password : string ; rememberMe? : boolean ; } Returns: interface LoginUserResponse { success : boolean ; sessionToken? : string ; user ?: { id : string ; email : string ; username : string ; walletAddress? : string ; }; message : string ; } Usage: const result = await Parse . Cloud . run ( 'loginUser' , { email : 'user@example.com' , password : 'securePassword123' , rememberMe : true });","title":"loginUser()"},{"location":"cloud-functions/auth-functions/#resetpassword","text":"Initiates password reset process via email. Parameters: interface ResetPasswordRequest { email : string ; } Returns: interface ResetPasswordResponse { success : boolean ; message : string ; }","title":"resetPassword()"},{"location":"cloud-functions/auth-functions/#changepassword","text":"Changes user password with current password verification. Parameters: interface ChangePasswordRequest { currentPassword : string ; newPassword : string ; } Returns: interface ChangePasswordResponse { success : boolean ; message : string ; }","title":"changePassword()"},{"location":"cloud-functions/auth-functions/#verifyemail","text":"Verifies user email address using verification token. Parameters: interface VerifyEmailRequest { token : string ; email : string ; } Returns: interface VerifyEmailResponse { success : boolean ; message : string ; }","title":"verifyEmail()"},{"location":"cloud-functions/auth-functions/#implementation-example","text":"","title":"Implementation Example"},{"location":"cloud-functions/auth-functions/#user-registration-with-dfns-integration","text":"Parse . Cloud . define ( 'registerUser' , async ( request ) => { const { email , password , username , firstName , lastName , acceptTerms } = request . params ; try { // Validate input if ( ! email || ! password || ! acceptTerms ) { throw new Error ( 'Missing required fields' ); } // Check if user already exists const existingUser = await new Parse . Query ( Parse . User ) . equalTo ( 'email' , email . toLowerCase ()) . first ({ useMasterKey : true }); if ( existingUser ) { throw new Error ( 'User already exists' ); } // Create new user const user = new Parse . User (); user . set ( 'email' , email . toLowerCase ()); user . set ( 'username' , username || email . toLowerCase ()); user . set ( 'password' , password ); user . set ( 'firstName' , firstName ); user . set ( 'lastName' , lastName ); user . set ( 'emailVerified' , false ); user . set ( 'acceptedTerms' , acceptTerms ); user . set ( 'acceptedTermsDate' , new Date ()); // Save user await user . signUp (); // Create DFNS wallet try { const walletResult = await Parse . Cloud . run ( 'createUserWallet' , { userId : user.id , email : email.toLowerCase () }); if ( walletResult . success ) { user . set ( 'walletAddress' , walletResult . walletAddress ); user . set ( 'dfnsWalletId' , walletResult . walletId ); await user . save ( null , { useMasterKey : true }); } } catch ( walletError ) { console . error ( 'Wallet creation failed:' , walletError ); // Continue with registration even if wallet creation fails } // Send verification email await sendVerificationEmail ( user ); return { success : true , userId : user.id , message : 'Registration successful. Please check your email for verification.' , verificationRequired : true }; } catch ( error ) { console . error ( 'Registration error:' , error ); return { success : false , message : error.message || 'Registration failed' }; } });","title":"User Registration with DFNS Integration"},{"location":"cloud-functions/auth-functions/#secure-login-with-rate-limiting","text":"Parse . Cloud . define ( 'loginUser' , async ( request ) => { const { email , password , rememberMe } = request . params ; try { // Rate limiting check const rateLimitKey = `login_attempts_ ${ email . toLowerCase () } ` ; const attempts = await getFromCache ( rateLimitKey ) || 0 ; if ( attempts >= 5 ) { throw new Error ( 'Too many login attempts. Please try again later.' ); } // Attempt login const user = await Parse . User . logIn ( email . toLowerCase (), password ); // Clear rate limiting on successful login await clearFromCache ( rateLimitKey ); // Check if email is verified if ( ! user . get ( 'emailVerified' )) { await Parse . User . logOut (); throw new Error ( 'Please verify your email before logging in' ); } // Update last login user . set ( 'lastLogin' , new Date ()); user . set ( 'loginCount' , ( user . get ( 'loginCount' ) || 0 ) + 1 ); await user . save ( null , { useMasterKey : true }); // Generate session token const sessionToken = user . getSessionToken (); return { success : true , sessionToken , user : { id : user.id , email : user.get ( 'email' ), username : user.get ( 'username' ), walletAddress : user.get ( 'walletAddress' ) }, message : 'Login successful' }; } catch ( error ) { // Increment rate limiting counter const rateLimitKey = `login_attempts_ ${ email . toLowerCase () } ` ; const attempts = await getFromCache ( rateLimitKey ) || 0 ; await setInCache ( rateLimitKey , attempts + 1 , 900 ); // 15 minutes console . error ( 'Login error:' , error ); return { success : false , message : error.message || 'Login failed' }; } });","title":"Secure Login with Rate Limiting"},{"location":"cloud-functions/auth-functions/#password-reset-with-email","text":"Parse . Cloud . define ( 'resetPassword' , async ( request ) => { const { email } = request . params ; try { // Find user const user = await new Parse . Query ( Parse . User ) . equalTo ( 'email' , email . toLowerCase ()) . first ({ useMasterKey : true }); if ( ! user ) { // Don't reveal if user exists or not return { success : true , message : 'If an account with that email exists, a reset link has been sent.' }; } // Generate reset token const resetToken = generateSecureToken (); const resetExpiry = new Date ( Date . now () + 3600000 ); // 1 hour user . set ( 'passwordResetToken' , resetToken ); user . set ( 'passwordResetExpiry' , resetExpiry ); await user . save ( null , { useMasterKey : true }); // Send reset email await sendPasswordResetEmail ( user , resetToken ); return { success : true , message : 'If an account with that email exists, a reset link has been sent.' }; } catch ( error ) { console . error ( 'Password reset error:' , error ); return { success : false , message : 'Password reset failed' }; } });","title":"Password Reset with Email"},{"location":"cloud-functions/auth-functions/#security-features","text":"","title":"Security Features"},{"location":"cloud-functions/auth-functions/#password-security","text":"// Password validation function validatePassword ( password : string ) : { valid : boolean ; message? : string } { if ( password . length < 8 ) { return { valid : false , message : 'Password must be at least 8 characters long' }; } if ( ! /(?=.*[a-z])/ . test ( password )) { return { valid : false , message : 'Password must contain at least one lowercase letter' }; } if ( ! /(?=.*[A-Z])/ . test ( password )) { return { valid : false , message : 'Password must contain at least one uppercase letter' }; } if ( ! /(?=.*\\d)/ . test ( password )) { return { valid : false , message : 'Password must contain at least one number' }; } if ( ! /(?=.*[@$!%*?&])/ . test ( password )) { return { valid : false , message : 'Password must contain at least one special character' }; } return { valid : true }; }","title":"Password Security"},{"location":"cloud-functions/auth-functions/#session-management","text":"Parse . Cloud . define ( 'validateSession' , async ( request ) => { try { const user = request . user ; if ( ! user ) { throw new Error ( 'Invalid session' ); } // Check if session is still valid const sessionQuery = new Parse . Query ( Parse . Session ); sessionQuery . equalTo ( 'user' , user ); sessionQuery . equalTo ( 'sessionToken' , request . headers [ 'x-parse-session-token' ]); const session = await sessionQuery . first ({ useMasterKey : true }); if ( ! session ) { throw new Error ( 'Session not found' ); } // Check session expiry const expiresAt = session . get ( 'expiresAt' ); if ( expiresAt && new Date () > expiresAt ) { await session . destroy ({ useMasterKey : true }); throw new Error ( 'Session expired' ); } return { success : true , user : { id : user.id , email : user.get ( 'email' ), username : user.get ( 'username' ) } }; } catch ( error ) { return { success : false , message : error.message }; } });","title":"Session Management"},{"location":"cloud-functions/auth-functions/#multi-factor-authentication","text":"Parse . Cloud . define ( 'enableMFA' , async ( request ) => { const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Generate TOTP secret const secret = generateTOTPSecret (); // Store secret (encrypted) user . set ( 'mfaSecret' , encryptSecret ( secret )); user . set ( 'mfaEnabled' , false ); // Will be enabled after verification await user . save ( null , { useMasterKey : true }); // Generate QR code for authenticator app const qrCode = generateQRCode ( user . get ( 'email' ), secret ); return { success : true , secret , qrCode , message : 'Scan the QR code with your authenticator app' }; } catch ( error ) { console . error ( 'MFA setup error:' , error ); throw new Error ( 'Failed to setup MFA' ); } });","title":"Multi-Factor Authentication"},{"location":"cloud-functions/auth-functions/#integration-patterns","text":"","title":"Integration Patterns"},{"location":"cloud-functions/auth-functions/#frontend-integration","text":"class AuthService { async register ( userData : RegisterUserRequest ) : Promise < RegisterUserResponse > { return await Parse . Cloud . run ( 'registerUser' , userData ); } async login ( credentials : LoginUserRequest ) : Promise < LoginUserResponse > { return await Parse . Cloud . run ( 'loginUser' , credentials ); } async logout () : Promise < void > { await Parse . User . logOut (); } async resetPassword ( email : string ) : Promise < ResetPasswordResponse > { return await Parse . Cloud . run ( 'resetPassword' , { email }); } async changePassword ( passwords : ChangePasswordRequest ) : Promise < ChangePasswordResponse > { return await Parse . Cloud . run ( 'changePassword' , passwords ); } getCurrentUser () : Parse . User | null { return Parse . User . current (); } isAuthenticated () : boolean { return Parse . User . current () !== null ; } }","title":"Frontend Integration"},{"location":"cloud-functions/auth-functions/#react-hook-integration","text":"export function useAuth () { const [ user , setUser ] = useState < Parse . User | null > ( null ); const [ loading , setLoading ] = useState ( true ); useEffect (() => { const currentUser = Parse . User . current (); setUser ( currentUser ); setLoading ( false ); }, []); const login = async ( email : string , password : string ) => { const result = await Parse . Cloud . run ( 'loginUser' , { email , password }); if ( result . success ) { setUser ( Parse . User . current ()); } return result ; }; const logout = async () => { await Parse . User . logOut (); setUser ( null ); }; const register = async ( userData : RegisterUserRequest ) => { return await Parse . Cloud . run ( 'registerUser' , userData ); }; return { user , loading , login , logout , register , isAuthenticated : !! user }; }","title":"React Hook Integration"},{"location":"cloud-functions/auth-functions/#error-handling","text":"","title":"Error Handling"},{"location":"cloud-functions/auth-functions/#common-errors","text":"\"User already exists\" : Email already registered \"Invalid credentials\" : Wrong email/password combination \"Email not verified\" : Account requires email verification \"Too many attempts\" : Rate limiting triggered \"Session expired\" : Authentication session has expired","title":"Common Errors"},{"location":"cloud-functions/auth-functions/#error-response-format","text":"interface ErrorResponse { success : false ; message : string ; code? : string ; details? : any ; }","title":"Error Response Format"},{"location":"cloud-functions/auth-functions/#best-practices","text":"","title":"Best Practices"},{"location":"cloud-functions/auth-functions/#security-guidelines","text":"Password Strength : Enforce strong password requirements Rate Limiting : Implement login attempt rate limiting Session Management : Use secure session handling Email Verification : Require email verification for new accounts","title":"Security Guidelines"},{"location":"cloud-functions/auth-functions/#development-guidelines","text":"Input Validation : Validate all input parameters Error Handling : Provide meaningful error messages Logging : Log authentication events for security monitoring Testing : Comprehensive testing of authentication flows","title":"Development Guidelines"},{"location":"cloud-functions/auth-functions/#related-documentation","text":"DFNS Integration User Management Guide Security Guide Parse Server Integration","title":"Related Documentation"},{"location":"cloud-functions/auth-functions/#security-considerations","text":"Password Storage : Passwords are hashed using bcrypt Session Security : JWT tokens with expiration Rate Limiting : Protection against brute force attacks Email Verification : Required for account activation MFA Support : Optional multi-factor authentication Audit Logging : All authentication events are logged","title":"Security Considerations"},{"location":"cloud-functions/authentication/","text":"Authentication Cloud Functions \u00b6 Overview \u00b6 The authFunctions.ts module provides comprehensive user authentication and account management functionality for the Gemforce platform. This module handles user registration, email verification, password management, and administrative functions through Parse Server cloud functions. Module Details \u00b6 File : src/cloud-functions/authFunctions.ts Framework : Parse Server Cloud Functions Language : TypeScript Dependencies : crypto, ejs, jsonwebtoken, @sendgrid/mail Key Features \u00b6 \ud83d\udd39 User Registration & Verification \u00b6 Secure user registration with email verification Duplicate email prevention Role-based access control setup Automated verification email sending \ud83d\udd39 Password Management \u00b6 Password reset request and processing Secure token-based password reset Email notifications for password changes Admin UI password setup \ud83d\udd39 User Account Management \u00b6 User profile updates with field validation Onboarding status tracking Wallet and identity integration Administrative user management \ud83d\udd39 Email Integration \u00b6 SendGrid email service integration EJS template-based email rendering Multiple email types (verification, reset, success) Professional email templates Cloud Functions \u00b6 User Registration Functions \u00b6 registerUser \u00b6 Parse . Cloud . define ( \"registerUser\" , async ( request ) => { const { username , password , email , company , firstName , lastName } = request . params ; // Implementation details... }); Purpose : Registers a new user account with email verification. Parameters : - username (string): Unique username for the account - password (string): User's password - email (string): User's email address - company (string, optional): User's company name - firstName (string, optional): User's first name - lastName (string, optional): User's last name Returns : Success message with verification instructions Process : 1. Validates required fields (username, password, email) 2. Checks for existing users with the same email 3. Creates new Parse User with provided information 4. Sets up role-based ACL (user + admin access) 5. Generates secure verification token (24-hour expiry) 6. Sends verification email via SendGrid 7. Returns success response Access Control : - User gets read/write access to their own data - Admin role gets read/write access to user data Example Usage : const result = await Parse . Cloud . run ( \"registerUser\" , { username : \"john.doe\" , password : \"SecurePassword123!\" , email : \"john.doe@example.com\" , company : \"Acme Corp\" , firstName : \"John\" , lastName : \"Doe\" }); console . log ( result . message ); // \"User registered successfully. Please verify your email.\" Error Conditions : - Missing required fields - Email already exists - Admin role not found - Email sending failure verifyEmail \u00b6 Parse . Cloud . define ( \"verifyEmail\" , async ( request ) => { const { token } = request . params ; // Implementation details... }); Purpose : Verifies user email address using verification token. Parameters : - token (string): Email verification token Returns : Success message confirming email verification Process : 1. Validates token parameter 2. Finds user associated with the token 3. Checks token expiration (24-hour limit) 4. Sets emailVerified flag to true 5. Removes verification token and expiration 6. Saves user with verified status Example Usage : const result = await Parse . Cloud . run ( \"verifyEmail\" , { token : \"abc123def456...\" }); console . log ( result . message ); // \"Email verified successfully.\" Error Conditions : - Missing token - Invalid or expired token - Token expiration exceeded retrieveEmailFromToken \u00b6 Parse . Cloud . define ( \"retrieveEmailFromToken\" , async ( request ) => { const { token } = request . params ; // Implementation details... }); Purpose : Retrieves email address associated with a verification token. Parameters : - token (string): Verification token Returns : Email address associated with the token Example Usage : const result = await Parse . Cloud . run ( \"retrieveEmailFromToken\" , { token : \"abc123def456...\" }); console . log ( result . email ); // \"john.doe@example.com\" Password Management Functions \u00b6 requestPasswordReset \u00b6 Parse . Cloud . define ( \"requestPasswordReset\" , async ( request ) => { const { email } = request . params ; // Implementation details... }); Purpose : Initiates password reset process by sending reset email. Parameters : - email (string): Email address of the account to reset Returns : Success message confirming reset email sent Process : 1. Validates email parameter 2. Finds user by email address 3. Generates secure reset token (1-hour expiry) 4. Saves token and expiration to user account 5. Sends password reset email with reset link 6. Returns success confirmation Example Usage : const result = await Parse . Cloud . run ( \"requestPasswordReset\" , { email : \"john.doe@example.com\" }); console . log ( result . message ); // \"Password reset email sent successfully.\" Error Conditions : - Missing email parameter - No user found with email - Email sending failure resetPassword \u00b6 Parse . Cloud . define ( \"resetPassword\" , async ( request ) => { const { token , newPassword , skipEmail = false } = request . params ; // Implementation details... }); Purpose : Completes password reset using reset token and new password. Parameters : - token (string): Password reset token - newPassword (string): New password for the account - skipEmail (boolean, optional): Skip sending success email Returns : Success message confirming password update Process : 1. Validates token and new password 2. Finds user with valid, non-expired token 3. Updates user password 4. Clears reset token and expiration 5. Optionally sends success confirmation email 6. Returns success response Example Usage : const result = await Parse . Cloud . run ( \"resetPassword\" , { token : \"reset123token456...\" , newPassword : \"NewSecurePassword123!\" , skipEmail : false }); console . log ( result . message ); // \"Password updated successfully. A confirmation email has been sent.\" Error Conditions : - Missing token or new password - Invalid or expired token - Password update failure User Management Functions \u00b6 updateUserByEmail \u00b6 Parse . Cloud . define ( \"updateUserByEmail\" , async ( request ) => { const { email , updates , secretKey } = request . params ; // Implementation details... }); Purpose : Updates user account information using email and secret key authentication. Parameters : - email (string): Email address of user to update - updates (object): Object containing fields to update - secretKey (string): Pre-shared secret key for authorization Allowed Update Fields : - termsAccepted (Date): Terms acceptance timestamp - email (string): Email address - walletAddress (string): Blockchain wallet address - walletId (string): Wallet identifier - walletPreference (string): Preferred wallet type - personaReferenceId (string): Persona verification ID - username (string): Username Returns : Success message with updated user data Security : Requires valid secret key matching AUTH_SECRET_KEY environment variable Example Usage : const result = await Parse . Cloud . run ( \"updateUserByEmail\" , { email : \"john.doe@example.com\" , updates : { walletAddress : \"0x1234567890123456789012345678901234567890\" , termsAccepted : new Date (). toISOString () }, secretKey : process . env . AUTH_SECRET_KEY }); console . log ( result . message ); // \"User updated successfully.\" Error Conditions : - Unauthorized secret key - Missing email or updates - User not found - Invalid field updates - Invalid date format for termsAccepted isUserOnboarded \u00b6 Parse . Cloud . define ( \"isUserOnboarded\" , async ( request ) => { const { email } = request . params ; // Implementation details... }); Purpose : Checks if user has completed onboarding process. Parameters : - email (string): Email address to check Returns : Boolean indicating onboarding completion status Onboarding Criteria : User is considered onboarded if they have both: - walletAddress set (not null/undefined) - personaReferenceId set (not null/undefined) Example Usage : const result = await Parse . Cloud . run ( \"isUserOnboarded\" , { email : \"john.doe@example.com\" }); console . log ( result . result ); // true if onboarded, false otherwise getUsersWithIdentityWallets \u00b6 Parse . Cloud . define ( \"getUsersWithIdentityWallets\" , async ( request ) => { // Implementation details... }); Purpose : Retrieves users who have wallet addresses matching Identity table records. Returns : Array of user objects with wallet addresses and emails Process : 1. Queries Identity table for all wallet addresses 2. Queries User table for users with matching wallet addresses 3. Returns filtered list with wallet address and email Example Usage : const users = await Parse . Cloud . run ( \"getUsersWithIdentityWallets\" ); users . forEach ( user => { console . log ( `User: ${ user . email } , Wallet: ${ user . walletAddress } ` ); }); Administrative Functions \u00b6 setupAdminUIPassword \u00b6 Parse . Cloud . define ( \"setupAdminUIPassword\" , async ( request ) => { const { email } = request . params ; // Implementation details... }); Purpose : Initiates admin UI password setup for existing users. Parameters : - email (string): Email address of admin user Returns : Success message confirming setup email sent Process : 1. Finds user by email address 2. Generates secure setup token (1-hour expiry) 3. Saves token to user account 4. Sends admin UI password setup email 5. Returns success confirmation Example Usage : const result = await Parse . Cloud . run ( \"setupAdminUIPassword\" , { email : \"admin@example.com\" }); console . log ( result . message ); // \"Setup Admin UI password email sent successfully.\" generateOnboardingLink \u00b6 Parse . Cloud . define ( \"generateOnboardingLink\" , async ( request ) => { const { jwtToken } = request . params ; // Implementation details... }); Purpose : Creates user account and generates onboarding link from JWT token. Parameters : - jwtToken (string): JWT token containing user information JWT Payload Structure : { email : string ; firstName : string ; lastName : string ; } Returns : Onboarding link for email verification Process : 1. Verifies JWT token with secret key 2. Extracts user information from token 3. Checks for existing user with same email 4. Creates new user account with default password 5. Sets up ACL permissions 6. Generates verification token 7. Returns onboarding link Example Usage : const payload = { email : \"newuser@example.com\" , firstName : \"New\" , lastName : \"User\" }; const jwtToken = jwt . sign ( payload , secretKey , { expiresIn : '1h' }); const result = await Parse . Cloud . run ( \"generateOnboardingLink\" , { jwtToken : jwtToken }); console . log ( result . result ); // \"https://app.example.com/verify-email/abc123...\" Email Templates and Integration \u00b6 SendGrid Configuration \u00b6 The module uses SendGrid for email delivery with the following configuration: - Sender : NomyxID.Registrations@nomyx.io - Templates : EJS-based HTML templates - Template Location : src/utils/emailTemplate/ Email Types \u00b6 Verification Email \u00b6 Template : verifyEmailTemplate.ejs Purpose : Email address verification Link : ${PROJECT_WIZARD_URL}/verify-email/${token} Password Reset Email \u00b6 Template : resetPasswordTemplate.ejs Purpose : Password reset request Link : ${PROJECT_WIZARD_URL}/reset-password/${token} Password Reset Success Email \u00b6 Template : resetPasswordSuccessTemplate.ejs Purpose : Password reset confirmation Content : Success notification Admin UI Password Setup Email \u00b6 Template : createPasswordTemplate.ejs Purpose : Admin UI password setup Link : ${ADMIN_UI_URL}/create-password/${token} Integration Examples \u00b6 User Registration Flow \u00b6 // Complete user registration and verification flow class UserRegistrationService { async registerNewUser ( userData ) { try { // Step 1: Register user const registrationResult = await Parse . Cloud . run ( \"registerUser\" , { username : userData . username , password : userData . password , email : userData . email , company : userData . company , firstName : userData . firstName , lastName : userData . lastName }); console . log ( \"Registration successful:\" , registrationResult . message ); // Step 2: User receives email and clicks verification link // This would be handled by frontend calling verifyEmail return { success : true , message : \"Registration initiated. Please check email for verification.\" }; } catch ( error ) { console . error ( \"Registration failed:\" , error . message ); throw error ; } } async verifyUserEmail ( token ) { try { const result = await Parse . Cloud . run ( \"verifyEmail\" , { token }); console . log ( \"Email verified:\" , result . message ); return result ; } catch ( error ) { console . error ( \"Verification failed:\" , error . message ); throw error ; } } } Password Reset Flow \u00b6 // Complete password reset workflow class PasswordResetService { async initiatePasswordReset ( email ) { try { const result = await Parse . Cloud . run ( \"requestPasswordReset\" , { email }); console . log ( \"Reset email sent:\" , result . message ); return result ; } catch ( error ) { console . error ( \"Reset request failed:\" , error . message ); throw error ; } } async completePasswordReset ( token , newPassword ) { try { const result = await Parse . Cloud . run ( \"resetPassword\" , { token , newPassword , skipEmail : false }); console . log ( \"Password reset successful:\" , result . message ); return result ; } catch ( error ) { console . error ( \"Password reset failed:\" , error . message ); throw error ; } } } User Onboarding Integration \u00b6 // User onboarding with wallet and identity integration class OnboardingService { async checkOnboardingStatus ( email ) { const result = await Parse . Cloud . run ( \"isUserOnboarded\" , { email }); return result . result ; } async completeOnboarding ( email , walletAddress , personaId ) { try { const result = await Parse . Cloud . run ( \"updateUserByEmail\" , { email , updates : { walletAddress , personaReferenceId : personaId , termsAccepted : new Date (). toISOString () }, secretKey : process . env . AUTH_SECRET_KEY }); console . log ( \"Onboarding completed:\" , result . message ); return result ; } catch ( error ) { console . error ( \"Onboarding failed:\" , error . message ); throw error ; } } } Admin User Management \u00b6 // Administrative user management functions class AdminUserService { async setupAdminPassword ( email ) { try { const result = await Parse . Cloud . run ( \"setupAdminUIPassword\" , { email }); console . log ( \"Admin setup initiated:\" , result . message ); return result ; } catch ( error ) { console . error ( \"Admin setup failed:\" , error . message ); throw error ; } } async getIdentityUsers () { try { const users = await Parse . Cloud . run ( \"getUsersWithIdentityWallets\" ); console . log ( `Found ${ users . length } users with identity wallets` ); return users ; } catch ( error ) { console . error ( \"Failed to get identity users:\" , error . message ); throw error ; } } } Security Considerations \u00b6 Token Security \u00b6 Cryptographically secure token generation using crypto.randomBytes(32) Time-limited tokens (24 hours for verification, 1 hour for password reset) Tokens are single-use and cleared after successful operations Access Control \u00b6 Role-based ACL system with user and admin permissions Secret key authentication for sensitive operations Email-based user identification and validation Data Protection \u00b6 Password hashing handled by Parse Server Sensitive operations require email verification Field validation for user updates Email Security \u00b6 Professional email templates to prevent phishing Secure token-based links Clear expiration times for all tokens Error Handling \u00b6 Validation Errors \u00b6 Missing required fields validation Email format validation Token expiration checking User Errors \u00b6 Duplicate email registration prevention Invalid token handling User not found scenarios System Errors \u00b6 Email sending failure handling Database operation error handling JWT token verification errors Testing Considerations \u00b6 Unit Tests \u00b6 Individual function testing Parameter validation testing Error condition handling Token generation and validation Integration Tests \u00b6 Complete registration flow Password reset workflow Email delivery testing ACL permission verification Security Tests \u00b6 Token security validation Access control testing Email template security Secret key validation Related Documentation \u00b6 Blockchain Cloud Functions - Network integration DFNS Cloud Functions - Wallet integration Contract Cloud Functions - Smart contract integration User Management Guide - Implementation guide Security Guide - Security best practices These authentication functions provide the foundation for secure user management within the Gemforce platform, supporting complete user lifecycle management from registration through onboarding and ongoing account management.","title":"Authentication Functions"},{"location":"cloud-functions/authentication/#authentication-cloud-functions","text":"","title":"Authentication Cloud Functions"},{"location":"cloud-functions/authentication/#overview","text":"The authFunctions.ts module provides comprehensive user authentication and account management functionality for the Gemforce platform. This module handles user registration, email verification, password management, and administrative functions through Parse Server cloud functions.","title":"Overview"},{"location":"cloud-functions/authentication/#module-details","text":"File : src/cloud-functions/authFunctions.ts Framework : Parse Server Cloud Functions Language : TypeScript Dependencies : crypto, ejs, jsonwebtoken, @sendgrid/mail","title":"Module Details"},{"location":"cloud-functions/authentication/#key-features","text":"","title":"Key Features"},{"location":"cloud-functions/authentication/#user-registration-verification","text":"Secure user registration with email verification Duplicate email prevention Role-based access control setup Automated verification email sending","title":"\ud83d\udd39 User Registration &amp; Verification"},{"location":"cloud-functions/authentication/#password-management","text":"Password reset request and processing Secure token-based password reset Email notifications for password changes Admin UI password setup","title":"\ud83d\udd39 Password Management"},{"location":"cloud-functions/authentication/#user-account-management","text":"User profile updates with field validation Onboarding status tracking Wallet and identity integration Administrative user management","title":"\ud83d\udd39 User Account Management"},{"location":"cloud-functions/authentication/#email-integration","text":"SendGrid email service integration EJS template-based email rendering Multiple email types (verification, reset, success) Professional email templates","title":"\ud83d\udd39 Email Integration"},{"location":"cloud-functions/authentication/#cloud-functions","text":"","title":"Cloud Functions"},{"location":"cloud-functions/authentication/#user-registration-functions","text":"","title":"User Registration Functions"},{"location":"cloud-functions/authentication/#registeruser","text":"Parse . Cloud . define ( \"registerUser\" , async ( request ) => { const { username , password , email , company , firstName , lastName } = request . params ; // Implementation details... }); Purpose : Registers a new user account with email verification. Parameters : - username (string): Unique username for the account - password (string): User's password - email (string): User's email address - company (string, optional): User's company name - firstName (string, optional): User's first name - lastName (string, optional): User's last name Returns : Success message with verification instructions Process : 1. Validates required fields (username, password, email) 2. Checks for existing users with the same email 3. Creates new Parse User with provided information 4. Sets up role-based ACL (user + admin access) 5. Generates secure verification token (24-hour expiry) 6. Sends verification email via SendGrid 7. Returns success response Access Control : - User gets read/write access to their own data - Admin role gets read/write access to user data Example Usage : const result = await Parse . Cloud . run ( \"registerUser\" , { username : \"john.doe\" , password : \"SecurePassword123!\" , email : \"john.doe@example.com\" , company : \"Acme Corp\" , firstName : \"John\" , lastName : \"Doe\" }); console . log ( result . message ); // \"User registered successfully. Please verify your email.\" Error Conditions : - Missing required fields - Email already exists - Admin role not found - Email sending failure","title":"registerUser"},{"location":"cloud-functions/authentication/#verifyemail","text":"Parse . Cloud . define ( \"verifyEmail\" , async ( request ) => { const { token } = request . params ; // Implementation details... }); Purpose : Verifies user email address using verification token. Parameters : - token (string): Email verification token Returns : Success message confirming email verification Process : 1. Validates token parameter 2. Finds user associated with the token 3. Checks token expiration (24-hour limit) 4. Sets emailVerified flag to true 5. Removes verification token and expiration 6. Saves user with verified status Example Usage : const result = await Parse . Cloud . run ( \"verifyEmail\" , { token : \"abc123def456...\" }); console . log ( result . message ); // \"Email verified successfully.\" Error Conditions : - Missing token - Invalid or expired token - Token expiration exceeded","title":"verifyEmail"},{"location":"cloud-functions/authentication/#retrieveemailfromtoken","text":"Parse . Cloud . define ( \"retrieveEmailFromToken\" , async ( request ) => { const { token } = request . params ; // Implementation details... }); Purpose : Retrieves email address associated with a verification token. Parameters : - token (string): Verification token Returns : Email address associated with the token Example Usage : const result = await Parse . Cloud . run ( \"retrieveEmailFromToken\" , { token : \"abc123def456...\" }); console . log ( result . email ); // \"john.doe@example.com\"","title":"retrieveEmailFromToken"},{"location":"cloud-functions/authentication/#password-management-functions","text":"","title":"Password Management Functions"},{"location":"cloud-functions/authentication/#requestpasswordreset","text":"Parse . Cloud . define ( \"requestPasswordReset\" , async ( request ) => { const { email } = request . params ; // Implementation details... }); Purpose : Initiates password reset process by sending reset email. Parameters : - email (string): Email address of the account to reset Returns : Success message confirming reset email sent Process : 1. Validates email parameter 2. Finds user by email address 3. Generates secure reset token (1-hour expiry) 4. Saves token and expiration to user account 5. Sends password reset email with reset link 6. Returns success confirmation Example Usage : const result = await Parse . Cloud . run ( \"requestPasswordReset\" , { email : \"john.doe@example.com\" }); console . log ( result . message ); // \"Password reset email sent successfully.\" Error Conditions : - Missing email parameter - No user found with email - Email sending failure","title":"requestPasswordReset"},{"location":"cloud-functions/authentication/#resetpassword","text":"Parse . Cloud . define ( \"resetPassword\" , async ( request ) => { const { token , newPassword , skipEmail = false } = request . params ; // Implementation details... }); Purpose : Completes password reset using reset token and new password. Parameters : - token (string): Password reset token - newPassword (string): New password for the account - skipEmail (boolean, optional): Skip sending success email Returns : Success message confirming password update Process : 1. Validates token and new password 2. Finds user with valid, non-expired token 3. Updates user password 4. Clears reset token and expiration 5. Optionally sends success confirmation email 6. Returns success response Example Usage : const result = await Parse . Cloud . run ( \"resetPassword\" , { token : \"reset123token456...\" , newPassword : \"NewSecurePassword123!\" , skipEmail : false }); console . log ( result . message ); // \"Password updated successfully. A confirmation email has been sent.\" Error Conditions : - Missing token or new password - Invalid or expired token - Password update failure","title":"resetPassword"},{"location":"cloud-functions/authentication/#user-management-functions","text":"","title":"User Management Functions"},{"location":"cloud-functions/authentication/#updateuserbyemail","text":"Parse . Cloud . define ( \"updateUserByEmail\" , async ( request ) => { const { email , updates , secretKey } = request . params ; // Implementation details... }); Purpose : Updates user account information using email and secret key authentication. Parameters : - email (string): Email address of user to update - updates (object): Object containing fields to update - secretKey (string): Pre-shared secret key for authorization Allowed Update Fields : - termsAccepted (Date): Terms acceptance timestamp - email (string): Email address - walletAddress (string): Blockchain wallet address - walletId (string): Wallet identifier - walletPreference (string): Preferred wallet type - personaReferenceId (string): Persona verification ID - username (string): Username Returns : Success message with updated user data Security : Requires valid secret key matching AUTH_SECRET_KEY environment variable Example Usage : const result = await Parse . Cloud . run ( \"updateUserByEmail\" , { email : \"john.doe@example.com\" , updates : { walletAddress : \"0x1234567890123456789012345678901234567890\" , termsAccepted : new Date (). toISOString () }, secretKey : process . env . AUTH_SECRET_KEY }); console . log ( result . message ); // \"User updated successfully.\" Error Conditions : - Unauthorized secret key - Missing email or updates - User not found - Invalid field updates - Invalid date format for termsAccepted","title":"updateUserByEmail"},{"location":"cloud-functions/authentication/#isuseronboarded","text":"Parse . Cloud . define ( \"isUserOnboarded\" , async ( request ) => { const { email } = request . params ; // Implementation details... }); Purpose : Checks if user has completed onboarding process. Parameters : - email (string): Email address to check Returns : Boolean indicating onboarding completion status Onboarding Criteria : User is considered onboarded if they have both: - walletAddress set (not null/undefined) - personaReferenceId set (not null/undefined) Example Usage : const result = await Parse . Cloud . run ( \"isUserOnboarded\" , { email : \"john.doe@example.com\" }); console . log ( result . result ); // true if onboarded, false otherwise","title":"isUserOnboarded"},{"location":"cloud-functions/authentication/#getuserswithidentitywallets","text":"Parse . Cloud . define ( \"getUsersWithIdentityWallets\" , async ( request ) => { // Implementation details... }); Purpose : Retrieves users who have wallet addresses matching Identity table records. Returns : Array of user objects with wallet addresses and emails Process : 1. Queries Identity table for all wallet addresses 2. Queries User table for users with matching wallet addresses 3. Returns filtered list with wallet address and email Example Usage : const users = await Parse . Cloud . run ( \"getUsersWithIdentityWallets\" ); users . forEach ( user => { console . log ( `User: ${ user . email } , Wallet: ${ user . walletAddress } ` ); });","title":"getUsersWithIdentityWallets"},{"location":"cloud-functions/authentication/#administrative-functions","text":"","title":"Administrative Functions"},{"location":"cloud-functions/authentication/#setupadminuipassword","text":"Parse . Cloud . define ( \"setupAdminUIPassword\" , async ( request ) => { const { email } = request . params ; // Implementation details... }); Purpose : Initiates admin UI password setup for existing users. Parameters : - email (string): Email address of admin user Returns : Success message confirming setup email sent Process : 1. Finds user by email address 2. Generates secure setup token (1-hour expiry) 3. Saves token to user account 4. Sends admin UI password setup email 5. Returns success confirmation Example Usage : const result = await Parse . Cloud . run ( \"setupAdminUIPassword\" , { email : \"admin@example.com\" }); console . log ( result . message ); // \"Setup Admin UI password email sent successfully.\"","title":"setupAdminUIPassword"},{"location":"cloud-functions/authentication/#generateonboardinglink","text":"Parse . Cloud . define ( \"generateOnboardingLink\" , async ( request ) => { const { jwtToken } = request . params ; // Implementation details... }); Purpose : Creates user account and generates onboarding link from JWT token. Parameters : - jwtToken (string): JWT token containing user information JWT Payload Structure : { email : string ; firstName : string ; lastName : string ; } Returns : Onboarding link for email verification Process : 1. Verifies JWT token with secret key 2. Extracts user information from token 3. Checks for existing user with same email 4. Creates new user account with default password 5. Sets up ACL permissions 6. Generates verification token 7. Returns onboarding link Example Usage : const payload = { email : \"newuser@example.com\" , firstName : \"New\" , lastName : \"User\" }; const jwtToken = jwt . sign ( payload , secretKey , { expiresIn : '1h' }); const result = await Parse . Cloud . run ( \"generateOnboardingLink\" , { jwtToken : jwtToken }); console . log ( result . result ); // \"https://app.example.com/verify-email/abc123...\"","title":"generateOnboardingLink"},{"location":"cloud-functions/authentication/#email-templates-and-integration","text":"","title":"Email Templates and Integration"},{"location":"cloud-functions/authentication/#sendgrid-configuration","text":"The module uses SendGrid for email delivery with the following configuration: - Sender : NomyxID.Registrations@nomyx.io - Templates : EJS-based HTML templates - Template Location : src/utils/emailTemplate/","title":"SendGrid Configuration"},{"location":"cloud-functions/authentication/#email-types","text":"","title":"Email Types"},{"location":"cloud-functions/authentication/#verification-email","text":"Template : verifyEmailTemplate.ejs Purpose : Email address verification Link : ${PROJECT_WIZARD_URL}/verify-email/${token}","title":"Verification Email"},{"location":"cloud-functions/authentication/#password-reset-email","text":"Template : resetPasswordTemplate.ejs Purpose : Password reset request Link : ${PROJECT_WIZARD_URL}/reset-password/${token}","title":"Password Reset Email"},{"location":"cloud-functions/authentication/#password-reset-success-email","text":"Template : resetPasswordSuccessTemplate.ejs Purpose : Password reset confirmation Content : Success notification","title":"Password Reset Success Email"},{"location":"cloud-functions/authentication/#admin-ui-password-setup-email","text":"Template : createPasswordTemplate.ejs Purpose : Admin UI password setup Link : ${ADMIN_UI_URL}/create-password/${token}","title":"Admin UI Password Setup Email"},{"location":"cloud-functions/authentication/#integration-examples","text":"","title":"Integration Examples"},{"location":"cloud-functions/authentication/#user-registration-flow","text":"// Complete user registration and verification flow class UserRegistrationService { async registerNewUser ( userData ) { try { // Step 1: Register user const registrationResult = await Parse . Cloud . run ( \"registerUser\" , { username : userData . username , password : userData . password , email : userData . email , company : userData . company , firstName : userData . firstName , lastName : userData . lastName }); console . log ( \"Registration successful:\" , registrationResult . message ); // Step 2: User receives email and clicks verification link // This would be handled by frontend calling verifyEmail return { success : true , message : \"Registration initiated. Please check email for verification.\" }; } catch ( error ) { console . error ( \"Registration failed:\" , error . message ); throw error ; } } async verifyUserEmail ( token ) { try { const result = await Parse . Cloud . run ( \"verifyEmail\" , { token }); console . log ( \"Email verified:\" , result . message ); return result ; } catch ( error ) { console . error ( \"Verification failed:\" , error . message ); throw error ; } } }","title":"User Registration Flow"},{"location":"cloud-functions/authentication/#password-reset-flow","text":"// Complete password reset workflow class PasswordResetService { async initiatePasswordReset ( email ) { try { const result = await Parse . Cloud . run ( \"requestPasswordReset\" , { email }); console . log ( \"Reset email sent:\" , result . message ); return result ; } catch ( error ) { console . error ( \"Reset request failed:\" , error . message ); throw error ; } } async completePasswordReset ( token , newPassword ) { try { const result = await Parse . Cloud . run ( \"resetPassword\" , { token , newPassword , skipEmail : false }); console . log ( \"Password reset successful:\" , result . message ); return result ; } catch ( error ) { console . error ( \"Password reset failed:\" , error . message ); throw error ; } } }","title":"Password Reset Flow"},{"location":"cloud-functions/authentication/#user-onboarding-integration","text":"// User onboarding with wallet and identity integration class OnboardingService { async checkOnboardingStatus ( email ) { const result = await Parse . Cloud . run ( \"isUserOnboarded\" , { email }); return result . result ; } async completeOnboarding ( email , walletAddress , personaId ) { try { const result = await Parse . Cloud . run ( \"updateUserByEmail\" , { email , updates : { walletAddress , personaReferenceId : personaId , termsAccepted : new Date (). toISOString () }, secretKey : process . env . AUTH_SECRET_KEY }); console . log ( \"Onboarding completed:\" , result . message ); return result ; } catch ( error ) { console . error ( \"Onboarding failed:\" , error . message ); throw error ; } } }","title":"User Onboarding Integration"},{"location":"cloud-functions/authentication/#admin-user-management","text":"// Administrative user management functions class AdminUserService { async setupAdminPassword ( email ) { try { const result = await Parse . Cloud . run ( \"setupAdminUIPassword\" , { email }); console . log ( \"Admin setup initiated:\" , result . message ); return result ; } catch ( error ) { console . error ( \"Admin setup failed:\" , error . message ); throw error ; } } async getIdentityUsers () { try { const users = await Parse . Cloud . run ( \"getUsersWithIdentityWallets\" ); console . log ( `Found ${ users . length } users with identity wallets` ); return users ; } catch ( error ) { console . error ( \"Failed to get identity users:\" , error . message ); throw error ; } } }","title":"Admin User Management"},{"location":"cloud-functions/authentication/#security-considerations","text":"","title":"Security Considerations"},{"location":"cloud-functions/authentication/#token-security","text":"Cryptographically secure token generation using crypto.randomBytes(32) Time-limited tokens (24 hours for verification, 1 hour for password reset) Tokens are single-use and cleared after successful operations","title":"Token Security"},{"location":"cloud-functions/authentication/#access-control","text":"Role-based ACL system with user and admin permissions Secret key authentication for sensitive operations Email-based user identification and validation","title":"Access Control"},{"location":"cloud-functions/authentication/#data-protection","text":"Password hashing handled by Parse Server Sensitive operations require email verification Field validation for user updates","title":"Data Protection"},{"location":"cloud-functions/authentication/#email-security","text":"Professional email templates to prevent phishing Secure token-based links Clear expiration times for all tokens","title":"Email Security"},{"location":"cloud-functions/authentication/#error-handling","text":"","title":"Error Handling"},{"location":"cloud-functions/authentication/#validation-errors","text":"Missing required fields validation Email format validation Token expiration checking","title":"Validation Errors"},{"location":"cloud-functions/authentication/#user-errors","text":"Duplicate email registration prevention Invalid token handling User not found scenarios","title":"User Errors"},{"location":"cloud-functions/authentication/#system-errors","text":"Email sending failure handling Database operation error handling JWT token verification errors","title":"System Errors"},{"location":"cloud-functions/authentication/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"cloud-functions/authentication/#unit-tests","text":"Individual function testing Parameter validation testing Error condition handling Token generation and validation","title":"Unit Tests"},{"location":"cloud-functions/authentication/#integration-tests","text":"Complete registration flow Password reset workflow Email delivery testing ACL permission verification","title":"Integration Tests"},{"location":"cloud-functions/authentication/#security-tests","text":"Token security validation Access control testing Email template security Secret key validation","title":"Security Tests"},{"location":"cloud-functions/authentication/#related-documentation","text":"Blockchain Cloud Functions - Network integration DFNS Cloud Functions - Wallet integration Contract Cloud Functions - Smart contract integration User Management Guide - Implementation guide Security Guide - Security best practices These authentication functions provide the foundation for secure user management within the Gemforce platform, supporting complete user lifecycle management from registration through onboarding and ongoing account management.","title":"Related Documentation"},{"location":"cloud-functions/blockchain/","text":"Blockchain Cloud Functions \u00b6 Overview \u00b6 The blockchain.ts module provides cloud functions for managing blockchain network connections, provider configurations, and blockchain data access. These functions serve as the foundation for all blockchain interactions within the Gemforce platform. Functions \u00b6 Network Configuration Functions \u00b6 loadAllBlockchains \u00b6 Parse . Cloud . run ( \"loadAllBlockchains\" ) Purpose : Retrieves configuration data for all supported blockchain networks. Parameters : None Returns : Array of blockchain configuration objects [ { providerUrl : \"https://sepolia.infura.io/v3/your-key\" , networkId : 11155111 }, { providerUrl : \"https://base-sepolia.infura.io/v3/your-key\" , networkId : 84532 } // ... more networks ] Usage Example : const blockchains = await Parse . Cloud . run ( \"loadAllBlockchains\" ); console . log ( \"Available networks:\" , blockchains ); // Use in network selection UI blockchains . forEach ( blockchain => { console . log ( `Network ${ blockchain . networkId } : ${ blockchain . providerUrl } ` ); }); Error Conditions : - Returns empty array if no blockchain configurations exist - Database connection errors loadProviderUrl \u00b6 Parse . Cloud . run ( \"loadProviderUrl\" , { networkId : 1337 }) Purpose : Retrieves the RPC endpoint URL for a specific blockchain network. Parameters : - networkId (number): The network ID of the blockchain Returns : String - RPC provider URL Usage Example : try { const providerUrl = await Parse . Cloud . run ( \"loadProviderUrl\" , { networkId : 11155111 // Sepolia }); console . log ( \"Sepolia RPC URL:\" , providerUrl ); // Use with ethers.js const provider = new ethers . providers . JsonRpcProvider ( providerUrl ); } catch ( error ) { console . error ( \"Network not found:\" , error . message ); } Supported Network IDs : - 1337 - Localhost (development) - 11155111 - Sepolia Ethereum testnet - 84532 - Base Sepolia testnet - 11155420 - OP Sepolia testnet Error Conditions : - \"No blockchain found for networkId: {networkId}\" - Invalid or unsupported network ID loadProviderWebSocketUrl \u00b6 Parse . Cloud . run ( \"loadProviderWebSocketUrl\" , { networkId : 1337 }) Purpose : Retrieves the WebSocket endpoint URL for real-time blockchain event monitoring. Parameters : - networkId (number): The network ID of the blockchain Returns : String - WebSocket provider URL Usage Example : const wsUrl = await Parse . Cloud . run ( \"loadProviderWebSocketUrl\" , { networkId : 11155111 }); // Use for event listening const wsProvider = new ethers . providers . WebSocketProvider ( wsUrl ); wsProvider . on ( \"block\" , ( blockNumber ) => { console . log ( \"New block:\" , blockNumber ); }); Error Conditions : - \"No blockchain found for networkId: {networkId}\" - Invalid network ID - WebSocket URL may be null for some networks loadAllProviderUrls \u00b6 Parse . Cloud . run ( \"loadAllProviderUrls\" ) Purpose : Retrieves WebSocket URLs for all configured blockchain networks. Parameters : None Returns : Array of WebSocket URLs Usage Example : const wsUrls = await Parse . Cloud . run ( \"loadAllProviderUrls\" ); // Set up multi-network monitoring wsUrls . forEach (( url , index ) => { if ( url ) { const provider = new ethers . providers . WebSocketProvider ( url ); provider . on ( \"block\" , ( blockNumber ) => { console . log ( `Network ${ index } - New block: ${ blockNumber } ` ); }); } }); Error Conditions : - \"No blockchain found\" - No blockchain configurations exist - Array may contain null values for networks without WebSocket support Blockchain Data Access \u00b6 loadBlockchainDataForNetwork \u00b6 Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId : 1337 }) Purpose : Creates a complete blockchain connection setup including provider, wallet, and signer for a specific network. Parameters : - networkId (number): The network ID of the blockchain Returns : Object containing blockchain connection components { signer : ethers . Signer , // Connected signer for transactions provider : ethers . Provider , // Network provider for queries wallet : ethers . Wallet // Wallet instance } Usage Example : // Get blockchain connection for Sepolia const { signer , provider , wallet } = await Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId : 11155111 } ); // Check wallet balance const balance = await provider . getBalance ( wallet . address ); console . log ( \"Wallet balance:\" , ethers . utils . formatEther ( balance )); // Send transaction const tx = await signer . sendTransaction ({ to : \"0x...\" , value : ethers . utils . parseEther ( \"0.1\" ) }); console . log ( \"Transaction hash:\" , tx . hash ); Security Considerations : - Uses server-side private key management - Private key is retrieved securely via getPrivateKey() - Signer is created server-side to prevent key exposure Error Conditions : - \"No blockchain found for networkId: {networkId}\" - Invalid network ID - Private key retrieval errors - Network connection failures Integration Patterns \u00b6 Multi-Network Operations \u00b6 // Load all networks and perform operations const blockchains = await Parse . Cloud . run ( \"loadAllBlockchains\" ); for ( const blockchain of blockchains ) { try { const { provider } = await Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId : blockchain . networkId }); const blockNumber = await provider . getBlockNumber (); console . log ( `Network ${ blockchain . networkId } - Block: ${ blockNumber } ` ); } catch ( error ) { console . error ( `Network ${ blockchain . networkId } error:` , error . message ); } } Event Monitoring Setup \u00b6 // Set up cross-network event monitoring async function setupEventMonitoring () { const wsUrls = await Parse . Cloud . run ( \"loadAllProviderUrls\" ); wsUrls . forEach (( url , index ) => { if ( url ) { const provider = new ethers . providers . WebSocketProvider ( url ); // Monitor new blocks provider . on ( \"block\" , ( blockNumber ) => { console . log ( `Network ${ index } - Block ${ blockNumber } ` ); }); // Monitor specific contract events const contract = new ethers . Contract ( contractAddress , abi , provider ); contract . on ( \"Transfer\" , ( from , to , value ) => { console . log ( `Transfer on network ${ index } :` , { from , to , value }); }); } }); } Network-Specific Contract Interactions \u00b6 // Deploy contract to specific network async function deployToNetwork ( networkId , contractBytecode , constructorArgs ) { const { signer } = await Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId }); const factory = new ethers . ContractFactory ( abi , contractBytecode , signer ); const contract = await factory . deploy (... constructorArgs ); await contract . deployed (); return contract . address ; } Database Schema \u00b6 The blockchain functions rely on the Blockchain Parse class with the following schema: // Blockchain class fields { networkId : Number , // Unique network identifier name : String , // Human-readable network name symbol : String , // Network symbol (e.g., \"ETH\", \"sETH\") rpcEndpoint : String , // HTTP RPC endpoint URL wssEndpoint : String , // WebSocket endpoint URL (optional) code : String , // Short network code (e.g., \"sepolia\") explorer : String // Block explorer URL } Sample Data \u00b6 // Sepolia network configuration { networkId : 11155111 , name : \"Sepolia Ethereum\" , symbol : \"sETH\" , rpcEndpoint : \"https://sepolia.infura.io/v3/your-key\" , wssEndpoint : \"wss://sepolia.infura.io/ws/v3/your-key\" , code : \"sepolia\" , explorer : \"https://sepolia.etherscan.io\" } Error Handling \u00b6 Common Error Patterns \u00b6 // Robust error handling for blockchain functions async function safeBlockchainCall ( networkId ) { try { const result = await Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId }); return result ; } catch ( error ) { if ( error . message . includes ( \"No blockchain found\" )) { console . error ( \"Unsupported network:\" , networkId ); // Handle unsupported network } else if ( error . message . includes ( \"connection\" )) { console . error ( \"Network connection failed:\" , error . message ); // Handle connection issues } else { console . error ( \"Unexpected error:\" , error . message ); // Handle other errors } throw error ; } } Performance Considerations \u00b6 Caching Strategies \u00b6 // Client-side caching of network configurations let cachedBlockchains = null ; let cacheTimestamp = 0 ; const CACHE_DURATION = 5 * 60 * 1000 ; // 5 minutes async function getCachedBlockchains () { const now = Date . now (); if ( ! cachedBlockchains || ( now - cacheTimestamp ) > CACHE_DURATION ) { cachedBlockchains = await Parse . Cloud . run ( \"loadAllBlockchains\" ); cacheTimestamp = now ; } return cachedBlockchains ; } Connection Pooling \u00b6 Provider instances should be reused when possible WebSocket connections should be managed carefully to avoid memory leaks Implement connection retry logic for production use Security Best Practices \u00b6 Private Key Management \u00b6 Private keys are stored securely server-side Never expose private keys to client applications Use environment variables for sensitive configuration Network Validation \u00b6 Always validate network IDs before processing Implement rate limiting for blockchain function calls Monitor for unusual usage patterns Testing \u00b6 Unit Tests \u00b6 describe ( \"Blockchain Functions\" , () => { test ( \"loadAllBlockchains returns array\" , async () => { const result = await Parse . Cloud . run ( \"loadAllBlockchains\" ); expect ( Array . isArray ( result )). toBe ( true ); }); test ( \"loadProviderUrl returns valid URL\" , async () => { const url = await Parse . Cloud . run ( \"loadProviderUrl\" , { networkId : 1337 }); expect ( url ). toMatch ( /^https?:\\/\\// ); }); }); Integration Tests \u00b6 Test with real network connections Validate provider functionality Test error conditions with invalid network IDs Related Documentation \u00b6 Contract Functions - Smart contract interactions DFNS Functions - Wallet management Deploy Functions - Contract deployment System Architecture - Overall system design These functions provide the foundation for all blockchain interactions in the Gemforce platform.","title":"Blockchain Functions"},{"location":"cloud-functions/blockchain/#blockchain-cloud-functions","text":"","title":"Blockchain Cloud Functions"},{"location":"cloud-functions/blockchain/#overview","text":"The blockchain.ts module provides cloud functions for managing blockchain network connections, provider configurations, and blockchain data access. These functions serve as the foundation for all blockchain interactions within the Gemforce platform.","title":"Overview"},{"location":"cloud-functions/blockchain/#functions","text":"","title":"Functions"},{"location":"cloud-functions/blockchain/#network-configuration-functions","text":"","title":"Network Configuration Functions"},{"location":"cloud-functions/blockchain/#loadallblockchains","text":"Parse . Cloud . run ( \"loadAllBlockchains\" ) Purpose : Retrieves configuration data for all supported blockchain networks. Parameters : None Returns : Array of blockchain configuration objects [ { providerUrl : \"https://sepolia.infura.io/v3/your-key\" , networkId : 11155111 }, { providerUrl : \"https://base-sepolia.infura.io/v3/your-key\" , networkId : 84532 } // ... more networks ] Usage Example : const blockchains = await Parse . Cloud . run ( \"loadAllBlockchains\" ); console . log ( \"Available networks:\" , blockchains ); // Use in network selection UI blockchains . forEach ( blockchain => { console . log ( `Network ${ blockchain . networkId } : ${ blockchain . providerUrl } ` ); }); Error Conditions : - Returns empty array if no blockchain configurations exist - Database connection errors","title":"loadAllBlockchains"},{"location":"cloud-functions/blockchain/#loadproviderurl","text":"Parse . Cloud . run ( \"loadProviderUrl\" , { networkId : 1337 }) Purpose : Retrieves the RPC endpoint URL for a specific blockchain network. Parameters : - networkId (number): The network ID of the blockchain Returns : String - RPC provider URL Usage Example : try { const providerUrl = await Parse . Cloud . run ( \"loadProviderUrl\" , { networkId : 11155111 // Sepolia }); console . log ( \"Sepolia RPC URL:\" , providerUrl ); // Use with ethers.js const provider = new ethers . providers . JsonRpcProvider ( providerUrl ); } catch ( error ) { console . error ( \"Network not found:\" , error . message ); } Supported Network IDs : - 1337 - Localhost (development) - 11155111 - Sepolia Ethereum testnet - 84532 - Base Sepolia testnet - 11155420 - OP Sepolia testnet Error Conditions : - \"No blockchain found for networkId: {networkId}\" - Invalid or unsupported network ID","title":"loadProviderUrl"},{"location":"cloud-functions/blockchain/#loadproviderwebsocketurl","text":"Parse . Cloud . run ( \"loadProviderWebSocketUrl\" , { networkId : 1337 }) Purpose : Retrieves the WebSocket endpoint URL for real-time blockchain event monitoring. Parameters : - networkId (number): The network ID of the blockchain Returns : String - WebSocket provider URL Usage Example : const wsUrl = await Parse . Cloud . run ( \"loadProviderWebSocketUrl\" , { networkId : 11155111 }); // Use for event listening const wsProvider = new ethers . providers . WebSocketProvider ( wsUrl ); wsProvider . on ( \"block\" , ( blockNumber ) => { console . log ( \"New block:\" , blockNumber ); }); Error Conditions : - \"No blockchain found for networkId: {networkId}\" - Invalid network ID - WebSocket URL may be null for some networks","title":"loadProviderWebSocketUrl"},{"location":"cloud-functions/blockchain/#loadallproviderurls","text":"Parse . Cloud . run ( \"loadAllProviderUrls\" ) Purpose : Retrieves WebSocket URLs for all configured blockchain networks. Parameters : None Returns : Array of WebSocket URLs Usage Example : const wsUrls = await Parse . Cloud . run ( \"loadAllProviderUrls\" ); // Set up multi-network monitoring wsUrls . forEach (( url , index ) => { if ( url ) { const provider = new ethers . providers . WebSocketProvider ( url ); provider . on ( \"block\" , ( blockNumber ) => { console . log ( `Network ${ index } - New block: ${ blockNumber } ` ); }); } }); Error Conditions : - \"No blockchain found\" - No blockchain configurations exist - Array may contain null values for networks without WebSocket support","title":"loadAllProviderUrls"},{"location":"cloud-functions/blockchain/#blockchain-data-access","text":"","title":"Blockchain Data Access"},{"location":"cloud-functions/blockchain/#loadblockchaindatafornetwork","text":"Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId : 1337 }) Purpose : Creates a complete blockchain connection setup including provider, wallet, and signer for a specific network. Parameters : - networkId (number): The network ID of the blockchain Returns : Object containing blockchain connection components { signer : ethers . Signer , // Connected signer for transactions provider : ethers . Provider , // Network provider for queries wallet : ethers . Wallet // Wallet instance } Usage Example : // Get blockchain connection for Sepolia const { signer , provider , wallet } = await Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId : 11155111 } ); // Check wallet balance const balance = await provider . getBalance ( wallet . address ); console . log ( \"Wallet balance:\" , ethers . utils . formatEther ( balance )); // Send transaction const tx = await signer . sendTransaction ({ to : \"0x...\" , value : ethers . utils . parseEther ( \"0.1\" ) }); console . log ( \"Transaction hash:\" , tx . hash ); Security Considerations : - Uses server-side private key management - Private key is retrieved securely via getPrivateKey() - Signer is created server-side to prevent key exposure Error Conditions : - \"No blockchain found for networkId: {networkId}\" - Invalid network ID - Private key retrieval errors - Network connection failures","title":"loadBlockchainDataForNetwork"},{"location":"cloud-functions/blockchain/#integration-patterns","text":"","title":"Integration Patterns"},{"location":"cloud-functions/blockchain/#multi-network-operations","text":"// Load all networks and perform operations const blockchains = await Parse . Cloud . run ( \"loadAllBlockchains\" ); for ( const blockchain of blockchains ) { try { const { provider } = await Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId : blockchain . networkId }); const blockNumber = await provider . getBlockNumber (); console . log ( `Network ${ blockchain . networkId } - Block: ${ blockNumber } ` ); } catch ( error ) { console . error ( `Network ${ blockchain . networkId } error:` , error . message ); } }","title":"Multi-Network Operations"},{"location":"cloud-functions/blockchain/#event-monitoring-setup","text":"// Set up cross-network event monitoring async function setupEventMonitoring () { const wsUrls = await Parse . Cloud . run ( \"loadAllProviderUrls\" ); wsUrls . forEach (( url , index ) => { if ( url ) { const provider = new ethers . providers . WebSocketProvider ( url ); // Monitor new blocks provider . on ( \"block\" , ( blockNumber ) => { console . log ( `Network ${ index } - Block ${ blockNumber } ` ); }); // Monitor specific contract events const contract = new ethers . Contract ( contractAddress , abi , provider ); contract . on ( \"Transfer\" , ( from , to , value ) => { console . log ( `Transfer on network ${ index } :` , { from , to , value }); }); } }); }","title":"Event Monitoring Setup"},{"location":"cloud-functions/blockchain/#network-specific-contract-interactions","text":"// Deploy contract to specific network async function deployToNetwork ( networkId , contractBytecode , constructorArgs ) { const { signer } = await Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId }); const factory = new ethers . ContractFactory ( abi , contractBytecode , signer ); const contract = await factory . deploy (... constructorArgs ); await contract . deployed (); return contract . address ; }","title":"Network-Specific Contract Interactions"},{"location":"cloud-functions/blockchain/#database-schema","text":"The blockchain functions rely on the Blockchain Parse class with the following schema: // Blockchain class fields { networkId : Number , // Unique network identifier name : String , // Human-readable network name symbol : String , // Network symbol (e.g., \"ETH\", \"sETH\") rpcEndpoint : String , // HTTP RPC endpoint URL wssEndpoint : String , // WebSocket endpoint URL (optional) code : String , // Short network code (e.g., \"sepolia\") explorer : String // Block explorer URL }","title":"Database Schema"},{"location":"cloud-functions/blockchain/#sample-data","text":"// Sepolia network configuration { networkId : 11155111 , name : \"Sepolia Ethereum\" , symbol : \"sETH\" , rpcEndpoint : \"https://sepolia.infura.io/v3/your-key\" , wssEndpoint : \"wss://sepolia.infura.io/ws/v3/your-key\" , code : \"sepolia\" , explorer : \"https://sepolia.etherscan.io\" }","title":"Sample Data"},{"location":"cloud-functions/blockchain/#error-handling","text":"","title":"Error Handling"},{"location":"cloud-functions/blockchain/#common-error-patterns","text":"// Robust error handling for blockchain functions async function safeBlockchainCall ( networkId ) { try { const result = await Parse . Cloud . run ( \"loadBlockchainDataForNetwork\" , { networkId }); return result ; } catch ( error ) { if ( error . message . includes ( \"No blockchain found\" )) { console . error ( \"Unsupported network:\" , networkId ); // Handle unsupported network } else if ( error . message . includes ( \"connection\" )) { console . error ( \"Network connection failed:\" , error . message ); // Handle connection issues } else { console . error ( \"Unexpected error:\" , error . message ); // Handle other errors } throw error ; } }","title":"Common Error Patterns"},{"location":"cloud-functions/blockchain/#performance-considerations","text":"","title":"Performance Considerations"},{"location":"cloud-functions/blockchain/#caching-strategies","text":"// Client-side caching of network configurations let cachedBlockchains = null ; let cacheTimestamp = 0 ; const CACHE_DURATION = 5 * 60 * 1000 ; // 5 minutes async function getCachedBlockchains () { const now = Date . now (); if ( ! cachedBlockchains || ( now - cacheTimestamp ) > CACHE_DURATION ) { cachedBlockchains = await Parse . Cloud . run ( \"loadAllBlockchains\" ); cacheTimestamp = now ; } return cachedBlockchains ; }","title":"Caching Strategies"},{"location":"cloud-functions/blockchain/#connection-pooling","text":"Provider instances should be reused when possible WebSocket connections should be managed carefully to avoid memory leaks Implement connection retry logic for production use","title":"Connection Pooling"},{"location":"cloud-functions/blockchain/#security-best-practices","text":"","title":"Security Best Practices"},{"location":"cloud-functions/blockchain/#private-key-management","text":"Private keys are stored securely server-side Never expose private keys to client applications Use environment variables for sensitive configuration","title":"Private Key Management"},{"location":"cloud-functions/blockchain/#network-validation","text":"Always validate network IDs before processing Implement rate limiting for blockchain function calls Monitor for unusual usage patterns","title":"Network Validation"},{"location":"cloud-functions/blockchain/#testing","text":"","title":"Testing"},{"location":"cloud-functions/blockchain/#unit-tests","text":"describe ( \"Blockchain Functions\" , () => { test ( \"loadAllBlockchains returns array\" , async () => { const result = await Parse . Cloud . run ( \"loadAllBlockchains\" ); expect ( Array . isArray ( result )). toBe ( true ); }); test ( \"loadProviderUrl returns valid URL\" , async () => { const url = await Parse . Cloud . run ( \"loadProviderUrl\" , { networkId : 1337 }); expect ( url ). toMatch ( /^https?:\\/\\// ); }); });","title":"Unit Tests"},{"location":"cloud-functions/blockchain/#integration-tests","text":"Test with real network connections Validate provider functionality Test error conditions with invalid network IDs","title":"Integration Tests"},{"location":"cloud-functions/blockchain/#related-documentation","text":"Contract Functions - Smart contract interactions DFNS Functions - Wallet management Deploy Functions - Contract deployment System Architecture - Overall system design These functions provide the foundation for all blockchain interactions in the Gemforce platform.","title":"Related Documentation"},{"location":"cloud-functions/bridge/","text":"Bridge Functions \u00b6 The Bridge Functions module provides cross-chain interoperability capabilities for the Gemforce platform, enabling asset transfers and data synchronization between different blockchain networks. Overview \u00b6 The Bridge Functions provide: Cross-Chain Transfers : Transfer assets between supported networks State Synchronization : Sync contract state across chains Event Bridging : Bridge events and notifications between networks Liquidity Management : Manage cross-chain liquidity pools Validation : Verify cross-chain transactions and state changes Key Features \u00b6 Cross-Chain Asset Transfer \u00b6 Token Bridging : Transfer ERC20, ERC721, and ERC1155 tokens Native Asset Support : Bridge native network tokens Batch Transfers : Efficient batch transfer operations Fee Management : Automatic bridge fee calculation and collection State Synchronization \u00b6 Contract State Sync : Synchronize diamond contract state Event Mirroring : Mirror events across supported networks Data Consistency : Ensure data consistency across chains Conflict Resolution : Handle state conflicts and discrepancies Security Features \u00b6 Multi-Signature Validation : Require multiple validators for transfers Time Locks : Implement time delays for large transfers Rate Limiting : Prevent excessive transfer volumes Fraud Detection : Monitor for suspicious transfer patterns Supported Networks \u00b6 Mainnet Networks \u00b6 Ethereum : Primary network for high-value transfers Polygon : Fast and low-cost transfers Optimism : Layer 2 scaling solution Arbitrum : High-throughput Layer 2 network Testnet Networks \u00b6 Sepolia : Ethereum testnet BaseSepolia : Base network testnet OptimismSepolia : Optimism testnet Mumbai : Polygon testnet Core Functions \u00b6 initiateBridgeTransfer() \u00b6 Initiates a cross-chain asset transfer. Parameters: interface BridgeTransferRequest { fromNetwork : string ; toNetwork : string ; tokenAddress : string ; tokenType : 'ERC20' | 'ERC721' | 'ERC1155' | 'NATIVE' ; amount : string ; tokenId? : string ; recipient : string ; metadata? : any ; } Returns: interface BridgeTransferResponse { success : boolean ; transferId : string ; estimatedTime : number ; bridgeFee : string ; message : string ; } Usage: const result = await Parse . Cloud . run ( 'initiateBridgeTransfer' , { fromNetwork : 'ethereum' , toNetwork : 'polygon' , tokenAddress : '0x...' , tokenType : 'ERC20' , amount : '1000000000000000000' , // 1 token recipient : '0x...' }); getBridgeStatus() \u00b6 Retrieves the status of a bridge transfer. Parameters: interface BridgeStatusRequest { transferId : string ; } Returns: interface BridgeStatusResponse { success : boolean ; status : 'pending' | 'confirmed' | 'completed' | 'failed' ; confirmations : number ; requiredConfirmations : number ; estimatedCompletion? : Date ; txHash? : string ; message : string ; } validateBridgeTransfer() \u00b6 Validates a bridge transfer for security and compliance. Parameters: interface BridgeValidationRequest { transferId : string ; validatorSignature : string ; } Returns: interface BridgeValidationResponse { success : boolean ; validated : boolean ; validatorCount : number ; requiredValidators : number ; message : string ; } getBridgeLiquidity() \u00b6 Retrieves current liquidity information for bridge operations. Parameters: interface BridgeLiquidityRequest { network : string ; tokenAddress : string ; } Returns: interface BridgeLiquidityResponse { success : boolean ; availableLiquidity : string ; totalLiquidity : string ; utilizationRate : number ; message : string ; } Implementation Example \u00b6 Cross-Chain Token Transfer \u00b6 Parse . Cloud . define ( 'initiateBridgeTransfer' , async ( request ) => { const { fromNetwork , toNetwork , tokenAddress , tokenType , amount , tokenId , recipient , metadata } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Validate networks if ( ! isSupportedNetwork ( fromNetwork ) || ! isSupportedNetwork ( toNetwork )) { throw new Error ( 'Unsupported network' ); } // Validate transfer parameters await validateTransferParams ({ fromNetwork , toNetwork , tokenAddress , tokenType , amount , tokenId , recipient }); // Check user balance and allowance const balanceCheck = await checkUserBalance ( user . id , fromNetwork , tokenAddress , amount , tokenId ); if ( ! balanceCheck . sufficient ) { throw new Error ( 'Insufficient balance or allowance' ); } // Calculate bridge fee const bridgeFee = await calculateBridgeFee ( fromNetwork , toNetwork , tokenType , amount ); // Check bridge liquidity const liquidityCheck = await checkBridgeLiquidity ( toNetwork , tokenAddress , amount ); if ( ! liquidityCheck . sufficient ) { throw new Error ( 'Insufficient bridge liquidity' ); } // Create transfer record const transferId = generateTransferId (); const transfer = new Parse . Object ( 'BridgeTransfer' ); transfer . set ( 'transferId' , transferId ); transfer . set ( 'user' , user ); transfer . set ( 'fromNetwork' , fromNetwork ); transfer . set ( 'toNetwork' , toNetwork ); transfer . set ( 'tokenAddress' , tokenAddress ); transfer . set ( 'tokenType' , tokenType ); transfer . set ( 'amount' , amount ); transfer . set ( 'tokenId' , tokenId ); transfer . set ( 'recipient' , recipient ); transfer . set ( 'bridgeFee' , bridgeFee ); transfer . set ( 'status' , 'pending' ); transfer . set ( 'metadata' , metadata ); transfer . set ( 'createdAt' , new Date ()); await transfer . save (); // Lock tokens on source network const lockResult = await lockTokensOnSource ({ network : fromNetwork , tokenAddress , tokenType , amount , tokenId , user : user.get ( 'walletAddress' ), transferId }); if ( ! lockResult . success ) { transfer . set ( 'status' , 'failed' ); transfer . set ( 'errorMessage' , lockResult . message ); await transfer . save (); throw new Error ( 'Failed to lock tokens' ); } transfer . set ( 'sourceTxHash' , lockResult . txHash ); transfer . set ( 'status' , 'locked' ); await transfer . save (); // Initiate validation process await initiateValidationProcess ( transferId ); return { success : true , transferId , estimatedTime : calculateEstimatedTime ( fromNetwork , toNetwork ), bridgeFee , message : 'Bridge transfer initiated successfully' }; } catch ( error ) { console . error ( 'Bridge transfer error:' , error ); return { success : false , message : error.message || 'Bridge transfer failed' }; } }); Bridge Validation System \u00b6 Parse . Cloud . define ( 'validateBridgeTransfer' , async ( request ) => { const { transferId , validatorSignature } = request . params ; const validator = request . user ; if ( ! validator || ! isAuthorizedValidator ( validator . id )) { throw new Error ( 'Unauthorized validator' ); } try { // Get transfer record const transferQuery = new Parse . Query ( 'BridgeTransfer' ); transferQuery . equalTo ( 'transferId' , transferId ); const transfer = await transferQuery . first ({ useMasterKey : true }); if ( ! transfer ) { throw new Error ( 'Transfer not found' ); } if ( transfer . get ( 'status' ) !== 'locked' ) { throw new Error ( 'Transfer not ready for validation' ); } // Verify validator signature const isValidSignature = await verifyValidatorSignature ( transferId , validatorSignature , validator . get ( 'validatorAddress' ) ); if ( ! isValidSignature ) { throw new Error ( 'Invalid validator signature' ); } // Check if validator already validated this transfer const existingValidation = await new Parse . Query ( 'BridgeValidation' ) . equalTo ( 'transferId' , transferId ) . equalTo ( 'validator' , validator ) . first ({ useMasterKey : true }); if ( existingValidation ) { throw new Error ( 'Transfer already validated by this validator' ); } // Create validation record const validation = new Parse . Object ( 'BridgeValidation' ); validation . set ( 'transferId' , transferId ); validation . set ( 'validator' , validator ); validation . set ( 'signature' , validatorSignature ); validation . set ( 'validatedAt' , new Date ()); await validation . save (); // Check if we have enough validations const validationCount = await new Parse . Query ( 'BridgeValidation' ) . equalTo ( 'transferId' , transferId ) . count ({ useMasterKey : true }); const requiredValidators = getRequiredValidatorCount ( transfer . get ( 'amount' )); if ( validationCount >= requiredValidators ) { // Sufficient validations, proceed with minting on destination await completeBridgeTransfer ( transferId ); } return { success : true , validated : true , validatorCount : validationCount , requiredValidators , message : 'Transfer validated successfully' }; } catch ( error ) { console . error ( 'Bridge validation error:' , error ); return { success : false , message : error.message || 'Validation failed' }; } }); Bridge Completion \u00b6 async function completeBridgeTransfer ( transferId : string ) { try { // Get transfer record const transferQuery = new Parse . Query ( 'BridgeTransfer' ); transferQuery . equalTo ( 'transferId' , transferId ); const transfer = await transferQuery . first ({ useMasterKey : true }); if ( ! transfer ) { throw new Error ( 'Transfer not found' ); } // Mint tokens on destination network const mintResult = await mintTokensOnDestination ({ network : transfer.get ( 'toNetwork' ), tokenAddress : transfer.get ( 'tokenAddress' ), tokenType : transfer.get ( 'tokenType' ), amount : transfer.get ( 'amount' ), tokenId : transfer.get ( 'tokenId' ), recipient : transfer.get ( 'recipient' ), transferId }); if ( ! mintResult . success ) { transfer . set ( 'status' , 'failed' ); transfer . set ( 'errorMessage' , mintResult . message ); await transfer . save (); // Initiate refund process await initiateRefund ( transferId ); return ; } // Update transfer status transfer . set ( 'status' , 'completed' ); transfer . set ( 'destinationTxHash' , mintResult . txHash ); transfer . set ( 'completedAt' , new Date ()); await transfer . save (); // Send completion notification await sendBridgeCompletionNotification ( transfer ); // Update bridge statistics await updateBridgeStats ( transfer ); } catch ( error ) { console . error ( 'Bridge completion error:' , error ); // Mark transfer as failed and initiate refund const transfer = await new Parse . Query ( 'BridgeTransfer' ) . equalTo ( 'transferId' , transferId ) . first ({ useMasterKey : true }); if ( transfer ) { transfer . set ( 'status' , 'failed' ); transfer . set ( 'errorMessage' , error . message ); await transfer . save (); await initiateRefund ( transferId ); } } } Security Features \u00b6 Multi-Signature Validation \u00b6 function getRequiredValidatorCount ( amount : string ) : number { const amountBN = new Parse . Cloud . BigNumber ( amount ); // Require more validators for larger amounts if ( amountBN . gte ( '1000000000000000000000' )) { // >= 1000 tokens return 5 ; } else if ( amountBN . gte ( '100000000000000000000' )) { // >= 100 tokens return 3 ; } else { return 2 ; } } async function verifyValidatorSignature ( transferId : string , signature : string , validatorAddress : string ) : Promise < boolean > { try { // Reconstruct the message that should have been signed const message = `bridge_transfer_ ${ transferId } ` ; const messageHash = Parse . Cloud . keccak256 ( message ); // Recover signer address from signature const recoveredAddress = Parse . Cloud . recoverAddress ( messageHash , signature ); return recoveredAddress . toLowerCase () === validatorAddress . toLowerCase (); } catch ( error ) { console . error ( 'Signature verification error:' , error ); return false ; } } Rate Limiting and Fraud Detection \u00b6 async function validateTransferParams ( params : any ) : Promise < void > { const { fromNetwork , toNetwork , tokenAddress , amount , recipient } = params ; // Check daily transfer limits const dailyLimit = await getDailyTransferLimit ( fromNetwork , toNetwork ); const dailyVolume = await getDailyTransferVolume ( fromNetwork , toNetwork ); if ( dailyVolume . plus ( amount ). gt ( dailyLimit )) { throw new Error ( 'Daily transfer limit exceeded' ); } // Check recipient address if ( ! isValidAddress ( recipient )) { throw new Error ( 'Invalid recipient address' ); } // Check for suspicious patterns const suspiciousActivity = await detectSuspiciousActivity ( params ); if ( suspiciousActivity . detected ) { throw new Error ( `Suspicious activity detected: ${ suspiciousActivity . reason } ` ); } // Validate token contract const tokenValidation = await validateTokenContract ( fromNetwork , tokenAddress ); if ( ! tokenValidation . valid ) { throw new Error ( 'Invalid or unsupported token contract' ); } } async function detectSuspiciousActivity ( params : any ) : Promise < { detected : boolean ; reason? : string } > { // Check for rapid successive transfers const recentTransfers = await new Parse . Query ( 'BridgeTransfer' ) . equalTo ( 'user' , Parse . User . current ()) . greaterThan ( 'createdAt' , new Date ( Date . now () - 300000 )) // Last 5 minutes . count ({ useMasterKey : true }); if ( recentTransfers > 5 ) { return { detected : true , reason : 'Too many transfers in short time period' }; } // Check for unusual amounts const amountBN = new Parse . Cloud . BigNumber ( params . amount ); const userHistory = await getUserTransferHistory ( Parse . User . current (). id ); if ( userHistory . averageAmount . gt ( 0 ) && amountBN . gt ( userHistory . averageAmount . times ( 10 ))) { return { detected : true , reason : 'Transfer amount significantly higher than usual' }; } return { detected : false }; } Liquidity Management \u00b6 Liquidity Pool Operations \u00b6 Parse . Cloud . define ( 'getBridgeLiquidity' , async ( request ) => { const { network , tokenAddress } = request . params ; try { // Get liquidity pool information const liquidityPool = await getLiquidityPool ( network , tokenAddress ); if ( ! liquidityPool ) { throw new Error ( 'Liquidity pool not found' ); } const availableLiquidity = liquidityPool . get ( 'availableBalance' ); const totalLiquidity = liquidityPool . get ( 'totalBalance' ); const utilizationRate = calculateUtilizationRate ( availableLiquidity , totalLiquidity ); return { success : true , availableLiquidity , totalLiquidity , utilizationRate , message : 'Liquidity information retrieved successfully' }; } catch ( error ) { console . error ( 'Liquidity check error:' , error ); return { success : false , message : error.message || 'Failed to get liquidity information' }; } }); async function checkBridgeLiquidity ( network : string , tokenAddress : string , amount : string ) : Promise < { sufficient : boolean ; available : string } > { const liquidityPool = await getLiquidityPool ( network , tokenAddress ); if ( ! liquidityPool ) { return { sufficient : false , available : '0' }; } const availableBalance = liquidityPool . get ( 'availableBalance' ); const amountBN = new Parse . Cloud . BigNumber ( amount ); const availableBN = new Parse . Cloud . BigNumber ( availableBalance ); return { sufficient : availableBN.gte ( amountBN ), available : availableBalance }; } Error Handling \u00b6 Common Errors \u00b6 \"Unsupported network\" : Network not supported by bridge \"Insufficient balance or allowance\" : User lacks sufficient tokens or approval \"Insufficient bridge liquidity\" : Not enough liquidity on destination network \"Daily transfer limit exceeded\" : Transfer exceeds daily limits \"Suspicious activity detected\" : Fraud detection triggered Error Recovery \u00b6 async function initiateRefund ( transferId : string ) : Promise < void > { try { const transfer = await new Parse . Query ( 'BridgeTransfer' ) . equalTo ( 'transferId' , transferId ) . first ({ useMasterKey : true }); if ( ! transfer ) { throw new Error ( 'Transfer not found' ); } // Unlock tokens on source network const unlockResult = await unlockTokensOnSource ({ network : transfer.get ( 'fromNetwork' ), tokenAddress : transfer.get ( 'tokenAddress' ), tokenType : transfer.get ( 'tokenType' ), amount : transfer.get ( 'amount' ), tokenId : transfer.get ( 'tokenId' ), user : transfer.get ( 'user' ). get ( 'walletAddress' ), transferId }); if ( unlockResult . success ) { transfer . set ( 'status' , 'refunded' ); transfer . set ( 'refundTxHash' , unlockResult . txHash ); transfer . set ( 'refundedAt' , new Date ()); await transfer . save (); // Send refund notification await sendRefundNotification ( transfer ); } } catch ( error ) { console . error ( 'Refund error:' , error ); } } Integration Examples \u00b6 Frontend Integration \u00b6 class BridgeService { async initiateBridgeTransfer ( params : BridgeTransferRequest ) : Promise < BridgeTransferResponse > { return await Parse . Cloud . run ( 'initiateBridgeTransfer' , params ); } async getBridgeStatus ( transferId : string ) : Promise < BridgeStatusResponse > { return await Parse . Cloud . run ( 'getBridgeStatus' , { transferId }); } async getBridgeLiquidity ( network : string , tokenAddress : string ) : Promise < BridgeLiquidityResponse > { return await Parse . Cloud . run ( 'getBridgeLiquidity' , { network , tokenAddress }); } async estimateBridgeFee ( fromNetwork : string , toNetwork : string , tokenType : string , amount : string ) : Promise < string > { const result = await Parse . Cloud . run ( 'estimateBridgeFee' , { fromNetwork , toNetwork , tokenType , amount }); return result . fee ; } } React Component Example \u00b6 export function BridgeTransfer () { const [ transfer , setTransfer ] = useState < BridgeTransferRequest > ({ fromNetwork : 'ethereum' , toNetwork : 'polygon' , tokenAddress : '' , tokenType : 'ERC20' , amount : '' , recipient : '' }); const handleBridgeTransfer = async () => { try { const result = await new BridgeService (). initiateBridgeTransfer ( transfer ); if ( result . success ) { // Show success message and transfer ID console . log ( 'Transfer initiated:' , result . transferId ); } else { // Show error message console . error ( 'Transfer failed:' , result . message ); } } catch ( error ) { console . error ( 'Bridge error:' , error ); } }; return ( < div > { /* Bridge transfer form */ } < form onSubmit = { handleBridgeTransfer } > { /* Form fields */ } < /form> < /div> ); } Best Practices \u00b6 Security Guidelines \u00b6 Multi-Signature Validation : Always require multiple validator signatures Rate Limiting : Implement transfer rate limits and daily caps Fraud Detection : Monitor for suspicious transfer patterns Liquidity Management : Maintain adequate liquidity across networks Development Guidelines \u00b6 Error Handling : Implement comprehensive error handling and recovery Event Logging : Log all bridge operations for auditing Testing : Thoroughly test cross-chain operations on testnets Monitoring : Monitor bridge health and performance metrics Related Documentation \u00b6 Blockchain Functions DFNS Integration Contract Functions Cross-Chain Integration Guide Bridge Security Guide Security Considerations \u00b6 Multi-Signature Validation : Multiple validators required for transfers Time Locks : Large transfers subject to time delays Rate Limiting : Daily and hourly transfer limits Fraud Detection : Automated suspicious activity detection Liquidity Management : Secure liquidity pool operations Audit Trail : Complete audit trail for all bridge operations","title":"Bridge Functions"},{"location":"cloud-functions/bridge/#bridge-functions","text":"The Bridge Functions module provides cross-chain interoperability capabilities for the Gemforce platform, enabling asset transfers and data synchronization between different blockchain networks.","title":"Bridge Functions"},{"location":"cloud-functions/bridge/#overview","text":"The Bridge Functions provide: Cross-Chain Transfers : Transfer assets between supported networks State Synchronization : Sync contract state across chains Event Bridging : Bridge events and notifications between networks Liquidity Management : Manage cross-chain liquidity pools Validation : Verify cross-chain transactions and state changes","title":"Overview"},{"location":"cloud-functions/bridge/#key-features","text":"","title":"Key Features"},{"location":"cloud-functions/bridge/#cross-chain-asset-transfer","text":"Token Bridging : Transfer ERC20, ERC721, and ERC1155 tokens Native Asset Support : Bridge native network tokens Batch Transfers : Efficient batch transfer operations Fee Management : Automatic bridge fee calculation and collection","title":"Cross-Chain Asset Transfer"},{"location":"cloud-functions/bridge/#state-synchronization","text":"Contract State Sync : Synchronize diamond contract state Event Mirroring : Mirror events across supported networks Data Consistency : Ensure data consistency across chains Conflict Resolution : Handle state conflicts and discrepancies","title":"State Synchronization"},{"location":"cloud-functions/bridge/#security-features","text":"Multi-Signature Validation : Require multiple validators for transfers Time Locks : Implement time delays for large transfers Rate Limiting : Prevent excessive transfer volumes Fraud Detection : Monitor for suspicious transfer patterns","title":"Security Features"},{"location":"cloud-functions/bridge/#supported-networks","text":"","title":"Supported Networks"},{"location":"cloud-functions/bridge/#mainnet-networks","text":"Ethereum : Primary network for high-value transfers Polygon : Fast and low-cost transfers Optimism : Layer 2 scaling solution Arbitrum : High-throughput Layer 2 network","title":"Mainnet Networks"},{"location":"cloud-functions/bridge/#testnet-networks","text":"Sepolia : Ethereum testnet BaseSepolia : Base network testnet OptimismSepolia : Optimism testnet Mumbai : Polygon testnet","title":"Testnet Networks"},{"location":"cloud-functions/bridge/#core-functions","text":"","title":"Core Functions"},{"location":"cloud-functions/bridge/#initiatebridgetransfer","text":"Initiates a cross-chain asset transfer. Parameters: interface BridgeTransferRequest { fromNetwork : string ; toNetwork : string ; tokenAddress : string ; tokenType : 'ERC20' | 'ERC721' | 'ERC1155' | 'NATIVE' ; amount : string ; tokenId? : string ; recipient : string ; metadata? : any ; } Returns: interface BridgeTransferResponse { success : boolean ; transferId : string ; estimatedTime : number ; bridgeFee : string ; message : string ; } Usage: const result = await Parse . Cloud . run ( 'initiateBridgeTransfer' , { fromNetwork : 'ethereum' , toNetwork : 'polygon' , tokenAddress : '0x...' , tokenType : 'ERC20' , amount : '1000000000000000000' , // 1 token recipient : '0x...' });","title":"initiateBridgeTransfer()"},{"location":"cloud-functions/bridge/#getbridgestatus","text":"Retrieves the status of a bridge transfer. Parameters: interface BridgeStatusRequest { transferId : string ; } Returns: interface BridgeStatusResponse { success : boolean ; status : 'pending' | 'confirmed' | 'completed' | 'failed' ; confirmations : number ; requiredConfirmations : number ; estimatedCompletion? : Date ; txHash? : string ; message : string ; }","title":"getBridgeStatus()"},{"location":"cloud-functions/bridge/#validatebridgetransfer","text":"Validates a bridge transfer for security and compliance. Parameters: interface BridgeValidationRequest { transferId : string ; validatorSignature : string ; } Returns: interface BridgeValidationResponse { success : boolean ; validated : boolean ; validatorCount : number ; requiredValidators : number ; message : string ; }","title":"validateBridgeTransfer()"},{"location":"cloud-functions/bridge/#getbridgeliquidity","text":"Retrieves current liquidity information for bridge operations. Parameters: interface BridgeLiquidityRequest { network : string ; tokenAddress : string ; } Returns: interface BridgeLiquidityResponse { success : boolean ; availableLiquidity : string ; totalLiquidity : string ; utilizationRate : number ; message : string ; }","title":"getBridgeLiquidity()"},{"location":"cloud-functions/bridge/#implementation-example","text":"","title":"Implementation Example"},{"location":"cloud-functions/bridge/#cross-chain-token-transfer","text":"Parse . Cloud . define ( 'initiateBridgeTransfer' , async ( request ) => { const { fromNetwork , toNetwork , tokenAddress , tokenType , amount , tokenId , recipient , metadata } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Validate networks if ( ! isSupportedNetwork ( fromNetwork ) || ! isSupportedNetwork ( toNetwork )) { throw new Error ( 'Unsupported network' ); } // Validate transfer parameters await validateTransferParams ({ fromNetwork , toNetwork , tokenAddress , tokenType , amount , tokenId , recipient }); // Check user balance and allowance const balanceCheck = await checkUserBalance ( user . id , fromNetwork , tokenAddress , amount , tokenId ); if ( ! balanceCheck . sufficient ) { throw new Error ( 'Insufficient balance or allowance' ); } // Calculate bridge fee const bridgeFee = await calculateBridgeFee ( fromNetwork , toNetwork , tokenType , amount ); // Check bridge liquidity const liquidityCheck = await checkBridgeLiquidity ( toNetwork , tokenAddress , amount ); if ( ! liquidityCheck . sufficient ) { throw new Error ( 'Insufficient bridge liquidity' ); } // Create transfer record const transferId = generateTransferId (); const transfer = new Parse . Object ( 'BridgeTransfer' ); transfer . set ( 'transferId' , transferId ); transfer . set ( 'user' , user ); transfer . set ( 'fromNetwork' , fromNetwork ); transfer . set ( 'toNetwork' , toNetwork ); transfer . set ( 'tokenAddress' , tokenAddress ); transfer . set ( 'tokenType' , tokenType ); transfer . set ( 'amount' , amount ); transfer . set ( 'tokenId' , tokenId ); transfer . set ( 'recipient' , recipient ); transfer . set ( 'bridgeFee' , bridgeFee ); transfer . set ( 'status' , 'pending' ); transfer . set ( 'metadata' , metadata ); transfer . set ( 'createdAt' , new Date ()); await transfer . save (); // Lock tokens on source network const lockResult = await lockTokensOnSource ({ network : fromNetwork , tokenAddress , tokenType , amount , tokenId , user : user.get ( 'walletAddress' ), transferId }); if ( ! lockResult . success ) { transfer . set ( 'status' , 'failed' ); transfer . set ( 'errorMessage' , lockResult . message ); await transfer . save (); throw new Error ( 'Failed to lock tokens' ); } transfer . set ( 'sourceTxHash' , lockResult . txHash ); transfer . set ( 'status' , 'locked' ); await transfer . save (); // Initiate validation process await initiateValidationProcess ( transferId ); return { success : true , transferId , estimatedTime : calculateEstimatedTime ( fromNetwork , toNetwork ), bridgeFee , message : 'Bridge transfer initiated successfully' }; } catch ( error ) { console . error ( 'Bridge transfer error:' , error ); return { success : false , message : error.message || 'Bridge transfer failed' }; } });","title":"Cross-Chain Token Transfer"},{"location":"cloud-functions/bridge/#bridge-validation-system","text":"Parse . Cloud . define ( 'validateBridgeTransfer' , async ( request ) => { const { transferId , validatorSignature } = request . params ; const validator = request . user ; if ( ! validator || ! isAuthorizedValidator ( validator . id )) { throw new Error ( 'Unauthorized validator' ); } try { // Get transfer record const transferQuery = new Parse . Query ( 'BridgeTransfer' ); transferQuery . equalTo ( 'transferId' , transferId ); const transfer = await transferQuery . first ({ useMasterKey : true }); if ( ! transfer ) { throw new Error ( 'Transfer not found' ); } if ( transfer . get ( 'status' ) !== 'locked' ) { throw new Error ( 'Transfer not ready for validation' ); } // Verify validator signature const isValidSignature = await verifyValidatorSignature ( transferId , validatorSignature , validator . get ( 'validatorAddress' ) ); if ( ! isValidSignature ) { throw new Error ( 'Invalid validator signature' ); } // Check if validator already validated this transfer const existingValidation = await new Parse . Query ( 'BridgeValidation' ) . equalTo ( 'transferId' , transferId ) . equalTo ( 'validator' , validator ) . first ({ useMasterKey : true }); if ( existingValidation ) { throw new Error ( 'Transfer already validated by this validator' ); } // Create validation record const validation = new Parse . Object ( 'BridgeValidation' ); validation . set ( 'transferId' , transferId ); validation . set ( 'validator' , validator ); validation . set ( 'signature' , validatorSignature ); validation . set ( 'validatedAt' , new Date ()); await validation . save (); // Check if we have enough validations const validationCount = await new Parse . Query ( 'BridgeValidation' ) . equalTo ( 'transferId' , transferId ) . count ({ useMasterKey : true }); const requiredValidators = getRequiredValidatorCount ( transfer . get ( 'amount' )); if ( validationCount >= requiredValidators ) { // Sufficient validations, proceed with minting on destination await completeBridgeTransfer ( transferId ); } return { success : true , validated : true , validatorCount : validationCount , requiredValidators , message : 'Transfer validated successfully' }; } catch ( error ) { console . error ( 'Bridge validation error:' , error ); return { success : false , message : error.message || 'Validation failed' }; } });","title":"Bridge Validation System"},{"location":"cloud-functions/bridge/#bridge-completion","text":"async function completeBridgeTransfer ( transferId : string ) { try { // Get transfer record const transferQuery = new Parse . Query ( 'BridgeTransfer' ); transferQuery . equalTo ( 'transferId' , transferId ); const transfer = await transferQuery . first ({ useMasterKey : true }); if ( ! transfer ) { throw new Error ( 'Transfer not found' ); } // Mint tokens on destination network const mintResult = await mintTokensOnDestination ({ network : transfer.get ( 'toNetwork' ), tokenAddress : transfer.get ( 'tokenAddress' ), tokenType : transfer.get ( 'tokenType' ), amount : transfer.get ( 'amount' ), tokenId : transfer.get ( 'tokenId' ), recipient : transfer.get ( 'recipient' ), transferId }); if ( ! mintResult . success ) { transfer . set ( 'status' , 'failed' ); transfer . set ( 'errorMessage' , mintResult . message ); await transfer . save (); // Initiate refund process await initiateRefund ( transferId ); return ; } // Update transfer status transfer . set ( 'status' , 'completed' ); transfer . set ( 'destinationTxHash' , mintResult . txHash ); transfer . set ( 'completedAt' , new Date ()); await transfer . save (); // Send completion notification await sendBridgeCompletionNotification ( transfer ); // Update bridge statistics await updateBridgeStats ( transfer ); } catch ( error ) { console . error ( 'Bridge completion error:' , error ); // Mark transfer as failed and initiate refund const transfer = await new Parse . Query ( 'BridgeTransfer' ) . equalTo ( 'transferId' , transferId ) . first ({ useMasterKey : true }); if ( transfer ) { transfer . set ( 'status' , 'failed' ); transfer . set ( 'errorMessage' , error . message ); await transfer . save (); await initiateRefund ( transferId ); } } }","title":"Bridge Completion"},{"location":"cloud-functions/bridge/#security-features_1","text":"","title":"Security Features"},{"location":"cloud-functions/bridge/#multi-signature-validation","text":"function getRequiredValidatorCount ( amount : string ) : number { const amountBN = new Parse . Cloud . BigNumber ( amount ); // Require more validators for larger amounts if ( amountBN . gte ( '1000000000000000000000' )) { // >= 1000 tokens return 5 ; } else if ( amountBN . gte ( '100000000000000000000' )) { // >= 100 tokens return 3 ; } else { return 2 ; } } async function verifyValidatorSignature ( transferId : string , signature : string , validatorAddress : string ) : Promise < boolean > { try { // Reconstruct the message that should have been signed const message = `bridge_transfer_ ${ transferId } ` ; const messageHash = Parse . Cloud . keccak256 ( message ); // Recover signer address from signature const recoveredAddress = Parse . Cloud . recoverAddress ( messageHash , signature ); return recoveredAddress . toLowerCase () === validatorAddress . toLowerCase (); } catch ( error ) { console . error ( 'Signature verification error:' , error ); return false ; } }","title":"Multi-Signature Validation"},{"location":"cloud-functions/bridge/#rate-limiting-and-fraud-detection","text":"async function validateTransferParams ( params : any ) : Promise < void > { const { fromNetwork , toNetwork , tokenAddress , amount , recipient } = params ; // Check daily transfer limits const dailyLimit = await getDailyTransferLimit ( fromNetwork , toNetwork ); const dailyVolume = await getDailyTransferVolume ( fromNetwork , toNetwork ); if ( dailyVolume . plus ( amount ). gt ( dailyLimit )) { throw new Error ( 'Daily transfer limit exceeded' ); } // Check recipient address if ( ! isValidAddress ( recipient )) { throw new Error ( 'Invalid recipient address' ); } // Check for suspicious patterns const suspiciousActivity = await detectSuspiciousActivity ( params ); if ( suspiciousActivity . detected ) { throw new Error ( `Suspicious activity detected: ${ suspiciousActivity . reason } ` ); } // Validate token contract const tokenValidation = await validateTokenContract ( fromNetwork , tokenAddress ); if ( ! tokenValidation . valid ) { throw new Error ( 'Invalid or unsupported token contract' ); } } async function detectSuspiciousActivity ( params : any ) : Promise < { detected : boolean ; reason? : string } > { // Check for rapid successive transfers const recentTransfers = await new Parse . Query ( 'BridgeTransfer' ) . equalTo ( 'user' , Parse . User . current ()) . greaterThan ( 'createdAt' , new Date ( Date . now () - 300000 )) // Last 5 minutes . count ({ useMasterKey : true }); if ( recentTransfers > 5 ) { return { detected : true , reason : 'Too many transfers in short time period' }; } // Check for unusual amounts const amountBN = new Parse . Cloud . BigNumber ( params . amount ); const userHistory = await getUserTransferHistory ( Parse . User . current (). id ); if ( userHistory . averageAmount . gt ( 0 ) && amountBN . gt ( userHistory . averageAmount . times ( 10 ))) { return { detected : true , reason : 'Transfer amount significantly higher than usual' }; } return { detected : false }; }","title":"Rate Limiting and Fraud Detection"},{"location":"cloud-functions/bridge/#liquidity-management","text":"","title":"Liquidity Management"},{"location":"cloud-functions/bridge/#liquidity-pool-operations","text":"Parse . Cloud . define ( 'getBridgeLiquidity' , async ( request ) => { const { network , tokenAddress } = request . params ; try { // Get liquidity pool information const liquidityPool = await getLiquidityPool ( network , tokenAddress ); if ( ! liquidityPool ) { throw new Error ( 'Liquidity pool not found' ); } const availableLiquidity = liquidityPool . get ( 'availableBalance' ); const totalLiquidity = liquidityPool . get ( 'totalBalance' ); const utilizationRate = calculateUtilizationRate ( availableLiquidity , totalLiquidity ); return { success : true , availableLiquidity , totalLiquidity , utilizationRate , message : 'Liquidity information retrieved successfully' }; } catch ( error ) { console . error ( 'Liquidity check error:' , error ); return { success : false , message : error.message || 'Failed to get liquidity information' }; } }); async function checkBridgeLiquidity ( network : string , tokenAddress : string , amount : string ) : Promise < { sufficient : boolean ; available : string } > { const liquidityPool = await getLiquidityPool ( network , tokenAddress ); if ( ! liquidityPool ) { return { sufficient : false , available : '0' }; } const availableBalance = liquidityPool . get ( 'availableBalance' ); const amountBN = new Parse . Cloud . BigNumber ( amount ); const availableBN = new Parse . Cloud . BigNumber ( availableBalance ); return { sufficient : availableBN.gte ( amountBN ), available : availableBalance }; }","title":"Liquidity Pool Operations"},{"location":"cloud-functions/bridge/#error-handling","text":"","title":"Error Handling"},{"location":"cloud-functions/bridge/#common-errors","text":"\"Unsupported network\" : Network not supported by bridge \"Insufficient balance or allowance\" : User lacks sufficient tokens or approval \"Insufficient bridge liquidity\" : Not enough liquidity on destination network \"Daily transfer limit exceeded\" : Transfer exceeds daily limits \"Suspicious activity detected\" : Fraud detection triggered","title":"Common Errors"},{"location":"cloud-functions/bridge/#error-recovery","text":"async function initiateRefund ( transferId : string ) : Promise < void > { try { const transfer = await new Parse . Query ( 'BridgeTransfer' ) . equalTo ( 'transferId' , transferId ) . first ({ useMasterKey : true }); if ( ! transfer ) { throw new Error ( 'Transfer not found' ); } // Unlock tokens on source network const unlockResult = await unlockTokensOnSource ({ network : transfer.get ( 'fromNetwork' ), tokenAddress : transfer.get ( 'tokenAddress' ), tokenType : transfer.get ( 'tokenType' ), amount : transfer.get ( 'amount' ), tokenId : transfer.get ( 'tokenId' ), user : transfer.get ( 'user' ). get ( 'walletAddress' ), transferId }); if ( unlockResult . success ) { transfer . set ( 'status' , 'refunded' ); transfer . set ( 'refundTxHash' , unlockResult . txHash ); transfer . set ( 'refundedAt' , new Date ()); await transfer . save (); // Send refund notification await sendRefundNotification ( transfer ); } } catch ( error ) { console . error ( 'Refund error:' , error ); } }","title":"Error Recovery"},{"location":"cloud-functions/bridge/#integration-examples","text":"","title":"Integration Examples"},{"location":"cloud-functions/bridge/#frontend-integration","text":"class BridgeService { async initiateBridgeTransfer ( params : BridgeTransferRequest ) : Promise < BridgeTransferResponse > { return await Parse . Cloud . run ( 'initiateBridgeTransfer' , params ); } async getBridgeStatus ( transferId : string ) : Promise < BridgeStatusResponse > { return await Parse . Cloud . run ( 'getBridgeStatus' , { transferId }); } async getBridgeLiquidity ( network : string , tokenAddress : string ) : Promise < BridgeLiquidityResponse > { return await Parse . Cloud . run ( 'getBridgeLiquidity' , { network , tokenAddress }); } async estimateBridgeFee ( fromNetwork : string , toNetwork : string , tokenType : string , amount : string ) : Promise < string > { const result = await Parse . Cloud . run ( 'estimateBridgeFee' , { fromNetwork , toNetwork , tokenType , amount }); return result . fee ; } }","title":"Frontend Integration"},{"location":"cloud-functions/bridge/#react-component-example","text":"export function BridgeTransfer () { const [ transfer , setTransfer ] = useState < BridgeTransferRequest > ({ fromNetwork : 'ethereum' , toNetwork : 'polygon' , tokenAddress : '' , tokenType : 'ERC20' , amount : '' , recipient : '' }); const handleBridgeTransfer = async () => { try { const result = await new BridgeService (). initiateBridgeTransfer ( transfer ); if ( result . success ) { // Show success message and transfer ID console . log ( 'Transfer initiated:' , result . transferId ); } else { // Show error message console . error ( 'Transfer failed:' , result . message ); } } catch ( error ) { console . error ( 'Bridge error:' , error ); } }; return ( < div > { /* Bridge transfer form */ } < form onSubmit = { handleBridgeTransfer } > { /* Form fields */ } < /form> < /div> ); }","title":"React Component Example"},{"location":"cloud-functions/bridge/#best-practices","text":"","title":"Best Practices"},{"location":"cloud-functions/bridge/#security-guidelines","text":"Multi-Signature Validation : Always require multiple validator signatures Rate Limiting : Implement transfer rate limits and daily caps Fraud Detection : Monitor for suspicious transfer patterns Liquidity Management : Maintain adequate liquidity across networks","title":"Security Guidelines"},{"location":"cloud-functions/bridge/#development-guidelines","text":"Error Handling : Implement comprehensive error handling and recovery Event Logging : Log all bridge operations for auditing Testing : Thoroughly test cross-chain operations on testnets Monitoring : Monitor bridge health and performance metrics","title":"Development Guidelines"},{"location":"cloud-functions/bridge/#related-documentation","text":"Blockchain Functions DFNS Integration Contract Functions Cross-Chain Integration Guide Bridge Security Guide","title":"Related Documentation"},{"location":"cloud-functions/bridge/#security-considerations","text":"Multi-Signature Validation : Multiple validators required for transfers Time Locks : Large transfers subject to time delays Rate Limiting : Daily and hourly transfer limits Fraud Detection : Automated suspicious activity detection Liquidity Management : Secure liquidity pool operations Audit Trail : Complete audit trail for all bridge operations","title":"Security Considerations"},{"location":"cloud-functions/contracts/","text":"Contract Cloud Functions \u00b6 Overview \u00b6 The contracts.ts module provides Parse Server cloud functions for interacting with smart contracts on various blockchain networks. These functions enable secure contract operations, diamond facet management, and flexible contract interaction patterns through a unified API. Module Details \u00b6 File : src/cloud-functions/contracts.ts Framework : Parse Server Cloud Functions Language : TypeScript Dependencies : Contract utilities, Diamond utilities Key Features \u00b6 \ud83d\udd39 Diamond Contract Management \u00b6 Add facets to diamond contracts dynamically Support for EIP-2535 Diamond Standard operations Network-agnostic diamond management \ud83d\udd39 Generic Contract Interaction \u00b6 Call state-changing contract methods Query read-only contract methods Support for custom ABIs and contract addresses \ud83d\udd39 Smart Contract Loading \u00b6 Load contract configurations for specific networks Batch loading of multiple contracts Network-specific contract resolution \ud83d\udd39 Flexible Parameter Handling \u00b6 Support for custom private keys Optional parameter validation Value transfer support for payable functions Cloud Functions \u00b6 Diamond Management Functions \u00b6 addDiamondFacet \u00b6 Parse . Cloud . define ( \"addDiamondFacet\" , async ( request : any ) => { const { networkId , diamondAddress , privateKey , facetName } = request . params ; // Implementation details... }); Purpose : Adds a new facet to an existing diamond contract. Parameters : - networkId (string): Target blockchain network identifier - diamondAddress (string): Address of the diamond contract - privateKey (string, optional): Private key for transaction signing - facetName (string): Name of the facet to add Returns : Transaction result with facet addition details Access Control : Requires valid private key with diamond owner permissions Example Usage : // Add marketplace facet to diamond const result = await Parse . Cloud . run ( \"addDiamondFacet\" , { networkId : \"baseSepolia\" , diamondAddress : \"0x1234567890123456789012345678901234567890\" , facetName : \"MarketplaceFacet\" }); console . log ( \"Facet added:\" , result . transactionHash ); Process : 1. Validates network and diamond address 2. Resolves private key (uses default if not provided) 3. Loads facet contract for the specified network 4. Executes diamond cut operation to add facet 5. Returns transaction details Error Conditions : - Invalid network ID - Diamond contract not found - Insufficient permissions - Facet already exists - Transaction failure Generic Contract Functions \u00b6 callMethod \u00b6 Parse . Cloud . define ( \"callMethod\" , async ( request : any ) => { const { methodName , params , privateKey } = request . params ; // Implementation details... }); Purpose : Calls a state-changing method on a pre-configured contract. Parameters : - methodName (string): Name of the contract method to call - params (array): Array of parameters for the method - privateKey (string, optional): Private key for transaction signing Returns : Transaction result with method execution details Example Usage : // Call mint function on NFT contract const result = await Parse . Cloud . run ( \"callMethod\" , { methodName : \"mint\" , params : [ \"0xRecipientAddress\" , \"tokenURI\" ], privateKey : \"0x...\" // Optional }); console . log ( \"Mint transaction:\" , result . transactionHash ); Use Cases : - Token minting operations - Marketplace listing creation - Identity claim management - Trade deal operations viewMethod \u00b6 Parse . Cloud . define ( \"viewMethod\" , async ( request : any ) => { const { methodName , params } = request . params ; // Implementation details... }); Purpose : Calls a read-only method on a pre-configured contract. Parameters : - methodName (string): Name of the view method to call - params (array): Array of parameters for the method Returns : Method return value(s) Example Usage : // Get token balance const balance = await Parse . Cloud . run ( \"viewMethod\" , { methodName : \"balanceOf\" , params : [ \"0xUserAddress\" ] }); console . log ( \"Token balance:\" , balance ); Use Cases : - Balance queries - Token metadata retrieval - Contract state inspection - Verification checks Custom Contract Functions \u00b6 callContractMethod \u00b6 Parse . Cloud . define ( \"callContractMethod\" , async ( request : any ) => { const { providerUrl , privateKey , abi , address , functionName , params , value } = request . params ; // Implementation details... }); Purpose : Calls a state-changing method on any contract with custom ABI. Parameters : - providerUrl (string): Blockchain RPC endpoint URL - privateKey (string): Private key for transaction signing - abi (array): Contract ABI definition - address (string): Contract address - functionName (string): Name of the function to call - params (array): Function parameters - value (string, optional): ETH value to send with transaction Returns : Transaction result with execution details Example Usage : // Call custom contract function const result = await Parse . Cloud . run ( \"callContractMethod\" , { providerUrl : \"https://sepolia.base.org\" , privateKey : \"0x...\" , abi : contractABI , address : \"0xContractAddress\" , functionName : \"customFunction\" , params : [ \"param1\" , \"param2\" ], value : \"1000000000000000000\" // 1 ETH in wei }); Use Cases : - Integration with external contracts - Custom protocol interactions - Multi-network operations - Advanced contract testing viewContractMethod \u00b6 Parse . Cloud . define ( \"viewContractMethod\" , async ( request : any ) => { const { providerUrl , abi , address , functionName , params } = request . params ; // Implementation details... }); Purpose : Calls a read-only method on any contract with custom ABI. Parameters : - providerUrl (string): Blockchain RPC endpoint URL - abi (array): Contract ABI definition - address (string): Contract address - functionName (string): Name of the view function to call - params (array): Function parameters Returns : Function return value(s) Example Usage : // Query custom contract state const result = await Parse . Cloud . run ( \"viewContractMethod\" , { providerUrl : \"https://sepolia.base.org\" , abi : contractABI , address : \"0xContractAddress\" , functionName : \"getCustomData\" , params : [ \"queryParam\" ] }); console . log ( \"Custom data:\" , result ); Use Cases : - External contract queries - Cross-protocol data retrieval - Multi-network state inspection - Integration testing Contract Loading Functions \u00b6 loadSmartContractForNetwork \u00b6 Parse . Cloud . define ( \"loadSmartContractForNetwork\" , async ( request : any ) => { const { smartContractName , networkId } = request . params ; // Implementation details... }); Purpose : Loads contract configuration for a specific contract on a specific network. Parameters : - smartContractName (string): Name of the smart contract - networkId (string): Target network identifier Returns : Contract configuration including address, ABI, and metadata Example Usage : // Load diamond contract for Base Sepolia const contract = await Parse . Cloud . run ( \"loadSmartContractForNetwork\" , { smartContractName : \"Diamond\" , networkId : \"baseSepolia\" }); console . log ( \"Diamond address:\" , contract . address ); console . log ( \"Diamond ABI:\" , contract . abi ); Use Cases : - Dynamic contract loading - Network-specific configurations - Contract address resolution - ABI retrieval for frontend loadSmartContractsForNetwork \u00b6 Parse . Cloud . define ( \"loadSmartContractsForNetwork\" , async ( request : any ) => { const { networkId } = request . params ; // Implementation details... }); Purpose : Loads all available contract configurations for a specific network. Parameters : - networkId (string): Target network identifier Returns : Object containing all contract configurations for the network Example Usage : // Load all contracts for Base Sepolia const contracts = await Parse . Cloud . run ( \"loadSmartContractsForNetwork\" , { networkId : \"baseSepolia\" }); console . log ( \"Available contracts:\" , Object . keys ( contracts )); console . log ( \"Diamond address:\" , contracts . Diamond . address ); console . log ( \"USDC address:\" , contracts . USDC . address ); Use Cases : - Bulk contract loading - Network initialization - Frontend contract registry - Development environment setup Integration Examples \u00b6 Diamond Facet Management \u00b6 // Complete diamond facet management workflow class DiamondManager { async addFacetToDiamond ( networkId , diamondAddress , facetName ) { try { // Add the facet const result = await Parse . Cloud . run ( \"addDiamondFacet\" , { networkId , diamondAddress , facetName }); console . log ( ` ${ facetName } added to diamond:` , result . transactionHash ); // Verify facet was added const diamond = await Parse . Cloud . run ( \"loadSmartContractForNetwork\" , { smartContractName : \"Diamond\" , networkId }); // Check if facet functions are available const facetFunctions = await Parse . Cloud . run ( \"viewContractMethod\" , { providerUrl : this . getProviderUrl ( networkId ), abi : diamond . abi , address : diamondAddress , functionName : \"facetFunctionSelectors\" , params : [ facetName ] }); console . log ( ` ${ facetName } functions:` , facetFunctions ); return result ; } catch ( error ) { console . error ( \"Failed to add facet:\" , error ); throw error ; } } } Multi-Network Contract Interaction \u00b6 // Interact with contracts across multiple networks class MultiNetworkContractManager { async deployToAllNetworks ( contractName , constructorParams ) { const networks = [ \"baseSepolia\" , \"optimismSepolia\" , \"sepolia\" ]; const deployments = {}; for ( const networkId of networks ) { try { // Load network-specific configuration const contracts = await Parse . Cloud . run ( \"loadSmartContractsForNetwork\" , { networkId }); // Deploy contract const result = await Parse . Cloud . run ( \"callContractMethod\" , { providerUrl : this . getProviderUrl ( networkId ), privateKey : this . getPrivateKey ( networkId ), abi : contracts [ contractName ]. abi , address : contracts . ContractFactory . address , functionName : \"deploy\" , params : constructorParams }); deployments [ networkId ] = result ; console . log ( `Deployed to ${ networkId } :` , result . contractAddress ); } catch ( error ) { console . error ( `Failed to deploy to ${ networkId } :` , error ); deployments [ networkId ] = { error : error . message }; } } return deployments ; } } Custom Contract Integration \u00b6 // Integrate with external protocols class ExternalProtocolIntegration { async interactWithUniswap ( tokenA , tokenB , amount ) { const uniswapABI = [ // Uniswap V3 Router ABI \"function exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160)) external payable returns (uint256)\" ]; const swapParams = { tokenIn : tokenA , tokenOut : tokenB , fee : 3000 , // 0.3% recipient : this . userAddress , deadline : Math . floor ( Date . now () / 1000 ) + 3600 , amountIn : amount , amountOutMinimum : 0 , sqrtPriceLimitX96 : 0 }; const result = await Parse . Cloud . run ( \"callContractMethod\" , { providerUrl : \"https://mainnet.base.org\" , privateKey : this . privateKey , abi : uniswapABI , address : \"0xUniswapV3RouterAddress\" , functionName : \"exactInputSingle\" , params : [ swapParams ] }); return result ; } } Contract State Monitoring \u00b6 // Monitor contract state changes class ContractMonitor { async monitorDiamondState ( networkId , diamondAddress ) { const contracts = await Parse . Cloud . run ( \"loadSmartContractsForNetwork\" , { networkId }); const diamond = contracts . Diamond ; // Get current facets const facets = await Parse . Cloud . run ( \"viewContractMethod\" , { providerUrl : this . getProviderUrl ( networkId ), abi : diamond . abi , address : diamondAddress , functionName : \"facets\" , params : [] }); console . log ( \"Current facets:\" , facets ); // Monitor for changes setInterval ( async () => { const currentFacets = await Parse . Cloud . run ( \"viewContractMethod\" , { providerUrl : this . getProviderUrl ( networkId ), abi : diamond . abi , address : diamondAddress , functionName : \"facets\" , params : [] }); if ( JSON . stringify ( currentFacets ) !== JSON . stringify ( facets )) { console . log ( \"Diamond facets changed:\" , currentFacets ); this . handleFacetChange ( currentFacets ); } }, 30000 ); // Check every 30 seconds } } Security Considerations \u00b6 Private Key Management \u00b6 Private keys are handled securely through utility functions Default private key fallback for authorized operations No private key logging or exposure in responses Access Control \u00b6 Functions validate network permissions Contract owner verification for sensitive operations Transaction signing validation Input Validation \u00b6 Parameter validation for all contract interactions ABI validation for custom contract calls Network ID validation against supported networks Error Handling \u00b6 Network Errors \u00b6 Invalid network ID validation RPC endpoint connectivity checks Transaction timeout handling Contract Errors \u00b6 Contract existence validation Function signature verification Parameter type checking Transaction Errors \u00b6 Gas estimation and limits Nonce management Transaction failure recovery Performance Optimization \u00b6 Caching \u00b6 Contract ABI caching for repeated calls Network configuration caching Provider connection pooling Batch Operations \u00b6 Multiple contract calls in single request Efficient parameter encoding Optimized gas usage Testing Considerations \u00b6 Unit Tests \u00b6 Individual function testing Parameter validation testing Error condition handling Integration Tests \u00b6 Multi-network deployment testing Diamond facet management workflows External contract integration Load Testing \u00b6 Concurrent request handling Network congestion scenarios Rate limiting validation Related Documentation \u00b6 Blockchain Cloud Functions - Network provider management DFNS Cloud Functions - Wallet-as-a-Service integration Contract Utilities - Underlying contract utilities Diamond Utilities - Diamond management utilities Developer Setup Guide - Environment configuration These cloud functions provide the backbone for secure, scalable smart contract interactions within the Gemforce platform, supporting both standard operations and custom integrations across multiple blockchain networks.","title":"Contract Functions"},{"location":"cloud-functions/contracts/#contract-cloud-functions","text":"","title":"Contract Cloud Functions"},{"location":"cloud-functions/contracts/#overview","text":"The contracts.ts module provides Parse Server cloud functions for interacting with smart contracts on various blockchain networks. These functions enable secure contract operations, diamond facet management, and flexible contract interaction patterns through a unified API.","title":"Overview"},{"location":"cloud-functions/contracts/#module-details","text":"File : src/cloud-functions/contracts.ts Framework : Parse Server Cloud Functions Language : TypeScript Dependencies : Contract utilities, Diamond utilities","title":"Module Details"},{"location":"cloud-functions/contracts/#key-features","text":"","title":"Key Features"},{"location":"cloud-functions/contracts/#diamond-contract-management","text":"Add facets to diamond contracts dynamically Support for EIP-2535 Diamond Standard operations Network-agnostic diamond management","title":"\ud83d\udd39 Diamond Contract Management"},{"location":"cloud-functions/contracts/#generic-contract-interaction","text":"Call state-changing contract methods Query read-only contract methods Support for custom ABIs and contract addresses","title":"\ud83d\udd39 Generic Contract Interaction"},{"location":"cloud-functions/contracts/#smart-contract-loading","text":"Load contract configurations for specific networks Batch loading of multiple contracts Network-specific contract resolution","title":"\ud83d\udd39 Smart Contract Loading"},{"location":"cloud-functions/contracts/#flexible-parameter-handling","text":"Support for custom private keys Optional parameter validation Value transfer support for payable functions","title":"\ud83d\udd39 Flexible Parameter Handling"},{"location":"cloud-functions/contracts/#cloud-functions","text":"","title":"Cloud Functions"},{"location":"cloud-functions/contracts/#diamond-management-functions","text":"","title":"Diamond Management Functions"},{"location":"cloud-functions/contracts/#adddiamondfacet","text":"Parse . Cloud . define ( \"addDiamondFacet\" , async ( request : any ) => { const { networkId , diamondAddress , privateKey , facetName } = request . params ; // Implementation details... }); Purpose : Adds a new facet to an existing diamond contract. Parameters : - networkId (string): Target blockchain network identifier - diamondAddress (string): Address of the diamond contract - privateKey (string, optional): Private key for transaction signing - facetName (string): Name of the facet to add Returns : Transaction result with facet addition details Access Control : Requires valid private key with diamond owner permissions Example Usage : // Add marketplace facet to diamond const result = await Parse . Cloud . run ( \"addDiamondFacet\" , { networkId : \"baseSepolia\" , diamondAddress : \"0x1234567890123456789012345678901234567890\" , facetName : \"MarketplaceFacet\" }); console . log ( \"Facet added:\" , result . transactionHash ); Process : 1. Validates network and diamond address 2. Resolves private key (uses default if not provided) 3. Loads facet contract for the specified network 4. Executes diamond cut operation to add facet 5. Returns transaction details Error Conditions : - Invalid network ID - Diamond contract not found - Insufficient permissions - Facet already exists - Transaction failure","title":"addDiamondFacet"},{"location":"cloud-functions/contracts/#generic-contract-functions","text":"","title":"Generic Contract Functions"},{"location":"cloud-functions/contracts/#callmethod","text":"Parse . Cloud . define ( \"callMethod\" , async ( request : any ) => { const { methodName , params , privateKey } = request . params ; // Implementation details... }); Purpose : Calls a state-changing method on a pre-configured contract. Parameters : - methodName (string): Name of the contract method to call - params (array): Array of parameters for the method - privateKey (string, optional): Private key for transaction signing Returns : Transaction result with method execution details Example Usage : // Call mint function on NFT contract const result = await Parse . Cloud . run ( \"callMethod\" , { methodName : \"mint\" , params : [ \"0xRecipientAddress\" , \"tokenURI\" ], privateKey : \"0x...\" // Optional }); console . log ( \"Mint transaction:\" , result . transactionHash ); Use Cases : - Token minting operations - Marketplace listing creation - Identity claim management - Trade deal operations","title":"callMethod"},{"location":"cloud-functions/contracts/#viewmethod","text":"Parse . Cloud . define ( \"viewMethod\" , async ( request : any ) => { const { methodName , params } = request . params ; // Implementation details... }); Purpose : Calls a read-only method on a pre-configured contract. Parameters : - methodName (string): Name of the view method to call - params (array): Array of parameters for the method Returns : Method return value(s) Example Usage : // Get token balance const balance = await Parse . Cloud . run ( \"viewMethod\" , { methodName : \"balanceOf\" , params : [ \"0xUserAddress\" ] }); console . log ( \"Token balance:\" , balance ); Use Cases : - Balance queries - Token metadata retrieval - Contract state inspection - Verification checks","title":"viewMethod"},{"location":"cloud-functions/contracts/#custom-contract-functions","text":"","title":"Custom Contract Functions"},{"location":"cloud-functions/contracts/#callcontractmethod","text":"Parse . Cloud . define ( \"callContractMethod\" , async ( request : any ) => { const { providerUrl , privateKey , abi , address , functionName , params , value } = request . params ; // Implementation details... }); Purpose : Calls a state-changing method on any contract with custom ABI. Parameters : - providerUrl (string): Blockchain RPC endpoint URL - privateKey (string): Private key for transaction signing - abi (array): Contract ABI definition - address (string): Contract address - functionName (string): Name of the function to call - params (array): Function parameters - value (string, optional): ETH value to send with transaction Returns : Transaction result with execution details Example Usage : // Call custom contract function const result = await Parse . Cloud . run ( \"callContractMethod\" , { providerUrl : \"https://sepolia.base.org\" , privateKey : \"0x...\" , abi : contractABI , address : \"0xContractAddress\" , functionName : \"customFunction\" , params : [ \"param1\" , \"param2\" ], value : \"1000000000000000000\" // 1 ETH in wei }); Use Cases : - Integration with external contracts - Custom protocol interactions - Multi-network operations - Advanced contract testing","title":"callContractMethod"},{"location":"cloud-functions/contracts/#viewcontractmethod","text":"Parse . Cloud . define ( \"viewContractMethod\" , async ( request : any ) => { const { providerUrl , abi , address , functionName , params } = request . params ; // Implementation details... }); Purpose : Calls a read-only method on any contract with custom ABI. Parameters : - providerUrl (string): Blockchain RPC endpoint URL - abi (array): Contract ABI definition - address (string): Contract address - functionName (string): Name of the view function to call - params (array): Function parameters Returns : Function return value(s) Example Usage : // Query custom contract state const result = await Parse . Cloud . run ( \"viewContractMethod\" , { providerUrl : \"https://sepolia.base.org\" , abi : contractABI , address : \"0xContractAddress\" , functionName : \"getCustomData\" , params : [ \"queryParam\" ] }); console . log ( \"Custom data:\" , result ); Use Cases : - External contract queries - Cross-protocol data retrieval - Multi-network state inspection - Integration testing","title":"viewContractMethod"},{"location":"cloud-functions/contracts/#contract-loading-functions","text":"","title":"Contract Loading Functions"},{"location":"cloud-functions/contracts/#loadsmartcontractfornetwork","text":"Parse . Cloud . define ( \"loadSmartContractForNetwork\" , async ( request : any ) => { const { smartContractName , networkId } = request . params ; // Implementation details... }); Purpose : Loads contract configuration for a specific contract on a specific network. Parameters : - smartContractName (string): Name of the smart contract - networkId (string): Target network identifier Returns : Contract configuration including address, ABI, and metadata Example Usage : // Load diamond contract for Base Sepolia const contract = await Parse . Cloud . run ( \"loadSmartContractForNetwork\" , { smartContractName : \"Diamond\" , networkId : \"baseSepolia\" }); console . log ( \"Diamond address:\" , contract . address ); console . log ( \"Diamond ABI:\" , contract . abi ); Use Cases : - Dynamic contract loading - Network-specific configurations - Contract address resolution - ABI retrieval for frontend","title":"loadSmartContractForNetwork"},{"location":"cloud-functions/contracts/#loadsmartcontractsfornetwork","text":"Parse . Cloud . define ( \"loadSmartContractsForNetwork\" , async ( request : any ) => { const { networkId } = request . params ; // Implementation details... }); Purpose : Loads all available contract configurations for a specific network. Parameters : - networkId (string): Target network identifier Returns : Object containing all contract configurations for the network Example Usage : // Load all contracts for Base Sepolia const contracts = await Parse . Cloud . run ( \"loadSmartContractsForNetwork\" , { networkId : \"baseSepolia\" }); console . log ( \"Available contracts:\" , Object . keys ( contracts )); console . log ( \"Diamond address:\" , contracts . Diamond . address ); console . log ( \"USDC address:\" , contracts . USDC . address ); Use Cases : - Bulk contract loading - Network initialization - Frontend contract registry - Development environment setup","title":"loadSmartContractsForNetwork"},{"location":"cloud-functions/contracts/#integration-examples","text":"","title":"Integration Examples"},{"location":"cloud-functions/contracts/#diamond-facet-management","text":"// Complete diamond facet management workflow class DiamondManager { async addFacetToDiamond ( networkId , diamondAddress , facetName ) { try { // Add the facet const result = await Parse . Cloud . run ( \"addDiamondFacet\" , { networkId , diamondAddress , facetName }); console . log ( ` ${ facetName } added to diamond:` , result . transactionHash ); // Verify facet was added const diamond = await Parse . Cloud . run ( \"loadSmartContractForNetwork\" , { smartContractName : \"Diamond\" , networkId }); // Check if facet functions are available const facetFunctions = await Parse . Cloud . run ( \"viewContractMethod\" , { providerUrl : this . getProviderUrl ( networkId ), abi : diamond . abi , address : diamondAddress , functionName : \"facetFunctionSelectors\" , params : [ facetName ] }); console . log ( ` ${ facetName } functions:` , facetFunctions ); return result ; } catch ( error ) { console . error ( \"Failed to add facet:\" , error ); throw error ; } } }","title":"Diamond Facet Management"},{"location":"cloud-functions/contracts/#multi-network-contract-interaction","text":"// Interact with contracts across multiple networks class MultiNetworkContractManager { async deployToAllNetworks ( contractName , constructorParams ) { const networks = [ \"baseSepolia\" , \"optimismSepolia\" , \"sepolia\" ]; const deployments = {}; for ( const networkId of networks ) { try { // Load network-specific configuration const contracts = await Parse . Cloud . run ( \"loadSmartContractsForNetwork\" , { networkId }); // Deploy contract const result = await Parse . Cloud . run ( \"callContractMethod\" , { providerUrl : this . getProviderUrl ( networkId ), privateKey : this . getPrivateKey ( networkId ), abi : contracts [ contractName ]. abi , address : contracts . ContractFactory . address , functionName : \"deploy\" , params : constructorParams }); deployments [ networkId ] = result ; console . log ( `Deployed to ${ networkId } :` , result . contractAddress ); } catch ( error ) { console . error ( `Failed to deploy to ${ networkId } :` , error ); deployments [ networkId ] = { error : error . message }; } } return deployments ; } }","title":"Multi-Network Contract Interaction"},{"location":"cloud-functions/contracts/#custom-contract-integration","text":"// Integrate with external protocols class ExternalProtocolIntegration { async interactWithUniswap ( tokenA , tokenB , amount ) { const uniswapABI = [ // Uniswap V3 Router ABI \"function exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160)) external payable returns (uint256)\" ]; const swapParams = { tokenIn : tokenA , tokenOut : tokenB , fee : 3000 , // 0.3% recipient : this . userAddress , deadline : Math . floor ( Date . now () / 1000 ) + 3600 , amountIn : amount , amountOutMinimum : 0 , sqrtPriceLimitX96 : 0 }; const result = await Parse . Cloud . run ( \"callContractMethod\" , { providerUrl : \"https://mainnet.base.org\" , privateKey : this . privateKey , abi : uniswapABI , address : \"0xUniswapV3RouterAddress\" , functionName : \"exactInputSingle\" , params : [ swapParams ] }); return result ; } }","title":"Custom Contract Integration"},{"location":"cloud-functions/contracts/#contract-state-monitoring","text":"// Monitor contract state changes class ContractMonitor { async monitorDiamondState ( networkId , diamondAddress ) { const contracts = await Parse . Cloud . run ( \"loadSmartContractsForNetwork\" , { networkId }); const diamond = contracts . Diamond ; // Get current facets const facets = await Parse . Cloud . run ( \"viewContractMethod\" , { providerUrl : this . getProviderUrl ( networkId ), abi : diamond . abi , address : diamondAddress , functionName : \"facets\" , params : [] }); console . log ( \"Current facets:\" , facets ); // Monitor for changes setInterval ( async () => { const currentFacets = await Parse . Cloud . run ( \"viewContractMethod\" , { providerUrl : this . getProviderUrl ( networkId ), abi : diamond . abi , address : diamondAddress , functionName : \"facets\" , params : [] }); if ( JSON . stringify ( currentFacets ) !== JSON . stringify ( facets )) { console . log ( \"Diamond facets changed:\" , currentFacets ); this . handleFacetChange ( currentFacets ); } }, 30000 ); // Check every 30 seconds } }","title":"Contract State Monitoring"},{"location":"cloud-functions/contracts/#security-considerations","text":"","title":"Security Considerations"},{"location":"cloud-functions/contracts/#private-key-management","text":"Private keys are handled securely through utility functions Default private key fallback for authorized operations No private key logging or exposure in responses","title":"Private Key Management"},{"location":"cloud-functions/contracts/#access-control","text":"Functions validate network permissions Contract owner verification for sensitive operations Transaction signing validation","title":"Access Control"},{"location":"cloud-functions/contracts/#input-validation","text":"Parameter validation for all contract interactions ABI validation for custom contract calls Network ID validation against supported networks","title":"Input Validation"},{"location":"cloud-functions/contracts/#error-handling","text":"","title":"Error Handling"},{"location":"cloud-functions/contracts/#network-errors","text":"Invalid network ID validation RPC endpoint connectivity checks Transaction timeout handling","title":"Network Errors"},{"location":"cloud-functions/contracts/#contract-errors","text":"Contract existence validation Function signature verification Parameter type checking","title":"Contract Errors"},{"location":"cloud-functions/contracts/#transaction-errors","text":"Gas estimation and limits Nonce management Transaction failure recovery","title":"Transaction Errors"},{"location":"cloud-functions/contracts/#performance-optimization","text":"","title":"Performance Optimization"},{"location":"cloud-functions/contracts/#caching","text":"Contract ABI caching for repeated calls Network configuration caching Provider connection pooling","title":"Caching"},{"location":"cloud-functions/contracts/#batch-operations","text":"Multiple contract calls in single request Efficient parameter encoding Optimized gas usage","title":"Batch Operations"},{"location":"cloud-functions/contracts/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"cloud-functions/contracts/#unit-tests","text":"Individual function testing Parameter validation testing Error condition handling","title":"Unit Tests"},{"location":"cloud-functions/contracts/#integration-tests","text":"Multi-network deployment testing Diamond facet management workflows External contract integration","title":"Integration Tests"},{"location":"cloud-functions/contracts/#load-testing","text":"Concurrent request handling Network congestion scenarios Rate limiting validation","title":"Load Testing"},{"location":"cloud-functions/contracts/#related-documentation","text":"Blockchain Cloud Functions - Network provider management DFNS Cloud Functions - Wallet-as-a-Service integration Contract Utilities - Underlying contract utilities Diamond Utilities - Diamond management utilities Developer Setup Guide - Environment configuration These cloud functions provide the backbone for secure, scalable smart contract interactions within the Gemforce platform, supporting both standard operations and custom integrations across multiple blockchain networks.","title":"Related Documentation"},{"location":"cloud-functions/deploy/","text":"Deploy Functions \u00b6 The Deploy Functions module provides comprehensive deployment capabilities for smart contracts, diamond proxies, and complete project infrastructures on multiple blockchain networks. It handles automated deployment pipelines, configuration management, and post-deployment verification. Overview \u00b6 The Deploy Functions provide: Smart Contract Deployment : Deploy individual contracts and contract suites Diamond Deployment : Deploy and configure diamond proxy contracts Multi-Network Support : Deploy across multiple blockchain networks Configuration Management : Manage deployment configurations and parameters Verification : Automated contract verification and validation Rollback Support : Rollback capabilities for failed deployments Key Features \u00b6 Deployment Types \u00b6 Single Contract : Deploy individual smart contracts Diamond Proxy : Deploy upgradeable diamond contracts Project Suite : Deploy complete project infrastructures Template Deployment : Deploy from predefined templates Network Management \u00b6 Multi-Network : Support for multiple blockchain networks Gas Optimization : Automatic gas price optimization Network Validation : Pre-deployment network validation Cross-Chain Coordination : Coordinate deployments across networks Automation Features \u00b6 Pipeline Automation : Automated deployment pipelines Configuration Validation : Validate deployment configurations Post-Deployment Testing : Automated testing after deployment Monitoring Integration : Integration with monitoring systems Core Functions \u00b6 deployContract() \u00b6 Deploys a single smart contract to a specified network. Parameters: interface DeployContractRequest { contractName : string ; network : string ; constructorArgs? : any []; deploymentConfig ?: { gasLimit? : string ; gasPrice? : string ; confirmations? : number ; timeout? : number ; }; verificationConfig ?: { verify : boolean ; apiKey? : string ; constructorArgsEncoded? : string ; }; metadata ?: { projectId? : string ; version? : string ; description? : string ; }; } Returns: interface DeployContractResponse { success : boolean ; contractAddress? : string ; transactionHash? : string ; gasUsed? : string ; deploymentCost? : string ; verificationStatus ?: 'pending' | 'verified' | 'failed' ; message : string ; } Usage: const result = await Parse . Cloud . run ( 'deployContract' , { contractName : 'MyToken' , network : 'polygon' , constructorArgs : [ 'My Token' , 'MTK' , 18 , '1000000000000000000000000' ], deploymentConfig : { gasLimit : '2000000' , confirmations : 3 }, verificationConfig : { verify : true }, metadata : { projectId : 'proj_123' , version : '1.0.0' , description : 'ERC20 token for my project' } }); deployDiamond() \u00b6 Deploys a diamond proxy contract with specified facets. Parameters: interface DeployDiamondRequest { network : string ; diamondName : string ; facets : FacetDeployment []; initContract? : string ; initData? : string ; owner? : string ; deploymentConfig? : DeploymentConfig ; verificationConfig? : VerificationConfig ; } interface FacetDeployment { name : string ; address? : string ; // If already deployed constructorArgs? : any []; functionSelectors? : string []; } Returns: interface DeployDiamondResponse { success : boolean ; diamondAddress? : string ; facetAddresses ?: { [ facetName : string ] : string }; transactionHashes? : string []; totalGasUsed? : string ; deploymentCost? : string ; message : string ; } deployProject() \u00b6 Deploys a complete project infrastructure including all contracts and configurations. Parameters: interface DeployProjectRequest { projectId : string ; network : string ; deploymentTemplate : string ; configuration : ProjectConfiguration ; deploymentOptions ?: { skipVerification? : boolean ; dryRun? : boolean ; parallelDeployment? : boolean ; rollbackOnFailure? : boolean ; }; } interface ProjectConfiguration { contracts : ContractConfig []; diamonds : DiamondConfig []; initializations : InitializationStep []; permissions : PermissionConfig []; } Returns: interface DeployProjectResponse { success : boolean ; deploymentId : string ; deployedContracts ?: { [ name : string ] : string }; deployedDiamonds ?: { [ name : string ] : string }; totalGasUsed? : string ; deploymentCost? : string ; deploymentTime? : number ; message : string ; } getDeploymentStatus() \u00b6 Retrieves the status of an ongoing or completed deployment. Parameters: interface DeploymentStatusRequest { deploymentId : string ; } Returns: interface DeploymentStatusResponse { success : boolean ; deployment ?: { id : string ; status : 'pending' | 'deploying' | 'completed' | 'failed' | 'rolled_back' ; network : string ; progress : number ; currentStep? : string ; deployedContracts : { [ name : string ] : string }; errors? : string []; startedAt : Date ; completedAt? : Date ; gasUsed : string ; cost : string ; }; message : string ; } rollbackDeployment() \u00b6 Rolls back a failed or problematic deployment. Parameters: interface RollbackDeploymentRequest { deploymentId : string ; reason : string ; preserveData? : boolean ; } Returns: interface RollbackDeploymentResponse { success : boolean ; rollbackTransactionHashes? : string []; message : string ; } Implementation Example \u00b6 Smart Contract Deployment \u00b6 Parse . Cloud . define ( 'deployContract' , async ( request ) => { const { contractName , network , constructorArgs , deploymentConfig , verificationConfig , metadata } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Validate deployment permissions const hasPermission = await checkDeploymentPermissions ( user . id , network ); if ( ! hasPermission ) { throw new Error ( 'Insufficient permissions for deployment' ); } // Validate network if ( ! isSupportedNetwork ( network )) { throw new Error ( 'Unsupported network' ); } // Get contract artifacts const contractArtifacts = await getContractArtifacts ( contractName ); if ( ! contractArtifacts ) { throw new Error ( 'Contract artifacts not found' ); } // Validate constructor arguments if ( constructorArgs ) { await validateConstructorArgs ( contractArtifacts . abi , constructorArgs ); } // Create deployment record const deployment = new Parse . Object ( 'Deployment' ); deployment . set ( 'type' , 'contract' ); deployment . set ( 'contractName' , contractName ); deployment . set ( 'network' , network ); deployment . set ( 'deployer' , user ); deployment . set ( 'status' , 'pending' ); deployment . set ( 'constructorArgs' , constructorArgs ); deployment . set ( 'deploymentConfig' , deploymentConfig ); deployment . set ( 'metadata' , metadata ); deployment . set ( 'createdAt' , new Date ()); await deployment . save (); // Get network configuration const networkConfig = await getNetworkConfig ( network ); const provider = getProvider ( networkConfig ); const wallet = getDeploymentWallet ( networkConfig ); // Estimate gas const gasEstimate = await estimateDeploymentGas ( contractArtifacts , constructorArgs , provider ); // Configure deployment transaction const deploymentTx = { gasLimit : deploymentConfig?.gasLimit || gasEstimate . mul ( 120 ). div ( 100 ), // 20% buffer gasPrice : deploymentConfig?.gasPrice || await provider . getGasPrice (), ... networkConfig . deploymentDefaults }; deployment . set ( 'estimatedGas' , gasEstimate . toString ()); deployment . set ( 'gasPrice' , deploymentTx . gasPrice . toString ()); deployment . set ( 'status' , 'deploying' ); await deployment . save (); // Deploy contract const contractFactory = new ethers . ContractFactory ( contractArtifacts . abi , contractArtifacts . bytecode , wallet ); const contract = await contractFactory . deploy (...( constructorArgs || []), deploymentTx ); deployment . set ( 'transactionHash' , contract . deployTransaction . hash ); await deployment . save (); // Wait for deployment confirmation const confirmations = deploymentConfig ? . confirmations || 3 ; const receipt = await contract . deployTransaction . wait ( confirmations ); deployment . set ( 'contractAddress' , contract . address ); deployment . set ( 'blockNumber' , receipt . blockNumber ); deployment . set ( 'gasUsed' , receipt . gasUsed . toString ()); deployment . set ( 'deploymentCost' , receipt . gasUsed . mul ( deploymentTx . gasPrice ). toString ()); deployment . set ( 'status' , 'deployed' ); deployment . set ( 'deployedAt' , new Date ()); await deployment . save (); // Verify contract if requested let verificationStatus = 'not_requested' ; if ( verificationConfig ? . verify ) { try { const verificationResult = await verifyContract ({ contractAddress : contract.address , contractName , network , constructorArgs , apiKey : verificationConfig.apiKey }); verificationStatus = verificationResult . success ? 'verified' : 'failed' ; deployment . set ( 'verificationStatus' , verificationStatus ); deployment . set ( 'verificationResult' , verificationResult ); await deployment . save (); } catch ( verificationError ) { console . error ( 'Contract verification failed:' , verificationError ); verificationStatus = 'failed' ; } } // Update project if specified if ( metadata ? . projectId ) { await updateProjectDeployment ( metadata . projectId , { contractName , contractAddress : contract.address , network , deploymentId : deployment.id }); } // Send deployment notification await sendDeploymentNotification ( deployment . id , 'completed' ); return { success : true , contractAddress : contract.address , transactionHash : contract.deployTransaction.hash , gasUsed : receipt.gasUsed.toString (), deploymentCost : receipt.gasUsed.mul ( deploymentTx . gasPrice ). toString (), verificationStatus , message : 'Contract deployed successfully' }; } catch ( error ) { console . error ( 'Contract deployment error:' , error ); // Update deployment record with error const deployment = await new Parse . Query ( 'Deployment' ) . equalTo ( 'contractName' , contractName ) . equalTo ( 'deployer' , user ) . equalTo ( 'status' , 'deploying' ) . first ({ useMasterKey : true }); if ( deployment ) { deployment . set ( 'status' , 'failed' ); deployment . set ( 'errorMessage' , error . message ); deployment . set ( 'failedAt' , new Date ()); await deployment . save (); } return { success : false , message : error.message || 'Contract deployment failed' }; } }); Diamond Deployment \u00b6 Parse . Cloud . define ( 'deployDiamond' , async ( request ) => { const { network , diamondName , facets , initContract , initData , owner , deploymentConfig , verificationConfig } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Validate deployment permissions const hasPermission = await checkDeploymentPermissions ( user . id , network ); if ( ! hasPermission ) { throw new Error ( 'Insufficient permissions for deployment' ); } // Create deployment record const deployment = new Parse . Object ( 'Deployment' ); deployment . set ( 'type' , 'diamond' ); deployment . set ( 'diamondName' , diamondName ); deployment . set ( 'network' , network ); deployment . set ( 'deployer' , user ); deployment . set ( 'status' , 'pending' ); deployment . set ( 'facets' , facets ); deployment . set ( 'createdAt' , new Date ()); await deployment . save (); const deployedContracts : { [ name : string ] : string } = {}; const transactionHashes : string [] = []; let totalGasUsed = ethers . BigNumber . from ( 0 ); // Get network configuration const networkConfig = await getNetworkConfig ( network ); const provider = getProvider ( networkConfig ); const wallet = getDeploymentWallet ( networkConfig ); deployment . set ( 'status' , 'deploying' ); await deployment . save (); // Deploy core diamond contracts first const diamondCutFacet = await deployCoreFacet ( 'DiamondCutFacet' , wallet , deploymentConfig ); deployedContracts [ 'DiamondCutFacet' ] = diamondCutFacet . address ; transactionHashes . push ( diamondCutFacet . deployTransaction . hash ); totalGasUsed = totalGasUsed . add ( await diamondCutFacet . deployTransaction . wait (). then ( r => r . gasUsed )); const diamondLoupeFacet = await deployCoreFacet ( 'DiamondLoupeFacet' , wallet , deploymentConfig ); deployedContracts [ 'DiamondLoupeFacet' ] = diamondLoupeFacet . address ; transactionHashes . push ( diamondLoupeFacet . deployTransaction . hash ); totalGasUsed = totalGasUsed . add ( await diamondLoupeFacet . deployTransaction . wait (). then ( r => r . gasUsed )); const ownershipFacet = await deployCoreFacet ( 'OwnershipFacet' , wallet , deploymentConfig ); deployedContracts [ 'OwnershipFacet' ] = ownershipFacet . address ; transactionHashes . push ( ownershipFacet . deployTransaction . hash ); totalGasUsed = totalGasUsed . add ( await ownershipFacet . deployTransaction . wait (). then ( r => r . gasUsed )); // Deploy custom facets for ( const facet of facets ) { if ( ! facet . address ) { const facetContract = await deployFacet ( facet , wallet , deploymentConfig ); deployedContracts [ facet . name ] = facetContract . address ; transactionHashes . push ( facetContract . deployTransaction . hash ); totalGasUsed = totalGasUsed . add ( await facetContract . deployTransaction . wait (). then ( r => r . gasUsed )); } else { deployedContracts [ facet . name ] = facet . address ; } } // Prepare diamond cut for initialization const diamondCut = prepareDiamondCut ([ { facetAddress : diamondCutFacet.address , action : 0 , // Add functionSelectors : getDiamondCutSelectors () }, { facetAddress : diamondLoupeFacet.address , action : 0 , // Add functionSelectors : getDiamondLoupeSelectors () }, { facetAddress : ownershipFacet.address , action : 0 , // Add functionSelectors : getOwnershipSelectors () }, ... facets . map ( facet => ({ facetAddress : deployedContracts [ facet . name ], action : 0 , // Add functionSelectors : facet.functionSelectors || getFacetSelectors ( facet . name ) })) ]); // Deploy diamond const diamondFactory = await getDiamondFactory ( wallet ); const diamondTx = await diamondFactory . deployDiamond ( owner || wallet . address , diamondCut , initContract || ethers . constants . AddressZero , initData || '0x' , deploymentConfig || {} ); const diamondReceipt = await diamondTx . wait (); const diamondAddress = await getDiamondAddressFromReceipt ( diamondReceipt ); deployedContracts [ 'Diamond' ] = diamondAddress ; transactionHashes . push ( diamondTx . hash ); totalGasUsed = totalGasUsed . add ( diamondReceipt . gasUsed ); // Update deployment record deployment . set ( 'diamondAddress' , diamondAddress ); deployment . set ( 'deployedContracts' , deployedContracts ); deployment . set ( 'transactionHashes' , transactionHashes ); deployment . set ( 'totalGasUsed' , totalGasUsed . toString ()); deployment . set ( 'status' , 'deployed' ); deployment . set ( 'deployedAt' , new Date ()); await deployment . save (); // Verify contracts if requested if ( verificationConfig ? . verify ) { await verifyDiamondContracts ( deployedContracts , network , verificationConfig ); } // Send deployment notification await sendDeploymentNotification ( deployment . id , 'completed' ); return { success : true , diamondAddress , facetAddresses : deployedContracts , transactionHashes , totalGasUsed : totalGasUsed.toString (), deploymentCost : totalGasUsed.mul ( await provider . getGasPrice ()). toString (), message : 'Diamond deployed successfully' }; } catch ( error ) { console . error ( 'Diamond deployment error:' , error ); // Update deployment record with error const deployment = await new Parse . Query ( 'Deployment' ) . equalTo ( 'diamondName' , diamondName ) . equalTo ( 'deployer' , user ) . equalTo ( 'status' , 'deploying' ) . first ({ useMasterKey : true }); if ( deployment ) { deployment . set ( 'status' , 'failed' ); deployment . set ( 'errorMessage' , error . message ); deployment . set ( 'failedAt' , new Date ()); await deployment . save (); } return { success : false , message : error.message || 'Diamond deployment failed' }; } }); Project Deployment \u00b6 Parse . Cloud . define ( 'deployProject' , async ( request ) => { const { projectId , network , deploymentTemplate , configuration , deploymentOptions } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Get project const project = await new Parse . Query ( 'Project' ) . equalTo ( 'objectId' , projectId ) . first ({ useMasterKey : true }); if ( ! project ) { throw new Error ( 'Project not found' ); } // Check project access const hasAccess = await checkProjectAccess ( projectId , user . id ); if ( ! hasAccess ) { throw new Error ( 'Access denied' ); } // Create deployment record const deploymentId = generateDeploymentId (); const deployment = new Parse . Object ( 'ProjectDeployment' ); deployment . set ( 'deploymentId' , deploymentId ); deployment . set ( 'project' , project ); deployment . set ( 'network' , network ); deployment . set ( 'template' , deploymentTemplate ); deployment . set ( 'configuration' , configuration ); deployment . set ( 'deployer' , user ); deployment . set ( 'status' , 'pending' ); deployment . set ( 'createdAt' , new Date ()); await deployment . save (); // Validate deployment configuration await validateProjectConfiguration ( configuration , deploymentTemplate ); // Perform dry run if requested if ( deploymentOptions ? . dryRun ) { const dryRunResult = await performDryRun ( configuration , network ); return { success : true , deploymentId , dryRunResult , message : 'Dry run completed successfully' }; } deployment . set ( 'status' , 'deploying' ); await deployment . save (); const deployedContracts : { [ name : string ] : string } = {}; const deployedDiamonds : { [ name : string ] : string } = {}; let totalGasUsed = ethers . BigNumber . from ( 0 ); const startTime = Date . now (); try { // Deploy contracts in dependency order for ( const contractConfig of configuration . contracts ) { const contractResult = await Parse . Cloud . run ( 'deployContract' , { contractName : contractConfig.name , network , constructorArgs : contractConfig.constructorArgs , deploymentConfig : contractConfig.deploymentConfig , verificationConfig : { verify : ! deploymentOptions ? . skipVerification } }); if ( ! contractResult . success ) { throw new Error ( `Failed to deploy ${ contractConfig . name } : ${ contractResult . message } ` ); } deployedContracts [ contractConfig . name ] = contractResult . contractAddress ; totalGasUsed = totalGasUsed . add ( contractResult . gasUsed || '0' ); // Update deployment progress deployment . set ( 'currentStep' , `Deployed ${ contractConfig . name } ` ); deployment . set ( 'deployedContracts' , deployedContracts ); await deployment . save (); } // Deploy diamonds for ( const diamondConfig of configuration . diamonds ) { const diamondResult = await Parse . Cloud . run ( 'deployDiamond' , { network , diamondName : diamondConfig.name , facets : diamondConfig.facets , initContract : diamondConfig.initContract , initData : diamondConfig.initData , owner : diamondConfig.owner , verificationConfig : { verify : ! deploymentOptions ? . skipVerification } }); if ( ! diamondResult . success ) { throw new Error ( `Failed to deploy ${ diamondConfig . name } : ${ diamondResult . message } ` ); } deployedDiamonds [ diamondConfig . name ] = diamondResult . diamondAddress ; totalGasUsed = totalGasUsed . add ( diamondResult . totalGasUsed || '0' ); // Update deployment progress deployment . set ( 'currentStep' , `Deployed ${ diamondConfig . name } ` ); deployment . set ( 'deployedDiamonds' , deployedDiamonds ); await deployment . save (); } // Execute initialization steps for ( const initStep of configuration . initializations ) { await executeInitializationStep ( initStep , deployedContracts , deployedDiamonds , network ); deployment . set ( 'currentStep' , `Executed ${ initStep . name } ` ); await deployment . save (); } // Configure permissions for ( const permissionConfig of configuration . permissions ) { await configurePermissions ( permissionConfig , deployedContracts , deployedDiamonds , network ); deployment . set ( 'currentStep' , `Configured ${ permissionConfig . name } ` ); await deployment . save (); } const deploymentTime = Date . now () - startTime ; // Update deployment record deployment . set ( 'status' , 'completed' ); deployment . set ( 'deployedContracts' , deployedContracts ); deployment . set ( 'deployedDiamonds' , deployedDiamonds ); deployment . set ( 'totalGasUsed' , totalGasUsed . toString ()); deployment . set ( 'deploymentTime' , deploymentTime ); deployment . set ( 'completedAt' , new Date ()); await deployment . save (); // Update project with deployment information project . set ( 'deployments' , [...( project . get ( 'deployments' ) || []), { deploymentId , network , status : 'completed' , deployedAt : new Date (), contracts : deployedContracts , diamonds : deployedDiamonds }]); await project . save (); // Send deployment notification await sendDeploymentNotification ( deploymentId , 'completed' ); return { success : true , deploymentId , deployedContracts , deployedDiamonds , totalGasUsed : totalGasUsed.toString (), deploymentCost : totalGasUsed.mul ( await getNetworkGasPrice ( network )). toString (), deploymentTime , message : 'Project deployed successfully' }; } catch ( deploymentError ) { // Handle deployment failure if ( deploymentOptions ? . rollbackOnFailure ) { await rollbackProjectDeployment ( deploymentId , deployedContracts , deployedDiamonds ); } deployment . set ( 'status' , 'failed' ); deployment . set ( 'errorMessage' , deploymentError . message ); deployment . set ( 'failedAt' , new Date ()); await deployment . save (); throw deploymentError ; } } catch ( error ) { console . error ( 'Project deployment error:' , error ); return { success : false , message : error.message || 'Project deployment failed' }; } }); Deployment Templates \u00b6 NFT Collection Template \u00b6 const nftCollectionTemplate = { name : 'NFT Collection' , description : 'Complete NFT collection with marketplace' , contracts : [ { name : 'CollectionToken' , type : 'ERC721' , constructorArgs : [ '{{tokenName}}' , '{{tokenSymbol}}' , '{{baseURI}}' ], deploymentConfig : { gasLimit : '3000000' } } ], diamonds : [ { name : 'CollectionDiamond' , facets : [ { name : 'ERC721Facet' }, { name : 'MarketplaceFacet' }, { name : 'MetadataFacet' }, { name : 'OwnershipFacet' } ], initContract : 'CollectionInit' , initData : '{{initData}}' } ], initializations : [ { name : 'SetupMarketplace' , contract : 'CollectionDiamond' , function : 'setupMarketplace' , args : [ '{{marketplaceFee}}' , '{{feeRecipient}}' ] } ], permissions : [ { name : 'MinterRole' , contract : 'CollectionDiamond' , role : 'MINTER_ROLE' , accounts : [ '{{owner}}' ] } ] }; DeFi Protocol Template \u00b6 const defiProtocolTemplate = { name : 'DeFi Protocol' , description : 'DeFi protocol with staking and governance' , contracts : [ { name : 'GovernanceToken' , type : 'ERC20' , constructorArgs : [ '{{tokenName}}' , '{{tokenSymbol}}' , '{{totalSupply}}' ] }, { name : 'Timelock' , type : 'TimelockController' , constructorArgs : [ '{{timelockDelay}}' , [ '{{admin}}' ], [ '{{admin}}' ], '{{admin}}' ] } ], diamonds : [ { name : 'ProtocolDiamond' , facets : [ { name : 'StakingFacet' }, { name : 'GovernanceFacet' }, { name : 'FeeDistributorFacet' }, { name : 'OwnershipFacet' } ] } ], initializations : [ { name : 'SetupStaking' , contract : 'ProtocolDiamond' , function : 'setupStaking' , args : [ '{{stakingToken}}' , '{{rewardRate}}' ] } ] }; Verification and Monitoring \u00b6 Contract Verification \u00b6 async function verifyContract ( params : { contractAddress : string ; contractName : string ; network : string ; constructorArgs? : any []; apiKey? : string ; }) : Promise < { success : boolean ; message : string } > { try { const { contractAddress , contractName , network , constructorArgs , apiKey } = params ; // Get network verification configuration const verificationConfig = getVerificationConfig ( network ); const explorerApiKey = apiKey || verificationConfig . defaultApiKey ; if ( ! explorerApiKey ) { throw new Error ( 'API key required for verification' ); } // Get contract source code and metadata const contractArtifacts = await getContractArtifacts ( contractName ); const sourceCode = await getContractSourceCode ( contractName ); // Prepare verification request const verificationRequest = { apikey : explorerApiKey , module : 'contract' , action : 'verifysourcecode' , contractaddress : contractAddress , sourceCode : sourceCode , codeformat : 'solidity-single-file' , contractname : contractName , compilerversion : contractArtifacts.compiler.version , optimizationUsed : contractArtifacts.compiler.optimizer.enabled ? 1 : 0 , runs : contractArtifacts.compiler.optimizer.runs , constructorArguements : constructorArgs ? encodeConstructorArgs ( constructorArgs ) : '' }; // Submit verification request const response = await submitVerificationRequest ( verificationConfig . apiUrl , verificationRequest ); if ( response . status !== '1' ) { throw new Error ( `Verification submission failed: ${ response . result } ` ); } // Poll for verification result const verificationResult = await pollVerificationResult ( verificationConfig . apiUrl , explorerApiKey , response . result ); return { success : verificationResult.status === '1' , message : verificationResult.result }; } catch ( error ) { console . error ( 'Contract verification error:' , error ); return { success : false , message : error.message || 'Verification failed' }; } } Deployment Monitoring \u00b6 ```typescript Parse.Cloud.define('getDeploymentStatus', async (request) => { const { deploymentId } = request.params; const user = request.user; if (!user) { throw new Error('Authentication required'); } try { // Get deployment record const deployment = await new Parse.Query('Deployment') .equalTo('deploymentId', deploymentId) .first({ useMasterKey: true }); if (!deployment) { throw new Error('Deployment not found'); } // Check access permissions if (deployment.get('deployer').id !== user.id) { const hasAccess = await checkDeploymentAccess(deploymentId, user.id); if (!hasAccess) { throw new Error('Access denied'); } } // Calculate progress const progress = calculateDeploymentProgress(deployment); return { success: true, deployment: { id: deployment.get('deploymentId'), status: deployment.get('status'), network: deployment.get('network'), progress, currentStep: deployment.get('currentStep'), deployedContracts: deployment.get('deployedContracts') || {}, errors: deployment.get('errors') || [], startedAt: deployment.get('createdAt'), completedAt: deployment.get('completedAt","title":"Deploy Functions"},{"location":"cloud-functions/deploy/#deploy-functions","text":"The Deploy Functions module provides comprehensive deployment capabilities for smart contracts, diamond proxies, and complete project infrastructures on multiple blockchain networks. It handles automated deployment pipelines, configuration management, and post-deployment verification.","title":"Deploy Functions"},{"location":"cloud-functions/deploy/#overview","text":"The Deploy Functions provide: Smart Contract Deployment : Deploy individual contracts and contract suites Diamond Deployment : Deploy and configure diamond proxy contracts Multi-Network Support : Deploy across multiple blockchain networks Configuration Management : Manage deployment configurations and parameters Verification : Automated contract verification and validation Rollback Support : Rollback capabilities for failed deployments","title":"Overview"},{"location":"cloud-functions/deploy/#key-features","text":"","title":"Key Features"},{"location":"cloud-functions/deploy/#deployment-types","text":"Single Contract : Deploy individual smart contracts Diamond Proxy : Deploy upgradeable diamond contracts Project Suite : Deploy complete project infrastructures Template Deployment : Deploy from predefined templates","title":"Deployment Types"},{"location":"cloud-functions/deploy/#network-management","text":"Multi-Network : Support for multiple blockchain networks Gas Optimization : Automatic gas price optimization Network Validation : Pre-deployment network validation Cross-Chain Coordination : Coordinate deployments across networks","title":"Network Management"},{"location":"cloud-functions/deploy/#automation-features","text":"Pipeline Automation : Automated deployment pipelines Configuration Validation : Validate deployment configurations Post-Deployment Testing : Automated testing after deployment Monitoring Integration : Integration with monitoring systems","title":"Automation Features"},{"location":"cloud-functions/deploy/#core-functions","text":"","title":"Core Functions"},{"location":"cloud-functions/deploy/#deploycontract","text":"Deploys a single smart contract to a specified network. Parameters: interface DeployContractRequest { contractName : string ; network : string ; constructorArgs? : any []; deploymentConfig ?: { gasLimit? : string ; gasPrice? : string ; confirmations? : number ; timeout? : number ; }; verificationConfig ?: { verify : boolean ; apiKey? : string ; constructorArgsEncoded? : string ; }; metadata ?: { projectId? : string ; version? : string ; description? : string ; }; } Returns: interface DeployContractResponse { success : boolean ; contractAddress? : string ; transactionHash? : string ; gasUsed? : string ; deploymentCost? : string ; verificationStatus ?: 'pending' | 'verified' | 'failed' ; message : string ; } Usage: const result = await Parse . Cloud . run ( 'deployContract' , { contractName : 'MyToken' , network : 'polygon' , constructorArgs : [ 'My Token' , 'MTK' , 18 , '1000000000000000000000000' ], deploymentConfig : { gasLimit : '2000000' , confirmations : 3 }, verificationConfig : { verify : true }, metadata : { projectId : 'proj_123' , version : '1.0.0' , description : 'ERC20 token for my project' } });","title":"deployContract()"},{"location":"cloud-functions/deploy/#deploydiamond","text":"Deploys a diamond proxy contract with specified facets. Parameters: interface DeployDiamondRequest { network : string ; diamondName : string ; facets : FacetDeployment []; initContract? : string ; initData? : string ; owner? : string ; deploymentConfig? : DeploymentConfig ; verificationConfig? : VerificationConfig ; } interface FacetDeployment { name : string ; address? : string ; // If already deployed constructorArgs? : any []; functionSelectors? : string []; } Returns: interface DeployDiamondResponse { success : boolean ; diamondAddress? : string ; facetAddresses ?: { [ facetName : string ] : string }; transactionHashes? : string []; totalGasUsed? : string ; deploymentCost? : string ; message : string ; }","title":"deployDiamond()"},{"location":"cloud-functions/deploy/#deployproject","text":"Deploys a complete project infrastructure including all contracts and configurations. Parameters: interface DeployProjectRequest { projectId : string ; network : string ; deploymentTemplate : string ; configuration : ProjectConfiguration ; deploymentOptions ?: { skipVerification? : boolean ; dryRun? : boolean ; parallelDeployment? : boolean ; rollbackOnFailure? : boolean ; }; } interface ProjectConfiguration { contracts : ContractConfig []; diamonds : DiamondConfig []; initializations : InitializationStep []; permissions : PermissionConfig []; } Returns: interface DeployProjectResponse { success : boolean ; deploymentId : string ; deployedContracts ?: { [ name : string ] : string }; deployedDiamonds ?: { [ name : string ] : string }; totalGasUsed? : string ; deploymentCost? : string ; deploymentTime? : number ; message : string ; }","title":"deployProject()"},{"location":"cloud-functions/deploy/#getdeploymentstatus","text":"Retrieves the status of an ongoing or completed deployment. Parameters: interface DeploymentStatusRequest { deploymentId : string ; } Returns: interface DeploymentStatusResponse { success : boolean ; deployment ?: { id : string ; status : 'pending' | 'deploying' | 'completed' | 'failed' | 'rolled_back' ; network : string ; progress : number ; currentStep? : string ; deployedContracts : { [ name : string ] : string }; errors? : string []; startedAt : Date ; completedAt? : Date ; gasUsed : string ; cost : string ; }; message : string ; }","title":"getDeploymentStatus()"},{"location":"cloud-functions/deploy/#rollbackdeployment","text":"Rolls back a failed or problematic deployment. Parameters: interface RollbackDeploymentRequest { deploymentId : string ; reason : string ; preserveData? : boolean ; } Returns: interface RollbackDeploymentResponse { success : boolean ; rollbackTransactionHashes? : string []; message : string ; }","title":"rollbackDeployment()"},{"location":"cloud-functions/deploy/#implementation-example","text":"","title":"Implementation Example"},{"location":"cloud-functions/deploy/#smart-contract-deployment","text":"Parse . Cloud . define ( 'deployContract' , async ( request ) => { const { contractName , network , constructorArgs , deploymentConfig , verificationConfig , metadata } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Validate deployment permissions const hasPermission = await checkDeploymentPermissions ( user . id , network ); if ( ! hasPermission ) { throw new Error ( 'Insufficient permissions for deployment' ); } // Validate network if ( ! isSupportedNetwork ( network )) { throw new Error ( 'Unsupported network' ); } // Get contract artifacts const contractArtifacts = await getContractArtifacts ( contractName ); if ( ! contractArtifacts ) { throw new Error ( 'Contract artifacts not found' ); } // Validate constructor arguments if ( constructorArgs ) { await validateConstructorArgs ( contractArtifacts . abi , constructorArgs ); } // Create deployment record const deployment = new Parse . Object ( 'Deployment' ); deployment . set ( 'type' , 'contract' ); deployment . set ( 'contractName' , contractName ); deployment . set ( 'network' , network ); deployment . set ( 'deployer' , user ); deployment . set ( 'status' , 'pending' ); deployment . set ( 'constructorArgs' , constructorArgs ); deployment . set ( 'deploymentConfig' , deploymentConfig ); deployment . set ( 'metadata' , metadata ); deployment . set ( 'createdAt' , new Date ()); await deployment . save (); // Get network configuration const networkConfig = await getNetworkConfig ( network ); const provider = getProvider ( networkConfig ); const wallet = getDeploymentWallet ( networkConfig ); // Estimate gas const gasEstimate = await estimateDeploymentGas ( contractArtifacts , constructorArgs , provider ); // Configure deployment transaction const deploymentTx = { gasLimit : deploymentConfig?.gasLimit || gasEstimate . mul ( 120 ). div ( 100 ), // 20% buffer gasPrice : deploymentConfig?.gasPrice || await provider . getGasPrice (), ... networkConfig . deploymentDefaults }; deployment . set ( 'estimatedGas' , gasEstimate . toString ()); deployment . set ( 'gasPrice' , deploymentTx . gasPrice . toString ()); deployment . set ( 'status' , 'deploying' ); await deployment . save (); // Deploy contract const contractFactory = new ethers . ContractFactory ( contractArtifacts . abi , contractArtifacts . bytecode , wallet ); const contract = await contractFactory . deploy (...( constructorArgs || []), deploymentTx ); deployment . set ( 'transactionHash' , contract . deployTransaction . hash ); await deployment . save (); // Wait for deployment confirmation const confirmations = deploymentConfig ? . confirmations || 3 ; const receipt = await contract . deployTransaction . wait ( confirmations ); deployment . set ( 'contractAddress' , contract . address ); deployment . set ( 'blockNumber' , receipt . blockNumber ); deployment . set ( 'gasUsed' , receipt . gasUsed . toString ()); deployment . set ( 'deploymentCost' , receipt . gasUsed . mul ( deploymentTx . gasPrice ). toString ()); deployment . set ( 'status' , 'deployed' ); deployment . set ( 'deployedAt' , new Date ()); await deployment . save (); // Verify contract if requested let verificationStatus = 'not_requested' ; if ( verificationConfig ? . verify ) { try { const verificationResult = await verifyContract ({ contractAddress : contract.address , contractName , network , constructorArgs , apiKey : verificationConfig.apiKey }); verificationStatus = verificationResult . success ? 'verified' : 'failed' ; deployment . set ( 'verificationStatus' , verificationStatus ); deployment . set ( 'verificationResult' , verificationResult ); await deployment . save (); } catch ( verificationError ) { console . error ( 'Contract verification failed:' , verificationError ); verificationStatus = 'failed' ; } } // Update project if specified if ( metadata ? . projectId ) { await updateProjectDeployment ( metadata . projectId , { contractName , contractAddress : contract.address , network , deploymentId : deployment.id }); } // Send deployment notification await sendDeploymentNotification ( deployment . id , 'completed' ); return { success : true , contractAddress : contract.address , transactionHash : contract.deployTransaction.hash , gasUsed : receipt.gasUsed.toString (), deploymentCost : receipt.gasUsed.mul ( deploymentTx . gasPrice ). toString (), verificationStatus , message : 'Contract deployed successfully' }; } catch ( error ) { console . error ( 'Contract deployment error:' , error ); // Update deployment record with error const deployment = await new Parse . Query ( 'Deployment' ) . equalTo ( 'contractName' , contractName ) . equalTo ( 'deployer' , user ) . equalTo ( 'status' , 'deploying' ) . first ({ useMasterKey : true }); if ( deployment ) { deployment . set ( 'status' , 'failed' ); deployment . set ( 'errorMessage' , error . message ); deployment . set ( 'failedAt' , new Date ()); await deployment . save (); } return { success : false , message : error.message || 'Contract deployment failed' }; } });","title":"Smart Contract Deployment"},{"location":"cloud-functions/deploy/#diamond-deployment","text":"Parse . Cloud . define ( 'deployDiamond' , async ( request ) => { const { network , diamondName , facets , initContract , initData , owner , deploymentConfig , verificationConfig } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Validate deployment permissions const hasPermission = await checkDeploymentPermissions ( user . id , network ); if ( ! hasPermission ) { throw new Error ( 'Insufficient permissions for deployment' ); } // Create deployment record const deployment = new Parse . Object ( 'Deployment' ); deployment . set ( 'type' , 'diamond' ); deployment . set ( 'diamondName' , diamondName ); deployment . set ( 'network' , network ); deployment . set ( 'deployer' , user ); deployment . set ( 'status' , 'pending' ); deployment . set ( 'facets' , facets ); deployment . set ( 'createdAt' , new Date ()); await deployment . save (); const deployedContracts : { [ name : string ] : string } = {}; const transactionHashes : string [] = []; let totalGasUsed = ethers . BigNumber . from ( 0 ); // Get network configuration const networkConfig = await getNetworkConfig ( network ); const provider = getProvider ( networkConfig ); const wallet = getDeploymentWallet ( networkConfig ); deployment . set ( 'status' , 'deploying' ); await deployment . save (); // Deploy core diamond contracts first const diamondCutFacet = await deployCoreFacet ( 'DiamondCutFacet' , wallet , deploymentConfig ); deployedContracts [ 'DiamondCutFacet' ] = diamondCutFacet . address ; transactionHashes . push ( diamondCutFacet . deployTransaction . hash ); totalGasUsed = totalGasUsed . add ( await diamondCutFacet . deployTransaction . wait (). then ( r => r . gasUsed )); const diamondLoupeFacet = await deployCoreFacet ( 'DiamondLoupeFacet' , wallet , deploymentConfig ); deployedContracts [ 'DiamondLoupeFacet' ] = diamondLoupeFacet . address ; transactionHashes . push ( diamondLoupeFacet . deployTransaction . hash ); totalGasUsed = totalGasUsed . add ( await diamondLoupeFacet . deployTransaction . wait (). then ( r => r . gasUsed )); const ownershipFacet = await deployCoreFacet ( 'OwnershipFacet' , wallet , deploymentConfig ); deployedContracts [ 'OwnershipFacet' ] = ownershipFacet . address ; transactionHashes . push ( ownershipFacet . deployTransaction . hash ); totalGasUsed = totalGasUsed . add ( await ownershipFacet . deployTransaction . wait (). then ( r => r . gasUsed )); // Deploy custom facets for ( const facet of facets ) { if ( ! facet . address ) { const facetContract = await deployFacet ( facet , wallet , deploymentConfig ); deployedContracts [ facet . name ] = facetContract . address ; transactionHashes . push ( facetContract . deployTransaction . hash ); totalGasUsed = totalGasUsed . add ( await facetContract . deployTransaction . wait (). then ( r => r . gasUsed )); } else { deployedContracts [ facet . name ] = facet . address ; } } // Prepare diamond cut for initialization const diamondCut = prepareDiamondCut ([ { facetAddress : diamondCutFacet.address , action : 0 , // Add functionSelectors : getDiamondCutSelectors () }, { facetAddress : diamondLoupeFacet.address , action : 0 , // Add functionSelectors : getDiamondLoupeSelectors () }, { facetAddress : ownershipFacet.address , action : 0 , // Add functionSelectors : getOwnershipSelectors () }, ... facets . map ( facet => ({ facetAddress : deployedContracts [ facet . name ], action : 0 , // Add functionSelectors : facet.functionSelectors || getFacetSelectors ( facet . name ) })) ]); // Deploy diamond const diamondFactory = await getDiamondFactory ( wallet ); const diamondTx = await diamondFactory . deployDiamond ( owner || wallet . address , diamondCut , initContract || ethers . constants . AddressZero , initData || '0x' , deploymentConfig || {} ); const diamondReceipt = await diamondTx . wait (); const diamondAddress = await getDiamondAddressFromReceipt ( diamondReceipt ); deployedContracts [ 'Diamond' ] = diamondAddress ; transactionHashes . push ( diamondTx . hash ); totalGasUsed = totalGasUsed . add ( diamondReceipt . gasUsed ); // Update deployment record deployment . set ( 'diamondAddress' , diamondAddress ); deployment . set ( 'deployedContracts' , deployedContracts ); deployment . set ( 'transactionHashes' , transactionHashes ); deployment . set ( 'totalGasUsed' , totalGasUsed . toString ()); deployment . set ( 'status' , 'deployed' ); deployment . set ( 'deployedAt' , new Date ()); await deployment . save (); // Verify contracts if requested if ( verificationConfig ? . verify ) { await verifyDiamondContracts ( deployedContracts , network , verificationConfig ); } // Send deployment notification await sendDeploymentNotification ( deployment . id , 'completed' ); return { success : true , diamondAddress , facetAddresses : deployedContracts , transactionHashes , totalGasUsed : totalGasUsed.toString (), deploymentCost : totalGasUsed.mul ( await provider . getGasPrice ()). toString (), message : 'Diamond deployed successfully' }; } catch ( error ) { console . error ( 'Diamond deployment error:' , error ); // Update deployment record with error const deployment = await new Parse . Query ( 'Deployment' ) . equalTo ( 'diamondName' , diamondName ) . equalTo ( 'deployer' , user ) . equalTo ( 'status' , 'deploying' ) . first ({ useMasterKey : true }); if ( deployment ) { deployment . set ( 'status' , 'failed' ); deployment . set ( 'errorMessage' , error . message ); deployment . set ( 'failedAt' , new Date ()); await deployment . save (); } return { success : false , message : error.message || 'Diamond deployment failed' }; } });","title":"Diamond Deployment"},{"location":"cloud-functions/deploy/#project-deployment","text":"Parse . Cloud . define ( 'deployProject' , async ( request ) => { const { projectId , network , deploymentTemplate , configuration , deploymentOptions } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Get project const project = await new Parse . Query ( 'Project' ) . equalTo ( 'objectId' , projectId ) . first ({ useMasterKey : true }); if ( ! project ) { throw new Error ( 'Project not found' ); } // Check project access const hasAccess = await checkProjectAccess ( projectId , user . id ); if ( ! hasAccess ) { throw new Error ( 'Access denied' ); } // Create deployment record const deploymentId = generateDeploymentId (); const deployment = new Parse . Object ( 'ProjectDeployment' ); deployment . set ( 'deploymentId' , deploymentId ); deployment . set ( 'project' , project ); deployment . set ( 'network' , network ); deployment . set ( 'template' , deploymentTemplate ); deployment . set ( 'configuration' , configuration ); deployment . set ( 'deployer' , user ); deployment . set ( 'status' , 'pending' ); deployment . set ( 'createdAt' , new Date ()); await deployment . save (); // Validate deployment configuration await validateProjectConfiguration ( configuration , deploymentTemplate ); // Perform dry run if requested if ( deploymentOptions ? . dryRun ) { const dryRunResult = await performDryRun ( configuration , network ); return { success : true , deploymentId , dryRunResult , message : 'Dry run completed successfully' }; } deployment . set ( 'status' , 'deploying' ); await deployment . save (); const deployedContracts : { [ name : string ] : string } = {}; const deployedDiamonds : { [ name : string ] : string } = {}; let totalGasUsed = ethers . BigNumber . from ( 0 ); const startTime = Date . now (); try { // Deploy contracts in dependency order for ( const contractConfig of configuration . contracts ) { const contractResult = await Parse . Cloud . run ( 'deployContract' , { contractName : contractConfig.name , network , constructorArgs : contractConfig.constructorArgs , deploymentConfig : contractConfig.deploymentConfig , verificationConfig : { verify : ! deploymentOptions ? . skipVerification } }); if ( ! contractResult . success ) { throw new Error ( `Failed to deploy ${ contractConfig . name } : ${ contractResult . message } ` ); } deployedContracts [ contractConfig . name ] = contractResult . contractAddress ; totalGasUsed = totalGasUsed . add ( contractResult . gasUsed || '0' ); // Update deployment progress deployment . set ( 'currentStep' , `Deployed ${ contractConfig . name } ` ); deployment . set ( 'deployedContracts' , deployedContracts ); await deployment . save (); } // Deploy diamonds for ( const diamondConfig of configuration . diamonds ) { const diamondResult = await Parse . Cloud . run ( 'deployDiamond' , { network , diamondName : diamondConfig.name , facets : diamondConfig.facets , initContract : diamondConfig.initContract , initData : diamondConfig.initData , owner : diamondConfig.owner , verificationConfig : { verify : ! deploymentOptions ? . skipVerification } }); if ( ! diamondResult . success ) { throw new Error ( `Failed to deploy ${ diamondConfig . name } : ${ diamondResult . message } ` ); } deployedDiamonds [ diamondConfig . name ] = diamondResult . diamondAddress ; totalGasUsed = totalGasUsed . add ( diamondResult . totalGasUsed || '0' ); // Update deployment progress deployment . set ( 'currentStep' , `Deployed ${ diamondConfig . name } ` ); deployment . set ( 'deployedDiamonds' , deployedDiamonds ); await deployment . save (); } // Execute initialization steps for ( const initStep of configuration . initializations ) { await executeInitializationStep ( initStep , deployedContracts , deployedDiamonds , network ); deployment . set ( 'currentStep' , `Executed ${ initStep . name } ` ); await deployment . save (); } // Configure permissions for ( const permissionConfig of configuration . permissions ) { await configurePermissions ( permissionConfig , deployedContracts , deployedDiamonds , network ); deployment . set ( 'currentStep' , `Configured ${ permissionConfig . name } ` ); await deployment . save (); } const deploymentTime = Date . now () - startTime ; // Update deployment record deployment . set ( 'status' , 'completed' ); deployment . set ( 'deployedContracts' , deployedContracts ); deployment . set ( 'deployedDiamonds' , deployedDiamonds ); deployment . set ( 'totalGasUsed' , totalGasUsed . toString ()); deployment . set ( 'deploymentTime' , deploymentTime ); deployment . set ( 'completedAt' , new Date ()); await deployment . save (); // Update project with deployment information project . set ( 'deployments' , [...( project . get ( 'deployments' ) || []), { deploymentId , network , status : 'completed' , deployedAt : new Date (), contracts : deployedContracts , diamonds : deployedDiamonds }]); await project . save (); // Send deployment notification await sendDeploymentNotification ( deploymentId , 'completed' ); return { success : true , deploymentId , deployedContracts , deployedDiamonds , totalGasUsed : totalGasUsed.toString (), deploymentCost : totalGasUsed.mul ( await getNetworkGasPrice ( network )). toString (), deploymentTime , message : 'Project deployed successfully' }; } catch ( deploymentError ) { // Handle deployment failure if ( deploymentOptions ? . rollbackOnFailure ) { await rollbackProjectDeployment ( deploymentId , deployedContracts , deployedDiamonds ); } deployment . set ( 'status' , 'failed' ); deployment . set ( 'errorMessage' , deploymentError . message ); deployment . set ( 'failedAt' , new Date ()); await deployment . save (); throw deploymentError ; } } catch ( error ) { console . error ( 'Project deployment error:' , error ); return { success : false , message : error.message || 'Project deployment failed' }; } });","title":"Project Deployment"},{"location":"cloud-functions/deploy/#deployment-templates","text":"","title":"Deployment Templates"},{"location":"cloud-functions/deploy/#nft-collection-template","text":"const nftCollectionTemplate = { name : 'NFT Collection' , description : 'Complete NFT collection with marketplace' , contracts : [ { name : 'CollectionToken' , type : 'ERC721' , constructorArgs : [ '{{tokenName}}' , '{{tokenSymbol}}' , '{{baseURI}}' ], deploymentConfig : { gasLimit : '3000000' } } ], diamonds : [ { name : 'CollectionDiamond' , facets : [ { name : 'ERC721Facet' }, { name : 'MarketplaceFacet' }, { name : 'MetadataFacet' }, { name : 'OwnershipFacet' } ], initContract : 'CollectionInit' , initData : '{{initData}}' } ], initializations : [ { name : 'SetupMarketplace' , contract : 'CollectionDiamond' , function : 'setupMarketplace' , args : [ '{{marketplaceFee}}' , '{{feeRecipient}}' ] } ], permissions : [ { name : 'MinterRole' , contract : 'CollectionDiamond' , role : 'MINTER_ROLE' , accounts : [ '{{owner}}' ] } ] };","title":"NFT Collection Template"},{"location":"cloud-functions/deploy/#defi-protocol-template","text":"const defiProtocolTemplate = { name : 'DeFi Protocol' , description : 'DeFi protocol with staking and governance' , contracts : [ { name : 'GovernanceToken' , type : 'ERC20' , constructorArgs : [ '{{tokenName}}' , '{{tokenSymbol}}' , '{{totalSupply}}' ] }, { name : 'Timelock' , type : 'TimelockController' , constructorArgs : [ '{{timelockDelay}}' , [ '{{admin}}' ], [ '{{admin}}' ], '{{admin}}' ] } ], diamonds : [ { name : 'ProtocolDiamond' , facets : [ { name : 'StakingFacet' }, { name : 'GovernanceFacet' }, { name : 'FeeDistributorFacet' }, { name : 'OwnershipFacet' } ] } ], initializations : [ { name : 'SetupStaking' , contract : 'ProtocolDiamond' , function : 'setupStaking' , args : [ '{{stakingToken}}' , '{{rewardRate}}' ] } ] };","title":"DeFi Protocol Template"},{"location":"cloud-functions/deploy/#verification-and-monitoring","text":"","title":"Verification and Monitoring"},{"location":"cloud-functions/deploy/#contract-verification","text":"async function verifyContract ( params : { contractAddress : string ; contractName : string ; network : string ; constructorArgs? : any []; apiKey? : string ; }) : Promise < { success : boolean ; message : string } > { try { const { contractAddress , contractName , network , constructorArgs , apiKey } = params ; // Get network verification configuration const verificationConfig = getVerificationConfig ( network ); const explorerApiKey = apiKey || verificationConfig . defaultApiKey ; if ( ! explorerApiKey ) { throw new Error ( 'API key required for verification' ); } // Get contract source code and metadata const contractArtifacts = await getContractArtifacts ( contractName ); const sourceCode = await getContractSourceCode ( contractName ); // Prepare verification request const verificationRequest = { apikey : explorerApiKey , module : 'contract' , action : 'verifysourcecode' , contractaddress : contractAddress , sourceCode : sourceCode , codeformat : 'solidity-single-file' , contractname : contractName , compilerversion : contractArtifacts.compiler.version , optimizationUsed : contractArtifacts.compiler.optimizer.enabled ? 1 : 0 , runs : contractArtifacts.compiler.optimizer.runs , constructorArguements : constructorArgs ? encodeConstructorArgs ( constructorArgs ) : '' }; // Submit verification request const response = await submitVerificationRequest ( verificationConfig . apiUrl , verificationRequest ); if ( response . status !== '1' ) { throw new Error ( `Verification submission failed: ${ response . result } ` ); } // Poll for verification result const verificationResult = await pollVerificationResult ( verificationConfig . apiUrl , explorerApiKey , response . result ); return { success : verificationResult.status === '1' , message : verificationResult.result }; } catch ( error ) { console . error ( 'Contract verification error:' , error ); return { success : false , message : error.message || 'Verification failed' }; } }","title":"Contract Verification"},{"location":"cloud-functions/deploy/#deployment-monitoring","text":"```typescript Parse.Cloud.define('getDeploymentStatus', async (request) => { const { deploymentId } = request.params; const user = request.user; if (!user) { throw new Error('Authentication required'); } try { // Get deployment record const deployment = await new Parse.Query('Deployment') .equalTo('deploymentId', deploymentId) .first({ useMasterKey: true }); if (!deployment) { throw new Error('Deployment not found'); } // Check access permissions if (deployment.get('deployer').id !== user.id) { const hasAccess = await checkDeploymentAccess(deploymentId, user.id); if (!hasAccess) { throw new Error('Access denied'); } } // Calculate progress const progress = calculateDeploymentProgress(deployment); return { success: true, deployment: { id: deployment.get('deploymentId'), status: deployment.get('status'), network: deployment.get('network'), progress, currentStep: deployment.get('currentStep'), deployedContracts: deployment.get('deployedContracts') || {}, errors: deployment.get('errors') || [], startedAt: deployment.get('createdAt'), completedAt: deployment.get('completedAt","title":"Deployment Monitoring"},{"location":"cloud-functions/dfns/","text":"DFNS Cloud Functions \u00b6 Overview \u00b6 The dfns.ts module provides comprehensive integration with DFNS (Decentralized Finance Network Services) Wallet-as-a-Service platform. These cloud functions enable secure wallet management, user authentication, transaction signing, and smart contract interactions through DFNS's infrastructure. DFNS Integration Architecture \u00b6 Key Components \u00b6 DfnsApiClient : Administrative client for system-level operations DfnsDelegatedApiClient : User-delegated client for end-user operations AsymmetricKeySigner : Cryptographic signing for API authentication Multi-Network Support : BaseSepolia, OptimismSepolia, and local networks Security Model \u00b6 Server-side private key management Delegated authentication for end users Challenge-response authentication flow Secure transaction signing with user approval Configuration \u00b6 Environment Variables \u00b6 # DFNS API Configuration DFNS_APP_ID = your_dfns_app_id DFNS_AUTH_TOKEN = your_dfns_auth_token DFNS_API_URL = https://api.dfns.ninja DFNS_CRED_ID = your_credential_id # Network Configuration CHAIN_ID = basesep # or optsep, localhost ETH_NODE_URI_BASESEP = https://base-sepolia.infura.io/v3/your-key ETH_NODE_URI_OPTSEP = https://optimism-sepolia.infura.io/v3/your-key # Private Key File # dfns_private.key file in project root Network Mapping \u00b6 const DFNS_NETWORK = (() => { if ( chainCode === \"basesep\" ) return \"BaseSepolia\" ; if ( chainCode === \"optsep\" ) return \"OptimismSepolia\" ; return \"local\" ; })(); Core Functions \u00b6 User Registration \u00b6 registerInit \u00b6 Parse . Cloud . run ( \"registerInit\" , { username : \"user@example.com\" }) Purpose : Initiates the user registration process with DFNS. Parameters : - username (string): User's email address for registration Returns : Registration challenge object { challenge : \"base64-encoded-challenge\" , temporaryAuthenticationToken : \"temp-token\" , // ... other challenge data } Process : 1. Validates username parameter 2. Creates DFNS API client with system credentials 3. Generates delegated registration challenge 4. Returns challenge for client-side signing Usage Example : // Client-side registration initiation const challenge = await Parse . Cloud . run ( \"registerInit\" , { username : \"user@example.com\" }); // Client signs the challenge using DFNS SDK const signedChallenge = await dfnsClient . signChallenge ( challenge ); Error Conditions : - VALIDATION_ERROR : Missing username parameter - INTERNAL_SERVER_ERROR : DFNS API communication failure registerComplete \u00b6 Parse . Cloud . run ( \"registerComplete\" , { signedChallenge : signedChallengeObject , temporaryAuthenticationToken : \"temp-token\" }) Purpose : Completes user registration and creates DFNS wallet. Parameters : - signedChallenge (object): Client-signed challenge from registerInit - temporaryAuthenticationToken (string): Temporary token from registerInit Returns : Registration result with user token and wallet information { token : \"user-auth-token\" , user : { id : \"user-id\" , email : \"user@example.com\" }, wallets : [ { id : \"wallet-id\" , network : \"BaseSepolia\" , address : \"0x...\" } ] } Process : 1. Validates signed challenge and temporary token 2. Creates DFNS client with temporary authentication 3. Registers end user with wallet creation 4. Returns user authentication token and wallet details User Authentication \u00b6 login \u00b6 Parse . Cloud . run ( \"login\" , { username : \"user@example.com\" }) Purpose : Authenticates existing DFNS user and returns access token. Parameters : - username (string): User's registered email address Returns : Login result with authentication token { username : \"user@example.com\" , token : \"user-auth-token\" } Process : 1. Validates username parameter 2. Performs delegated login with DFNS 3. Returns authentication token for subsequent operations Usage Example : // User login const loginResult = await Parse . Cloud . run ( \"login\" , { username : \"user@example.com\" }); // Store token for subsequent API calls const authToken = loginResult . token ; Wallet Management \u00b6 listWallets \u00b6 Parse . Cloud . run ( \"listWallets\" , { authToken : \"user-auth-token\" }) Purpose : Retrieves all wallets associated with the authenticated user. Parameters : - authToken (string): User's authentication token from login Returns : Array of user's wallets { items : [ { id : \"wallet-id-1\" , network : \"BaseSepolia\" , address : \"0x1234...\" , status : \"Active\" , dateCreated : \"2024-01-01T00:00:00Z\" }, { id : \"wallet-id-2\" , network : \"OptimismSepolia\" , address : \"0x5678...\" , status : \"Active\" , dateCreated : \"2024-01-01T00:00:00Z\" } ] } Usage Example : // List user's wallets const wallets = await Parse . Cloud . run ( \"listWallets\" , { authToken : userAuthToken }); // Find wallet for specific network const baseWallet = wallets . items . find ( w => w . network === \"BaseSepolia\" ); Transaction Signing \u00b6 signaturesInit \u00b6 Parse . Cloud . run ( \"signaturesInit\" , { authToken : \"user-auth-token\" , walletId : \"wallet-id\" , message : \"Hello, World!\" }) Purpose : Initiates message signing process for the specified wallet. Parameters : - authToken (string): User's authentication token - walletId (string): ID of the wallet to use for signing - message (string): Message to be signed Returns : Signature initialization data { requestBody : { kind : \"Message\" , message : \"48656c6c6f2c20576f726c6421\" // hex-encoded message }, challenge : { challenge : \"base64-challenge\" , // ... other challenge data } } Process : 1. Validates authentication token, wallet ID, and message 2. Creates delegated DFNS client 3. Converts message to hex format 4. Generates signature initialization challenge 5. Returns challenge for client-side signing signaturesComplete \u00b6 Parse . Cloud . run ( \"signaturesComplete\" , { authToken : \"user-auth-token\" , walletId : \"wallet-id\" , requestBody : requestBodyFromInit , signedChallenge : clientSignedChallenge }) Purpose : Completes the message signing process with user-signed challenge. Parameters : - authToken (string): User's authentication token - walletId (string): Wallet ID used for signing - requestBody (object): Request body from signaturesInit - signedChallenge (object): Client-signed challenge Returns : Completed signature { signature : \"0x1234567890abcdef...\" , recoveryId : 0 , // ... other signature data } Usage Example : // Complete signing workflow const initResult = await Parse . Cloud . run ( \"signaturesInit\" , { authToken : userToken , walletId : walletId , message : \"Transaction approval\" }); // Client signs the challenge const signedChallenge = await dfnsClient . signChallenge ( initResult . challenge ); // Complete the signature const signature = await Parse . Cloud . run ( \"signaturesComplete\" , { authToken : userToken , walletId : walletId , requestBody : initResult . requestBody , signedChallenge : signedChallenge }); Smart Contract Interactions \u00b6 dfnsInitiatePurchase \u00b6 Parse . Cloud . run ( \"dfnsInitiatePurchase\" , { tokenId : 123 , walletId : \"wallet-id\" , dfns_token : \"user-auth-token\" }) Purpose : Initiates an NFT purchase transaction through DFNS wallet. Parameters : - tokenId (number): ID of the NFT to purchase - walletId (string): DFNS wallet ID for the transaction - dfns_token (string): User's DFNS authentication token Returns : Transaction initialization data for marketplace purchase Process : 1. Validates all required parameters 2. Creates delegated DFNS client 3. Encodes marketplace purchase transaction data 4. Prepares EVM transaction body 5. Returns transaction data for user approval Integration : Works with MarketplaceFacet for NFT purchases Client Integration Patterns \u00b6 Complete User Onboarding Flow \u00b6 // 1. Register new user const registrationChallenge = await Parse . Cloud . run ( \"registerInit\" , { username : \"user@example.com\" }); // 2. Client signs challenge (using DFNS SDK) const signedChallenge = await dfnsClient . signChallenge ( registrationChallenge ); // 3. Complete registration const registrationResult = await Parse . Cloud . run ( \"registerComplete\" , { signedChallenge : signedChallenge , temporaryAuthenticationToken : registrationChallenge . temporaryAuthenticationToken }); // 4. Store user token const userToken = registrationResult . token ; Wallet Operations Flow \u00b6 // 1. Login existing user const loginResult = await Parse . Cloud . run ( \"login\" , { username : \"user@example.com\" }); // 2. List user's wallets const wallets = await Parse . Cloud . run ( \"listWallets\" , { authToken : loginResult . token }); // 3. Select wallet for operations const selectedWallet = wallets . items [ 0 ]; Transaction Signing Flow \u00b6 // 1. Initiate signature const signatureInit = await Parse . Cloud . run ( \"signaturesInit\" , { authToken : userToken , walletId : selectedWallet . id , message : \"Approve transaction\" }); // 2. Client signs challenge const signedChallenge = await dfnsClient . signChallenge ( signatureInit . challenge ); // 3. Complete signature const signature = await Parse . Cloud . run ( \"signaturesComplete\" , { authToken : userToken , walletId : selectedWallet . id , requestBody : signatureInit . requestBody , signedChallenge : signedChallenge }); Contract Integration \u00b6 Supported Contracts \u00b6 The DFNS module automatically loads ABIs and addresses for: Treasury Contract : Financial operations Marketplace Contract : NFT trading USDC Contract : Stable coin payments Carbon Credits Contract : Environmental assets Identity Contracts : User verification Trade Deal Contracts : Financial instruments Dynamic Contract Loading \u00b6 // Contracts are loaded based on network configuration const networkConfig = config . find ( chain => chain . code === chainCode ); const artifactsPath = `../../deployments/ ${ chainCode } ` ; // ABIs and addresses loaded from deployment artifacts if ( fs . existsSync ( marketplaceFilePath )) { const { address , abi } = JSON . parse ( fs . readFileSync ( marketplaceFilePath , \"utf8\" )); MARKETPLACE_CONTRACT_ADDRESS = address ; MARKETPLACE_CONTRACT_ABI = abi ; } Security Considerations \u00b6 Authentication Security \u00b6 Server-side private key storage for DFNS API authentication Delegated authentication prevents direct key exposure Challenge-response flow ensures user consent Transaction Security \u00b6 User approval required for all transactions Message signing for transaction authorization Network-specific wallet isolation API Security \u00b6 Input validation for all parameters Error handling prevents information leakage Rate limiting through Parse Server Error Handling \u00b6 Common Error Patterns \u00b6 // Validation errors if ( ! username ) { throw new Parse . Error ( Parse . Error . VALIDATION_ERROR , \"Username is required\" ); } // DFNS API errors try { const result = await client . auth . delegatedLogin ({ body : { username } }); return result ; } catch ( error ) { throw new Parse . Error ( Parse . Error . INTERNAL_SERVER_ERROR , `Error during login: ${ error . message } ` ); } Error Types \u00b6 VALIDATION_ERROR : Missing or invalid parameters INTERNAL_SERVER_ERROR : DFNS API communication failures AUTHENTICATION_ERROR : Invalid tokens or credentials Performance Considerations \u00b6 Client Caching \u00b6 Cache user authentication tokens Reuse wallet information Minimize API calls through batching Network Optimization \u00b6 Use appropriate network for operations Consider gas costs for different networks Implement retry logic for network failures Testing \u00b6 Unit Tests \u00b6 describe ( \"DFNS Functions\" , () => { test ( \"registerInit requires username\" , async () => { await expect ( Parse . Cloud . run ( \"registerInit\" , {}) ). rejects . toThrow ( \"Username is required\" ); }); test ( \"login returns token\" , async () => { const result = await Parse . Cloud . run ( \"login\" , { username : \"test@example.com\" }); expect ( result ). toHaveProperty ( \"token\" ); }); }); Integration Tests \u00b6 Test with DFNS sandbox environment Validate wallet creation and management Test transaction signing flows Verify contract interaction patterns Related Documentation \u00b6 DFNS API Documentation Blockchain Functions - Network management Contract Functions - Smart contract interactions Authentication Functions - User authentication Developer Setup Guide - Environment configuration These functions provide secure wallet-as-a-service integration for the Gemforce platform through DFNS infrastructure.","title":"DFNS Functions"},{"location":"cloud-functions/dfns/#dfns-cloud-functions","text":"","title":"DFNS Cloud Functions"},{"location":"cloud-functions/dfns/#overview","text":"The dfns.ts module provides comprehensive integration with DFNS (Decentralized Finance Network Services) Wallet-as-a-Service platform. These cloud functions enable secure wallet management, user authentication, transaction signing, and smart contract interactions through DFNS's infrastructure.","title":"Overview"},{"location":"cloud-functions/dfns/#dfns-integration-architecture","text":"","title":"DFNS Integration Architecture"},{"location":"cloud-functions/dfns/#key-components","text":"DfnsApiClient : Administrative client for system-level operations DfnsDelegatedApiClient : User-delegated client for end-user operations AsymmetricKeySigner : Cryptographic signing for API authentication Multi-Network Support : BaseSepolia, OptimismSepolia, and local networks","title":"Key Components"},{"location":"cloud-functions/dfns/#security-model","text":"Server-side private key management Delegated authentication for end users Challenge-response authentication flow Secure transaction signing with user approval","title":"Security Model"},{"location":"cloud-functions/dfns/#configuration","text":"","title":"Configuration"},{"location":"cloud-functions/dfns/#environment-variables","text":"# DFNS API Configuration DFNS_APP_ID = your_dfns_app_id DFNS_AUTH_TOKEN = your_dfns_auth_token DFNS_API_URL = https://api.dfns.ninja DFNS_CRED_ID = your_credential_id # Network Configuration CHAIN_ID = basesep # or optsep, localhost ETH_NODE_URI_BASESEP = https://base-sepolia.infura.io/v3/your-key ETH_NODE_URI_OPTSEP = https://optimism-sepolia.infura.io/v3/your-key # Private Key File # dfns_private.key file in project root","title":"Environment Variables"},{"location":"cloud-functions/dfns/#network-mapping","text":"const DFNS_NETWORK = (() => { if ( chainCode === \"basesep\" ) return \"BaseSepolia\" ; if ( chainCode === \"optsep\" ) return \"OptimismSepolia\" ; return \"local\" ; })();","title":"Network Mapping"},{"location":"cloud-functions/dfns/#core-functions","text":"","title":"Core Functions"},{"location":"cloud-functions/dfns/#user-registration","text":"","title":"User Registration"},{"location":"cloud-functions/dfns/#registerinit","text":"Parse . Cloud . run ( \"registerInit\" , { username : \"user@example.com\" }) Purpose : Initiates the user registration process with DFNS. Parameters : - username (string): User's email address for registration Returns : Registration challenge object { challenge : \"base64-encoded-challenge\" , temporaryAuthenticationToken : \"temp-token\" , // ... other challenge data } Process : 1. Validates username parameter 2. Creates DFNS API client with system credentials 3. Generates delegated registration challenge 4. Returns challenge for client-side signing Usage Example : // Client-side registration initiation const challenge = await Parse . Cloud . run ( \"registerInit\" , { username : \"user@example.com\" }); // Client signs the challenge using DFNS SDK const signedChallenge = await dfnsClient . signChallenge ( challenge ); Error Conditions : - VALIDATION_ERROR : Missing username parameter - INTERNAL_SERVER_ERROR : DFNS API communication failure","title":"registerInit"},{"location":"cloud-functions/dfns/#registercomplete","text":"Parse . Cloud . run ( \"registerComplete\" , { signedChallenge : signedChallengeObject , temporaryAuthenticationToken : \"temp-token\" }) Purpose : Completes user registration and creates DFNS wallet. Parameters : - signedChallenge (object): Client-signed challenge from registerInit - temporaryAuthenticationToken (string): Temporary token from registerInit Returns : Registration result with user token and wallet information { token : \"user-auth-token\" , user : { id : \"user-id\" , email : \"user@example.com\" }, wallets : [ { id : \"wallet-id\" , network : \"BaseSepolia\" , address : \"0x...\" } ] } Process : 1. Validates signed challenge and temporary token 2. Creates DFNS client with temporary authentication 3. Registers end user with wallet creation 4. Returns user authentication token and wallet details","title":"registerComplete"},{"location":"cloud-functions/dfns/#user-authentication","text":"","title":"User Authentication"},{"location":"cloud-functions/dfns/#login","text":"Parse . Cloud . run ( \"login\" , { username : \"user@example.com\" }) Purpose : Authenticates existing DFNS user and returns access token. Parameters : - username (string): User's registered email address Returns : Login result with authentication token { username : \"user@example.com\" , token : \"user-auth-token\" } Process : 1. Validates username parameter 2. Performs delegated login with DFNS 3. Returns authentication token for subsequent operations Usage Example : // User login const loginResult = await Parse . Cloud . run ( \"login\" , { username : \"user@example.com\" }); // Store token for subsequent API calls const authToken = loginResult . token ;","title":"login"},{"location":"cloud-functions/dfns/#wallet-management","text":"","title":"Wallet Management"},{"location":"cloud-functions/dfns/#listwallets","text":"Parse . Cloud . run ( \"listWallets\" , { authToken : \"user-auth-token\" }) Purpose : Retrieves all wallets associated with the authenticated user. Parameters : - authToken (string): User's authentication token from login Returns : Array of user's wallets { items : [ { id : \"wallet-id-1\" , network : \"BaseSepolia\" , address : \"0x1234...\" , status : \"Active\" , dateCreated : \"2024-01-01T00:00:00Z\" }, { id : \"wallet-id-2\" , network : \"OptimismSepolia\" , address : \"0x5678...\" , status : \"Active\" , dateCreated : \"2024-01-01T00:00:00Z\" } ] } Usage Example : // List user's wallets const wallets = await Parse . Cloud . run ( \"listWallets\" , { authToken : userAuthToken }); // Find wallet for specific network const baseWallet = wallets . items . find ( w => w . network === \"BaseSepolia\" );","title":"listWallets"},{"location":"cloud-functions/dfns/#transaction-signing","text":"","title":"Transaction Signing"},{"location":"cloud-functions/dfns/#signaturesinit","text":"Parse . Cloud . run ( \"signaturesInit\" , { authToken : \"user-auth-token\" , walletId : \"wallet-id\" , message : \"Hello, World!\" }) Purpose : Initiates message signing process for the specified wallet. Parameters : - authToken (string): User's authentication token - walletId (string): ID of the wallet to use for signing - message (string): Message to be signed Returns : Signature initialization data { requestBody : { kind : \"Message\" , message : \"48656c6c6f2c20576f726c6421\" // hex-encoded message }, challenge : { challenge : \"base64-challenge\" , // ... other challenge data } } Process : 1. Validates authentication token, wallet ID, and message 2. Creates delegated DFNS client 3. Converts message to hex format 4. Generates signature initialization challenge 5. Returns challenge for client-side signing","title":"signaturesInit"},{"location":"cloud-functions/dfns/#signaturescomplete","text":"Parse . Cloud . run ( \"signaturesComplete\" , { authToken : \"user-auth-token\" , walletId : \"wallet-id\" , requestBody : requestBodyFromInit , signedChallenge : clientSignedChallenge }) Purpose : Completes the message signing process with user-signed challenge. Parameters : - authToken (string): User's authentication token - walletId (string): Wallet ID used for signing - requestBody (object): Request body from signaturesInit - signedChallenge (object): Client-signed challenge Returns : Completed signature { signature : \"0x1234567890abcdef...\" , recoveryId : 0 , // ... other signature data } Usage Example : // Complete signing workflow const initResult = await Parse . Cloud . run ( \"signaturesInit\" , { authToken : userToken , walletId : walletId , message : \"Transaction approval\" }); // Client signs the challenge const signedChallenge = await dfnsClient . signChallenge ( initResult . challenge ); // Complete the signature const signature = await Parse . Cloud . run ( \"signaturesComplete\" , { authToken : userToken , walletId : walletId , requestBody : initResult . requestBody , signedChallenge : signedChallenge });","title":"signaturesComplete"},{"location":"cloud-functions/dfns/#smart-contract-interactions","text":"","title":"Smart Contract Interactions"},{"location":"cloud-functions/dfns/#dfnsinitiatepurchase","text":"Parse . Cloud . run ( \"dfnsInitiatePurchase\" , { tokenId : 123 , walletId : \"wallet-id\" , dfns_token : \"user-auth-token\" }) Purpose : Initiates an NFT purchase transaction through DFNS wallet. Parameters : - tokenId (number): ID of the NFT to purchase - walletId (string): DFNS wallet ID for the transaction - dfns_token (string): User's DFNS authentication token Returns : Transaction initialization data for marketplace purchase Process : 1. Validates all required parameters 2. Creates delegated DFNS client 3. Encodes marketplace purchase transaction data 4. Prepares EVM transaction body 5. Returns transaction data for user approval Integration : Works with MarketplaceFacet for NFT purchases","title":"dfnsInitiatePurchase"},{"location":"cloud-functions/dfns/#client-integration-patterns","text":"","title":"Client Integration Patterns"},{"location":"cloud-functions/dfns/#complete-user-onboarding-flow","text":"// 1. Register new user const registrationChallenge = await Parse . Cloud . run ( \"registerInit\" , { username : \"user@example.com\" }); // 2. Client signs challenge (using DFNS SDK) const signedChallenge = await dfnsClient . signChallenge ( registrationChallenge ); // 3. Complete registration const registrationResult = await Parse . Cloud . run ( \"registerComplete\" , { signedChallenge : signedChallenge , temporaryAuthenticationToken : registrationChallenge . temporaryAuthenticationToken }); // 4. Store user token const userToken = registrationResult . token ;","title":"Complete User Onboarding Flow"},{"location":"cloud-functions/dfns/#wallet-operations-flow","text":"// 1. Login existing user const loginResult = await Parse . Cloud . run ( \"login\" , { username : \"user@example.com\" }); // 2. List user's wallets const wallets = await Parse . Cloud . run ( \"listWallets\" , { authToken : loginResult . token }); // 3. Select wallet for operations const selectedWallet = wallets . items [ 0 ];","title":"Wallet Operations Flow"},{"location":"cloud-functions/dfns/#transaction-signing-flow","text":"// 1. Initiate signature const signatureInit = await Parse . Cloud . run ( \"signaturesInit\" , { authToken : userToken , walletId : selectedWallet . id , message : \"Approve transaction\" }); // 2. Client signs challenge const signedChallenge = await dfnsClient . signChallenge ( signatureInit . challenge ); // 3. Complete signature const signature = await Parse . Cloud . run ( \"signaturesComplete\" , { authToken : userToken , walletId : selectedWallet . id , requestBody : signatureInit . requestBody , signedChallenge : signedChallenge });","title":"Transaction Signing Flow"},{"location":"cloud-functions/dfns/#contract-integration","text":"","title":"Contract Integration"},{"location":"cloud-functions/dfns/#supported-contracts","text":"The DFNS module automatically loads ABIs and addresses for: Treasury Contract : Financial operations Marketplace Contract : NFT trading USDC Contract : Stable coin payments Carbon Credits Contract : Environmental assets Identity Contracts : User verification Trade Deal Contracts : Financial instruments","title":"Supported Contracts"},{"location":"cloud-functions/dfns/#dynamic-contract-loading","text":"// Contracts are loaded based on network configuration const networkConfig = config . find ( chain => chain . code === chainCode ); const artifactsPath = `../../deployments/ ${ chainCode } ` ; // ABIs and addresses loaded from deployment artifacts if ( fs . existsSync ( marketplaceFilePath )) { const { address , abi } = JSON . parse ( fs . readFileSync ( marketplaceFilePath , \"utf8\" )); MARKETPLACE_CONTRACT_ADDRESS = address ; MARKETPLACE_CONTRACT_ABI = abi ; }","title":"Dynamic Contract Loading"},{"location":"cloud-functions/dfns/#security-considerations","text":"","title":"Security Considerations"},{"location":"cloud-functions/dfns/#authentication-security","text":"Server-side private key storage for DFNS API authentication Delegated authentication prevents direct key exposure Challenge-response flow ensures user consent","title":"Authentication Security"},{"location":"cloud-functions/dfns/#transaction-security","text":"User approval required for all transactions Message signing for transaction authorization Network-specific wallet isolation","title":"Transaction Security"},{"location":"cloud-functions/dfns/#api-security","text":"Input validation for all parameters Error handling prevents information leakage Rate limiting through Parse Server","title":"API Security"},{"location":"cloud-functions/dfns/#error-handling","text":"","title":"Error Handling"},{"location":"cloud-functions/dfns/#common-error-patterns","text":"// Validation errors if ( ! username ) { throw new Parse . Error ( Parse . Error . VALIDATION_ERROR , \"Username is required\" ); } // DFNS API errors try { const result = await client . auth . delegatedLogin ({ body : { username } }); return result ; } catch ( error ) { throw new Parse . Error ( Parse . Error . INTERNAL_SERVER_ERROR , `Error during login: ${ error . message } ` ); }","title":"Common Error Patterns"},{"location":"cloud-functions/dfns/#error-types","text":"VALIDATION_ERROR : Missing or invalid parameters INTERNAL_SERVER_ERROR : DFNS API communication failures AUTHENTICATION_ERROR : Invalid tokens or credentials","title":"Error Types"},{"location":"cloud-functions/dfns/#performance-considerations","text":"","title":"Performance Considerations"},{"location":"cloud-functions/dfns/#client-caching","text":"Cache user authentication tokens Reuse wallet information Minimize API calls through batching","title":"Client Caching"},{"location":"cloud-functions/dfns/#network-optimization","text":"Use appropriate network for operations Consider gas costs for different networks Implement retry logic for network failures","title":"Network Optimization"},{"location":"cloud-functions/dfns/#testing","text":"","title":"Testing"},{"location":"cloud-functions/dfns/#unit-tests","text":"describe ( \"DFNS Functions\" , () => { test ( \"registerInit requires username\" , async () => { await expect ( Parse . Cloud . run ( \"registerInit\" , {}) ). rejects . toThrow ( \"Username is required\" ); }); test ( \"login returns token\" , async () => { const result = await Parse . Cloud . run ( \"login\" , { username : \"test@example.com\" }); expect ( result ). toHaveProperty ( \"token\" ); }); });","title":"Unit Tests"},{"location":"cloud-functions/dfns/#integration-tests","text":"Test with DFNS sandbox environment Validate wallet creation and management Test transaction signing flows Verify contract interaction patterns","title":"Integration Tests"},{"location":"cloud-functions/dfns/#related-documentation","text":"DFNS API Documentation Blockchain Functions - Network management Contract Functions - Smart contract interactions Authentication Functions - User authentication Developer Setup Guide - Environment configuration These functions provide secure wallet-as-a-service integration for the Gemforce platform through DFNS infrastructure.","title":"Related Documentation"},{"location":"cloud-functions/project/","text":"Project Functions \u00b6 The Project Functions module provides comprehensive project management capabilities for the Gemforce platform, enabling users to create, manage, and deploy blockchain-based projects with integrated smart contracts and tokenization features. Overview \u00b6 The Project Functions provide: Project Creation : Create new blockchain projects with customizable templates Project Management : Manage project lifecycle, settings, and configurations Token Integration : Integrate ERC20, ERC721, and ERC1155 tokens Smart Contract Deployment : Deploy and manage project smart contracts Collaboration : Multi-user project collaboration and permissions Analytics : Project performance metrics and analytics Key Features \u00b6 Project Lifecycle Management \u00b6 Project Templates : Pre-configured project templates for common use cases Custom Configuration : Flexible project configuration options Deployment Pipeline : Automated deployment to multiple networks Version Control : Project versioning and rollback capabilities Token Management \u00b6 Multi-Token Support : Support for various token standards Token Economics : Configure tokenomics and distribution models Minting Controls : Manage token minting permissions and limits Marketplace Integration : Integrate with NFT marketplaces Smart Contract Integration \u00b6 Diamond Architecture : Deploy upgradeable diamond contracts Facet Management : Add, remove, and upgrade contract facets Access Control : Manage contract permissions and roles Event Monitoring : Monitor contract events and transactions Core Functions \u00b6 createProject() \u00b6 Creates a new blockchain project with specified configuration. Parameters: interface CreateProjectRequest { name : string ; description : string ; template : string ; network : string ; tokenConfig ?: { type : 'ERC20' | 'ERC721' | 'ERC1155' ; name : string ; symbol : string ; totalSupply? : string ; baseURI? : string ; }; collaborators? : string []; settings? : ProjectSettings ; } interface ProjectSettings { isPublic : boolean ; allowMinting : boolean ; enableMarketplace : boolean ; enableGovernance : boolean ; customDomain? : string ; } Returns: interface CreateProjectResponse { success : boolean ; projectId : string ; contractAddress? : string ; deploymentTxHash? : string ; message : string ; } Usage: const result = await Parse . Cloud . run ( 'createProject' , { name : 'My NFT Collection' , description : 'A unique NFT collection with utility features' , template : 'nft-collection' , network : 'polygon' , tokenConfig : { type : 'ERC721' , name : 'My Collection' , symbol : 'MYC' , baseURI : 'https://api.myproject.com/metadata/' }, settings : { isPublic : true , allowMinting : true , enableMarketplace : true , enableGovernance : false } }); updateProject() \u00b6 Updates project configuration and settings. Parameters: interface UpdateProjectRequest { projectId : string ; updates : { name? : string ; description? : string ; settings? : Partial < ProjectSettings > ; collaborators? : string []; }; } Returns: interface UpdateProjectResponse { success : boolean ; message : string ; } deployProject() \u00b6 Deploys project smart contracts to specified network. Parameters: interface DeployProjectRequest { projectId : string ; network : string ; deploymentConfig ?: { gasLimit? : string ; gasPrice? : string ; confirmations? : number ; }; } Returns: interface DeployProjectResponse { success : boolean ; contractAddress? : string ; deploymentTxHash? : string ; estimatedGasCost? : string ; message : string ; } getProject() \u00b6 Retrieves project information and current status. Parameters: interface GetProjectRequest { projectId : string ; } Returns: interface GetProjectResponse { success : boolean ; project ?: { id : string ; name : string ; description : string ; template : string ; network : string ; contractAddress? : string ; status : 'draft' | 'deploying' | 'deployed' | 'failed' ; tokenConfig : any ; settings : ProjectSettings ; collaborators : string []; createdAt : Date ; updatedAt : Date ; analytics : ProjectAnalytics ; }; message : string ; } interface ProjectAnalytics { totalTransactions : number ; totalVolume : string ; uniqueUsers : number ; tokensMinted : number ; lastActivity : Date ; } listProjects() \u00b6 Lists projects accessible to the current user. Parameters: interface ListProjectsRequest { filter ?: 'owned' | 'collaborated' | 'public' ; limit? : number ; skip? : number ; sortBy ?: 'name' | 'createdAt' | 'updatedAt' ; sortOrder ?: 'asc' | 'desc' ; } Returns: interface ListProjectsResponse { success : boolean ; projects : ProjectSummary []; total : number ; message : string ; } interface ProjectSummary { id : string ; name : string ; description : string ; template : string ; network : string ; status : string ; createdAt : Date ; isOwner : boolean ; isCollaborator : boolean ; } Implementation Example \u00b6 Project Creation with Smart Contract Deployment \u00b6 Parse . Cloud . define ( 'createProject' , async ( request ) => { const { name , description , template , network , tokenConfig , collaborators , settings } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Validate input parameters if ( ! name || ! template || ! network ) { throw new Error ( 'Missing required parameters' ); } // Check if user has permission to create projects const userPermissions = await getUserPermissions ( user . id ); if ( ! userPermissions . canCreateProjects ) { throw new Error ( 'Insufficient permissions to create projects' ); } // Validate network support if ( ! isSupportedNetwork ( network )) { throw new Error ( 'Unsupported network' ); } // Get project template const projectTemplate = await getProjectTemplate ( template ); if ( ! projectTemplate ) { throw new Error ( 'Invalid project template' ); } // Create project record const project = new Parse . Object ( 'Project' ); project . set ( 'name' , name ); project . set ( 'description' , description ); project . set ( 'template' , template ); project . set ( 'network' , network ); project . set ( 'tokenConfig' , tokenConfig ); project . set ( 'settings' , settings || {}); project . set ( 'owner' , user ); project . set ( 'collaborators' , collaborators || []); project . set ( 'status' , 'draft' ); project . set ( 'createdAt' , new Date ()); project . set ( 'updatedAt' , new Date ()); await project . save (); // Deploy smart contracts if auto-deploy is enabled let deploymentResult = null ; if ( projectTemplate . autoDeploy ) { deploymentResult = await deployProjectContracts ( project . id , network , tokenConfig ); if ( deploymentResult . success ) { project . set ( 'contractAddress' , deploymentResult . contractAddress ); project . set ( 'deploymentTxHash' , deploymentResult . txHash ); project . set ( 'status' , 'deployed' ); } else { project . set ( 'status' , 'failed' ); project . set ( 'deploymentError' , deploymentResult . message ); } await project . save (); } // Setup project permissions await setupProjectPermissions ( project . id , user . id , collaborators ); // Initialize project analytics await initializeProjectAnalytics ( project . id ); // Send notifications to collaborators if ( collaborators && collaborators . length > 0 ) { await sendCollaborationInvites ( project . id , collaborators ); } return { success : true , projectId : project.id , contractAddress : deploymentResult?.contractAddress , deploymentTxHash : deploymentResult?.txHash , message : 'Project created successfully' }; } catch ( error ) { console . error ( 'Project creation error:' , error ); return { success : false , message : error.message || 'Failed to create project' }; } }); Smart Contract Deployment \u00b6 async function deployProjectContracts ( projectId : string , network : string , tokenConfig : any ) : Promise < { success : boolean ; contractAddress? : string ; txHash? : string ; message : string } > { try { // Get network configuration const networkConfig = await getNetworkConfig ( network ); if ( ! networkConfig ) { throw new Error ( 'Network configuration not found' ); } // Prepare deployment parameters const deploymentParams = { network , tokenType : tokenConfig.type , tokenName : tokenConfig.name , tokenSymbol : tokenConfig.symbol , totalSupply : tokenConfig.totalSupply , baseURI : tokenConfig.baseURI , projectId }; // Deploy diamond contract const diamondDeployment = await Parse . Cloud . run ( 'deployDiamond' , { network , template : 'project-diamond' , initParams : deploymentParams }); if ( ! diamondDeployment . success ) { throw new Error ( `Diamond deployment failed: ${ diamondDeployment . message } ` ); } // Deploy token contract const tokenDeployment = await Parse . Cloud . run ( 'deployToken' , deploymentParams ); if ( ! tokenDeployment . success ) { throw new Error ( `Token deployment failed: ${ tokenDeployment . message } ` ); } // Link contracts const linkingResult = await linkProjectContracts ( diamondDeployment . contractAddress , tokenDeployment . contractAddress , network ); if ( ! linkingResult . success ) { throw new Error ( `Contract linking failed: ${ linkingResult . message } ` ); } return { success : true , contractAddress : diamondDeployment.contractAddress , txHash : diamondDeployment.txHash , message : 'Contracts deployed successfully' }; } catch ( error ) { console . error ( 'Contract deployment error:' , error ); return { success : false , message : error.message || 'Contract deployment failed' }; } } Project Analytics \u00b6 Parse . Cloud . define ( 'getProjectAnalytics' , async ( request ) => { const { projectId , timeRange } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Check project access permissions const hasAccess = await checkProjectAccess ( projectId , user . id ); if ( ! hasAccess ) { throw new Error ( 'Access denied' ); } // Get project const project = await new Parse . Query ( 'Project' ) . equalTo ( 'objectId' , projectId ) . first ({ useMasterKey : true }); if ( ! project ) { throw new Error ( 'Project not found' ); } // Calculate time range const endDate = new Date (); const startDate = new Date (); switch ( timeRange ) { case '24h' : startDate . setHours ( startDate . getHours () - 24 ); break ; case '7d' : startDate . setDate ( startDate . getDate () - 7 ); break ; case '30d' : startDate . setDate ( startDate . getDate () - 30 ); break ; default : startDate.setDate ( startDate . getDate () - 7 ); } // Get analytics data const analytics = await calculateProjectAnalytics ( projectId , startDate , endDate ); return { success : true , analytics : { totalTransactions : analytics.transactionCount , totalVolume : analytics.totalVolume , uniqueUsers : analytics.uniqueUsers , tokensMinted : analytics.tokensMinted , averageTransactionValue : analytics.averageTransactionValue , topUsers : analytics.topUsers , dailyActivity : analytics.dailyActivity , revenueBreakdown : analytics.revenueBreakdown }, message : 'Analytics retrieved successfully' }; } catch ( error ) { console . error ( 'Analytics error:' , error ); return { success : false , message : error.message || 'Failed to get analytics' }; } }); async function calculateProjectAnalytics ( projectId : string , startDate : Date , endDate : Date ) : Promise < any > { // Get project transactions const transactions = await new Parse . Query ( 'Transaction' ) . equalTo ( 'projectId' , projectId ) . greaterThanOrEqualTo ( 'createdAt' , startDate ) . lessThanOrEqualTo ( 'createdAt' , endDate ) . find ({ useMasterKey : true }); // Calculate metrics const transactionCount = transactions . length ; const totalVolume = transactions . reduce (( sum , tx ) => sum + parseFloat ( tx . get ( 'value' ) || '0' ), 0 ); const uniqueUsers = new Set ( transactions . map ( tx => tx . get ( 'user' ) ? . id )). size ; // Get minting data const mintingEvents = await new Parse . Query ( 'MintingEvent' ) . equalTo ( 'projectId' , projectId ) . greaterThanOrEqualTo ( 'createdAt' , startDate ) . lessThanOrEqualTo ( 'createdAt' , endDate ) . find ({ useMasterKey : true }); const tokensMinted = mintingEvents . reduce (( sum , event ) => sum + ( event . get ( 'quantity' ) || 1 ), 0 ); // Calculate daily activity const dailyActivity = calculateDailyActivity ( transactions , startDate , endDate ); // Get top users const topUsers = calculateTopUsers ( transactions ); return { transactionCount , totalVolume : totalVolume.toString (), uniqueUsers , tokensMinted , averageTransactionValue : transactionCount > 0 ? ( totalVolume / transactionCount ). toString () : '0' , topUsers , dailyActivity , revenueBreakdown : calculateRevenueBreakdown ( transactions ) }; } Project Templates \u00b6 NFT Collection Template \u00b6 const nftCollectionTemplate = { name : 'NFT Collection' , description : 'Complete NFT collection with marketplace integration' , autoDeploy : true , facets : [ 'ERC721Facet' , 'MarketplaceFacet' , 'MetadataFacet' , 'OwnershipFacet' ], defaultSettings : { isPublic : true , allowMinting : true , enableMarketplace : true , enableGovernance : false }, requiredConfig : [ 'tokenName' , 'tokenSymbol' , 'baseURI' ], optionalConfig : [ 'maxSupply' , 'mintPrice' , 'royaltyPercentage' ] }; DeFi Protocol Template \u00b6 const defiProtocolTemplate = { name : 'DeFi Protocol' , description : 'Decentralized finance protocol with staking and governance' , autoDeploy : true , facets : [ 'ERC20Facet' , 'StakingFacet' , 'GovernanceFacet' , 'FeeDistributorFacet' , 'OwnershipFacet' ], defaultSettings : { isPublic : true , allowMinting : false , enableMarketplace : false , enableGovernance : true }, requiredConfig : [ 'tokenName' , 'tokenSymbol' , 'totalSupply' ], optionalConfig : [ 'stakingRewards' , 'governanceThreshold' , 'feePercentage' ] }; Gaming Platform Template \u00b6 const gamingPlatformTemplate = { name : 'Gaming Platform' , description : 'Gaming platform with NFT items and marketplace' , autoDeploy : true , facets : [ 'ERC1155Facet' , 'MarketplaceFacet' , 'AttributeFacet' , 'CraftingFacet' , 'OwnershipFacet' ], defaultSettings : { isPublic : true , allowMinting : true , enableMarketplace : true , enableGovernance : false }, requiredConfig : [ 'gameName' , 'baseURI' ], optionalConfig : [ 'itemTypes' , 'craftingRecipes' , 'marketplaceFee' ] }; Collaboration Features \u00b6 Project Permissions \u00b6 Parse . Cloud . define ( 'addCollaborator' , async ( request ) => { const { projectId , collaboratorEmail , role } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Check if user is project owner const project = await new Parse . Query ( 'Project' ) . equalTo ( 'objectId' , projectId ) . equalTo ( 'owner' , user ) . first ({ useMasterKey : true }); if ( ! project ) { throw new Error ( 'Project not found or access denied' ); } // Find collaborator user const collaborator = await new Parse . Query ( Parse . User ) . equalTo ( 'email' , collaboratorEmail . toLowerCase ()) . first ({ useMasterKey : true }); if ( ! collaborator ) { throw new Error ( 'User not found' ); } // Check if already a collaborator const existingCollaboration = await new Parse . Query ( 'ProjectCollaboration' ) . equalTo ( 'project' , project ) . equalTo ( 'collaborator' , collaborator ) . first ({ useMasterKey : true }); if ( existingCollaboration ) { throw new Error ( 'User is already a collaborator' ); } // Create collaboration record const collaboration = new Parse . Object ( 'ProjectCollaboration' ); collaboration . set ( 'project' , project ); collaboration . set ( 'collaborator' , collaborator ); collaboration . set ( 'role' , role || 'contributor' ); collaboration . set ( 'invitedBy' , user ); collaboration . set ( 'invitedAt' , new Date ()); collaboration . set ( 'status' , 'pending' ); await collaboration . save (); // Send invitation email await sendCollaborationInvite ( project , collaborator , user ); return { success : true , message : 'Collaborator invited successfully' }; } catch ( error ) { console . error ( 'Add collaborator error:' , error ); return { success : false , message : error.message || 'Failed to add collaborator' }; } }); Integration Examples \u00b6 Frontend Integration \u00b6 class ProjectService { async createProject ( projectData : CreateProjectRequest ) : Promise < CreateProjectResponse > { return await Parse . Cloud . run ( 'createProject' , projectData ); } async getProject ( projectId : string ) : Promise < GetProjectResponse > { return await Parse . Cloud . run ( 'getProject' , { projectId }); } async listProjects ( filter? : ListProjectsRequest ) : Promise < ListProjectsResponse > { return await Parse . Cloud . run ( 'listProjects' , filter || {}); } async deployProject ( projectId : string , network : string ) : Promise < DeployProjectResponse > { return await Parse . Cloud . run ( 'deployProject' , { projectId , network }); } async getAnalytics ( projectId : string , timeRange : string ) : Promise < any > { return await Parse . Cloud . run ( 'getProjectAnalytics' , { projectId , timeRange }); } } React Component Example \u00b6 export function ProjectDashboard () { const [ projects , setProjects ] = useState < ProjectSummary [] > ([]); const [ loading , setLoading ] = useState ( true ); useEffect (() => { loadProjects (); }, []); const loadProjects = async () => { try { const result = await new ProjectService (). listProjects ({ filter : 'owned' }); if ( result . success ) { setProjects ( result . projects ); } } catch ( error ) { console . error ( 'Failed to load projects:' , error ); } finally { setLoading ( false ); } }; const createNewProject = async ( projectData : CreateProjectRequest ) => { try { const result = await new ProjectService (). createProject ( projectData ); if ( result . success ) { await loadProjects (); // Refresh project list return result ; } } catch ( error ) { console . error ( 'Failed to create project:' , error ); throw error ; } }; return ( < div > < h1 > My Projects < /h1> { loading ? ( < div > Loading ... < /div> ) : ( < div > { projects . map ( project => ( < ProjectCard key = { project . id } project = { project } /> ))} < /div> )} < /div> ); } Error Handling \u00b6 Common Errors \u00b6 \"Authentication required\" : User not logged in \"Insufficient permissions\" : User lacks required permissions \"Unsupported network\" : Network not supported \"Invalid project template\" : Template not found or invalid \"Contract deployment failed\" : Smart contract deployment error \"Project not found\" : Project ID not found or access denied Error Recovery \u00b6 async function handleProjectDeploymentFailure ( projectId : string , error : any ) : Promise < void > { try { const project = await new Parse . Query ( 'Project' ) . equalTo ( 'objectId' , projectId ) . first ({ useMasterKey : true }); if ( project ) { project . set ( 'status' , 'failed' ); project . set ( 'deploymentError' , error . message ); project . set ( 'lastFailedAt' , new Date ()); await project . save (); // Notify project owner await sendDeploymentFailureNotification ( project , error ); // Schedule retry if appropriate if ( isRetryableError ( error )) { await scheduleDeploymentRetry ( projectId ); } } } catch ( recoveryError ) { console . error ( 'Error recovery failed:' , recoveryError ); } } Best Practices \u00b6 Project Management \u00b6 Template Validation : Validate project templates before deployment Permission Management : Implement proper access controls Resource Monitoring : Monitor deployment resources and costs Backup Strategy : Implement project backup and recovery Development Guidelines \u00b6 Error Handling : Comprehensive error handling and recovery Event Logging : Log all project operations for auditing Testing : Thorough testing of project templates and deployments Documentation : Document project templates and configurations Related Documentation \u00b6 Smart Contracts Overview Diamond Factory DFNS Integration Blockchain Functions Contract Functions Project Templates Guide Deployment Guide Security Considerations \u00b6 Access Control : Proper project access controls and permissions Contract Security : Secure smart contract deployment and management Data Validation : Validate all project configuration data Audit Trail : Complete audit trail for all project operations Resource Limits : Implement resource limits and quotas Collaboration Security : Secure collaboration and permission management","title":"Project Functions"},{"location":"cloud-functions/project/#project-functions","text":"The Project Functions module provides comprehensive project management capabilities for the Gemforce platform, enabling users to create, manage, and deploy blockchain-based projects with integrated smart contracts and tokenization features.","title":"Project Functions"},{"location":"cloud-functions/project/#overview","text":"The Project Functions provide: Project Creation : Create new blockchain projects with customizable templates Project Management : Manage project lifecycle, settings, and configurations Token Integration : Integrate ERC20, ERC721, and ERC1155 tokens Smart Contract Deployment : Deploy and manage project smart contracts Collaboration : Multi-user project collaboration and permissions Analytics : Project performance metrics and analytics","title":"Overview"},{"location":"cloud-functions/project/#key-features","text":"","title":"Key Features"},{"location":"cloud-functions/project/#project-lifecycle-management","text":"Project Templates : Pre-configured project templates for common use cases Custom Configuration : Flexible project configuration options Deployment Pipeline : Automated deployment to multiple networks Version Control : Project versioning and rollback capabilities","title":"Project Lifecycle Management"},{"location":"cloud-functions/project/#token-management","text":"Multi-Token Support : Support for various token standards Token Economics : Configure tokenomics and distribution models Minting Controls : Manage token minting permissions and limits Marketplace Integration : Integrate with NFT marketplaces","title":"Token Management"},{"location":"cloud-functions/project/#smart-contract-integration","text":"Diamond Architecture : Deploy upgradeable diamond contracts Facet Management : Add, remove, and upgrade contract facets Access Control : Manage contract permissions and roles Event Monitoring : Monitor contract events and transactions","title":"Smart Contract Integration"},{"location":"cloud-functions/project/#core-functions","text":"","title":"Core Functions"},{"location":"cloud-functions/project/#createproject","text":"Creates a new blockchain project with specified configuration. Parameters: interface CreateProjectRequest { name : string ; description : string ; template : string ; network : string ; tokenConfig ?: { type : 'ERC20' | 'ERC721' | 'ERC1155' ; name : string ; symbol : string ; totalSupply? : string ; baseURI? : string ; }; collaborators? : string []; settings? : ProjectSettings ; } interface ProjectSettings { isPublic : boolean ; allowMinting : boolean ; enableMarketplace : boolean ; enableGovernance : boolean ; customDomain? : string ; } Returns: interface CreateProjectResponse { success : boolean ; projectId : string ; contractAddress? : string ; deploymentTxHash? : string ; message : string ; } Usage: const result = await Parse . Cloud . run ( 'createProject' , { name : 'My NFT Collection' , description : 'A unique NFT collection with utility features' , template : 'nft-collection' , network : 'polygon' , tokenConfig : { type : 'ERC721' , name : 'My Collection' , symbol : 'MYC' , baseURI : 'https://api.myproject.com/metadata/' }, settings : { isPublic : true , allowMinting : true , enableMarketplace : true , enableGovernance : false } });","title":"createProject()"},{"location":"cloud-functions/project/#updateproject","text":"Updates project configuration and settings. Parameters: interface UpdateProjectRequest { projectId : string ; updates : { name? : string ; description? : string ; settings? : Partial < ProjectSettings > ; collaborators? : string []; }; } Returns: interface UpdateProjectResponse { success : boolean ; message : string ; }","title":"updateProject()"},{"location":"cloud-functions/project/#deployproject","text":"Deploys project smart contracts to specified network. Parameters: interface DeployProjectRequest { projectId : string ; network : string ; deploymentConfig ?: { gasLimit? : string ; gasPrice? : string ; confirmations? : number ; }; } Returns: interface DeployProjectResponse { success : boolean ; contractAddress? : string ; deploymentTxHash? : string ; estimatedGasCost? : string ; message : string ; }","title":"deployProject()"},{"location":"cloud-functions/project/#getproject","text":"Retrieves project information and current status. Parameters: interface GetProjectRequest { projectId : string ; } Returns: interface GetProjectResponse { success : boolean ; project ?: { id : string ; name : string ; description : string ; template : string ; network : string ; contractAddress? : string ; status : 'draft' | 'deploying' | 'deployed' | 'failed' ; tokenConfig : any ; settings : ProjectSettings ; collaborators : string []; createdAt : Date ; updatedAt : Date ; analytics : ProjectAnalytics ; }; message : string ; } interface ProjectAnalytics { totalTransactions : number ; totalVolume : string ; uniqueUsers : number ; tokensMinted : number ; lastActivity : Date ; }","title":"getProject()"},{"location":"cloud-functions/project/#listprojects","text":"Lists projects accessible to the current user. Parameters: interface ListProjectsRequest { filter ?: 'owned' | 'collaborated' | 'public' ; limit? : number ; skip? : number ; sortBy ?: 'name' | 'createdAt' | 'updatedAt' ; sortOrder ?: 'asc' | 'desc' ; } Returns: interface ListProjectsResponse { success : boolean ; projects : ProjectSummary []; total : number ; message : string ; } interface ProjectSummary { id : string ; name : string ; description : string ; template : string ; network : string ; status : string ; createdAt : Date ; isOwner : boolean ; isCollaborator : boolean ; }","title":"listProjects()"},{"location":"cloud-functions/project/#implementation-example","text":"","title":"Implementation Example"},{"location":"cloud-functions/project/#project-creation-with-smart-contract-deployment","text":"Parse . Cloud . define ( 'createProject' , async ( request ) => { const { name , description , template , network , tokenConfig , collaborators , settings } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Validate input parameters if ( ! name || ! template || ! network ) { throw new Error ( 'Missing required parameters' ); } // Check if user has permission to create projects const userPermissions = await getUserPermissions ( user . id ); if ( ! userPermissions . canCreateProjects ) { throw new Error ( 'Insufficient permissions to create projects' ); } // Validate network support if ( ! isSupportedNetwork ( network )) { throw new Error ( 'Unsupported network' ); } // Get project template const projectTemplate = await getProjectTemplate ( template ); if ( ! projectTemplate ) { throw new Error ( 'Invalid project template' ); } // Create project record const project = new Parse . Object ( 'Project' ); project . set ( 'name' , name ); project . set ( 'description' , description ); project . set ( 'template' , template ); project . set ( 'network' , network ); project . set ( 'tokenConfig' , tokenConfig ); project . set ( 'settings' , settings || {}); project . set ( 'owner' , user ); project . set ( 'collaborators' , collaborators || []); project . set ( 'status' , 'draft' ); project . set ( 'createdAt' , new Date ()); project . set ( 'updatedAt' , new Date ()); await project . save (); // Deploy smart contracts if auto-deploy is enabled let deploymentResult = null ; if ( projectTemplate . autoDeploy ) { deploymentResult = await deployProjectContracts ( project . id , network , tokenConfig ); if ( deploymentResult . success ) { project . set ( 'contractAddress' , deploymentResult . contractAddress ); project . set ( 'deploymentTxHash' , deploymentResult . txHash ); project . set ( 'status' , 'deployed' ); } else { project . set ( 'status' , 'failed' ); project . set ( 'deploymentError' , deploymentResult . message ); } await project . save (); } // Setup project permissions await setupProjectPermissions ( project . id , user . id , collaborators ); // Initialize project analytics await initializeProjectAnalytics ( project . id ); // Send notifications to collaborators if ( collaborators && collaborators . length > 0 ) { await sendCollaborationInvites ( project . id , collaborators ); } return { success : true , projectId : project.id , contractAddress : deploymentResult?.contractAddress , deploymentTxHash : deploymentResult?.txHash , message : 'Project created successfully' }; } catch ( error ) { console . error ( 'Project creation error:' , error ); return { success : false , message : error.message || 'Failed to create project' }; } });","title":"Project Creation with Smart Contract Deployment"},{"location":"cloud-functions/project/#smart-contract-deployment","text":"async function deployProjectContracts ( projectId : string , network : string , tokenConfig : any ) : Promise < { success : boolean ; contractAddress? : string ; txHash? : string ; message : string } > { try { // Get network configuration const networkConfig = await getNetworkConfig ( network ); if ( ! networkConfig ) { throw new Error ( 'Network configuration not found' ); } // Prepare deployment parameters const deploymentParams = { network , tokenType : tokenConfig.type , tokenName : tokenConfig.name , tokenSymbol : tokenConfig.symbol , totalSupply : tokenConfig.totalSupply , baseURI : tokenConfig.baseURI , projectId }; // Deploy diamond contract const diamondDeployment = await Parse . Cloud . run ( 'deployDiamond' , { network , template : 'project-diamond' , initParams : deploymentParams }); if ( ! diamondDeployment . success ) { throw new Error ( `Diamond deployment failed: ${ diamondDeployment . message } ` ); } // Deploy token contract const tokenDeployment = await Parse . Cloud . run ( 'deployToken' , deploymentParams ); if ( ! tokenDeployment . success ) { throw new Error ( `Token deployment failed: ${ tokenDeployment . message } ` ); } // Link contracts const linkingResult = await linkProjectContracts ( diamondDeployment . contractAddress , tokenDeployment . contractAddress , network ); if ( ! linkingResult . success ) { throw new Error ( `Contract linking failed: ${ linkingResult . message } ` ); } return { success : true , contractAddress : diamondDeployment.contractAddress , txHash : diamondDeployment.txHash , message : 'Contracts deployed successfully' }; } catch ( error ) { console . error ( 'Contract deployment error:' , error ); return { success : false , message : error.message || 'Contract deployment failed' }; } }","title":"Smart Contract Deployment"},{"location":"cloud-functions/project/#project-analytics","text":"Parse . Cloud . define ( 'getProjectAnalytics' , async ( request ) => { const { projectId , timeRange } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Check project access permissions const hasAccess = await checkProjectAccess ( projectId , user . id ); if ( ! hasAccess ) { throw new Error ( 'Access denied' ); } // Get project const project = await new Parse . Query ( 'Project' ) . equalTo ( 'objectId' , projectId ) . first ({ useMasterKey : true }); if ( ! project ) { throw new Error ( 'Project not found' ); } // Calculate time range const endDate = new Date (); const startDate = new Date (); switch ( timeRange ) { case '24h' : startDate . setHours ( startDate . getHours () - 24 ); break ; case '7d' : startDate . setDate ( startDate . getDate () - 7 ); break ; case '30d' : startDate . setDate ( startDate . getDate () - 30 ); break ; default : startDate.setDate ( startDate . getDate () - 7 ); } // Get analytics data const analytics = await calculateProjectAnalytics ( projectId , startDate , endDate ); return { success : true , analytics : { totalTransactions : analytics.transactionCount , totalVolume : analytics.totalVolume , uniqueUsers : analytics.uniqueUsers , tokensMinted : analytics.tokensMinted , averageTransactionValue : analytics.averageTransactionValue , topUsers : analytics.topUsers , dailyActivity : analytics.dailyActivity , revenueBreakdown : analytics.revenueBreakdown }, message : 'Analytics retrieved successfully' }; } catch ( error ) { console . error ( 'Analytics error:' , error ); return { success : false , message : error.message || 'Failed to get analytics' }; } }); async function calculateProjectAnalytics ( projectId : string , startDate : Date , endDate : Date ) : Promise < any > { // Get project transactions const transactions = await new Parse . Query ( 'Transaction' ) . equalTo ( 'projectId' , projectId ) . greaterThanOrEqualTo ( 'createdAt' , startDate ) . lessThanOrEqualTo ( 'createdAt' , endDate ) . find ({ useMasterKey : true }); // Calculate metrics const transactionCount = transactions . length ; const totalVolume = transactions . reduce (( sum , tx ) => sum + parseFloat ( tx . get ( 'value' ) || '0' ), 0 ); const uniqueUsers = new Set ( transactions . map ( tx => tx . get ( 'user' ) ? . id )). size ; // Get minting data const mintingEvents = await new Parse . Query ( 'MintingEvent' ) . equalTo ( 'projectId' , projectId ) . greaterThanOrEqualTo ( 'createdAt' , startDate ) . lessThanOrEqualTo ( 'createdAt' , endDate ) . find ({ useMasterKey : true }); const tokensMinted = mintingEvents . reduce (( sum , event ) => sum + ( event . get ( 'quantity' ) || 1 ), 0 ); // Calculate daily activity const dailyActivity = calculateDailyActivity ( transactions , startDate , endDate ); // Get top users const topUsers = calculateTopUsers ( transactions ); return { transactionCount , totalVolume : totalVolume.toString (), uniqueUsers , tokensMinted , averageTransactionValue : transactionCount > 0 ? ( totalVolume / transactionCount ). toString () : '0' , topUsers , dailyActivity , revenueBreakdown : calculateRevenueBreakdown ( transactions ) }; }","title":"Project Analytics"},{"location":"cloud-functions/project/#project-templates","text":"","title":"Project Templates"},{"location":"cloud-functions/project/#nft-collection-template","text":"const nftCollectionTemplate = { name : 'NFT Collection' , description : 'Complete NFT collection with marketplace integration' , autoDeploy : true , facets : [ 'ERC721Facet' , 'MarketplaceFacet' , 'MetadataFacet' , 'OwnershipFacet' ], defaultSettings : { isPublic : true , allowMinting : true , enableMarketplace : true , enableGovernance : false }, requiredConfig : [ 'tokenName' , 'tokenSymbol' , 'baseURI' ], optionalConfig : [ 'maxSupply' , 'mintPrice' , 'royaltyPercentage' ] };","title":"NFT Collection Template"},{"location":"cloud-functions/project/#defi-protocol-template","text":"const defiProtocolTemplate = { name : 'DeFi Protocol' , description : 'Decentralized finance protocol with staking and governance' , autoDeploy : true , facets : [ 'ERC20Facet' , 'StakingFacet' , 'GovernanceFacet' , 'FeeDistributorFacet' , 'OwnershipFacet' ], defaultSettings : { isPublic : true , allowMinting : false , enableMarketplace : false , enableGovernance : true }, requiredConfig : [ 'tokenName' , 'tokenSymbol' , 'totalSupply' ], optionalConfig : [ 'stakingRewards' , 'governanceThreshold' , 'feePercentage' ] };","title":"DeFi Protocol Template"},{"location":"cloud-functions/project/#gaming-platform-template","text":"const gamingPlatformTemplate = { name : 'Gaming Platform' , description : 'Gaming platform with NFT items and marketplace' , autoDeploy : true , facets : [ 'ERC1155Facet' , 'MarketplaceFacet' , 'AttributeFacet' , 'CraftingFacet' , 'OwnershipFacet' ], defaultSettings : { isPublic : true , allowMinting : true , enableMarketplace : true , enableGovernance : false }, requiredConfig : [ 'gameName' , 'baseURI' ], optionalConfig : [ 'itemTypes' , 'craftingRecipes' , 'marketplaceFee' ] };","title":"Gaming Platform Template"},{"location":"cloud-functions/project/#collaboration-features","text":"","title":"Collaboration Features"},{"location":"cloud-functions/project/#project-permissions","text":"Parse . Cloud . define ( 'addCollaborator' , async ( request ) => { const { projectId , collaboratorEmail , role } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Check if user is project owner const project = await new Parse . Query ( 'Project' ) . equalTo ( 'objectId' , projectId ) . equalTo ( 'owner' , user ) . first ({ useMasterKey : true }); if ( ! project ) { throw new Error ( 'Project not found or access denied' ); } // Find collaborator user const collaborator = await new Parse . Query ( Parse . User ) . equalTo ( 'email' , collaboratorEmail . toLowerCase ()) . first ({ useMasterKey : true }); if ( ! collaborator ) { throw new Error ( 'User not found' ); } // Check if already a collaborator const existingCollaboration = await new Parse . Query ( 'ProjectCollaboration' ) . equalTo ( 'project' , project ) . equalTo ( 'collaborator' , collaborator ) . first ({ useMasterKey : true }); if ( existingCollaboration ) { throw new Error ( 'User is already a collaborator' ); } // Create collaboration record const collaboration = new Parse . Object ( 'ProjectCollaboration' ); collaboration . set ( 'project' , project ); collaboration . set ( 'collaborator' , collaborator ); collaboration . set ( 'role' , role || 'contributor' ); collaboration . set ( 'invitedBy' , user ); collaboration . set ( 'invitedAt' , new Date ()); collaboration . set ( 'status' , 'pending' ); await collaboration . save (); // Send invitation email await sendCollaborationInvite ( project , collaborator , user ); return { success : true , message : 'Collaborator invited successfully' }; } catch ( error ) { console . error ( 'Add collaborator error:' , error ); return { success : false , message : error.message || 'Failed to add collaborator' }; } });","title":"Project Permissions"},{"location":"cloud-functions/project/#integration-examples","text":"","title":"Integration Examples"},{"location":"cloud-functions/project/#frontend-integration","text":"class ProjectService { async createProject ( projectData : CreateProjectRequest ) : Promise < CreateProjectResponse > { return await Parse . Cloud . run ( 'createProject' , projectData ); } async getProject ( projectId : string ) : Promise < GetProjectResponse > { return await Parse . Cloud . run ( 'getProject' , { projectId }); } async listProjects ( filter? : ListProjectsRequest ) : Promise < ListProjectsResponse > { return await Parse . Cloud . run ( 'listProjects' , filter || {}); } async deployProject ( projectId : string , network : string ) : Promise < DeployProjectResponse > { return await Parse . Cloud . run ( 'deployProject' , { projectId , network }); } async getAnalytics ( projectId : string , timeRange : string ) : Promise < any > { return await Parse . Cloud . run ( 'getProjectAnalytics' , { projectId , timeRange }); } }","title":"Frontend Integration"},{"location":"cloud-functions/project/#react-component-example","text":"export function ProjectDashboard () { const [ projects , setProjects ] = useState < ProjectSummary [] > ([]); const [ loading , setLoading ] = useState ( true ); useEffect (() => { loadProjects (); }, []); const loadProjects = async () => { try { const result = await new ProjectService (). listProjects ({ filter : 'owned' }); if ( result . success ) { setProjects ( result . projects ); } } catch ( error ) { console . error ( 'Failed to load projects:' , error ); } finally { setLoading ( false ); } }; const createNewProject = async ( projectData : CreateProjectRequest ) => { try { const result = await new ProjectService (). createProject ( projectData ); if ( result . success ) { await loadProjects (); // Refresh project list return result ; } } catch ( error ) { console . error ( 'Failed to create project:' , error ); throw error ; } }; return ( < div > < h1 > My Projects < /h1> { loading ? ( < div > Loading ... < /div> ) : ( < div > { projects . map ( project => ( < ProjectCard key = { project . id } project = { project } /> ))} < /div> )} < /div> ); }","title":"React Component Example"},{"location":"cloud-functions/project/#error-handling","text":"","title":"Error Handling"},{"location":"cloud-functions/project/#common-errors","text":"\"Authentication required\" : User not logged in \"Insufficient permissions\" : User lacks required permissions \"Unsupported network\" : Network not supported \"Invalid project template\" : Template not found or invalid \"Contract deployment failed\" : Smart contract deployment error \"Project not found\" : Project ID not found or access denied","title":"Common Errors"},{"location":"cloud-functions/project/#error-recovery","text":"async function handleProjectDeploymentFailure ( projectId : string , error : any ) : Promise < void > { try { const project = await new Parse . Query ( 'Project' ) . equalTo ( 'objectId' , projectId ) . first ({ useMasterKey : true }); if ( project ) { project . set ( 'status' , 'failed' ); project . set ( 'deploymentError' , error . message ); project . set ( 'lastFailedAt' , new Date ()); await project . save (); // Notify project owner await sendDeploymentFailureNotification ( project , error ); // Schedule retry if appropriate if ( isRetryableError ( error )) { await scheduleDeploymentRetry ( projectId ); } } } catch ( recoveryError ) { console . error ( 'Error recovery failed:' , recoveryError ); } }","title":"Error Recovery"},{"location":"cloud-functions/project/#best-practices","text":"","title":"Best Practices"},{"location":"cloud-functions/project/#project-management","text":"Template Validation : Validate project templates before deployment Permission Management : Implement proper access controls Resource Monitoring : Monitor deployment resources and costs Backup Strategy : Implement project backup and recovery","title":"Project Management"},{"location":"cloud-functions/project/#development-guidelines","text":"Error Handling : Comprehensive error handling and recovery Event Logging : Log all project operations for auditing Testing : Thorough testing of project templates and deployments Documentation : Document project templates and configurations","title":"Development Guidelines"},{"location":"cloud-functions/project/#related-documentation","text":"Smart Contracts Overview Diamond Factory DFNS Integration Blockchain Functions Contract Functions Project Templates Guide Deployment Guide","title":"Related Documentation"},{"location":"cloud-functions/project/#security-considerations","text":"Access Control : Proper project access controls and permissions Contract Security : Secure smart contract deployment and management Data Validation : Validate all project configuration data Audit Trail : Complete audit trail for all project operations Resource Limits : Implement resource limits and quotas Collaboration Security : Secure collaboration and permission management","title":"Security Considerations"},{"location":"cloud-functions/trade-deal/","text":"Trade Deal Functions \u00b6 The Trade Deal Functions module provides comprehensive trade deal management capabilities for the Gemforce platform, enabling users to create, manage, and execute collateralized trade deals with invoice NFTs and automated settlement. Overview \u00b6 The Trade Deal Functions provide: Trade Deal Creation : Create collateralized trade deals with customizable terms Invoice Management : Generate and manage invoice NFTs for trade deals Collateral Management : Handle collateral deposits and releases Settlement Automation : Automated trade deal settlement and dispute resolution Payment Processing : Integrate with various payment methods and currencies Compliance : KYC/AML compliance and regulatory reporting Key Features \u00b6 Trade Deal Lifecycle \u00b6 Deal Creation : Create trade deals with flexible terms and conditions Collateral Handling : Secure collateral deposit and management Invoice Generation : Automatic invoice NFT creation and management Settlement Processing : Automated settlement upon deal completion Dispute Resolution : Built-in dispute resolution mechanisms Financial Integration \u00b6 Multi-Currency Support : Support for various cryptocurrencies and stablecoins Payment Rails : Integration with traditional and crypto payment systems Escrow Services : Secure escrow for high-value transactions Fee Management : Transparent fee structure and collection Compliance Features \u00b6 KYC Integration : Know Your Customer verification AML Monitoring : Anti-Money Laundering compliance Regulatory Reporting : Automated compliance reporting Audit Trail : Complete transaction audit trail Core Functions \u00b6 createTradeDeal() \u00b6 Creates a new trade deal with specified terms and collateral requirements. Parameters: interface CreateTradeDealRequest { dealType : 'purchase_order' | 'service_agreement' | 'supply_contract' ; buyer : string ; seller : string ; dealTerms : { description : string ; totalAmount : string ; currency : string ; deliveryDate : Date ; paymentTerms : string ; specifications? : any ; }; collateralRequirements : { buyerCollateral : string ; sellerCollateral : string ; collateralCurrency : string ; }; milestones? : TradeDealMilestone []; disputeResolution? : DisputeResolutionTerms ; } interface TradeDealMilestone { id : string ; description : string ; amount : string ; dueDate : Date ; deliverables : string []; } interface DisputeResolutionTerms { arbitrator? : string ; timeoutPeriod : number ; penaltyPercentage : number ; } Returns: interface CreateTradeDealResponse { success : boolean ; dealId : string ; contractAddress? : string ; collateralAddresses ?: { buyer : string ; seller : string ; }; message : string ; } Usage: const result = await Parse . Cloud . run ( 'createTradeDeal' , { dealType : 'purchase_order' , buyer : 'buyer@company.com' , seller : 'seller@supplier.com' , dealTerms : { description : 'Supply of 1000 units of Product X' , totalAmount : '50000' , currency : 'USDC' , deliveryDate : new Date ( '2024-12-31' ), paymentTerms : 'Net 30' , specifications : { quantity : 1000 , quality : 'Grade A' , packaging : 'Standard' } }, collateralRequirements : { buyerCollateral : '5000' , sellerCollateral : '2500' , collateralCurrency : 'USDC' } }); depositCollateral() \u00b6 Deposits collateral for a trade deal. Parameters: interface DepositCollateralRequest { dealId : string ; party : 'buyer' | 'seller' ; amount : string ; currency : string ; paymentMethod : 'crypto' | 'bank_transfer' | 'credit_card' ; } Returns: interface DepositCollateralResponse { success : boolean ; transactionHash? : string ; escrowAddress? : string ; confirmationRequired? : boolean ; message : string ; } generateInvoice() \u00b6 Generates an invoice NFT for a trade deal milestone. Parameters: interface GenerateInvoiceRequest { dealId : string ; milestoneId? : string ; invoiceDetails : { invoiceNumber : string ; amount : string ; currency : string ; dueDate : Date ; lineItems : InvoiceLineItem []; taxDetails? : TaxDetails ; }; recipient : string ; } interface InvoiceLineItem { description : string ; quantity : number ; unitPrice : string ; totalPrice : string ; } interface TaxDetails { taxRate : number ; taxAmount : string ; taxJurisdiction : string ; } Returns: interface GenerateInvoiceResponse { success : boolean ; invoiceId : string ; nftTokenId? : string ; invoiceNFTAddress? : string ; metadataURI? : string ; message : string ; } settleTradeDeal() \u00b6 Settles a completed trade deal and releases collateral. Parameters: interface SettleTradeDealRequest { dealId : string ; settlementType : 'successful' | 'disputed' | 'cancelled' ; settlementDetails ?: { actualDeliveryDate? : Date ; qualityRating? : number ; performanceNotes? : string ; }; disputeResolution ?: { ruling : string ; collateralDistribution : { buyerReturn : string ; sellerReturn : string ; penaltyAmount : string ; }; }; } Returns: interface SettleTradeDealResponse { success : boolean ; settlementTransactionHash? : string ; collateralReleaseHashes? : string []; finalStatus : string ; message : string ; } getTradeDeal() \u00b6 Retrieves trade deal information and current status. Parameters: interface GetTradeDealRequest { dealId : string ; } Returns: interface GetTradeDealResponse { success : boolean ; tradeDeal ?: { id : string ; dealType : string ; buyer : string ; seller : string ; status : 'created' | 'collateral_pending' | 'active' | 'completed' | 'disputed' | 'cancelled' ; dealTerms : any ; collateralStatus : { buyerDeposited : boolean ; sellerDeposited : boolean ; amounts : any ; }; milestones : TradeDealMilestone []; invoices : InvoiceInfo []; timeline : TradeDealEvent []; createdAt : Date ; updatedAt : Date ; }; message : string ; } interface InvoiceInfo { id : string ; invoiceNumber : string ; amount : string ; status : 'generated' | 'sent' | 'paid' | 'overdue' ; nftTokenId? : string ; createdAt : Date ; } interface TradeDealEvent { type : string ; description : string ; timestamp : Date ; actor : string ; transactionHash? : string ; } Implementation Example \u00b6 Trade Deal Creation with Smart Contract Deployment \u00b6 Parse . Cloud . define ( 'createTradeDeal' , async ( request ) => { const { dealType , buyer , seller , dealTerms , collateralRequirements , milestones , disputeResolution } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Validate participants const buyerUser = await validateTradeDealParticipant ( buyer ); const sellerUser = await validateTradeDealParticipant ( seller ); if ( ! buyerUser || ! sellerUser ) { throw new Error ( 'Invalid trade deal participants' ); } // Check KYC compliance const buyerKYC = await checkKYCStatus ( buyerUser . id ); const sellerKYC = await checkKYCStatus ( sellerUser . id ); if ( ! buyerKYC . verified || ! sellerKYC . verified ) { throw new Error ( 'KYC verification required for all participants' ); } // Validate deal terms await validateTradeDealTerms ( dealTerms , collateralRequirements ); // Create trade deal record const tradeDeal = new Parse . Object ( 'TradeDeal' ); tradeDeal . set ( 'dealType' , dealType ); tradeDeal . set ( 'buyer' , buyerUser ); tradeDeal . set ( 'seller' , sellerUser ); tradeDeal . set ( 'creator' , user ); tradeDeal . set ( 'dealTerms' , dealTerms ); tradeDeal . set ( 'collateralRequirements' , collateralRequirements ); tradeDeal . set ( 'milestones' , milestones || []); tradeDeal . set ( 'disputeResolution' , disputeResolution ); tradeDeal . set ( 'status' , 'created' ); tradeDeal . set ( 'createdAt' , new Date ()); tradeDeal . set ( 'updatedAt' , new Date ()); await tradeDeal . save (); // Deploy trade deal smart contract const contractDeployment = await deployTradeDealContract ({ dealId : tradeDeal.id , buyer : buyerUser.get ( 'walletAddress' ), seller : sellerUser.get ( 'walletAddress' ), dealTerms , collateralRequirements }); if ( ! contractDeployment . success ) { tradeDeal . set ( 'status' , 'failed' ); tradeDeal . set ( 'deploymentError' , contractDeployment . message ); await tradeDeal . save (); throw new Error ( `Contract deployment failed: ${ contractDeployment . message } ` ); } // Update trade deal with contract information tradeDeal . set ( 'contractAddress' , contractDeployment . contractAddress ); tradeDeal . set ( 'deploymentTxHash' , contractDeployment . txHash ); tradeDeal . set ( 'status' , 'collateral_pending' ); await tradeDeal . save (); // Create collateral escrow contracts const escrowDeployment = await deployCollateralEscrows ( tradeDeal . id , collateralRequirements ); if ( escrowDeployment . success ) { tradeDeal . set ( 'collateralAddresses' , escrowDeployment . addresses ); await tradeDeal . save (); } // Send notifications to participants await sendTradeDealNotifications ( tradeDeal . id , 'created' ); // Log trade deal creation event await logTradeDealEvent ( tradeDeal . id , 'deal_created' , 'Trade deal created successfully' , user . id ); return { success : true , dealId : tradeDeal.id , contractAddress : contractDeployment.contractAddress , collateralAddresses : escrowDeployment.addresses , message : 'Trade deal created successfully' }; } catch ( error ) { console . error ( 'Trade deal creation error:' , error ); return { success : false , message : error.message || 'Failed to create trade deal' }; } }); Collateral Management \u00b6 Parse . Cloud . define ( 'depositCollateral' , async ( request ) => { const { dealId , party , amount , currency , paymentMethod } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Get trade deal const tradeDeal = await new Parse . Query ( 'TradeDeal' ) . equalTo ( 'objectId' , dealId ) . first ({ useMasterKey : true }); if ( ! tradeDeal ) { throw new Error ( 'Trade deal not found' ); } // Verify user is authorized party const isAuthorized = ( party === 'buyer' && tradeDeal . get ( 'buyer' ). id === user . id ) || ( party === 'seller' && tradeDeal . get ( 'seller' ). id === user . id ); if ( ! isAuthorized ) { throw new Error ( 'Unauthorized to deposit collateral for this party' ); } // Check if collateral already deposited const collateralStatus = tradeDeal . get ( 'collateralStatus' ) || {}; const partyKey = ` ${ party } Deposited` ; if ( collateralStatus [ partyKey ]) { throw new Error ( 'Collateral already deposited' ); } // Validate collateral amount const requiredAmount = tradeDeal . get ( 'collateralRequirements' )[ ` ${ party } Collateral` ]; if ( amount !== requiredAmount ) { throw new Error ( `Incorrect collateral amount. Required: ${ requiredAmount } ` ); } // Process collateral deposit based on payment method let depositResult ; switch ( paymentMethod ) { case 'crypto' : depositResult = await processCryptoCollateralDeposit ( dealId , party , amount , currency , user ); break ; case 'bank_transfer' : depositResult = await processBankTransferCollateral ( dealId , party , amount , currency , user ); break ; case 'credit_card' : depositResult = await processCreditCardCollateral ( dealId , party , amount , currency , user ); break ; default : throw new Error ( 'Unsupported payment method' ); } if ( ! depositResult . success ) { throw new Error ( `Collateral deposit failed: ${ depositResult . message } ` ); } // Update collateral status collateralStatus [ partyKey ] = true ; collateralStatus [ ` ${ party } Amount` ] = amount ; collateralStatus [ ` ${ party } TxHash` ] = depositResult . transactionHash ; collateralStatus [ ` ${ party } DepositedAt` ] = new Date (); tradeDeal . set ( 'collateralStatus' , collateralStatus ); // Check if both parties have deposited collateral if ( collateralStatus . buyerDeposited && collateralStatus . sellerDeposited ) { tradeDeal . set ( 'status' , 'active' ); tradeDeal . set ( 'activatedAt' , new Date ()); // Activate the trade deal contract await activateTradeDealContract ( tradeDeal . get ( 'contractAddress' )); // Send activation notifications await sendTradeDealNotifications ( dealId , 'activated' ); } await tradeDeal . save (); // Log collateral deposit event await logTradeDealEvent ( dealId , 'collateral_deposited' , ` ${ party } deposited collateral` , user . id , depositResult . transactionHash ); return { success : true , transactionHash : depositResult.transactionHash , escrowAddress : depositResult.escrowAddress , confirmationRequired : depositResult.confirmationRequired , message : 'Collateral deposited successfully' }; } catch ( error ) { console . error ( 'Collateral deposit error:' , error ); return { success : false , message : error.message || 'Failed to deposit collateral' }; } }); Invoice NFT Generation \u00b6 Parse . Cloud . define ( 'generateInvoice' , async ( request ) => { const { dealId , milestoneId , invoiceDetails , recipient } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Get trade deal const tradeDeal = await new Parse . Query ( 'TradeDeal' ) . equalTo ( 'objectId' , dealId ) . first ({ useMasterKey : true }); if ( ! tradeDeal ) { throw new Error ( 'Trade deal not found' ); } // Verify user is authorized to generate invoice const isAuthorized = tradeDeal . get ( 'seller' ). id === user . id || tradeDeal . get ( 'buyer' ). id === user . id ; if ( ! isAuthorized ) { throw new Error ( 'Unauthorized to generate invoice for this trade deal' ); } // Validate invoice details await validateInvoiceDetails ( invoiceDetails ); // Create invoice record const invoice = new Parse . Object ( 'Invoice' ); invoice . set ( 'tradeDeal' , tradeDeal ); invoice . set ( 'milestoneId' , milestoneId ); invoice . set ( 'invoiceNumber' , invoiceDetails . invoiceNumber ); invoice . set ( 'amount' , invoiceDetails . amount ); invoice . set ( 'currency' , invoiceDetails . currency ); invoice . set ( 'dueDate' , invoiceDetails . dueDate ); invoice . set ( 'lineItems' , invoiceDetails . lineItems ); invoice . set ( 'taxDetails' , invoiceDetails . taxDetails ); invoice . set ( 'recipient' , recipient ); invoice . set ( 'issuer' , user ); invoice . set ( 'status' , 'generated' ); invoice . set ( 'createdAt' , new Date ()); await invoice . save (); // Generate invoice metadata const metadata = await generateInvoiceMetadata ( invoice . id , invoiceDetails ); // Mint invoice NFT const nftMinting = await mintInvoiceNFT ({ invoiceId : invoice.id , recipient , metadata , tradeDealContract : tradeDeal.get ( 'contractAddress' ) }); if ( ! nftMinting . success ) { invoice . set ( 'status' , 'failed' ); invoice . set ( 'mintingError' , nftMinting . message ); await invoice . save (); throw new Error ( `Invoice NFT minting failed: ${ nftMinting . message } ` ); } // Update invoice with NFT information invoice . set ( 'nftTokenId' , nftMinting . tokenId ); invoice . set ( 'nftAddress' , nftMinting . contractAddress ); invoice . set ( 'metadataURI' , nftMinting . metadataURI ); invoice . set ( 'mintingTxHash' , nftMinting . txHash ); invoice . set ( 'status' , 'minted' ); await invoice . save (); // Update trade deal with invoice reference const invoices = tradeDeal . get ( 'invoices' ) || []; invoices . push ({ id : invoice.id , invoiceNumber : invoiceDetails.invoiceNumber , amount : invoiceDetails.amount , nftTokenId : nftMinting.tokenId , createdAt : new Date () }); tradeDeal . set ( 'invoices' , invoices ); await tradeDeal . save (); // Send invoice notification await sendInvoiceNotification ( invoice . id , recipient ); // Log invoice generation event await logTradeDealEvent ( dealId , 'invoice_generated' , `Invoice ${ invoiceDetails . invoiceNumber } generated` , user . id , nftMinting . txHash ); return { success : true , invoiceId : invoice.id , nftTokenId : nftMinting.tokenId , invoiceNFTAddress : nftMinting.contractAddress , metadataURI : nftMinting.metadataURI , message : 'Invoice generated successfully' }; } catch ( error ) { console . error ( 'Invoice generation error:' , error ); return { success : false , message : error.message || 'Failed to generate invoice' }; } }); Trade Deal Settlement \u00b6 Parse . Cloud . define ( 'settleTradeDeal' , async ( request ) => { const { dealId , settlementType , settlementDetails , disputeResolution } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Get trade deal const tradeDeal = await new Parse . Query ( 'TradeDeal' ) . equalTo ( 'objectId' , dealId ) . first ({ useMasterKey : true }); if ( ! tradeDeal ) { throw new Error ( 'Trade deal not found' ); } // Verify user is authorized to settle const isAuthorized = tradeDeal . get ( 'buyer' ). id === user . id || tradeDeal . get ( 'seller' ). id === user . id || isArbitrator ( user . id , tradeDeal ); if ( ! isAuthorized ) { throw new Error ( 'Unauthorized to settle this trade deal' ); } // Validate settlement type and current status if ( tradeDeal . get ( 'status' ) !== 'active' && tradeDeal . get ( 'status' ) !== 'disputed' ) { throw new Error ( 'Trade deal is not in a settleable state' ); } // Process settlement based on type let settlementResult ; switch ( settlementType ) { case 'successful' : settlementResult = await processSuccessfulSettlement ( tradeDeal , settlementDetails ); break ; case 'disputed' : settlementResult = await processDisputedSettlement ( tradeDeal , disputeResolution ); break ; case 'cancelled' : settlementResult = await processCancelledSettlement ( tradeDeal ); break ; default : throw new Error ( 'Invalid settlement type' ); } if ( ! settlementResult . success ) { throw new Error ( `Settlement failed: ${ settlementResult . message } ` ); } // Update trade deal status tradeDeal . set ( 'status' , settlementType === 'successful' ? 'completed' : settlementType ); tradeDeal . set ( 'settlementType' , settlementType ); tradeDeal . set ( 'settlementDetails' , settlementDetails ); tradeDeal . set ( 'settlementTxHash' , settlementResult . transactionHash ); tradeDeal . set ( 'settledAt' , new Date ()); tradeDeal . set ( 'settledBy' , user ); if ( disputeResolution ) { tradeDeal . set ( 'disputeResolution' , disputeResolution ); } await tradeDeal . save (); // Release collateral according to settlement terms const collateralRelease = await releaseCollateral ( tradeDeal , settlementType , disputeResolution ); // Send settlement notifications await sendSettlementNotifications ( dealId , settlementType ); // Update compliance records await updateComplianceRecords ( tradeDeal , settlementType ); // Log settlement event await logTradeDealEvent ( dealId , 'deal_settled' , `Trade deal settled: ${ settlementType } ` , user . id , settlementResult . transactionHash ); return { success : true , settlementTransactionHash : settlementResult.transactionHash , collateralReleaseHashes : collateralRelease.transactionHashes , finalStatus : tradeDeal.get ( 'status' ), message : 'Trade deal settled successfully' }; } catch ( error ) { console . error ( 'Trade deal settlement error:' , error ); return { success : false , message : error.message || 'Failed to settle trade deal' }; } }); Compliance and Reporting \u00b6 KYC Integration \u00b6 async function checkKYCStatus ( userId : string ) : Promise < { verified : boolean ; level : string ; expiresAt? : Date } > { try { const kycRecord = await new Parse . Query ( 'KYCRecord' ) . equalTo ( 'user' , userId ) . first ({ useMasterKey : true }); if ( ! kycRecord ) { return { verified : false , level : 'none' }; } const status = kycRecord . get ( 'status' ); const level = kycRecord . get ( 'level' ); const expiresAt = kycRecord . get ( 'expiresAt' ); // Check if KYC is still valid if ( expiresAt && new Date () > expiresAt ) { return { verified : false , level , expiresAt }; } return { verified : status === 'verified' , level , expiresAt }; } catch ( error ) { console . error ( 'KYC check error:' , error ); return { verified : false , level : 'error' }; } } AML Monitoring \u00b6 async function performAMLCheck ( tradeDeal : any ) : Promise < { passed : boolean ; riskScore : number ; flags : string [] } > { try { const buyer = tradeDeal . get ( 'buyer' ); const seller = tradeDeal . get ( 'seller' ); const dealAmount = parseFloat ( tradeDeal . get ( 'dealTerms' ). totalAmount ); let riskScore = 0 ; const flags : string [] = []; // Check transaction amount if ( dealAmount > 10000 ) { riskScore += 10 ; flags . push ( 'high_value_transaction' ); } // Check user risk profiles const buyerRisk = await getUserRiskProfile ( buyer . id ); const sellerRisk = await getUserRiskProfile ( seller . id ); riskScore += buyerRisk . score + sellerRisk . score ; flags . push (... buyerRisk . flags , ... sellerRisk . flags ); // Check for suspicious patterns const suspiciousActivity = await detectSuspiciousActivity ( buyer . id , seller . id , dealAmount ); if ( suspiciousActivity . detected ) { riskScore += 20 ; flags . push (... suspiciousActivity . flags ); } // Determine if AML check passed const passed = riskScore < 50 ; // Threshold for automatic approval return { passed , riskScore , flags }; } catch ( error ) { console . error ( 'AML check error:' , error ); return { passed : false , riskScore : 100 , flags : [ 'aml_check_error' ] }; } } Integration Examples \u00b6 Frontend Integration \u00b6 class TradeDealService { async createTradeDeal ( dealData : CreateTradeDealRequest ) : Promise < CreateTradeDealResponse > { return await Parse . Cloud . run ( 'createTradeDeal' , dealData ); } async depositCollateral ( dealId : string , party : 'buyer' | 'seller' , amount : string , currency : string , paymentMethod : string ) : Promise < DepositCollateralResponse > { return await Parse . Cloud . run ( 'depositCollateral' , { dealId , party , amount , currency , paymentMethod }); } async generateInvoice ( invoiceData : GenerateInvoiceRequest ) : Promise < GenerateInvoiceResponse > { return await Parse . Cloud . run ( 'generateInvoice' , invoiceData ); } async settleTradeDeal ( settlementData : SettleTradeDealRequest ) : Promise < SettleTradeDealResponse > { return await Parse . Cloud . run ( 'settleTradeDeal' , settlementData ); } async getTradeDeal ( dealId : string ) : Promise < GetTradeDealResponse > { return await Parse . Cloud . run ( 'getTradeDeal' , { dealId }); } } React Component Example \u00b6 export function TradeDealDashboard () { const [ tradeDeals , setTradeDeals ] = useState < any [] > ([]); const [ loading , setLoading ] = useState ( true ); useEffect (() => { loadTradeDeals (); }, []); const loadTradeDeals = async () => { try { const result = await Parse . Cloud . run ( 'listTradeDeals' , { status : 'active' }); if ( result . success ) { setTradeDeals ( result . tradeDeals ); } } catch ( error ) { console . error ( 'Failed to load trade deals:' , error ); } finally { setLoading ( false ); } }; const handleSettlement = async ( dealId : string , settlementType : string ) => { try { const result = await new TradeDealService (). settleTradeDeal ({ dealId , settlementType , settlementDetails : { actualDeliveryDate : new Date (), qualityRating : 5 , performanceNotes : 'Delivered as expected' } }); if ( result . success ) { await loadTradeDeals (); // Refresh list } } catch ( error ) { console . error ( 'Settlement failed:' , error ); } }; return ( < div > < h1 > Trade Deals < /h1> { loading ? ( < div > Loading ... < /div> ) : ( < div > { tradeDeals . map ( deal => ( < TradeDealCard key = { deal . id } deal = { deal } onSettle = { handleSettlement } /> ))} < /div> )} < /div> ); } Error Handling \u00b6 Common Errors \u00b6 \"Authentication required\" : User not logged in \"KYC verification required\" : KYC not completed \"Invalid trade deal participants\" : Participant validation failed \"Collateral already deposited\" : Attempting to deposit collateral twice \"Unauthorized to settle\" : User lacks settlement permissions \"Trade deal not in settleable state\" : Invalid status for settlement Error Recovery \u00b6 async function handleTradeDealError ( dealId : string , error : any , operation : string ) : Promise < void > { try { const tradeDeal = await new Parse . Query ( 'TradeDeal' ) . equalTo ( 'objectId' , dealId ) . first ({ useMasterKey : true }); if ( tradeDeal ) { // Log error event await logTradeDealEvent ( dealId , 'error' , ` ${ operation } failed: ${ error . message } ` , 'system' ); // Send error notification to participants await sendErrorNotification ( tradeDeal , error , operation ); // Attempt automatic recovery for certain errors if ( isRecoverableError ( error )) { await attemptErrorRecovery ( dealId , operation , error ); } } } catch ( recoveryError ) { console . error ( 'Error recovery failed:' , recoveryError ); } } Best Practices \u00b6 Trade Deal Management \u00b6 KYC Compliance : Ensure all participants are KYC verified Collateral Security : Use secure escrow for collateral management Clear Terms : Define clear and unambiguous deal terms Dispute Resolution : Establish clear dispute resolution mechanisms Development Guidelines \u00b6 Error Handling : Comprehensive error handling and recovery Event Logging : Log all trade deal operations for auditing Testing : Thorough testing of trade deal workflows Security : Implement proper access controls and validation Related Documentation \u00b6 Trade Deal Management Facet Trade Deal Operations Facet Trade Deal Admin Facet ITradeDeal Interface Trade Deal Library \u00b6","title":"Trade Deal Functions"},{"location":"cloud-functions/trade-deal/#trade-deal-functions","text":"The Trade Deal Functions module provides comprehensive trade deal management capabilities for the Gemforce platform, enabling users to create, manage, and execute collateralized trade deals with invoice NFTs and automated settlement.","title":"Trade Deal Functions"},{"location":"cloud-functions/trade-deal/#overview","text":"The Trade Deal Functions provide: Trade Deal Creation : Create collateralized trade deals with customizable terms Invoice Management : Generate and manage invoice NFTs for trade deals Collateral Management : Handle collateral deposits and releases Settlement Automation : Automated trade deal settlement and dispute resolution Payment Processing : Integrate with various payment methods and currencies Compliance : KYC/AML compliance and regulatory reporting","title":"Overview"},{"location":"cloud-functions/trade-deal/#key-features","text":"","title":"Key Features"},{"location":"cloud-functions/trade-deal/#trade-deal-lifecycle","text":"Deal Creation : Create trade deals with flexible terms and conditions Collateral Handling : Secure collateral deposit and management Invoice Generation : Automatic invoice NFT creation and management Settlement Processing : Automated settlement upon deal completion Dispute Resolution : Built-in dispute resolution mechanisms","title":"Trade Deal Lifecycle"},{"location":"cloud-functions/trade-deal/#financial-integration","text":"Multi-Currency Support : Support for various cryptocurrencies and stablecoins Payment Rails : Integration with traditional and crypto payment systems Escrow Services : Secure escrow for high-value transactions Fee Management : Transparent fee structure and collection","title":"Financial Integration"},{"location":"cloud-functions/trade-deal/#compliance-features","text":"KYC Integration : Know Your Customer verification AML Monitoring : Anti-Money Laundering compliance Regulatory Reporting : Automated compliance reporting Audit Trail : Complete transaction audit trail","title":"Compliance Features"},{"location":"cloud-functions/trade-deal/#core-functions","text":"","title":"Core Functions"},{"location":"cloud-functions/trade-deal/#createtradedeal","text":"Creates a new trade deal with specified terms and collateral requirements. Parameters: interface CreateTradeDealRequest { dealType : 'purchase_order' | 'service_agreement' | 'supply_contract' ; buyer : string ; seller : string ; dealTerms : { description : string ; totalAmount : string ; currency : string ; deliveryDate : Date ; paymentTerms : string ; specifications? : any ; }; collateralRequirements : { buyerCollateral : string ; sellerCollateral : string ; collateralCurrency : string ; }; milestones? : TradeDealMilestone []; disputeResolution? : DisputeResolutionTerms ; } interface TradeDealMilestone { id : string ; description : string ; amount : string ; dueDate : Date ; deliverables : string []; } interface DisputeResolutionTerms { arbitrator? : string ; timeoutPeriod : number ; penaltyPercentage : number ; } Returns: interface CreateTradeDealResponse { success : boolean ; dealId : string ; contractAddress? : string ; collateralAddresses ?: { buyer : string ; seller : string ; }; message : string ; } Usage: const result = await Parse . Cloud . run ( 'createTradeDeal' , { dealType : 'purchase_order' , buyer : 'buyer@company.com' , seller : 'seller@supplier.com' , dealTerms : { description : 'Supply of 1000 units of Product X' , totalAmount : '50000' , currency : 'USDC' , deliveryDate : new Date ( '2024-12-31' ), paymentTerms : 'Net 30' , specifications : { quantity : 1000 , quality : 'Grade A' , packaging : 'Standard' } }, collateralRequirements : { buyerCollateral : '5000' , sellerCollateral : '2500' , collateralCurrency : 'USDC' } });","title":"createTradeDeal()"},{"location":"cloud-functions/trade-deal/#depositcollateral","text":"Deposits collateral for a trade deal. Parameters: interface DepositCollateralRequest { dealId : string ; party : 'buyer' | 'seller' ; amount : string ; currency : string ; paymentMethod : 'crypto' | 'bank_transfer' | 'credit_card' ; } Returns: interface DepositCollateralResponse { success : boolean ; transactionHash? : string ; escrowAddress? : string ; confirmationRequired? : boolean ; message : string ; }","title":"depositCollateral()"},{"location":"cloud-functions/trade-deal/#generateinvoice","text":"Generates an invoice NFT for a trade deal milestone. Parameters: interface GenerateInvoiceRequest { dealId : string ; milestoneId? : string ; invoiceDetails : { invoiceNumber : string ; amount : string ; currency : string ; dueDate : Date ; lineItems : InvoiceLineItem []; taxDetails? : TaxDetails ; }; recipient : string ; } interface InvoiceLineItem { description : string ; quantity : number ; unitPrice : string ; totalPrice : string ; } interface TaxDetails { taxRate : number ; taxAmount : string ; taxJurisdiction : string ; } Returns: interface GenerateInvoiceResponse { success : boolean ; invoiceId : string ; nftTokenId? : string ; invoiceNFTAddress? : string ; metadataURI? : string ; message : string ; }","title":"generateInvoice()"},{"location":"cloud-functions/trade-deal/#settletradedeal","text":"Settles a completed trade deal and releases collateral. Parameters: interface SettleTradeDealRequest { dealId : string ; settlementType : 'successful' | 'disputed' | 'cancelled' ; settlementDetails ?: { actualDeliveryDate? : Date ; qualityRating? : number ; performanceNotes? : string ; }; disputeResolution ?: { ruling : string ; collateralDistribution : { buyerReturn : string ; sellerReturn : string ; penaltyAmount : string ; }; }; } Returns: interface SettleTradeDealResponse { success : boolean ; settlementTransactionHash? : string ; collateralReleaseHashes? : string []; finalStatus : string ; message : string ; }","title":"settleTradeDeal()"},{"location":"cloud-functions/trade-deal/#gettradedeal","text":"Retrieves trade deal information and current status. Parameters: interface GetTradeDealRequest { dealId : string ; } Returns: interface GetTradeDealResponse { success : boolean ; tradeDeal ?: { id : string ; dealType : string ; buyer : string ; seller : string ; status : 'created' | 'collateral_pending' | 'active' | 'completed' | 'disputed' | 'cancelled' ; dealTerms : any ; collateralStatus : { buyerDeposited : boolean ; sellerDeposited : boolean ; amounts : any ; }; milestones : TradeDealMilestone []; invoices : InvoiceInfo []; timeline : TradeDealEvent []; createdAt : Date ; updatedAt : Date ; }; message : string ; } interface InvoiceInfo { id : string ; invoiceNumber : string ; amount : string ; status : 'generated' | 'sent' | 'paid' | 'overdue' ; nftTokenId? : string ; createdAt : Date ; } interface TradeDealEvent { type : string ; description : string ; timestamp : Date ; actor : string ; transactionHash? : string ; }","title":"getTradeDeal()"},{"location":"cloud-functions/trade-deal/#implementation-example","text":"","title":"Implementation Example"},{"location":"cloud-functions/trade-deal/#trade-deal-creation-with-smart-contract-deployment","text":"Parse . Cloud . define ( 'createTradeDeal' , async ( request ) => { const { dealType , buyer , seller , dealTerms , collateralRequirements , milestones , disputeResolution } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Validate participants const buyerUser = await validateTradeDealParticipant ( buyer ); const sellerUser = await validateTradeDealParticipant ( seller ); if ( ! buyerUser || ! sellerUser ) { throw new Error ( 'Invalid trade deal participants' ); } // Check KYC compliance const buyerKYC = await checkKYCStatus ( buyerUser . id ); const sellerKYC = await checkKYCStatus ( sellerUser . id ); if ( ! buyerKYC . verified || ! sellerKYC . verified ) { throw new Error ( 'KYC verification required for all participants' ); } // Validate deal terms await validateTradeDealTerms ( dealTerms , collateralRequirements ); // Create trade deal record const tradeDeal = new Parse . Object ( 'TradeDeal' ); tradeDeal . set ( 'dealType' , dealType ); tradeDeal . set ( 'buyer' , buyerUser ); tradeDeal . set ( 'seller' , sellerUser ); tradeDeal . set ( 'creator' , user ); tradeDeal . set ( 'dealTerms' , dealTerms ); tradeDeal . set ( 'collateralRequirements' , collateralRequirements ); tradeDeal . set ( 'milestones' , milestones || []); tradeDeal . set ( 'disputeResolution' , disputeResolution ); tradeDeal . set ( 'status' , 'created' ); tradeDeal . set ( 'createdAt' , new Date ()); tradeDeal . set ( 'updatedAt' , new Date ()); await tradeDeal . save (); // Deploy trade deal smart contract const contractDeployment = await deployTradeDealContract ({ dealId : tradeDeal.id , buyer : buyerUser.get ( 'walletAddress' ), seller : sellerUser.get ( 'walletAddress' ), dealTerms , collateralRequirements }); if ( ! contractDeployment . success ) { tradeDeal . set ( 'status' , 'failed' ); tradeDeal . set ( 'deploymentError' , contractDeployment . message ); await tradeDeal . save (); throw new Error ( `Contract deployment failed: ${ contractDeployment . message } ` ); } // Update trade deal with contract information tradeDeal . set ( 'contractAddress' , contractDeployment . contractAddress ); tradeDeal . set ( 'deploymentTxHash' , contractDeployment . txHash ); tradeDeal . set ( 'status' , 'collateral_pending' ); await tradeDeal . save (); // Create collateral escrow contracts const escrowDeployment = await deployCollateralEscrows ( tradeDeal . id , collateralRequirements ); if ( escrowDeployment . success ) { tradeDeal . set ( 'collateralAddresses' , escrowDeployment . addresses ); await tradeDeal . save (); } // Send notifications to participants await sendTradeDealNotifications ( tradeDeal . id , 'created' ); // Log trade deal creation event await logTradeDealEvent ( tradeDeal . id , 'deal_created' , 'Trade deal created successfully' , user . id ); return { success : true , dealId : tradeDeal.id , contractAddress : contractDeployment.contractAddress , collateralAddresses : escrowDeployment.addresses , message : 'Trade deal created successfully' }; } catch ( error ) { console . error ( 'Trade deal creation error:' , error ); return { success : false , message : error.message || 'Failed to create trade deal' }; } });","title":"Trade Deal Creation with Smart Contract Deployment"},{"location":"cloud-functions/trade-deal/#collateral-management","text":"Parse . Cloud . define ( 'depositCollateral' , async ( request ) => { const { dealId , party , amount , currency , paymentMethod } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Get trade deal const tradeDeal = await new Parse . Query ( 'TradeDeal' ) . equalTo ( 'objectId' , dealId ) . first ({ useMasterKey : true }); if ( ! tradeDeal ) { throw new Error ( 'Trade deal not found' ); } // Verify user is authorized party const isAuthorized = ( party === 'buyer' && tradeDeal . get ( 'buyer' ). id === user . id ) || ( party === 'seller' && tradeDeal . get ( 'seller' ). id === user . id ); if ( ! isAuthorized ) { throw new Error ( 'Unauthorized to deposit collateral for this party' ); } // Check if collateral already deposited const collateralStatus = tradeDeal . get ( 'collateralStatus' ) || {}; const partyKey = ` ${ party } Deposited` ; if ( collateralStatus [ partyKey ]) { throw new Error ( 'Collateral already deposited' ); } // Validate collateral amount const requiredAmount = tradeDeal . get ( 'collateralRequirements' )[ ` ${ party } Collateral` ]; if ( amount !== requiredAmount ) { throw new Error ( `Incorrect collateral amount. Required: ${ requiredAmount } ` ); } // Process collateral deposit based on payment method let depositResult ; switch ( paymentMethod ) { case 'crypto' : depositResult = await processCryptoCollateralDeposit ( dealId , party , amount , currency , user ); break ; case 'bank_transfer' : depositResult = await processBankTransferCollateral ( dealId , party , amount , currency , user ); break ; case 'credit_card' : depositResult = await processCreditCardCollateral ( dealId , party , amount , currency , user ); break ; default : throw new Error ( 'Unsupported payment method' ); } if ( ! depositResult . success ) { throw new Error ( `Collateral deposit failed: ${ depositResult . message } ` ); } // Update collateral status collateralStatus [ partyKey ] = true ; collateralStatus [ ` ${ party } Amount` ] = amount ; collateralStatus [ ` ${ party } TxHash` ] = depositResult . transactionHash ; collateralStatus [ ` ${ party } DepositedAt` ] = new Date (); tradeDeal . set ( 'collateralStatus' , collateralStatus ); // Check if both parties have deposited collateral if ( collateralStatus . buyerDeposited && collateralStatus . sellerDeposited ) { tradeDeal . set ( 'status' , 'active' ); tradeDeal . set ( 'activatedAt' , new Date ()); // Activate the trade deal contract await activateTradeDealContract ( tradeDeal . get ( 'contractAddress' )); // Send activation notifications await sendTradeDealNotifications ( dealId , 'activated' ); } await tradeDeal . save (); // Log collateral deposit event await logTradeDealEvent ( dealId , 'collateral_deposited' , ` ${ party } deposited collateral` , user . id , depositResult . transactionHash ); return { success : true , transactionHash : depositResult.transactionHash , escrowAddress : depositResult.escrowAddress , confirmationRequired : depositResult.confirmationRequired , message : 'Collateral deposited successfully' }; } catch ( error ) { console . error ( 'Collateral deposit error:' , error ); return { success : false , message : error.message || 'Failed to deposit collateral' }; } });","title":"Collateral Management"},{"location":"cloud-functions/trade-deal/#invoice-nft-generation","text":"Parse . Cloud . define ( 'generateInvoice' , async ( request ) => { const { dealId , milestoneId , invoiceDetails , recipient } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Get trade deal const tradeDeal = await new Parse . Query ( 'TradeDeal' ) . equalTo ( 'objectId' , dealId ) . first ({ useMasterKey : true }); if ( ! tradeDeal ) { throw new Error ( 'Trade deal not found' ); } // Verify user is authorized to generate invoice const isAuthorized = tradeDeal . get ( 'seller' ). id === user . id || tradeDeal . get ( 'buyer' ). id === user . id ; if ( ! isAuthorized ) { throw new Error ( 'Unauthorized to generate invoice for this trade deal' ); } // Validate invoice details await validateInvoiceDetails ( invoiceDetails ); // Create invoice record const invoice = new Parse . Object ( 'Invoice' ); invoice . set ( 'tradeDeal' , tradeDeal ); invoice . set ( 'milestoneId' , milestoneId ); invoice . set ( 'invoiceNumber' , invoiceDetails . invoiceNumber ); invoice . set ( 'amount' , invoiceDetails . amount ); invoice . set ( 'currency' , invoiceDetails . currency ); invoice . set ( 'dueDate' , invoiceDetails . dueDate ); invoice . set ( 'lineItems' , invoiceDetails . lineItems ); invoice . set ( 'taxDetails' , invoiceDetails . taxDetails ); invoice . set ( 'recipient' , recipient ); invoice . set ( 'issuer' , user ); invoice . set ( 'status' , 'generated' ); invoice . set ( 'createdAt' , new Date ()); await invoice . save (); // Generate invoice metadata const metadata = await generateInvoiceMetadata ( invoice . id , invoiceDetails ); // Mint invoice NFT const nftMinting = await mintInvoiceNFT ({ invoiceId : invoice.id , recipient , metadata , tradeDealContract : tradeDeal.get ( 'contractAddress' ) }); if ( ! nftMinting . success ) { invoice . set ( 'status' , 'failed' ); invoice . set ( 'mintingError' , nftMinting . message ); await invoice . save (); throw new Error ( `Invoice NFT minting failed: ${ nftMinting . message } ` ); } // Update invoice with NFT information invoice . set ( 'nftTokenId' , nftMinting . tokenId ); invoice . set ( 'nftAddress' , nftMinting . contractAddress ); invoice . set ( 'metadataURI' , nftMinting . metadataURI ); invoice . set ( 'mintingTxHash' , nftMinting . txHash ); invoice . set ( 'status' , 'minted' ); await invoice . save (); // Update trade deal with invoice reference const invoices = tradeDeal . get ( 'invoices' ) || []; invoices . push ({ id : invoice.id , invoiceNumber : invoiceDetails.invoiceNumber , amount : invoiceDetails.amount , nftTokenId : nftMinting.tokenId , createdAt : new Date () }); tradeDeal . set ( 'invoices' , invoices ); await tradeDeal . save (); // Send invoice notification await sendInvoiceNotification ( invoice . id , recipient ); // Log invoice generation event await logTradeDealEvent ( dealId , 'invoice_generated' , `Invoice ${ invoiceDetails . invoiceNumber } generated` , user . id , nftMinting . txHash ); return { success : true , invoiceId : invoice.id , nftTokenId : nftMinting.tokenId , invoiceNFTAddress : nftMinting.contractAddress , metadataURI : nftMinting.metadataURI , message : 'Invoice generated successfully' }; } catch ( error ) { console . error ( 'Invoice generation error:' , error ); return { success : false , message : error.message || 'Failed to generate invoice' }; } });","title":"Invoice NFT Generation"},{"location":"cloud-functions/trade-deal/#trade-deal-settlement","text":"Parse . Cloud . define ( 'settleTradeDeal' , async ( request ) => { const { dealId , settlementType , settlementDetails , disputeResolution } = request . params ; const user = request . user ; if ( ! user ) { throw new Error ( 'Authentication required' ); } try { // Get trade deal const tradeDeal = await new Parse . Query ( 'TradeDeal' ) . equalTo ( 'objectId' , dealId ) . first ({ useMasterKey : true }); if ( ! tradeDeal ) { throw new Error ( 'Trade deal not found' ); } // Verify user is authorized to settle const isAuthorized = tradeDeal . get ( 'buyer' ). id === user . id || tradeDeal . get ( 'seller' ). id === user . id || isArbitrator ( user . id , tradeDeal ); if ( ! isAuthorized ) { throw new Error ( 'Unauthorized to settle this trade deal' ); } // Validate settlement type and current status if ( tradeDeal . get ( 'status' ) !== 'active' && tradeDeal . get ( 'status' ) !== 'disputed' ) { throw new Error ( 'Trade deal is not in a settleable state' ); } // Process settlement based on type let settlementResult ; switch ( settlementType ) { case 'successful' : settlementResult = await processSuccessfulSettlement ( tradeDeal , settlementDetails ); break ; case 'disputed' : settlementResult = await processDisputedSettlement ( tradeDeal , disputeResolution ); break ; case 'cancelled' : settlementResult = await processCancelledSettlement ( tradeDeal ); break ; default : throw new Error ( 'Invalid settlement type' ); } if ( ! settlementResult . success ) { throw new Error ( `Settlement failed: ${ settlementResult . message } ` ); } // Update trade deal status tradeDeal . set ( 'status' , settlementType === 'successful' ? 'completed' : settlementType ); tradeDeal . set ( 'settlementType' , settlementType ); tradeDeal . set ( 'settlementDetails' , settlementDetails ); tradeDeal . set ( 'settlementTxHash' , settlementResult . transactionHash ); tradeDeal . set ( 'settledAt' , new Date ()); tradeDeal . set ( 'settledBy' , user ); if ( disputeResolution ) { tradeDeal . set ( 'disputeResolution' , disputeResolution ); } await tradeDeal . save (); // Release collateral according to settlement terms const collateralRelease = await releaseCollateral ( tradeDeal , settlementType , disputeResolution ); // Send settlement notifications await sendSettlementNotifications ( dealId , settlementType ); // Update compliance records await updateComplianceRecords ( tradeDeal , settlementType ); // Log settlement event await logTradeDealEvent ( dealId , 'deal_settled' , `Trade deal settled: ${ settlementType } ` , user . id , settlementResult . transactionHash ); return { success : true , settlementTransactionHash : settlementResult.transactionHash , collateralReleaseHashes : collateralRelease.transactionHashes , finalStatus : tradeDeal.get ( 'status' ), message : 'Trade deal settled successfully' }; } catch ( error ) { console . error ( 'Trade deal settlement error:' , error ); return { success : false , message : error.message || 'Failed to settle trade deal' }; } });","title":"Trade Deal Settlement"},{"location":"cloud-functions/trade-deal/#compliance-and-reporting","text":"","title":"Compliance and Reporting"},{"location":"cloud-functions/trade-deal/#kyc-integration","text":"async function checkKYCStatus ( userId : string ) : Promise < { verified : boolean ; level : string ; expiresAt? : Date } > { try { const kycRecord = await new Parse . Query ( 'KYCRecord' ) . equalTo ( 'user' , userId ) . first ({ useMasterKey : true }); if ( ! kycRecord ) { return { verified : false , level : 'none' }; } const status = kycRecord . get ( 'status' ); const level = kycRecord . get ( 'level' ); const expiresAt = kycRecord . get ( 'expiresAt' ); // Check if KYC is still valid if ( expiresAt && new Date () > expiresAt ) { return { verified : false , level , expiresAt }; } return { verified : status === 'verified' , level , expiresAt }; } catch ( error ) { console . error ( 'KYC check error:' , error ); return { verified : false , level : 'error' }; } }","title":"KYC Integration"},{"location":"cloud-functions/trade-deal/#aml-monitoring","text":"async function performAMLCheck ( tradeDeal : any ) : Promise < { passed : boolean ; riskScore : number ; flags : string [] } > { try { const buyer = tradeDeal . get ( 'buyer' ); const seller = tradeDeal . get ( 'seller' ); const dealAmount = parseFloat ( tradeDeal . get ( 'dealTerms' ). totalAmount ); let riskScore = 0 ; const flags : string [] = []; // Check transaction amount if ( dealAmount > 10000 ) { riskScore += 10 ; flags . push ( 'high_value_transaction' ); } // Check user risk profiles const buyerRisk = await getUserRiskProfile ( buyer . id ); const sellerRisk = await getUserRiskProfile ( seller . id ); riskScore += buyerRisk . score + sellerRisk . score ; flags . push (... buyerRisk . flags , ... sellerRisk . flags ); // Check for suspicious patterns const suspiciousActivity = await detectSuspiciousActivity ( buyer . id , seller . id , dealAmount ); if ( suspiciousActivity . detected ) { riskScore += 20 ; flags . push (... suspiciousActivity . flags ); } // Determine if AML check passed const passed = riskScore < 50 ; // Threshold for automatic approval return { passed , riskScore , flags }; } catch ( error ) { console . error ( 'AML check error:' , error ); return { passed : false , riskScore : 100 , flags : [ 'aml_check_error' ] }; } }","title":"AML Monitoring"},{"location":"cloud-functions/trade-deal/#integration-examples","text":"","title":"Integration Examples"},{"location":"cloud-functions/trade-deal/#frontend-integration","text":"class TradeDealService { async createTradeDeal ( dealData : CreateTradeDealRequest ) : Promise < CreateTradeDealResponse > { return await Parse . Cloud . run ( 'createTradeDeal' , dealData ); } async depositCollateral ( dealId : string , party : 'buyer' | 'seller' , amount : string , currency : string , paymentMethod : string ) : Promise < DepositCollateralResponse > { return await Parse . Cloud . run ( 'depositCollateral' , { dealId , party , amount , currency , paymentMethod }); } async generateInvoice ( invoiceData : GenerateInvoiceRequest ) : Promise < GenerateInvoiceResponse > { return await Parse . Cloud . run ( 'generateInvoice' , invoiceData ); } async settleTradeDeal ( settlementData : SettleTradeDealRequest ) : Promise < SettleTradeDealResponse > { return await Parse . Cloud . run ( 'settleTradeDeal' , settlementData ); } async getTradeDeal ( dealId : string ) : Promise < GetTradeDealResponse > { return await Parse . Cloud . run ( 'getTradeDeal' , { dealId }); } }","title":"Frontend Integration"},{"location":"cloud-functions/trade-deal/#react-component-example","text":"export function TradeDealDashboard () { const [ tradeDeals , setTradeDeals ] = useState < any [] > ([]); const [ loading , setLoading ] = useState ( true ); useEffect (() => { loadTradeDeals (); }, []); const loadTradeDeals = async () => { try { const result = await Parse . Cloud . run ( 'listTradeDeals' , { status : 'active' }); if ( result . success ) { setTradeDeals ( result . tradeDeals ); } } catch ( error ) { console . error ( 'Failed to load trade deals:' , error ); } finally { setLoading ( false ); } }; const handleSettlement = async ( dealId : string , settlementType : string ) => { try { const result = await new TradeDealService (). settleTradeDeal ({ dealId , settlementType , settlementDetails : { actualDeliveryDate : new Date (), qualityRating : 5 , performanceNotes : 'Delivered as expected' } }); if ( result . success ) { await loadTradeDeals (); // Refresh list } } catch ( error ) { console . error ( 'Settlement failed:' , error ); } }; return ( < div > < h1 > Trade Deals < /h1> { loading ? ( < div > Loading ... < /div> ) : ( < div > { tradeDeals . map ( deal => ( < TradeDealCard key = { deal . id } deal = { deal } onSettle = { handleSettlement } /> ))} < /div> )} < /div> ); }","title":"React Component Example"},{"location":"cloud-functions/trade-deal/#error-handling","text":"","title":"Error Handling"},{"location":"cloud-functions/trade-deal/#common-errors","text":"\"Authentication required\" : User not logged in \"KYC verification required\" : KYC not completed \"Invalid trade deal participants\" : Participant validation failed \"Collateral already deposited\" : Attempting to deposit collateral twice \"Unauthorized to settle\" : User lacks settlement permissions \"Trade deal not in settleable state\" : Invalid status for settlement","title":"Common Errors"},{"location":"cloud-functions/trade-deal/#error-recovery","text":"async function handleTradeDealError ( dealId : string , error : any , operation : string ) : Promise < void > { try { const tradeDeal = await new Parse . Query ( 'TradeDeal' ) . equalTo ( 'objectId' , dealId ) . first ({ useMasterKey : true }); if ( tradeDeal ) { // Log error event await logTradeDealEvent ( dealId , 'error' , ` ${ operation } failed: ${ error . message } ` , 'system' ); // Send error notification to participants await sendErrorNotification ( tradeDeal , error , operation ); // Attempt automatic recovery for certain errors if ( isRecoverableError ( error )) { await attemptErrorRecovery ( dealId , operation , error ); } } } catch ( recoveryError ) { console . error ( 'Error recovery failed:' , recoveryError ); } }","title":"Error Recovery"},{"location":"cloud-functions/trade-deal/#best-practices","text":"","title":"Best Practices"},{"location":"cloud-functions/trade-deal/#trade-deal-management","text":"KYC Compliance : Ensure all participants are KYC verified Collateral Security : Use secure escrow for collateral management Clear Terms : Define clear and unambiguous deal terms Dispute Resolution : Establish clear dispute resolution mechanisms","title":"Trade Deal Management"},{"location":"cloud-functions/trade-deal/#development-guidelines","text":"Error Handling : Comprehensive error handling and recovery Event Logging : Log all trade deal operations for auditing Testing : Thorough testing of trade deal workflows Security : Implement proper access controls and validation","title":"Development Guidelines"},{"location":"cloud-functions/trade-deal/#related-documentation","text":"Trade Deal Management Facet Trade Deal Operations Facet Trade Deal Admin Facet ITradeDeal Interface","title":"Related Documentation"},{"location":"cloud-functions/trade-deal/#trade-deal-library","text":"","title":"Trade Deal Library"},{"location":"cloud-functions/tasks/admin-utils/","text":"Cloud Functions: Admin Utility Tasks \u00b6 This document details the cloud functions designed for administrative utilities within the Gemforce platform. These functions provide privileged access to perform maintenance, configuration, and data management tasks, primarily intended for platform administrators and operators. Overview \u00b6 Admin Utility tasks enable: Data Management : Bulk operations on the Parse Server database (e.g., cleaning up old data, modifying user roles). Configuration Updates : Changing platform-wide settings. System Health Checks : Performing diagnostics and integrity checks. User Management : Advanced user operations not available through standard APIs (e.g., forced password resets, account locking). Smart Contract Configuration : Updating certain smart contract settings (e.g., fee percentages, trusted addresses) via backend-signed transactions. These functions are critical for platform maintenance and operational control. Key Functions \u00b6 1. cleanDatabase \u00b6 Performs cleanup operations on specified Parse collections, primarily for test environments or old data. Function Name : cleanDatabase Method : POST Parameters : collections (Array of Strings, required): Names of Parse collections to clean (e.g., [\"_User\", \"Project\", \"Transactions\"]). query (Object, optional): A Parse query object (JSON string) to specify which records to delete. If omitted, all records in the specified collections are deleted. dryRun (Boolean, optional): If true , the function will only report what would be deleted without performing the deletion. Defaults to false . Returns : deletedCount (Number): The number of records deleted (or to be deleted in dry run). message (String): A summary of the operation. Example Request : { \"functionName\" : \"cleanDatabase\" , \"parameters\" : { \"collections\" : [ \"Project\" , \"TradeDeal\" ], \"query\" : { \"status\" : \"completed\" , \"createdAt\" : { \"$lt\" : { \"__type\" : \"Date\" , \"iso\" : \"2024-01-01T00:00:00.000Z\" } } }, \"dryRun\" : false } } 2. updatePlatformSetting \u00b6 Updates a global platform setting stored in a Parse configuration class. Function Name : updatePlatformSetting Method : POST Parameters : settingKey (String, required): The key of the setting to update (e.g., \"marketplaceFeePercentage\", \"maxTradeDealDuration\"). settingValue (Any, required): The new value for the setting. Returns : success (Boolean): true if the update was successful. 3. syncBlockchainData \u00b6 Triggers a synchronization process for specific blockchain data, such as refreshing cached smart contract states or re-indexing events. (Note: A more detailed version might be sync-events ). Function Name : syncBlockchainData Method : POST Parameters : dataType (String, required): The type of data to sync (e.g., \"marketplaceListings\", \"userWalletBalances\"). network (String, optional): The blockchain network to sync from. options (Object, optional): Sync-specific options (e.g., fromBlock , toBlock ). Returns : syncSummary (Object): Details about the synchronization, including number of items synced. 4. forceUserLogout \u00b6 Forces a user's session to expire, effectively logging them out from all devices. Function Name : forceUserLogout Method : POST Parameters : userId (String, required): The objectId of the Parse User to log out. Returns : success (Boolean) Error Handling \u00b6 Admin Utility tasks require robust error handling: Permission Denied : The most common error. Only users with the Parse Master Key or specific admin roles should be able to call these functions. Invalid Input : Incorrect collection names, malformed queries, or invalid setting values. Operational Errors : Failures during database operations or smart contract interactions. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Extreme Privilege : These functions provide significant control over the platform. They should be guarded extremely carefully. Master Key Usage : Access to these functions MUST require the Parse Master Key or a highly restricted administrative role with strict ACLs/CLPs. Logging and Auditing : Every execution of these functions must be thoroughly logged, including who called it, when, and with what parameters. Implement alerts for unauthorized attempts. Rate Limiting : Apply aggressive rate limiting to prevent abuse. Least Privilege Principle : When developing these functions, ensure they only have the necessary permissions to perform their specific task and nothing more. Test Environment : Never test these functions on production environments. Use dedicated staging or test environments. Related Documentation \u00b6 Integrator's Guide: Authentication Parse Server Cloud Code Guide (External)","title":"Admin Utilities"},{"location":"cloud-functions/tasks/admin-utils/#cloud-functions-admin-utility-tasks","text":"This document details the cloud functions designed for administrative utilities within the Gemforce platform. These functions provide privileged access to perform maintenance, configuration, and data management tasks, primarily intended for platform administrators and operators.","title":"Cloud Functions: Admin Utility Tasks"},{"location":"cloud-functions/tasks/admin-utils/#overview","text":"Admin Utility tasks enable: Data Management : Bulk operations on the Parse Server database (e.g., cleaning up old data, modifying user roles). Configuration Updates : Changing platform-wide settings. System Health Checks : Performing diagnostics and integrity checks. User Management : Advanced user operations not available through standard APIs (e.g., forced password resets, account locking). Smart Contract Configuration : Updating certain smart contract settings (e.g., fee percentages, trusted addresses) via backend-signed transactions. These functions are critical for platform maintenance and operational control.","title":"Overview"},{"location":"cloud-functions/tasks/admin-utils/#key-functions","text":"","title":"Key Functions"},{"location":"cloud-functions/tasks/admin-utils/#1-cleandatabase","text":"Performs cleanup operations on specified Parse collections, primarily for test environments or old data. Function Name : cleanDatabase Method : POST Parameters : collections (Array of Strings, required): Names of Parse collections to clean (e.g., [\"_User\", \"Project\", \"Transactions\"]). query (Object, optional): A Parse query object (JSON string) to specify which records to delete. If omitted, all records in the specified collections are deleted. dryRun (Boolean, optional): If true , the function will only report what would be deleted without performing the deletion. Defaults to false . Returns : deletedCount (Number): The number of records deleted (or to be deleted in dry run). message (String): A summary of the operation. Example Request : { \"functionName\" : \"cleanDatabase\" , \"parameters\" : { \"collections\" : [ \"Project\" , \"TradeDeal\" ], \"query\" : { \"status\" : \"completed\" , \"createdAt\" : { \"$lt\" : { \"__type\" : \"Date\" , \"iso\" : \"2024-01-01T00:00:00.000Z\" } } }, \"dryRun\" : false } }","title":"1. cleanDatabase"},{"location":"cloud-functions/tasks/admin-utils/#2-updateplatformsetting","text":"Updates a global platform setting stored in a Parse configuration class. Function Name : updatePlatformSetting Method : POST Parameters : settingKey (String, required): The key of the setting to update (e.g., \"marketplaceFeePercentage\", \"maxTradeDealDuration\"). settingValue (Any, required): The new value for the setting. Returns : success (Boolean): true if the update was successful.","title":"2. updatePlatformSetting"},{"location":"cloud-functions/tasks/admin-utils/#3-syncblockchaindata","text":"Triggers a synchronization process for specific blockchain data, such as refreshing cached smart contract states or re-indexing events. (Note: A more detailed version might be sync-events ). Function Name : syncBlockchainData Method : POST Parameters : dataType (String, required): The type of data to sync (e.g., \"marketplaceListings\", \"userWalletBalances\"). network (String, optional): The blockchain network to sync from. options (Object, optional): Sync-specific options (e.g., fromBlock , toBlock ). Returns : syncSummary (Object): Details about the synchronization, including number of items synced.","title":"3. syncBlockchainData"},{"location":"cloud-functions/tasks/admin-utils/#4-forceuserlogout","text":"Forces a user's session to expire, effectively logging them out from all devices. Function Name : forceUserLogout Method : POST Parameters : userId (String, required): The objectId of the Parse User to log out. Returns : success (Boolean)","title":"4. forceUserLogout"},{"location":"cloud-functions/tasks/admin-utils/#error-handling","text":"Admin Utility tasks require robust error handling: Permission Denied : The most common error. Only users with the Parse Master Key or specific admin roles should be able to call these functions. Invalid Input : Incorrect collection names, malformed queries, or invalid setting values. Operational Errors : Failures during database operations or smart contract interactions. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"cloud-functions/tasks/admin-utils/#security-considerations","text":"Extreme Privilege : These functions provide significant control over the platform. They should be guarded extremely carefully. Master Key Usage : Access to these functions MUST require the Parse Master Key or a highly restricted administrative role with strict ACLs/CLPs. Logging and Auditing : Every execution of these functions must be thoroughly logged, including who called it, when, and with what parameters. Implement alerts for unauthorized attempts. Rate Limiting : Apply aggressive rate limiting to prevent abuse. Least Privilege Principle : When developing these functions, ensure they only have the necessary permissions to perform their specific task and nothing more. Test Environment : Never test these functions on production environments. Use dedicated staging or test environments.","title":"Security Considerations"},{"location":"cloud-functions/tasks/admin-utils/#related-documentation","text":"Integrator's Guide: Authentication Parse Server Cloud Code Guide (External)","title":"Related Documentation"},{"location":"cloud-functions/tasks/carbon-credit-management/","text":"Cloud Functions: Carbon Credit Management Tasks \u00b6 This document details the cloud functions designed for managing carbon credits within the Gemforce platform. These functions provide an abstracted API for interacting with on-chain carbon credit tokens, including issuance, retirement, and transfer operations, aligning with environmental asset standards. Overview \u00b6 Carbon Credit Management tasks enable: Issuance : Minting new carbon credit tokens. Retirement : Burning or retiring carbon credit tokens to signify their use. Transfer : Facilitating the transfer of carbon credit tokens between accounts. Traceability : Querying the history and status of carbon credits. Registry Integration : Interaction with external carbon registries or standards. These functions are crucial for projects focused on environmental assets, allowing seamless integration with Gemforce's carbon credit framework. Key Functions \u00b6 1. issueCarbonCredits \u00b6 Issue new carbon credit tokens to a designated recipient. Function Name : issueCarbonCredits Method : POST Parameters : recipientAddress (String, required): The address that will receive the newly issued carbon credit tokens. amount (String, required): The amount of carbon credit tokens to issue (as a string to handle large numbers). projectId (String, optional): An identifier for the project associated with these carbon credits. vintageYear (Number, optional): The vintage year of the carbon credits. metadataURI (String, optional): URI pointing to additional metadata about the credits (e.g., certification details). network (String, required): The blockchain network where the carbon credit contract is deployed. Returns : transactionHash (String): The transaction hash of the issuance. Example Request : { \"functionName\" : \"issueCarbonCredits\" , \"parameters\" : { \"recipientAddress\" : \"0xYourCompanyWalletAddress\" , \"amount\" : \"1000000000000000000\" , // 1 carbon credit token (1e18) \"projectId\" : \"GHG-Reduction-2023-A\" , \"vintageYear\" : 2023 , \"network\" : \"base-sepolia\" } } Example Response : { \"result\" : { \"transactionHash\" : \"0xabc...def\" } } Workflow : Client application calls issueCarbonCredits Cloud Function. Cloud Function validates parameters and permissions (e.g., only authorized issuers). Calls the issue function on the CarbonCreditFacet of the Diamond contract. Returns the transaction hash. 2. retireCarbonCredits \u00b6 Retire (burn) carbon credit tokens, signifying their permanent removal from circulation. Function Name : retireCarbonCredits Method : POST Parameters : amount (String, required): The amount of carbon credit tokens to retire. reason (String, optional): A description of the reason for retirement. network (String, required): The blockchain network. Returns : transactionHash (String) 3. transferCarbonCredits \u00b6 Transfer carbon credit tokens from one account to another. Function Name : transferCarbonCredits Method : POST Parameters : fromAddress (String, optional): Sender's address. Defaults to the caller's associated wallet address. toAddress (String, required): Recipient's address. amount (String, required): The amount of carbon credit tokens to transfer. network (String, required): The blockchain network. Returns : transactionHash (String) Error Handling \u00b6 Carbon Credit Management tasks can encounter various errors, including: Invalid Parameters : Invalid amounts, or unsupported networks. Blockchain Transaction Errors : Transaction reverts (e.g., insufficient balance, unauthorized issuer/retirer). Access Control : Caller not authorized to issue or retire credits. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Authorization : Crucial that only authorized entities (e.g., certified project developers, auditors) can issue or retire carbon credits. Implement strict access control within the cloud functions. Double Counting Prevention : Ensure that the process for issuance and retirement is robust to prevent double counting or re-use of retired credits. Token Standard Compliance : Verify that on-chain operations comply with relevant carbon credit token standards (e.g., ERC-20, specific Carbon Credit EIPs). Input Validation : Sanitize and validate all inputs to prevent malicious attempts or incorrect operations. Related Documentation \u00b6 Smart Contracts: Carbon Credit Facet Smart Contracts: ICarbonCredit Interface EIP: Carbon Credit Standard Integrator's Guide: Authentication","title":"Carbon Credit Management Tasks"},{"location":"cloud-functions/tasks/carbon-credit-management/#cloud-functions-carbon-credit-management-tasks","text":"This document details the cloud functions designed for managing carbon credits within the Gemforce platform. These functions provide an abstracted API for interacting with on-chain carbon credit tokens, including issuance, retirement, and transfer operations, aligning with environmental asset standards.","title":"Cloud Functions: Carbon Credit Management Tasks"},{"location":"cloud-functions/tasks/carbon-credit-management/#overview","text":"Carbon Credit Management tasks enable: Issuance : Minting new carbon credit tokens. Retirement : Burning or retiring carbon credit tokens to signify their use. Transfer : Facilitating the transfer of carbon credit tokens between accounts. Traceability : Querying the history and status of carbon credits. Registry Integration : Interaction with external carbon registries or standards. These functions are crucial for projects focused on environmental assets, allowing seamless integration with Gemforce's carbon credit framework.","title":"Overview"},{"location":"cloud-functions/tasks/carbon-credit-management/#key-functions","text":"","title":"Key Functions"},{"location":"cloud-functions/tasks/carbon-credit-management/#1-issuecarboncredits","text":"Issue new carbon credit tokens to a designated recipient. Function Name : issueCarbonCredits Method : POST Parameters : recipientAddress (String, required): The address that will receive the newly issued carbon credit tokens. amount (String, required): The amount of carbon credit tokens to issue (as a string to handle large numbers). projectId (String, optional): An identifier for the project associated with these carbon credits. vintageYear (Number, optional): The vintage year of the carbon credits. metadataURI (String, optional): URI pointing to additional metadata about the credits (e.g., certification details). network (String, required): The blockchain network where the carbon credit contract is deployed. Returns : transactionHash (String): The transaction hash of the issuance. Example Request : { \"functionName\" : \"issueCarbonCredits\" , \"parameters\" : { \"recipientAddress\" : \"0xYourCompanyWalletAddress\" , \"amount\" : \"1000000000000000000\" , // 1 carbon credit token (1e18) \"projectId\" : \"GHG-Reduction-2023-A\" , \"vintageYear\" : 2023 , \"network\" : \"base-sepolia\" } } Example Response : { \"result\" : { \"transactionHash\" : \"0xabc...def\" } } Workflow : Client application calls issueCarbonCredits Cloud Function. Cloud Function validates parameters and permissions (e.g., only authorized issuers). Calls the issue function on the CarbonCreditFacet of the Diamond contract. Returns the transaction hash.","title":"1. issueCarbonCredits"},{"location":"cloud-functions/tasks/carbon-credit-management/#2-retirecarboncredits","text":"Retire (burn) carbon credit tokens, signifying their permanent removal from circulation. Function Name : retireCarbonCredits Method : POST Parameters : amount (String, required): The amount of carbon credit tokens to retire. reason (String, optional): A description of the reason for retirement. network (String, required): The blockchain network. Returns : transactionHash (String)","title":"2. retireCarbonCredits"},{"location":"cloud-functions/tasks/carbon-credit-management/#3-transfercarboncredits","text":"Transfer carbon credit tokens from one account to another. Function Name : transferCarbonCredits Method : POST Parameters : fromAddress (String, optional): Sender's address. Defaults to the caller's associated wallet address. toAddress (String, required): Recipient's address. amount (String, required): The amount of carbon credit tokens to transfer. network (String, required): The blockchain network. Returns : transactionHash (String)","title":"3. transferCarbonCredits"},{"location":"cloud-functions/tasks/carbon-credit-management/#error-handling","text":"Carbon Credit Management tasks can encounter various errors, including: Invalid Parameters : Invalid amounts, or unsupported networks. Blockchain Transaction Errors : Transaction reverts (e.g., insufficient balance, unauthorized issuer/retirer). Access Control : Caller not authorized to issue or retire credits. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"cloud-functions/tasks/carbon-credit-management/#security-considerations","text":"Authorization : Crucial that only authorized entities (e.g., certified project developers, auditors) can issue or retire carbon credits. Implement strict access control within the cloud functions. Double Counting Prevention : Ensure that the process for issuance and retirement is robust to prevent double counting or re-use of retired credits. Token Standard Compliance : Verify that on-chain operations comply with relevant carbon credit token standards (e.g., ERC-20, specific Carbon Credit EIPs). Input Validation : Sanitize and validate all inputs to prevent malicious attempts or incorrect operations.","title":"Security Considerations"},{"location":"cloud-functions/tasks/carbon-credit-management/#related-documentation","text":"Smart Contracts: Carbon Credit Facet Smart Contracts: ICarbonCredit Interface EIP: Carbon Credit Standard Integrator's Guide: Authentication","title":"Related Documentation"},{"location":"cloud-functions/tasks/diamond/","text":"Cloud Functions: Diamond Tasks \u00b6 This document details the cloud functions related to managing Gemforce Diamond smart contracts. These functions provide an abstracted API for deploying, configuring, and interacting with Diamond contracts on various blockchain networks, leveraging Parse Server's backend capabilities. Overview \u00b6 Diamond tasks enable: Deployment : Deploying new Diamond contracts with predefined facets. Facet Management : Adding, replacing, or removing facets from an existing Diamond. Ownership Management : Transferring ownership of a Diamond contract. Initialization : Running post-deployment initialization logic. These functions streamline the deployment and management of complex Diamond contracts, abstracting away direct blockchain interactions for frontend or backend applications. Key Functions \u00b6 1. deployDiamond \u00b6 Deploy a new Gemforce Diamond contract. Function Name : deployDiamond Method : POST (via Parse Cloud Function endpoint) Parameters : templateName (String, required): The name of a pre-registered Diamond template to use for deployment (e.g., \"StandardNFTDiamond\", \"DeFiProtocolDiamond\"). salt (String, optional): A unique identifier (hex string) for deterministic address generation using CREATE2. If not provided, a random salt will be generated. initData (String, optional): ABI-encoded data (hex string) for the Diamond's init function after deployment. ownerAddress (String, optional): The address to set as the initial owner of the Diamond. Defaults to the deployer's address if not provided. network (String, required): The blockchain network to deploy to (e.g., \"base-sepolia\", \"optimism-sepolia\", \"sepolia\"). Returns : diamondAddress (String): The deployed address of the new Diamond contract. transactionHash (String): The transaction hash of the deployment. templateUsed (String): The name of the template used. Example Request : { \"functionName\" : \"deployDiamond\" , \"parameters\" : { \"templateName\" : \"StandardNFTDiamond\" , \"salt\" : \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\" , \"ownerAddress\" : \"0xYourDesiredOwnerAddress\" , \"network\" : \"base-sepolia\" } } Example Response : { \"result\" : { \"diamondAddress\" : \"0x789...abc\" , \"transactionHash\" : \"0xdef...ghi\" , \"templateUsed\" : \"StandardNFTDiamond\" } } Workflow : Client application calls deployDiamond Cloud Function. Cloud Function retrieves the specified Diamond template from a configuration or registry. Utilizes the DiamondFactory smart contract to deploy a new Diamond instance. Optionally runs initialization logic and sets ownership. Returns the new Diamond's address and transaction details. 2. addFacet \u00b6 Add a new facet to an existing Diamond contract. Function Name : addFacet Method : POST Parameters : diamondAddress (String, required): The address of the Diamond contract to modify. facetAddress (String, required): The address of the facet contract to add. functionSelectors (Array of Strings, required): An array of function selectors (e.g., \"0xdeadbeef\" ) to add from the facet. initContract (String, optional): Address of an initialization contract to call after the cut. initData (String, optional): ABI-encoded data for the initContract call. network (String, required): The blockchain network where the Diamond is deployed. Returns : transactionHash (String): The transaction hash of the facet addition. Example Request : { \"functionName\" : \"addFacet\" , \"parameters\" : { \"diamondAddress\" : \"0x789...abc\" , \"facetAddress\" : \"0x123...def\" , \"functionSelectors\" : [ \"0xabcd1234\" , \"0xefgh5678\" ], \"network\" : \"base-sepolia\" } } 3. replaceFacet \u00b6 Replace an existing facet's functions with new ones from a different facet contract. Function Name : replaceFacet Method : POST Parameters : (Similar to addFacet , but replaces existing selectors) diamondAddress (String, required) facetAddress (String, required): The address of the new facet contract. functionSelectors (Array of Strings, required): Function selectors to replace. initContract (String, optional) initData (String, optional) network (String, required) Returns : transactionHash (String) 4. removeFacet \u00b6 Remove functions from a Diamond contract. Function Name : removeFacet Method : POST Parameters : (Similar to addFacet , but removes selectors) diamondAddress (String, required) functionSelectors (Array of Strings, required): Function selectors to remove. network (String, required) Returns : transactionHash (String) Error Handling \u00b6 Diamond tasks can encounter various errors, including: Invalid Parameters : Missing required fields or incorrect data types in the request. Blockchain Transaction Errors : Transaction reverts, out-of-gas, insufficient funds, or network congestion. Access Control : Caller not authorized to perform the operation on the Diamond (e.g., not the owner). Template Not Found : The specified templateName for deployDiamond does not exist. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Access Control : Ensure that only authorized users or services can call these Cloud Functions, either through Parse's CLP/ACLs or custom logic. Master Key Usage : Cloud Functions that interact with smart contracts typically require useMasterKey: true for the Parse SDK calls, as they often sign transactions on behalf of an admin address. Securely manage your Parse Master Key. Input Sanitization : Always sanitize and validate all inputs received by Cloud Functions to prevent injection attacks or unexpected behavior. DFNS Integration : If DFNS is used for signing, ensure the policies associated with the DFNS wallets are robust and match your security requirements. Related Documentation \u00b6 Smart Contracts: Diamond Contract Smart Contracts: Diamond Factory Smart Contracts: Facets (Diamond Cut Facet) Integrator's Guide: Authentication Integrator's Guide: DFNS Integration","title":"Diamond Tasks"},{"location":"cloud-functions/tasks/diamond/#cloud-functions-diamond-tasks","text":"This document details the cloud functions related to managing Gemforce Diamond smart contracts. These functions provide an abstracted API for deploying, configuring, and interacting with Diamond contracts on various blockchain networks, leveraging Parse Server's backend capabilities.","title":"Cloud Functions: Diamond Tasks"},{"location":"cloud-functions/tasks/diamond/#overview","text":"Diamond tasks enable: Deployment : Deploying new Diamond contracts with predefined facets. Facet Management : Adding, replacing, or removing facets from an existing Diamond. Ownership Management : Transferring ownership of a Diamond contract. Initialization : Running post-deployment initialization logic. These functions streamline the deployment and management of complex Diamond contracts, abstracting away direct blockchain interactions for frontend or backend applications.","title":"Overview"},{"location":"cloud-functions/tasks/diamond/#key-functions","text":"","title":"Key Functions"},{"location":"cloud-functions/tasks/diamond/#1-deploydiamond","text":"Deploy a new Gemforce Diamond contract. Function Name : deployDiamond Method : POST (via Parse Cloud Function endpoint) Parameters : templateName (String, required): The name of a pre-registered Diamond template to use for deployment (e.g., \"StandardNFTDiamond\", \"DeFiProtocolDiamond\"). salt (String, optional): A unique identifier (hex string) for deterministic address generation using CREATE2. If not provided, a random salt will be generated. initData (String, optional): ABI-encoded data (hex string) for the Diamond's init function after deployment. ownerAddress (String, optional): The address to set as the initial owner of the Diamond. Defaults to the deployer's address if not provided. network (String, required): The blockchain network to deploy to (e.g., \"base-sepolia\", \"optimism-sepolia\", \"sepolia\"). Returns : diamondAddress (String): The deployed address of the new Diamond contract. transactionHash (String): The transaction hash of the deployment. templateUsed (String): The name of the template used. Example Request : { \"functionName\" : \"deployDiamond\" , \"parameters\" : { \"templateName\" : \"StandardNFTDiamond\" , \"salt\" : \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\" , \"ownerAddress\" : \"0xYourDesiredOwnerAddress\" , \"network\" : \"base-sepolia\" } } Example Response : { \"result\" : { \"diamondAddress\" : \"0x789...abc\" , \"transactionHash\" : \"0xdef...ghi\" , \"templateUsed\" : \"StandardNFTDiamond\" } } Workflow : Client application calls deployDiamond Cloud Function. Cloud Function retrieves the specified Diamond template from a configuration or registry. Utilizes the DiamondFactory smart contract to deploy a new Diamond instance. Optionally runs initialization logic and sets ownership. Returns the new Diamond's address and transaction details.","title":"1. deployDiamond"},{"location":"cloud-functions/tasks/diamond/#2-addfacet","text":"Add a new facet to an existing Diamond contract. Function Name : addFacet Method : POST Parameters : diamondAddress (String, required): The address of the Diamond contract to modify. facetAddress (String, required): The address of the facet contract to add. functionSelectors (Array of Strings, required): An array of function selectors (e.g., \"0xdeadbeef\" ) to add from the facet. initContract (String, optional): Address of an initialization contract to call after the cut. initData (String, optional): ABI-encoded data for the initContract call. network (String, required): The blockchain network where the Diamond is deployed. Returns : transactionHash (String): The transaction hash of the facet addition. Example Request : { \"functionName\" : \"addFacet\" , \"parameters\" : { \"diamondAddress\" : \"0x789...abc\" , \"facetAddress\" : \"0x123...def\" , \"functionSelectors\" : [ \"0xabcd1234\" , \"0xefgh5678\" ], \"network\" : \"base-sepolia\" } }","title":"2. addFacet"},{"location":"cloud-functions/tasks/diamond/#3-replacefacet","text":"Replace an existing facet's functions with new ones from a different facet contract. Function Name : replaceFacet Method : POST Parameters : (Similar to addFacet , but replaces existing selectors) diamondAddress (String, required) facetAddress (String, required): The address of the new facet contract. functionSelectors (Array of Strings, required): Function selectors to replace. initContract (String, optional) initData (String, optional) network (String, required) Returns : transactionHash (String)","title":"3. replaceFacet"},{"location":"cloud-functions/tasks/diamond/#4-removefacet","text":"Remove functions from a Diamond contract. Function Name : removeFacet Method : POST Parameters : (Similar to addFacet , but removes selectors) diamondAddress (String, required) functionSelectors (Array of Strings, required): Function selectors to remove. network (String, required) Returns : transactionHash (String)","title":"4. removeFacet"},{"location":"cloud-functions/tasks/diamond/#error-handling","text":"Diamond tasks can encounter various errors, including: Invalid Parameters : Missing required fields or incorrect data types in the request. Blockchain Transaction Errors : Transaction reverts, out-of-gas, insufficient funds, or network congestion. Access Control : Caller not authorized to perform the operation on the Diamond (e.g., not the owner). Template Not Found : The specified templateName for deployDiamond does not exist. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"cloud-functions/tasks/diamond/#security-considerations","text":"Access Control : Ensure that only authorized users or services can call these Cloud Functions, either through Parse's CLP/ACLs or custom logic. Master Key Usage : Cloud Functions that interact with smart contracts typically require useMasterKey: true for the Parse SDK calls, as they often sign transactions on behalf of an admin address. Securely manage your Parse Master Key. Input Sanitization : Always sanitize and validate all inputs received by Cloud Functions to prevent injection attacks or unexpected behavior. DFNS Integration : If DFNS is used for signing, ensure the policies associated with the DFNS wallets are robust and match your security requirements.","title":"Security Considerations"},{"location":"cloud-functions/tasks/diamond/#related-documentation","text":"Smart Contracts: Diamond Contract Smart Contracts: Diamond Factory Smart Contracts: Facets (Diamond Cut Facet) Integrator's Guide: Authentication Integrator's Guide: DFNS Integration","title":"Related Documentation"},{"location":"cloud-functions/tasks/identities/","text":"Cloud Functions: Identity Tasks \u00b6 This document details the cloud functions related to managing IIdentity smart contracts within the Gemforce platform. These functions provide a convenient API for creating, managing keys, and verifying claims associated with decentralized identities, abstracting away the underlying blockchain complexities. Overview \u00b6 Identity tasks enable: Identity Creation : Deploying new IIdentity contracts for users. Key Management : Adding and removing cryptographic keys for an identity. Claim Management : Adding, retrieving, and removing verifiable claims for an identity. Profile Management : Updating an identity's associated off-chain profile data. Verification Flow : Initiating and processing identity verification requests. These functions are crucial for applications that need to interact with Gemforce's identity system without directly handling smart contract interactions. Key Functions \u00b6 1. createIdentity \u00b6 Deploy a new IIdentity contract for a user. Function Name : createIdentity Method : POST Parameters : ownerAddress (String, optional): The address that will initially control the new identity contract. If not provided, the caller's associated wallet address from the Parse session is used. profile (Object, optional): An object containing initial off-chain profile data for the identity (e.g., { name: \"John Doe\", email: \"john.doe@example.com\" } ). name (String) email (String) country (String) metadataURI (String): URI to external metadata. network (String, required): The blockchain network to deploy the identity on (e.g., \"base-sepolia\"). Returns : identityAddress (String): The deployed address of the new IIdentity contract. transactionHash (String): The transaction hash of the deployment. identityHash (String): A unique hash representing the identity within the Gemforce registry. Example Request : { \"functionName\" : \"createIdentity\" , \"parameters\" : { \"ownerAddress\" : \"0xYourUserWalletAddress\" , \"profile\" : { \"name\" : \"Alice Smith\" , \"email\" : \"alice@example.com\" , \"country\" : \"USA\" }, \"network\" : \"sepolia\" } } Example Response : { \"result\" : { \"identityAddress\" : \"0xabc...123\" , \"transactionHash\" : \"0xdef...456\" , \"identityHash\" : \"0xghi...789\" } } 2. addKeyToIdentity \u00b6 Add a new cryptographic key to an existing identity. Function Name : addKeyToIdentity Method : POST Parameters : identityAddress (String, required): The address of the IIdentity contract. key (String, required): The hex string representation of the public key to add (e.g., 0x<publicKeyHex> ). purpose (Number, required): An integer representing the key's purpose (e.g., 1 for MANAGEMENT, 2 for ACTION, 3 for CLAIM, 4 for ENCRYPTION). See IIdentity interface for full details. keyType (Number, required): An integer representing the key's type (e.g., 1 for ECDSA, 2 for RSA). network (String, required): The blockchain network where the identity is deployed. Returns : transactionHash (String) 3. addClaimToIdentity \u00b6 Add a verifiable claim to an identity. Function Name : addClaimToIdentity Method : POST Parameters : identityAddress (String, required): The address of the IIdentity contract. topic (Number, required): The topic of the claim (e.g., 1 for \"KYC Approved\", 2 for \"Accredited Investor\"). scheme (Number, required): The signature scheme used for the claim (e.g., 1 for ECDSA signature on data ). issuerAddress (String, required): The address of the claim issuer (must be a trusted issuer). signature (String, required): The hex string of the cryptographic signature of the claim data. data (String, required): The hex string of the ABI-encoded claim data. uri (String, optional): A URI pointing to external details about the claim. network (String, required): The blockchain network where the identity is deployed. Returns : transactionHash (String) Error Handling \u00b6 Identity tasks can fail due to: Invalid Parameters : Incorrect key formats, invalid purpose/key types. Blockchain Transaction Errors : Reverted transactions (e.g., IIdentity: Key already exists ), out-of-gas. Access Control : Caller not authorized to add keys or claims to the specified identity. Trusted Issuer Issues : issuerAddress not recognized as a trusted issuer. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Key Exposure : Never expose private keys of identity owners on the client-side. Utilize Cloud Functions or DFNS integration for signing on behalf of identity owners. Access Control : Thoroughly implement access control within your Cloud Functions to ensure only authorized users can modify their identities or perform privileged operations. Trusted Issuers : Claims are only meaningful if the issuerAddress is recognized as trusted. Ensure your system verifies issuerAddress against the ITrustedIssuersRegistry . Input Validation : Sanitize and validate all inputs, especially key , signature , and data parameters, to prevent malicious data injection. Related Documentation \u00b6 Smart Contracts: Identity Factory Smart Contracts: IIdentity Interface Smart Contracts: ITrustedIssuersRegistry Interface Integrator's Guide: Authentication","title":"Identity Tasks"},{"location":"cloud-functions/tasks/identities/#cloud-functions-identity-tasks","text":"This document details the cloud functions related to managing IIdentity smart contracts within the Gemforce platform. These functions provide a convenient API for creating, managing keys, and verifying claims associated with decentralized identities, abstracting away the underlying blockchain complexities.","title":"Cloud Functions: Identity Tasks"},{"location":"cloud-functions/tasks/identities/#overview","text":"Identity tasks enable: Identity Creation : Deploying new IIdentity contracts for users. Key Management : Adding and removing cryptographic keys for an identity. Claim Management : Adding, retrieving, and removing verifiable claims for an identity. Profile Management : Updating an identity's associated off-chain profile data. Verification Flow : Initiating and processing identity verification requests. These functions are crucial for applications that need to interact with Gemforce's identity system without directly handling smart contract interactions.","title":"Overview"},{"location":"cloud-functions/tasks/identities/#key-functions","text":"","title":"Key Functions"},{"location":"cloud-functions/tasks/identities/#1-createidentity","text":"Deploy a new IIdentity contract for a user. Function Name : createIdentity Method : POST Parameters : ownerAddress (String, optional): The address that will initially control the new identity contract. If not provided, the caller's associated wallet address from the Parse session is used. profile (Object, optional): An object containing initial off-chain profile data for the identity (e.g., { name: \"John Doe\", email: \"john.doe@example.com\" } ). name (String) email (String) country (String) metadataURI (String): URI to external metadata. network (String, required): The blockchain network to deploy the identity on (e.g., \"base-sepolia\"). Returns : identityAddress (String): The deployed address of the new IIdentity contract. transactionHash (String): The transaction hash of the deployment. identityHash (String): A unique hash representing the identity within the Gemforce registry. Example Request : { \"functionName\" : \"createIdentity\" , \"parameters\" : { \"ownerAddress\" : \"0xYourUserWalletAddress\" , \"profile\" : { \"name\" : \"Alice Smith\" , \"email\" : \"alice@example.com\" , \"country\" : \"USA\" }, \"network\" : \"sepolia\" } } Example Response : { \"result\" : { \"identityAddress\" : \"0xabc...123\" , \"transactionHash\" : \"0xdef...456\" , \"identityHash\" : \"0xghi...789\" } }","title":"1. createIdentity"},{"location":"cloud-functions/tasks/identities/#2-addkeytoidentity","text":"Add a new cryptographic key to an existing identity. Function Name : addKeyToIdentity Method : POST Parameters : identityAddress (String, required): The address of the IIdentity contract. key (String, required): The hex string representation of the public key to add (e.g., 0x<publicKeyHex> ). purpose (Number, required): An integer representing the key's purpose (e.g., 1 for MANAGEMENT, 2 for ACTION, 3 for CLAIM, 4 for ENCRYPTION). See IIdentity interface for full details. keyType (Number, required): An integer representing the key's type (e.g., 1 for ECDSA, 2 for RSA). network (String, required): The blockchain network where the identity is deployed. Returns : transactionHash (String)","title":"2. addKeyToIdentity"},{"location":"cloud-functions/tasks/identities/#3-addclaimtoidentity","text":"Add a verifiable claim to an identity. Function Name : addClaimToIdentity Method : POST Parameters : identityAddress (String, required): The address of the IIdentity contract. topic (Number, required): The topic of the claim (e.g., 1 for \"KYC Approved\", 2 for \"Accredited Investor\"). scheme (Number, required): The signature scheme used for the claim (e.g., 1 for ECDSA signature on data ). issuerAddress (String, required): The address of the claim issuer (must be a trusted issuer). signature (String, required): The hex string of the cryptographic signature of the claim data. data (String, required): The hex string of the ABI-encoded claim data. uri (String, optional): A URI pointing to external details about the claim. network (String, required): The blockchain network where the identity is deployed. Returns : transactionHash (String)","title":"3. addClaimToIdentity"},{"location":"cloud-functions/tasks/identities/#error-handling","text":"Identity tasks can fail due to: Invalid Parameters : Incorrect key formats, invalid purpose/key types. Blockchain Transaction Errors : Reverted transactions (e.g., IIdentity: Key already exists ), out-of-gas. Access Control : Caller not authorized to add keys or claims to the specified identity. Trusted Issuer Issues : issuerAddress not recognized as a trusted issuer. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"cloud-functions/tasks/identities/#security-considerations","text":"Key Exposure : Never expose private keys of identity owners on the client-side. Utilize Cloud Functions or DFNS integration for signing on behalf of identity owners. Access Control : Thoroughly implement access control within your Cloud Functions to ensure only authorized users can modify their identities or perform privileged operations. Trusted Issuers : Claims are only meaningful if the issuerAddress is recognized as trusted. Ensure your system verifies issuerAddress against the ITrustedIssuersRegistry . Input Validation : Sanitize and validate all inputs, especially key , signature , and data parameters, to prevent malicious data injection.","title":"Security Considerations"},{"location":"cloud-functions/tasks/identities/#related-documentation","text":"Smart Contracts: Identity Factory Smart Contracts: IIdentity Interface Smart Contracts: ITrustedIssuersRegistry Interface Integrator's Guide: Authentication","title":"Related Documentation"},{"location":"cloud-functions/tasks/integration-test-marketplace/","text":"Cloud Functions: Marketplace Integration Test Tasks \u00b6 This document specifically details cloud functions designed for comprehensive integration testing of the Gemforce NFT Marketplace functionality. These functions extend general integration test capabilities to provide a streamlined way to set up, operate, and verify marketplace scenarios in a test environment. Overview \u00b6 Marketplace integration test tasks enable: Test Listing Creation : Creating various types of test NFT listings (fixed price, auction). Test Purchase Simulation : Simulating purchases of listed NFTs. Test Data Cleanup : Rapidly clearing marketplace-related test data. State Verification : Checking the active state of listings, balances, and ownership after simulated interactions. These functions are invaluable for ensuring the robustness and correctness of marketplace logic and integrations. Key Functions \u00b6 1. createTestListing \u00b6 Creates a test NFT listing for integration testing purposes. This function might abstract away approvals and other setup steps needed in a real scenario. Function Name : createTestListing Method : POST Parameters : nftContractAddress (String, required): Address of the test NFT contract. tokenId (String, required): ID of the test NFT. price (String, required): Listing price in Wei or base units. paymentTokenAddress (String, required): Address of payment token (or address(0) for native ETH). sellerAddress (String, required): The address of the test seller account. network (String, required): The blockchain network. options (Object, optional): approveNFT (Boolean, default: true): Whether to automatically approve the marketplace for NFT transfer. listDuration (Number, default: 86400): Duration of the listing in seconds. Returns : listingId (String): The ID of the created test listing. transactionHash (String): Transaction hash of the listing. Example Request : { \"functionName\" : \"createTestListing\" , \"parameters\" : { \"nftContractAddress\" : \"0xTestNftContract\" , \"tokenId\" : \"1\" , \"price\" : \"100000000000000000\" , // 0.1 ETH \"paymentTokenAddress\" : \"0x0000000000000000000000000000000000000000\" , \"sellerAddress\" : \"0xTestSellerWallet\" , \"network\" : \"sepolia\" } } 2. simulatePurchase \u00b6 Simulates a purchase of a test NFT listing. Function Name : simulatePurchase Method : POST Parameters : listingId (String, required): The ID of the test listing to purchase. buyerAddress (String, required): The address of the test buyer account. value (String, optional): The value to send with the transaction (for ETH payments). network (String, required): The blockchain network. Returns : transactionHash (String) 3. getTestListingDetails \u00b6 Retrieves details of a test listing. Function Name : getTestListingDetails Method : GET (or POST for Cloud Function) Parameters : listingId (String, required): The ID of the test listing. network (String, required): The blockchain network. Returns : listing (Object): Detailed information about the test listing. Error Handling \u00b6 Errors specific to marketplace integration tests typically involve: Invalid Test Data : Using non-existent nftContractAddress or tokenId . Marketplace Logic Errors : Issues arising from the marketplace smart contract's internal logic during simulated actions. Approval Failures : If approveNFT is false or fails for some reason. Balance Issues : The test seller/buyer accounts having insufficient funds or tokens. Refer to the Integrator's Guide: Error Handling and Cloud Functions: Integration Test Tasks for more general error handling strategies. Security Considerations \u00b6 Testnet Isolation : These functions should ONLY be used on testnets. They are designed for test environment manipulation and should absolutely not be exposed or callable in production environments. Access Control : Strictly limit who can call these test- prefixed Cloud Functions. They often require Master Key access. Data Contamination : Ensure that test operations do not accidentally affect or expose any production data. Use dedicated test databases and contracts. Related Documentation \u00b6 Smart Contracts: Marketplace Facet Cloud Functions: Integration Test Tasks Integrator's Guide: Testing","title":"Marketplace Integration Test Tasks"},{"location":"cloud-functions/tasks/integration-test-marketplace/#cloud-functions-marketplace-integration-test-tasks","text":"This document specifically details cloud functions designed for comprehensive integration testing of the Gemforce NFT Marketplace functionality. These functions extend general integration test capabilities to provide a streamlined way to set up, operate, and verify marketplace scenarios in a test environment.","title":"Cloud Functions: Marketplace Integration Test Tasks"},{"location":"cloud-functions/tasks/integration-test-marketplace/#overview","text":"Marketplace integration test tasks enable: Test Listing Creation : Creating various types of test NFT listings (fixed price, auction). Test Purchase Simulation : Simulating purchases of listed NFTs. Test Data Cleanup : Rapidly clearing marketplace-related test data. State Verification : Checking the active state of listings, balances, and ownership after simulated interactions. These functions are invaluable for ensuring the robustness and correctness of marketplace logic and integrations.","title":"Overview"},{"location":"cloud-functions/tasks/integration-test-marketplace/#key-functions","text":"","title":"Key Functions"},{"location":"cloud-functions/tasks/integration-test-marketplace/#1-createtestlisting","text":"Creates a test NFT listing for integration testing purposes. This function might abstract away approvals and other setup steps needed in a real scenario. Function Name : createTestListing Method : POST Parameters : nftContractAddress (String, required): Address of the test NFT contract. tokenId (String, required): ID of the test NFT. price (String, required): Listing price in Wei or base units. paymentTokenAddress (String, required): Address of payment token (or address(0) for native ETH). sellerAddress (String, required): The address of the test seller account. network (String, required): The blockchain network. options (Object, optional): approveNFT (Boolean, default: true): Whether to automatically approve the marketplace for NFT transfer. listDuration (Number, default: 86400): Duration of the listing in seconds. Returns : listingId (String): The ID of the created test listing. transactionHash (String): Transaction hash of the listing. Example Request : { \"functionName\" : \"createTestListing\" , \"parameters\" : { \"nftContractAddress\" : \"0xTestNftContract\" , \"tokenId\" : \"1\" , \"price\" : \"100000000000000000\" , // 0.1 ETH \"paymentTokenAddress\" : \"0x0000000000000000000000000000000000000000\" , \"sellerAddress\" : \"0xTestSellerWallet\" , \"network\" : \"sepolia\" } }","title":"1. createTestListing"},{"location":"cloud-functions/tasks/integration-test-marketplace/#2-simulatepurchase","text":"Simulates a purchase of a test NFT listing. Function Name : simulatePurchase Method : POST Parameters : listingId (String, required): The ID of the test listing to purchase. buyerAddress (String, required): The address of the test buyer account. value (String, optional): The value to send with the transaction (for ETH payments). network (String, required): The blockchain network. Returns : transactionHash (String)","title":"2. simulatePurchase"},{"location":"cloud-functions/tasks/integration-test-marketplace/#3-gettestlistingdetails","text":"Retrieves details of a test listing. Function Name : getTestListingDetails Method : GET (or POST for Cloud Function) Parameters : listingId (String, required): The ID of the test listing. network (String, required): The blockchain network. Returns : listing (Object): Detailed information about the test listing.","title":"3. getTestListingDetails"},{"location":"cloud-functions/tasks/integration-test-marketplace/#error-handling","text":"Errors specific to marketplace integration tests typically involve: Invalid Test Data : Using non-existent nftContractAddress or tokenId . Marketplace Logic Errors : Issues arising from the marketplace smart contract's internal logic during simulated actions. Approval Failures : If approveNFT is false or fails for some reason. Balance Issues : The test seller/buyer accounts having insufficient funds or tokens. Refer to the Integrator's Guide: Error Handling and Cloud Functions: Integration Test Tasks for more general error handling strategies.","title":"Error Handling"},{"location":"cloud-functions/tasks/integration-test-marketplace/#security-considerations","text":"Testnet Isolation : These functions should ONLY be used on testnets. They are designed for test environment manipulation and should absolutely not be exposed or callable in production environments. Access Control : Strictly limit who can call these test- prefixed Cloud Functions. They often require Master Key access. Data Contamination : Ensure that test operations do not accidentally affect or expose any production data. Use dedicated test databases and contracts.","title":"Security Considerations"},{"location":"cloud-functions/tasks/integration-test-marketplace/#related-documentation","text":"Smart Contracts: Marketplace Facet Cloud Functions: Integration Test Tasks Integrator's Guide: Testing","title":"Related Documentation"},{"location":"cloud-functions/tasks/integration-test-trade-deal/","text":"Cloud Functions: Trade Deal Integration Test Tasks \u00b6 This document specifically details cloud functions designed for comprehensive integration testing of the Gemforce Trade Deal functionality. These functions provide a streamlined way to set up, operate, and verify various trade deal scenarios in a test environment, from creation to resolution or default. Overview \u00b6 Trade Deal integration test tasks enable: Test Trade Deal Creation : Creating test trade deals with predefined terms and participants. Test Fund/Collateral Operations : Simulating funding by lender and collateral deposit by borrower. Test Resolution/Default : Advancing trade deals to resolution or default states. Test Data Cleanup : Rapidly clearing trade deal-related test data. State Verification : Checking the active state of trade deals, token balances, and ownership after simulated interactions. These functions are invaluable for ensuring the robustness and correctness of trade deal logic and integrations. Key Functions \u00b6 1. createTestTradeDeal \u00b6 Creates a test trade deal for integration testing purposes. This function might abstract away token approvals and other setup steps. Function Name : createTestTradeDeal Method : POST Parameters : principalAmount (String, required): Principal amount for the test trade deal. principalTokenAddress (String, required): Address of the principal token. collateralAmount (String, required): Collateral amount. collateralTokenAddress (String, required): Address of the collateral token. borrowerAddress (String, required): The address of the test borrower account. lenderAddress (String, required): The address of the test lender account. maturityDate (Number, required): Unix timestamp for maturity. network (String, required): The blockchain network. options (Object, optional): autoApproveTokens (Boolean, default: true): Whether to automatically approve tokens for transfer. Returns : tradeDealId (String): The ID of the created test trade deal. transactionHash (String): Transaction hash of the trade deal creation. Example Request : { \"functionName\" : \"createTestTradeDeal\" , \"parameters\" : { \"principalAmount\" : \"100000000000000000000\" , // 100 PrincipalTokens \"principalTokenAddress\" : \"0xTestPrincipalToken\" , \"collateralAmount\" : \"150000000000000000000\" , // 150 CollateralTokens \"collateralTokenAddress\" : \"0xTestCollateralToken\" , \"borrowerAddress\" : \"0xTestBorrowerWallet\" , \"lenderAddress\" : \"0xTestLenderWallet\" , \"maturityDate\" : 1735689600 , // Jan 1, 2025 \"network\" : \"sepolia\" } } 2. simulateFundTradeDeal \u00b6 Simulates the lender funding a test trade deal. Function Name : simulateFundTradeDeal Method : POST Parameters : tradeDealId (String, required): The ID of the test trade deal. network (String, required): The blockchain network. Returns : transactionHash (String) 3. simulateDepositCollateral \u00b6 Simulates the borrower depositing collateral for a test trade deal. Function Name : simulateDepositCollateral Method : POST Parameters : tradeDealId (String, required): The ID of the test trade deal. network (String, required): The blockchain network. Returns : transactionHash (String) 4. simulateResolveTradeDeal \u00b6 Simulates the resolution of a test trade deal ( resolveTradeDeal function). Function Name : simulateResolveTradeDeal Method : POST Parameters : tradeDealId (String, required): The ID of the test trade deal. network (String, required): The blockchain network. Returns : transactionHash (String) 5. simulateDefaultTradeDeal \u00b6 Simulates a trade deal going into default ( triggerDefault function). Function Name : simulateDefaultTradeDeal Method : POST Parameters : tradeDealId (String, required): The ID of the test trade deal. network (String, required): The blockchain network. Returns : transactionHash (String) Error Handling \u00b6 Errors specific to trade deal integration tests typically involve: Invalid Test Data : Using non-existent tradeDealId , or incorrect token addresses. Trade Deal Logic Errors : Issues arising from the trade deal smart contract's internal logic during simulated actions. Approval Failures : If autoApproveTokens is false or fails for some reason. Balance Issues : The test borrower/lender accounts having insufficient funds or tokens. Refer to the Integrator's Guide: Error Handling and Cloud Functions: Integration Test Tasks for more general error handling strategies. Security Considerations \u00b6 Testnet Isolation : These functions should ONLY be used on testnets. They are designed for test environment manipulation and should absolutely not be exposed or callable in production environments. Access Control : Strictly limit who can call these test- prefixed Cloud Functions. They often require Master Key access. Data Contamination : Ensure that test operations do not accidentally affect or expose any production data. Use dedicated test databases and contracts. Related Documentation \u00b6 Smart Contracts: Trade Deal Management Facet Smart Contracts: ITradeDeal Interface Cloud Functions: Integration Test Tasks Integrator's Guide: Testing","title":"Trade Deal Integration Test Tasks"},{"location":"cloud-functions/tasks/integration-test-trade-deal/#cloud-functions-trade-deal-integration-test-tasks","text":"This document specifically details cloud functions designed for comprehensive integration testing of the Gemforce Trade Deal functionality. These functions provide a streamlined way to set up, operate, and verify various trade deal scenarios in a test environment, from creation to resolution or default.","title":"Cloud Functions: Trade Deal Integration Test Tasks"},{"location":"cloud-functions/tasks/integration-test-trade-deal/#overview","text":"Trade Deal integration test tasks enable: Test Trade Deal Creation : Creating test trade deals with predefined terms and participants. Test Fund/Collateral Operations : Simulating funding by lender and collateral deposit by borrower. Test Resolution/Default : Advancing trade deals to resolution or default states. Test Data Cleanup : Rapidly clearing trade deal-related test data. State Verification : Checking the active state of trade deals, token balances, and ownership after simulated interactions. These functions are invaluable for ensuring the robustness and correctness of trade deal logic and integrations.","title":"Overview"},{"location":"cloud-functions/tasks/integration-test-trade-deal/#key-functions","text":"","title":"Key Functions"},{"location":"cloud-functions/tasks/integration-test-trade-deal/#1-createtesttradedeal","text":"Creates a test trade deal for integration testing purposes. This function might abstract away token approvals and other setup steps. Function Name : createTestTradeDeal Method : POST Parameters : principalAmount (String, required): Principal amount for the test trade deal. principalTokenAddress (String, required): Address of the principal token. collateralAmount (String, required): Collateral amount. collateralTokenAddress (String, required): Address of the collateral token. borrowerAddress (String, required): The address of the test borrower account. lenderAddress (String, required): The address of the test lender account. maturityDate (Number, required): Unix timestamp for maturity. network (String, required): The blockchain network. options (Object, optional): autoApproveTokens (Boolean, default: true): Whether to automatically approve tokens for transfer. Returns : tradeDealId (String): The ID of the created test trade deal. transactionHash (String): Transaction hash of the trade deal creation. Example Request : { \"functionName\" : \"createTestTradeDeal\" , \"parameters\" : { \"principalAmount\" : \"100000000000000000000\" , // 100 PrincipalTokens \"principalTokenAddress\" : \"0xTestPrincipalToken\" , \"collateralAmount\" : \"150000000000000000000\" , // 150 CollateralTokens \"collateralTokenAddress\" : \"0xTestCollateralToken\" , \"borrowerAddress\" : \"0xTestBorrowerWallet\" , \"lenderAddress\" : \"0xTestLenderWallet\" , \"maturityDate\" : 1735689600 , // Jan 1, 2025 \"network\" : \"sepolia\" } }","title":"1. createTestTradeDeal"},{"location":"cloud-functions/tasks/integration-test-trade-deal/#2-simulatefundtradedeal","text":"Simulates the lender funding a test trade deal. Function Name : simulateFundTradeDeal Method : POST Parameters : tradeDealId (String, required): The ID of the test trade deal. network (String, required): The blockchain network. Returns : transactionHash (String)","title":"2. simulateFundTradeDeal"},{"location":"cloud-functions/tasks/integration-test-trade-deal/#3-simulatedepositcollateral","text":"Simulates the borrower depositing collateral for a test trade deal. Function Name : simulateDepositCollateral Method : POST Parameters : tradeDealId (String, required): The ID of the test trade deal. network (String, required): The blockchain network. Returns : transactionHash (String)","title":"3. simulateDepositCollateral"},{"location":"cloud-functions/tasks/integration-test-trade-deal/#4-simulateresolvetradedeal","text":"Simulates the resolution of a test trade deal ( resolveTradeDeal function). Function Name : simulateResolveTradeDeal Method : POST Parameters : tradeDealId (String, required): The ID of the test trade deal. network (String, required): The blockchain network. Returns : transactionHash (String)","title":"4. simulateResolveTradeDeal"},{"location":"cloud-functions/tasks/integration-test-trade-deal/#5-simulatedefaulttradedeal","text":"Simulates a trade deal going into default ( triggerDefault function). Function Name : simulateDefaultTradeDeal Method : POST Parameters : tradeDealId (String, required): The ID of the test trade deal. network (String, required): The blockchain network. Returns : transactionHash (String)","title":"5. simulateDefaultTradeDeal"},{"location":"cloud-functions/tasks/integration-test-trade-deal/#error-handling","text":"Errors specific to trade deal integration tests typically involve: Invalid Test Data : Using non-existent tradeDealId , or incorrect token addresses. Trade Deal Logic Errors : Issues arising from the trade deal smart contract's internal logic during simulated actions. Approval Failures : If autoApproveTokens is false or fails for some reason. Balance Issues : The test borrower/lender accounts having insufficient funds or tokens. Refer to the Integrator's Guide: Error Handling and Cloud Functions: Integration Test Tasks for more general error handling strategies.","title":"Error Handling"},{"location":"cloud-functions/tasks/integration-test-trade-deal/#security-considerations","text":"Testnet Isolation : These functions should ONLY be used on testnets. They are designed for test environment manipulation and should absolutely not be exposed or callable in production environments. Access Control : Strictly limit who can call these test- prefixed Cloud Functions. They often require Master Key access. Data Contamination : Ensure that test operations do not accidentally affect or expose any production data. Use dedicated test databases and contracts.","title":"Security Considerations"},{"location":"cloud-functions/tasks/integration-test-trade-deal/#related-documentation","text":"Smart Contracts: Trade Deal Management Facet Smart Contracts: ITradeDeal Interface Cloud Functions: Integration Test Tasks Integrator's Guide: Testing","title":"Related Documentation"},{"location":"cloud-functions/tasks/integration-test/","text":"Cloud Functions: Integration Test Tasks \u00b6 This document describes the cloud functions specifically designed to facilitate integration testing within the Gemforce ecosystem. These functions provide utilities to set up, manipulate, and tear down test environments, making it easier to perform end-to-end and integration tests across smart contracts, cloud functions, and external services. Overview \u00b6 Integration Test tasks enable: Test Data Setup : Creating and populating test data in Parse Server. Environment Manipulation : Resetting specific components or states for clean test runs. Mocking External Services : Directing test calls to mock services instead of live ones. Status Querying : Retrieving the state of test-related data or processes. These functions are invaluable for automated testing pipelines and for developers performing manual integration tests. Key Functions \u00b6 1. prepareTestEnvironment \u00b6 Sets up a clean or specific test environment state. This might involve clearing Parse collections, deploying specific smart contract configurations on a testnet, or seeding initial data. Function Name : prepareTestEnvironment Method : POST Parameters : scenario (String, required): Defines the test scenario to prepare (e.g., \"empty\", \"initialUsers\", \"marketplaceSetup\"). network (String, optional): The blockchain network to target if smart contract operations are involved. options (Object, optional): Additional key-value pairs for scenario-specific configurations. Returns : status (String): \"success\" or \"failure\". message (String): A descriptive message about the setup outcome. details (Object, optional): Any test-specific details (e.g., deployed contract addresses). Example Request : { \"functionName\" : \"prepareTestEnvironment\" , \"parameters\" : { \"scenario\" : \"marketplaceSetup\" , \"network\" : \"sepolia\" , \"options\" : { \"initialNFTs\" : 5 , \"testAccountBalance\" : \"1000000000000000000\" // 1 ETH } } } Example Response : { \"result\" : { \"status\" : \"success\" , \"message\" : \"Marketplace test environment prepared.\" , \"details\" : { \"marketplaceAddress\" : \"0xabc...xyz\" , \"testUserWallet\" : \"0xuser...wallet\" } } } 2. resetTestData \u00b6 Clears specific test data from Parse Server collections or resets smart contract states to a known clean state. Function Name : resetTestData Method : POST Parameters : collections (Array of Strings, optional): An array of Parse collection names to clear (e.g., [\"_User\", \"Project\", \"Transactions\"]). If empty, might reset default collections. network (String, optional): The blockchain network to reset smart contract states on. Returns : status (String): \"success\" or \"failure\". message (String): Outcome message. 3. getTestState \u00b6 Retrieves the current state of test-related data or configurations. Useful for assertions within test cases. Function Name : getTestState Method : GET (or POST for Cloud Function) Parameters : query (Object, optional): A query object to specify what state to retrieve (e.g., { type: \"userCount\" } ). network (String, optional) Returns : data (Object): The requested state data. 4. finalizeTestRun \u00b6 Performs cleanup operations after a test run. This might involve deleting all test data, deactivating test accounts, or undeploying temporary smart contracts. Function Name : finalizeTestRun Method : POST Parameters : options (Object, optional): Options for cleanup (e.g., deleteAllData: true ). Returns : status (String): \"success\" or \"failure\". Error Handling \u00b6 Errors in integration test tasks typically stem from: Configuration Issues : Invalid scenario or options . Permissions : The Cloud Function lacks the necessary Parse Master Key or blockchain permissions to perform resets/deploys. External Service Failures : Issues with the blockchain network or third-party test services. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Restricted Access : Integration test functions often have powerful capabilities (e.g., deleting data, deploying contracts). They should be highly restricted in production environments, accessible only by specific administrative tools or during CI/CD pipelines. Master Key Usage : Many of these functions will require the Parse Master Key. Ensure its secure management. Testnet Isolation : Perform all integration testing on dedicated testnets (e.g., Sepolia, Base Sepolia) and never on a mainnet environment. Data Sensitivity : Be cautious with any sensitive data used or generated during testing. Ensure it is properly cleaned up. Related Documentation \u00b6 Integrator's Guide: Testing Integrator's Guide: Deployment (if dealing with testnet deployments) Cloud Functions: Deploy Tasks","title":"Integration Test Tasks"},{"location":"cloud-functions/tasks/integration-test/#cloud-functions-integration-test-tasks","text":"This document describes the cloud functions specifically designed to facilitate integration testing within the Gemforce ecosystem. These functions provide utilities to set up, manipulate, and tear down test environments, making it easier to perform end-to-end and integration tests across smart contracts, cloud functions, and external services.","title":"Cloud Functions: Integration Test Tasks"},{"location":"cloud-functions/tasks/integration-test/#overview","text":"Integration Test tasks enable: Test Data Setup : Creating and populating test data in Parse Server. Environment Manipulation : Resetting specific components or states for clean test runs. Mocking External Services : Directing test calls to mock services instead of live ones. Status Querying : Retrieving the state of test-related data or processes. These functions are invaluable for automated testing pipelines and for developers performing manual integration tests.","title":"Overview"},{"location":"cloud-functions/tasks/integration-test/#key-functions","text":"","title":"Key Functions"},{"location":"cloud-functions/tasks/integration-test/#1-preparetestenvironment","text":"Sets up a clean or specific test environment state. This might involve clearing Parse collections, deploying specific smart contract configurations on a testnet, or seeding initial data. Function Name : prepareTestEnvironment Method : POST Parameters : scenario (String, required): Defines the test scenario to prepare (e.g., \"empty\", \"initialUsers\", \"marketplaceSetup\"). network (String, optional): The blockchain network to target if smart contract operations are involved. options (Object, optional): Additional key-value pairs for scenario-specific configurations. Returns : status (String): \"success\" or \"failure\". message (String): A descriptive message about the setup outcome. details (Object, optional): Any test-specific details (e.g., deployed contract addresses). Example Request : { \"functionName\" : \"prepareTestEnvironment\" , \"parameters\" : { \"scenario\" : \"marketplaceSetup\" , \"network\" : \"sepolia\" , \"options\" : { \"initialNFTs\" : 5 , \"testAccountBalance\" : \"1000000000000000000\" // 1 ETH } } } Example Response : { \"result\" : { \"status\" : \"success\" , \"message\" : \"Marketplace test environment prepared.\" , \"details\" : { \"marketplaceAddress\" : \"0xabc...xyz\" , \"testUserWallet\" : \"0xuser...wallet\" } } }","title":"1. prepareTestEnvironment"},{"location":"cloud-functions/tasks/integration-test/#2-resettestdata","text":"Clears specific test data from Parse Server collections or resets smart contract states to a known clean state. Function Name : resetTestData Method : POST Parameters : collections (Array of Strings, optional): An array of Parse collection names to clear (e.g., [\"_User\", \"Project\", \"Transactions\"]). If empty, might reset default collections. network (String, optional): The blockchain network to reset smart contract states on. Returns : status (String): \"success\" or \"failure\". message (String): Outcome message.","title":"2. resetTestData"},{"location":"cloud-functions/tasks/integration-test/#3-getteststate","text":"Retrieves the current state of test-related data or configurations. Useful for assertions within test cases. Function Name : getTestState Method : GET (or POST for Cloud Function) Parameters : query (Object, optional): A query object to specify what state to retrieve (e.g., { type: \"userCount\" } ). network (String, optional) Returns : data (Object): The requested state data.","title":"3. getTestState"},{"location":"cloud-functions/tasks/integration-test/#4-finalizetestrun","text":"Performs cleanup operations after a test run. This might involve deleting all test data, deactivating test accounts, or undeploying temporary smart contracts. Function Name : finalizeTestRun Method : POST Parameters : options (Object, optional): Options for cleanup (e.g., deleteAllData: true ). Returns : status (String): \"success\" or \"failure\".","title":"4. finalizeTestRun"},{"location":"cloud-functions/tasks/integration-test/#error-handling","text":"Errors in integration test tasks typically stem from: Configuration Issues : Invalid scenario or options . Permissions : The Cloud Function lacks the necessary Parse Master Key or blockchain permissions to perform resets/deploys. External Service Failures : Issues with the blockchain network or third-party test services. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"cloud-functions/tasks/integration-test/#security-considerations","text":"Restricted Access : Integration test functions often have powerful capabilities (e.g., deleting data, deploying contracts). They should be highly restricted in production environments, accessible only by specific administrative tools or during CI/CD pipelines. Master Key Usage : Many of these functions will require the Parse Master Key. Ensure its secure management. Testnet Isolation : Perform all integration testing on dedicated testnets (e.g., Sepolia, Base Sepolia) and never on a mainnet environment. Data Sensitivity : Be cautious with any sensitive data used or generated during testing. Ensure it is properly cleaned up.","title":"Security Considerations"},{"location":"cloud-functions/tasks/integration-test/#related-documentation","text":"Integrator's Guide: Testing Integrator's Guide: Deployment (if dealing with testnet deployments) Cloud Functions: Deploy Tasks","title":"Related Documentation"},{"location":"cloud-functions/tasks/marketplace-management/","text":"Cloud Functions: Marketplace Management Tasks \u00b6 This document details the cloud functions designed for managing the Gemforce NFT Marketplace. These functions provide an abstracted API for listing, unlisting, buying, and managing NFTs within the marketplace, streamlining interactions for both creators and consumers. Overview \u00b6 Marketplace management tasks enable: Listing Management : Creating and updating NFT listings. Purchase Execution : Facilitating the buying of listed NFTs. Offer Management : Handling bids and offers for NFTs. Royalty Distribution : Ensuring proper distribution of royalties from sales. Marketplace Configuration : Adjusting global marketplace settings (e.g., fees, whitelists). These functions are critical for building responsive and user-friendly marketplace UIs and for automating marketplace operations. Key Functions \u00b6 1. createListing \u00b6 Create a new NFT listing on the Gemforce Marketplace. Function Name : createListing Method : POST Parameters : nftContractAddress (String, required): The address of the NFT contract (ERC721 or ERC1155). tokenId (String, required): The ID of the NFT to list. price (String, required): The listing price in Wei (or equivalent smallest unit of the payment token). paymentTokenAddress (String, required): The address of the ERC20 token used for payment, or address(0) for native blockchain currency (e.g., ETH). duration (Number, optional): The duration of the listing in seconds. currency (String, optional): The symbol or name of the payment token (e.g., \"ETH\", \"USDC\"). For display purposes. network (String, required): The blockchain network where the NFT and Marketplace are deployed. Returns : listingId (String): A unique identifier for the created listing. transactionHash (String): The transaction hash of the listing creation on-chain. Example Request : { \"functionName\" : \"createListing\" , \"parameters\" : { \"nftContractAddress\" : \"0xabc...123\" , \"tokenId\" : \"456\" , \"price\" : \"100000000000000000\" , // 0.1 ETH \"paymentTokenAddress\" : \"0x0000000000000000000000000000000000000000\" , // ETH \"duration\" : 86400 , // 24 hours \"network\" : \"base-sepolia\" } } Example Response : { \"result\" : { \"listingId\" : \"0x789...def\" , \"transactionHash\" : \"0xghi...jkl\" } } Workflow : Client application calls createListing Cloud Function. Before calling the MarketplaceFacet on-chain, the Cloud Function likely performs approvals (if required, e.g., for ERC721 setApprovalForAll ). Calls the listItem function on the MarketplaceFacet of the Diamond contract. Returns the listing ID and transaction details. 2. purchaseListing \u00b6 Purchase a listed NFT from the Gemforce Marketplace. Function Name : purchaseListing Method : POST Parameters : listingId (String, required): The unique identifier of the listing to purchase. buyerAddress (String, optional): The address of the buyer. Defaults to the caller's associated wallet address from the Parse session. amount (String, optional): The amount of NFTs to purchase (for ERC1155 or multi-edition NFTs). Defaults to 1 for ERC721. network (String, required): The blockchain network. Returns : transactionHash (String) 3. cancelListing \u00b6 Cancel an active NFT listing. Function Name : cancelListing Method : POST Parameters : listingId (String, required): The unique identifier of the listing to cancel. network (String, required): The blockchain network. Returns : transactionHash (String) 4. makeOffer \u00b6 Make an offer for an unlisted NFT or a specific listing. Function Name : makeOffer Method : POST Parameters : (Details about offer parameters such as nftContractAddress , tokenId , offerAmount , expiration , offerorAddress , paymentTokenAddress , network ) Returns : offerId (String), transactionHash (String) Error Handling \u00b6 Marketplace tasks can encounter various errors, including: Invalid Parameters : Incorrect listing IDs, invalid prices, or unsupported tokens. Blockchain Transaction Errors : Transaction reverts (e.g., NFT not approved, insufficient funds, listing expired). Approval Issues : The NFT contract has not granted allowance to the marketplace. Business Logic Violations : Attempting to buy an already sold item, or a price mismatch. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Approvals : Ensure your application gracefully handles ERC721 and ERC1155 approvals before attempting to list assets. Often, the user needs to approve the Marketplace contract to transfer their NFTs. Secure Funds Handling : If the marketplace functions involve handling user funds (e.g., for escrow or direct transfers), verify that the smart contract logic is robust and audited. Marketplace Fees : Be transparent about any marketplace fees and ensure they are correctly applied and distributed. Fraud Prevention : Implement server-side validation to prevent common marketplace frauds (e.g., fake listings, price manipulations beyond smart contract logic). Spam Prevention : Consider rate limits on listing creation to prevent marketplace spam. Related Documentation \u00b6 Smart Contracts: Marketplace Facet Smart Contracts: IMultiSale Interface Integrator's Guide: Smart Contracts Integrator's Guide: Authentication","title":"Marketplace Management Tasks"},{"location":"cloud-functions/tasks/marketplace-management/#cloud-functions-marketplace-management-tasks","text":"This document details the cloud functions designed for managing the Gemforce NFT Marketplace. These functions provide an abstracted API for listing, unlisting, buying, and managing NFTs within the marketplace, streamlining interactions for both creators and consumers.","title":"Cloud Functions: Marketplace Management Tasks"},{"location":"cloud-functions/tasks/marketplace-management/#overview","text":"Marketplace management tasks enable: Listing Management : Creating and updating NFT listings. Purchase Execution : Facilitating the buying of listed NFTs. Offer Management : Handling bids and offers for NFTs. Royalty Distribution : Ensuring proper distribution of royalties from sales. Marketplace Configuration : Adjusting global marketplace settings (e.g., fees, whitelists). These functions are critical for building responsive and user-friendly marketplace UIs and for automating marketplace operations.","title":"Overview"},{"location":"cloud-functions/tasks/marketplace-management/#key-functions","text":"","title":"Key Functions"},{"location":"cloud-functions/tasks/marketplace-management/#1-createlisting","text":"Create a new NFT listing on the Gemforce Marketplace. Function Name : createListing Method : POST Parameters : nftContractAddress (String, required): The address of the NFT contract (ERC721 or ERC1155). tokenId (String, required): The ID of the NFT to list. price (String, required): The listing price in Wei (or equivalent smallest unit of the payment token). paymentTokenAddress (String, required): The address of the ERC20 token used for payment, or address(0) for native blockchain currency (e.g., ETH). duration (Number, optional): The duration of the listing in seconds. currency (String, optional): The symbol or name of the payment token (e.g., \"ETH\", \"USDC\"). For display purposes. network (String, required): The blockchain network where the NFT and Marketplace are deployed. Returns : listingId (String): A unique identifier for the created listing. transactionHash (String): The transaction hash of the listing creation on-chain. Example Request : { \"functionName\" : \"createListing\" , \"parameters\" : { \"nftContractAddress\" : \"0xabc...123\" , \"tokenId\" : \"456\" , \"price\" : \"100000000000000000\" , // 0.1 ETH \"paymentTokenAddress\" : \"0x0000000000000000000000000000000000000000\" , // ETH \"duration\" : 86400 , // 24 hours \"network\" : \"base-sepolia\" } } Example Response : { \"result\" : { \"listingId\" : \"0x789...def\" , \"transactionHash\" : \"0xghi...jkl\" } } Workflow : Client application calls createListing Cloud Function. Before calling the MarketplaceFacet on-chain, the Cloud Function likely performs approvals (if required, e.g., for ERC721 setApprovalForAll ). Calls the listItem function on the MarketplaceFacet of the Diamond contract. Returns the listing ID and transaction details.","title":"1. createListing"},{"location":"cloud-functions/tasks/marketplace-management/#2-purchaselisting","text":"Purchase a listed NFT from the Gemforce Marketplace. Function Name : purchaseListing Method : POST Parameters : listingId (String, required): The unique identifier of the listing to purchase. buyerAddress (String, optional): The address of the buyer. Defaults to the caller's associated wallet address from the Parse session. amount (String, optional): The amount of NFTs to purchase (for ERC1155 or multi-edition NFTs). Defaults to 1 for ERC721. network (String, required): The blockchain network. Returns : transactionHash (String)","title":"2. purchaseListing"},{"location":"cloud-functions/tasks/marketplace-management/#3-cancellisting","text":"Cancel an active NFT listing. Function Name : cancelListing Method : POST Parameters : listingId (String, required): The unique identifier of the listing to cancel. network (String, required): The blockchain network. Returns : transactionHash (String)","title":"3. cancelListing"},{"location":"cloud-functions/tasks/marketplace-management/#4-makeoffer","text":"Make an offer for an unlisted NFT or a specific listing. Function Name : makeOffer Method : POST Parameters : (Details about offer parameters such as nftContractAddress , tokenId , offerAmount , expiration , offerorAddress , paymentTokenAddress , network ) Returns : offerId (String), transactionHash (String)","title":"4. makeOffer"},{"location":"cloud-functions/tasks/marketplace-management/#error-handling","text":"Marketplace tasks can encounter various errors, including: Invalid Parameters : Incorrect listing IDs, invalid prices, or unsupported tokens. Blockchain Transaction Errors : Transaction reverts (e.g., NFT not approved, insufficient funds, listing expired). Approval Issues : The NFT contract has not granted allowance to the marketplace. Business Logic Violations : Attempting to buy an already sold item, or a price mismatch. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"cloud-functions/tasks/marketplace-management/#security-considerations","text":"Approvals : Ensure your application gracefully handles ERC721 and ERC1155 approvals before attempting to list assets. Often, the user needs to approve the Marketplace contract to transfer their NFTs. Secure Funds Handling : If the marketplace functions involve handling user funds (e.g., for escrow or direct transfers), verify that the smart contract logic is robust and audited. Marketplace Fees : Be transparent about any marketplace fees and ensure they are correctly applied and distributed. Fraud Prevention : Implement server-side validation to prevent common marketplace frauds (e.g., fake listings, price manipulations beyond smart contract logic). Spam Prevention : Consider rate limits on listing creation to prevent marketplace spam.","title":"Security Considerations"},{"location":"cloud-functions/tasks/marketplace-management/#related-documentation","text":"Smart Contracts: Marketplace Facet Smart Contracts: IMultiSale Interface Integrator's Guide: Smart Contracts Integrator's Guide: Authentication","title":"Related Documentation"},{"location":"cloud-functions/tasks/sync-diamond/","text":"Cloud Functions: Sync Diamond Tasks \u00b6 This document details the cloud functions responsible for synchronizing data related to Gemforce Diamond contracts between the blockchain and the Parse Server backend. These functions ensure that the off-chain environment accurately reflects the current state of on-chain Diamond deployments and configurations. Overview \u00b6 Sync Diamond tasks enable: State Reconciliation : Automatically updating Parse models (e.g., Diamond , Facet ) to match their on-chain counterparts. Event Processing : Indexing historical and real-time smart contract events to derive off-chain state. Configuration Mirroring : Ensuring that deployed Diamond configurations (facets, function selectors) are available in the backend. These functions are crucial for maintaining consistency, providing fast lookup capabilities, and building user interfaces that rely on comprehensive Diamond data. Key Functions \u00b6 1. syncAllDiamonds \u00b6 Initiates a full synchronization process for all known Gemforce Diamonds, fetching their current configurations and relevant events. Function Name : syncAllDiamonds Method : POST Parameters : network (String, required): The blockchain network to synchronize from. fromBlock (Number, optional): The starting block number for event synchronization. If omitted, starts from a predefined historical block or the last synced block. toBlock (Number, optional): The ending block number for event synchronization. If omitted, syncs up to the latest block. reindexAll (Boolean, optional): If true , forces a complete re-indexing of all events and configurations, discarding previous state. Use with caution. Returns : summary (Object): A summary of the synchronization process, including number of Diamonds processed, events indexed, and any errors encountered. Example Request : { \"functionName\" : \"syncAllDiamonds\" , \"parameters\" : { \"network\" : \"base-sepolia\" , \"reindexAll\" : false } } Example Response : { \"result\" : { \"diamondsSynced\" : 15 , \"facetsUpdated\" : 50 , \"eventsIndexed\" : 1200 , \"lastSyncedBlock\" : 12345678 , \"status\" : \"success\" } } 2. syncDiamondByAddress \u00b6 Synchronizes data for a specific Diamond contract. Function Name : syncDiamondByAddress Method : POST Parameters : diamondAddress (String, required): The address of the Diamond contract to synchronize. network (String, required): The blockchain network. fromBlock (Number, optional): Starting block for events. Returns : summary (Object): Summary for the specific Diamond sync. 3. syncDiamondEvents \u00b6 Specifically focuses on indexing events for a Diamond contract (e.g., DiamondCut , OwnershipTransferred ). Function Name : syncDiamondEvents Method : POST Parameters : diamondAddress (String, required): Address of the Diamond. network (String, required): Blockchain network. eventType (String, optional): Specific event type to sync (e.g., \"DiamondCut\"). fromBlock (Number, optional): Starting block for events. Returns : eventsIndexed (Number) Error Handling \u00b6 Sync Diamond tasks can face errors due to: Blockchain Connectivity : Problems connecting to the RPC node, timeouts during large data fetches. Invalid Addresses/Networks : Non-existent Diamond addresses or unsupported networks. Data Consistency Issues : Discrepancies between on-chain data and expected Parse schema. Gas Limits/Timeouts : Long-running sync processes hitting Cloud Function execution limits. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Access Control : Synchronization functions are typically privileged. Limit access to trusted backend services or administrators that have a clear purpose for triggering these syncs. Data Integrity : Implement robust validation on received blockchain data to prevent corruption of the off-chain database. Resource Consumption : Be mindful of the computational resources (CPU, memory, database writes) required for large-scale synchronization, especially for reindexAll . Implement rate limiting or schedule these functions during off-peak hours. RPC Provider Security : Ensure your RPC provider connection (e.g., API keys) is secure. Related Documentation \u00b6 Smart Contracts: Diamond Contract Smart Contracts: Facets (Diamond Cut Facet) Integrator's Guide: Integration Patterns (especially event-driven architecture)","title":"Sync Diamond Tasks"},{"location":"cloud-functions/tasks/sync-diamond/#cloud-functions-sync-diamond-tasks","text":"This document details the cloud functions responsible for synchronizing data related to Gemforce Diamond contracts between the blockchain and the Parse Server backend. These functions ensure that the off-chain environment accurately reflects the current state of on-chain Diamond deployments and configurations.","title":"Cloud Functions: Sync Diamond Tasks"},{"location":"cloud-functions/tasks/sync-diamond/#overview","text":"Sync Diamond tasks enable: State Reconciliation : Automatically updating Parse models (e.g., Diamond , Facet ) to match their on-chain counterparts. Event Processing : Indexing historical and real-time smart contract events to derive off-chain state. Configuration Mirroring : Ensuring that deployed Diamond configurations (facets, function selectors) are available in the backend. These functions are crucial for maintaining consistency, providing fast lookup capabilities, and building user interfaces that rely on comprehensive Diamond data.","title":"Overview"},{"location":"cloud-functions/tasks/sync-diamond/#key-functions","text":"","title":"Key Functions"},{"location":"cloud-functions/tasks/sync-diamond/#1-syncalldiamonds","text":"Initiates a full synchronization process for all known Gemforce Diamonds, fetching their current configurations and relevant events. Function Name : syncAllDiamonds Method : POST Parameters : network (String, required): The blockchain network to synchronize from. fromBlock (Number, optional): The starting block number for event synchronization. If omitted, starts from a predefined historical block or the last synced block. toBlock (Number, optional): The ending block number for event synchronization. If omitted, syncs up to the latest block. reindexAll (Boolean, optional): If true , forces a complete re-indexing of all events and configurations, discarding previous state. Use with caution. Returns : summary (Object): A summary of the synchronization process, including number of Diamonds processed, events indexed, and any errors encountered. Example Request : { \"functionName\" : \"syncAllDiamonds\" , \"parameters\" : { \"network\" : \"base-sepolia\" , \"reindexAll\" : false } } Example Response : { \"result\" : { \"diamondsSynced\" : 15 , \"facetsUpdated\" : 50 , \"eventsIndexed\" : 1200 , \"lastSyncedBlock\" : 12345678 , \"status\" : \"success\" } }","title":"1. syncAllDiamonds"},{"location":"cloud-functions/tasks/sync-diamond/#2-syncdiamondbyaddress","text":"Synchronizes data for a specific Diamond contract. Function Name : syncDiamondByAddress Method : POST Parameters : diamondAddress (String, required): The address of the Diamond contract to synchronize. network (String, required): The blockchain network. fromBlock (Number, optional): Starting block for events. Returns : summary (Object): Summary for the specific Diamond sync.","title":"2. syncDiamondByAddress"},{"location":"cloud-functions/tasks/sync-diamond/#3-syncdiamondevents","text":"Specifically focuses on indexing events for a Diamond contract (e.g., DiamondCut , OwnershipTransferred ). Function Name : syncDiamondEvents Method : POST Parameters : diamondAddress (String, required): Address of the Diamond. network (String, required): Blockchain network. eventType (String, optional): Specific event type to sync (e.g., \"DiamondCut\"). fromBlock (Number, optional): Starting block for events. Returns : eventsIndexed (Number)","title":"3. syncDiamondEvents"},{"location":"cloud-functions/tasks/sync-diamond/#error-handling","text":"Sync Diamond tasks can face errors due to: Blockchain Connectivity : Problems connecting to the RPC node, timeouts during large data fetches. Invalid Addresses/Networks : Non-existent Diamond addresses or unsupported networks. Data Consistency Issues : Discrepancies between on-chain data and expected Parse schema. Gas Limits/Timeouts : Long-running sync processes hitting Cloud Function execution limits. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"cloud-functions/tasks/sync-diamond/#security-considerations","text":"Access Control : Synchronization functions are typically privileged. Limit access to trusted backend services or administrators that have a clear purpose for triggering these syncs. Data Integrity : Implement robust validation on received blockchain data to prevent corruption of the off-chain database. Resource Consumption : Be mindful of the computational resources (CPU, memory, database writes) required for large-scale synchronization, especially for reindexAll . Implement rate limiting or schedule these functions during off-peak hours. RPC Provider Security : Ensure your RPC provider connection (e.g., API keys) is secure.","title":"Security Considerations"},{"location":"cloud-functions/tasks/sync-diamond/#related-documentation","text":"Smart Contracts: Diamond Contract Smart Contracts: Facets (Diamond Cut Facet) Integrator's Guide: Integration Patterns (especially event-driven architecture)","title":"Related Documentation"},{"location":"cloud-functions/tasks/sync-events/","text":"Cloud Functions: Sync Events Tasks \u00b6 This document details the cloud functions dedicated to synchronizing blockchain events with the Parse Server backend. These functions are crucial for building responsive applications that react to on-chain activities like token transfers, NFT mints, marketplace listings, and trade deal state changes, by storing event data in a queryable off-chain database. Overview \u00b6 Sync Events tasks enable: Event Ingestion : Reading events from blockchain nodes and writing them to Parse collections. Historical Sync : Backfilling events from past blocks. Real-time Processing : Monitoring new blocks for live event indexing. Data Consistency : Ensuring that the off-chain representation of events matches the on-chain source of truth. These functions are fundamental for any application feature that requires querying or displaying historical blockchain data or reacting to new on-chain actions. Key Functions \u00b6 1. syncEvent \u00b6 Synchronizes events of a specific type from a blockchain contract. Function Name : syncEvent Method : POST Parameters : contractAddress (String, required): The address of the smart contract emitting the events. eventName (String, required): The name of the event to synchronize (e.g., \"Transfer\", \"ItemListed\", \"TradeDealCreated\"). network (String, required): The blockchain network where the contract is deployed. abi (Object, required): The ABI of the contract, specifically containing the event definition. fromBlock (Number, optional): The starting block number for the synchronization. If omitted, it syncs from the last recorded block for this event or a predefined default. toBlock (Number, optional): The ending block number. If omitted, syncs up to the latest block. chunkSize (Number, optional): The number of blocks to process in each batch to avoid RPC timeouts or memory limits. Defaults to a reasonable value. reindex (Boolean, optional): If true , forces a full re-indexing of the event, deleting existing records before starting. Use with caution. queryFilters (Object, optional): An object containing indexed event parameters to filter events (e.g., { from: \"0xSenderAddress\" } ). Returns : eventsIndexed (Number): The total number of events indexed during the process. lastBlockProcessed (Number): The last block number successfully processed. Example Request : { \"functionName\" : \"syncEvent\" , \"parameters\" : { \"contractAddress\" : \"0xYourNFTContractAddress\" , \"eventName\" : \"Transfer\" , \"network\" : \"base-sepolia\" , \"abi\" : { \"anonymous\" : false , \"inputs\" : [ { \"indexed\" : true , \"internalType\" : \"address\" , \"name\" : \"from\" , \"type\" : \"address\" }, { \"indexed\" : true , \"internalType\" : \"address\" , \"name\" : \"to\" , \"type\" : \"address\" }, { \"indexed\" : false , \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" } ], \"name\" : \"Transfer\" , \"type\" : \"event\" }, \"fromBlock\" : 12345000 , \"queryFilters\" : { \"to\" : \"0xYourAddress\" } } } Example Response : { \"result\" : { \"eventsIndexed\" : 50 , \"lastBlockProcessed\" : 12345678 } } Workflow : Client application (backend service) calls syncEvent Cloud Function. Cloud Function connects to the specified blockchain network. Queries the contract for events within the given block range and filters. Processes each event, parses its data, and saves it to a designated Parse collection (e.g., BlockchainEvent ). Updates the last processed block to ensure continuity for the next sync. 2. syncAllRelevantEvents \u00b6 A higher-level function that triggers the synchronization of a predefined set of critical Gemforce events across various core contracts. Function Name : syncAllRelevantEvents Method : POST Parameters : network (String, required): The blockchain network to synchronize events from. fromBlock (Number, optional): Global starting block. toBlock (Number, optional): Global ending block. Returns : summary (Object with details of all synced events) Error Handling \u00b6 Sync Events tasks can encounter errors such as: RPC Node Issues : Connectivity problems, rate limits, or outmoded RPC nodes. Invalid ABI/Contract Address : The provided ABI does not match the contract, or the address is incorrect. Event Parsing Errors : Issues decoding event data due to ABI mismatch or corrupted logs. Database Write Errors : Problems saving processed events to Parse. Timeout : Long-running syncs exceeding Cloud Function execution limits, especially for large block ranges. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Access Control : These functions often require privileged access ( Master Key ) if they perform large-scale data writes to the Parse database. This access should be strictly controlled. Data Integrity : Implement robust validation on ingested event data to prevent corruption or malicious injection into the off-chain database. Resource Management : Be mindful of the computational and network resources consumed by large-scale event synchronization. Implement rate limiting and smart chunking. RPC Endpoint Security : Ensure that the RPC endpoints used for fetching events are secure and trusted. Related Documentation \u00b6 Smart Contracts: Overview Integrator's Guide: Integration Patterns (specifically event-driven architecture) Parse Server Cloud Code Guide (External)","title":"Sync Events Tasks"},{"location":"cloud-functions/tasks/sync-events/#cloud-functions-sync-events-tasks","text":"This document details the cloud functions dedicated to synchronizing blockchain events with the Parse Server backend. These functions are crucial for building responsive applications that react to on-chain activities like token transfers, NFT mints, marketplace listings, and trade deal state changes, by storing event data in a queryable off-chain database.","title":"Cloud Functions: Sync Events Tasks"},{"location":"cloud-functions/tasks/sync-events/#overview","text":"Sync Events tasks enable: Event Ingestion : Reading events from blockchain nodes and writing them to Parse collections. Historical Sync : Backfilling events from past blocks. Real-time Processing : Monitoring new blocks for live event indexing. Data Consistency : Ensuring that the off-chain representation of events matches the on-chain source of truth. These functions are fundamental for any application feature that requires querying or displaying historical blockchain data or reacting to new on-chain actions.","title":"Overview"},{"location":"cloud-functions/tasks/sync-events/#key-functions","text":"","title":"Key Functions"},{"location":"cloud-functions/tasks/sync-events/#1-syncevent","text":"Synchronizes events of a specific type from a blockchain contract. Function Name : syncEvent Method : POST Parameters : contractAddress (String, required): The address of the smart contract emitting the events. eventName (String, required): The name of the event to synchronize (e.g., \"Transfer\", \"ItemListed\", \"TradeDealCreated\"). network (String, required): The blockchain network where the contract is deployed. abi (Object, required): The ABI of the contract, specifically containing the event definition. fromBlock (Number, optional): The starting block number for the synchronization. If omitted, it syncs from the last recorded block for this event or a predefined default. toBlock (Number, optional): The ending block number. If omitted, syncs up to the latest block. chunkSize (Number, optional): The number of blocks to process in each batch to avoid RPC timeouts or memory limits. Defaults to a reasonable value. reindex (Boolean, optional): If true , forces a full re-indexing of the event, deleting existing records before starting. Use with caution. queryFilters (Object, optional): An object containing indexed event parameters to filter events (e.g., { from: \"0xSenderAddress\" } ). Returns : eventsIndexed (Number): The total number of events indexed during the process. lastBlockProcessed (Number): The last block number successfully processed. Example Request : { \"functionName\" : \"syncEvent\" , \"parameters\" : { \"contractAddress\" : \"0xYourNFTContractAddress\" , \"eventName\" : \"Transfer\" , \"network\" : \"base-sepolia\" , \"abi\" : { \"anonymous\" : false , \"inputs\" : [ { \"indexed\" : true , \"internalType\" : \"address\" , \"name\" : \"from\" , \"type\" : \"address\" }, { \"indexed\" : true , \"internalType\" : \"address\" , \"name\" : \"to\" , \"type\" : \"address\" }, { \"indexed\" : false , \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" } ], \"name\" : \"Transfer\" , \"type\" : \"event\" }, \"fromBlock\" : 12345000 , \"queryFilters\" : { \"to\" : \"0xYourAddress\" } } } Example Response : { \"result\" : { \"eventsIndexed\" : 50 , \"lastBlockProcessed\" : 12345678 } } Workflow : Client application (backend service) calls syncEvent Cloud Function. Cloud Function connects to the specified blockchain network. Queries the contract for events within the given block range and filters. Processes each event, parses its data, and saves it to a designated Parse collection (e.g., BlockchainEvent ). Updates the last processed block to ensure continuity for the next sync.","title":"1. syncEvent"},{"location":"cloud-functions/tasks/sync-events/#2-syncallrelevantevents","text":"A higher-level function that triggers the synchronization of a predefined set of critical Gemforce events across various core contracts. Function Name : syncAllRelevantEvents Method : POST Parameters : network (String, required): The blockchain network to synchronize events from. fromBlock (Number, optional): Global starting block. toBlock (Number, optional): Global ending block. Returns : summary (Object with details of all synced events)","title":"2. syncAllRelevantEvents"},{"location":"cloud-functions/tasks/sync-events/#error-handling","text":"Sync Events tasks can encounter errors such as: RPC Node Issues : Connectivity problems, rate limits, or outmoded RPC nodes. Invalid ABI/Contract Address : The provided ABI does not match the contract, or the address is incorrect. Event Parsing Errors : Issues decoding event data due to ABI mismatch or corrupted logs. Database Write Errors : Problems saving processed events to Parse. Timeout : Long-running syncs exceeding Cloud Function execution limits, especially for large block ranges. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"cloud-functions/tasks/sync-events/#security-considerations","text":"Access Control : These functions often require privileged access ( Master Key ) if they perform large-scale data writes to the Parse database. This access should be strictly controlled. Data Integrity : Implement robust validation on ingested event data to prevent corruption or malicious injection into the off-chain database. Resource Management : Be mindful of the computational and network resources consumed by large-scale event synchronization. Implement rate limiting and smart chunking. RPC Endpoint Security : Ensure that the RPC endpoints used for fetching events are secure and trusted.","title":"Security Considerations"},{"location":"cloud-functions/tasks/sync-events/#related-documentation","text":"Smart Contracts: Overview Integrator's Guide: Integration Patterns (specifically event-driven architecture) Parse Server Cloud Code Guide (External)","title":"Related Documentation"},{"location":"cloud-functions/tasks/trade-deal/","text":"Cloud Functions: Trade Deal Tasks \u00b6 This document details the cloud functions designed for managing TradeDeal smart contracts within the Gemforce platform. These functions provide an abstracted API for creating, managing, and resolving collateralized finance instruments, streamlining the trade deal lifecycle for users and applications. Overview \u00b6 Trade Deal tasks enable: Creation : Initiating new trade deals with specified terms and collateral. Execution/Resolution : Progressing the trade deal through its stages, including releasing collateral. Default/Dispute : Managing scenarios where a trade deal defaults or enters a dispute state. Querying : Retrieving detailed information about ongoing and historical trade deals. These functions are critical for applications that facilitate decentralized finance agreements and asset-backed transactions on the Gemforce platform. Key Functions \u00b6 1. createTradeDeal \u00b6 Create a new trade deal with specified terms. Function Name : createTradeDeal Method : POST Parameters : principalAmount (String, required): The principal amount of the trade deal (as string to handle large numbers). collateralAmount (String, required): The amount of collateral required. principalTokenAddress (String, required): Address of the ERC20 token for the principal. collateralTokenAddress (String, required): Address of the ERC20 token for the collateral. borrowerAddress (String, required): The address of the borrower. lenderAddress (String, required): The address of the lender. maturityDate (Number, required): Unix timestamp for the deal's maturity. interestRate (Number, optional): Annual interest rate (in basis points, e.g., 500 = 5%). collateralRatio (Number, optional): The collateralization ratio (in percentage, e.g., 150 = 150%). network (String, required): The blockchain network where the trade deal will be created. Returns : tradeDealId (String): A unique identifier (bytes32 hex string) for the new trade deal. transactionHash (String): The transaction hash of the deal creation. Example Request : { \"functionName\" : \"createTradeDeal\" , \"parameters\" : { \"principalAmount\" : \"100000000000000000000\" , // 100 principal tokens \"collateralAmount\" : \"150000000000000000000\" , // 150 collateral tokens \"principalTokenAddress\" : \"0xPrincipalTokenAddress\" , \"collateralTokenAddress\" : \"0xCollateralTokenAddress\" , \"borrowerAddress\" : \"0xBorrowerWalletAddress\" , \"lenderAddress\" : \"0xLenderWalletAddress\" , \"maturityDate\" : 1735689600 , // Jan 1, 2025, 00:00:00 GMT \"interestRate\" : 750 , // 7.5% \"network\" : \"optimism-sepolia\" } } Example Response : { \"result\" : { \"tradeDealId\" : \"0xabc...efg\" , \"transactionHash\" : \"0xhij...klm\" } } Workflow : Client application calls createTradeDeal Cloud Function. Cloud Function validates parameters. Calls the create function on the TradeDealManagementFacet (or analogous contract) of the Diamond. Returns the tradeDealId and transaction details. 2. fundTradeDeal \u00b6 Lender funds a newly created trade deal by depositing the principal amount. Function Name : fundTradeDeal Method : POST Parameters : tradeDealId (String, required): The ID of the trade deal to fund. network (String, required): The blockchain network. Returns : transactionHash (String) 3. depositCollateral \u00b6 Borrower deposits the required collateral for a trade deal. Function Name : depositCollateral Method : POST Parameters : tradeDealId (String, required): The ID of the trade deal. network (String, required): The blockchain network. Returns : transactionHash (String) 4. resolveTradeDeal \u00b6 Resolves a trade deal, allowing the lender to claim principal + interest and releasing collateral to the borrower (if repaid). Function Name : resolveTradeDeal Method : POST Parameters : tradeDealId (String, required): The ID of the trade deal to resolve. network (String, required): The blockchain network. Returns : transactionHash (String) 5. triggerDefault \u00b6 Triggers a default on a trade deal, allowing the lender to claim collateral. Function Name : triggerDefault Method : POST Parameters : tradeDealId (String, required): The ID of the trade deal to default. network (String, required): The blockchain network. Returns : transactionHash (String) Error Handling \u00b6 Trade Deal tasks can encounter various errors, including: Invalid Parameters : Missing fields, incorrect token addresses. Blockchain Transaction Errors : Transaction reverts (e.g., deal not found, insufficient funds, collateral not approved). State Transitions : Attempting to fund an already funded deal, or resolve a defaulted deal. Authorization : Caller not authorized to perform the action (e.g., only lender can fund). Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Collateral Management : Ensure the collateral is securely held and released only under correct conditions. Token Approvals : The borrower and lender must explicitly approve the TradeDeal contract (or a TradeDeal facet) to transfer their tokens before depositCollateral or fundTradeDeal can succeed. Your application should guide users through this step. Interest Calculation : Verify the accuracy of interest rate calculations on-chain. Oracle Dependency : If trade deals depend on external price feeds (e.g., for liquidation), ensure the oracle is secure and reliable. Access Control : Strictly enforce roles (borrower, lender) for each action within the cloud functions. Related Documentation \u00b6 Smart Contracts: Trade Deal Management Facet Smart Contracts: ITradeDeal Interface Smart Contracts: Trade Deal Operations Facet EIP: Collateralized Trade Deal Standard Integrator's Guide: Authentication","title":"Trade Deal Tasks"},{"location":"cloud-functions/tasks/trade-deal/#cloud-functions-trade-deal-tasks","text":"This document details the cloud functions designed for managing TradeDeal smart contracts within the Gemforce platform. These functions provide an abstracted API for creating, managing, and resolving collateralized finance instruments, streamlining the trade deal lifecycle for users and applications.","title":"Cloud Functions: Trade Deal Tasks"},{"location":"cloud-functions/tasks/trade-deal/#overview","text":"Trade Deal tasks enable: Creation : Initiating new trade deals with specified terms and collateral. Execution/Resolution : Progressing the trade deal through its stages, including releasing collateral. Default/Dispute : Managing scenarios where a trade deal defaults or enters a dispute state. Querying : Retrieving detailed information about ongoing and historical trade deals. These functions are critical for applications that facilitate decentralized finance agreements and asset-backed transactions on the Gemforce platform.","title":"Overview"},{"location":"cloud-functions/tasks/trade-deal/#key-functions","text":"","title":"Key Functions"},{"location":"cloud-functions/tasks/trade-deal/#1-createtradedeal","text":"Create a new trade deal with specified terms. Function Name : createTradeDeal Method : POST Parameters : principalAmount (String, required): The principal amount of the trade deal (as string to handle large numbers). collateralAmount (String, required): The amount of collateral required. principalTokenAddress (String, required): Address of the ERC20 token for the principal. collateralTokenAddress (String, required): Address of the ERC20 token for the collateral. borrowerAddress (String, required): The address of the borrower. lenderAddress (String, required): The address of the lender. maturityDate (Number, required): Unix timestamp for the deal's maturity. interestRate (Number, optional): Annual interest rate (in basis points, e.g., 500 = 5%). collateralRatio (Number, optional): The collateralization ratio (in percentage, e.g., 150 = 150%). network (String, required): The blockchain network where the trade deal will be created. Returns : tradeDealId (String): A unique identifier (bytes32 hex string) for the new trade deal. transactionHash (String): The transaction hash of the deal creation. Example Request : { \"functionName\" : \"createTradeDeal\" , \"parameters\" : { \"principalAmount\" : \"100000000000000000000\" , // 100 principal tokens \"collateralAmount\" : \"150000000000000000000\" , // 150 collateral tokens \"principalTokenAddress\" : \"0xPrincipalTokenAddress\" , \"collateralTokenAddress\" : \"0xCollateralTokenAddress\" , \"borrowerAddress\" : \"0xBorrowerWalletAddress\" , \"lenderAddress\" : \"0xLenderWalletAddress\" , \"maturityDate\" : 1735689600 , // Jan 1, 2025, 00:00:00 GMT \"interestRate\" : 750 , // 7.5% \"network\" : \"optimism-sepolia\" } } Example Response : { \"result\" : { \"tradeDealId\" : \"0xabc...efg\" , \"transactionHash\" : \"0xhij...klm\" } } Workflow : Client application calls createTradeDeal Cloud Function. Cloud Function validates parameters. Calls the create function on the TradeDealManagementFacet (or analogous contract) of the Diamond. Returns the tradeDealId and transaction details.","title":"1. createTradeDeal"},{"location":"cloud-functions/tasks/trade-deal/#2-fundtradedeal","text":"Lender funds a newly created trade deal by depositing the principal amount. Function Name : fundTradeDeal Method : POST Parameters : tradeDealId (String, required): The ID of the trade deal to fund. network (String, required): The blockchain network. Returns : transactionHash (String)","title":"2. fundTradeDeal"},{"location":"cloud-functions/tasks/trade-deal/#3-depositcollateral","text":"Borrower deposits the required collateral for a trade deal. Function Name : depositCollateral Method : POST Parameters : tradeDealId (String, required): The ID of the trade deal. network (String, required): The blockchain network. Returns : transactionHash (String)","title":"3. depositCollateral"},{"location":"cloud-functions/tasks/trade-deal/#4-resolvetradedeal","text":"Resolves a trade deal, allowing the lender to claim principal + interest and releasing collateral to the borrower (if repaid). Function Name : resolveTradeDeal Method : POST Parameters : tradeDealId (String, required): The ID of the trade deal to resolve. network (String, required): The blockchain network. Returns : transactionHash (String)","title":"4. resolveTradeDeal"},{"location":"cloud-functions/tasks/trade-deal/#5-triggerdefault","text":"Triggers a default on a trade deal, allowing the lender to claim collateral. Function Name : triggerDefault Method : POST Parameters : tradeDealId (String, required): The ID of the trade deal to default. network (String, required): The blockchain network. Returns : transactionHash (String)","title":"5. triggerDefault"},{"location":"cloud-functions/tasks/trade-deal/#error-handling","text":"Trade Deal tasks can encounter various errors, including: Invalid Parameters : Missing fields, incorrect token addresses. Blockchain Transaction Errors : Transaction reverts (e.g., deal not found, insufficient funds, collateral not approved). State Transitions : Attempting to fund an already funded deal, or resolve a defaulted deal. Authorization : Caller not authorized to perform the action (e.g., only lender can fund). Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"cloud-functions/tasks/trade-deal/#security-considerations","text":"Collateral Management : Ensure the collateral is securely held and released only under correct conditions. Token Approvals : The borrower and lender must explicitly approve the TradeDeal contract (or a TradeDeal facet) to transfer their tokens before depositCollateral or fundTradeDeal can succeed. Your application should guide users through this step. Interest Calculation : Verify the accuracy of interest rate calculations on-chain. Oracle Dependency : If trade deals depend on external price feeds (e.g., for liquidation), ensure the oracle is secure and reliable. Access Control : Strictly enforce roles (borrower, lender) for each action within the cloud functions.","title":"Security Considerations"},{"location":"cloud-functions/tasks/trade-deal/#related-documentation","text":"Smart Contracts: Trade Deal Management Facet Smart Contracts: ITradeDeal Interface Smart Contracts: Trade Deal Operations Facet EIP: Collateralized Trade Deal Standard Integrator's Guide: Authentication","title":"Related Documentation"},{"location":"eips/","text":"Gemforce EIPs (Ethereum Improvement Proposals) \u00b6 Welcome to the comprehensive collection of Ethereum Improvement Proposals developed by the Gemforce team. These EIPs represent innovative blockchain standards and patterns extracted from real-world smart contract implementations. Overview \u00b6 The Gemforce EIP suite consists of six interconnected standards that work together to create a comprehensive blockchain ecosystem for digital identity, asset management, and environmental sustainability. EIP Collection \u00b6 \ud83c\udfea Diamond-Enhanced NFT Marketplace \u00b6 Status : Draft | Category : Standards Track - ERC A standardized interface for NFT marketplaces built on the Diamond Standard (EIP-2535) with advanced features: Configurable Fee Distribution : Parts-per-million precision for multiple fee receivers Multi-Payment Support : Both ETH and ERC20 token payments Identity Verification : Integration with ERC734/ERC735 for buyer verification Security Features : Price protection and reentrancy protection Modularity : Diamond Standard enables upgradeable marketplace functionality \ud83d\udcb0 Multi-Token Sale Standard \u00b6 Status : Draft | Category : Standards Track - ERC A comprehensive standard for token sales supporting multiple token types and advanced purchase mechanisms: Universal Token Support : ERC20, ERC721, and ERC1155 tokens Cryptographic Proofs : Merkle proof-based allowlist purchases Flexible Payments : ETH and ERC20 payments with automatic refunds Purchase Controls : Per-account limits and quantity tracking Batch Operations : Efficient multi-token operations \ud83e\udd1d Collateralized Trade Deal Standard \u00b6 Status : Draft | Category : Standards Track - ERC A standardized interface for creating and managing collateralized trade deals for invoice financing: Invoice NFTs : Tokenized invoices as collateral Multi-Party Funding : Proportional token distribution Automated Interest : Calculation and distribution systems Identity Controls : Claim-based participation requirements Flexible Operations : Multiple financing scenario modes \ud83c\udd94 Enhanced Identity System \u00b6 Status : Draft | Category : Standards Track - ERC An enhanced identity standard extending ERC734/ERC735 with enterprise-grade features: Trusted Issuer Registry : Centralized claim topic authorization Attribute Management : Typed attributes with verification status Smart Contract Integration : Automated verification for dApps Access Control : Claim topic-based permissions Compliance Features : Verification status tracking \ud83c\udfed Diamond Factory Standard \u00b6 Status : Draft | Category : Standards Track - ERC A standardized factory pattern for deploying and managing Diamond Standard contracts: Template Deployment : Predefined Diamond configurations Configurable Facets : Flexible facet set management Security Features : Upgrade timelock initialization Event Tracking : Deployment verification and monitoring Tooling Integration : Compatible with existing Diamond infrastructure \ud83c\udf31 Carbon Credit Standard \u00b6 Status : Draft | Category : Standards Track - ERC A comprehensive standard for tokenizing and trading environmental assets: Asset Tokenization : NFTs or fungible tokens for carbon credits Lifecycle Tracking : From issuance to retirement Registry Integration : Compatible with VCS, CDM, Gold Standard Automated Retirement : Smart contract-based offset mechanisms Fractional Trading : Divisible environmental assets Ecosystem Integration \u00b6 These EIPs are designed as an interconnected ecosystem: graph TD A[Diamond Factory] --> B[Enhanced Identity] A --> C[Diamond Marketplace] A --> D[Multi-Token Sale] A --> E[Trade Deals] A --> F[Carbon Credits] B --> C B --> D B --> E C --> F D --> F E --> C style A fill:#e1f5fe style B fill:#f3e5f5 style C fill:#e8f5e8 style D fill:#fff3e0 style E fill:#fce4ec style F fill:#e0f2f1 Integration Patterns \u00b6 Foundation Layer : Diamond Factory enables deployment of all other standards Identity Layer : Enhanced Identity System provides access control across all systems Asset Layer : Multi-Token Sale enables distribution of tokens used in other systems Trading Layer : Marketplace facilitates trading of all tokenized assets Finance Layer : Trade Deals enable sophisticated financial products Environmental Layer : Carbon Credits enable sustainability features Implementation Status \u00b6 All EIPs include: \u2705 Complete interface specifications \u2705 Detailed rationale and motivation \u2705 Implementation examples and patterns \u2705 Security considerations \u2705 Reference to actual smart contract implementations \u2705 Test case requirements \u2705 Backwards compatibility analysis Standards Compliance \u00b6 These EIPs build upon and extend existing Ethereum standards: Standard Purpose Integration EIP-2535 Diamond Standard Foundation for all upgradeable contracts EIP-721 Non-Fungible Tokens NFT marketplace and carbon credits EIP-20 Token Standard Payment tokens and fungible assets EIP-1155 Multi Token Standard Hybrid token implementations ERC-734 Key Manager Identity system foundation ERC-735 Claim Holder Identity verification EIP-165 Interface Detection Standard interface support Getting Started \u00b6 For Developers \u00b6 Start with the Diamond Factory Standard to understand deployment patterns Implement Enhanced Identity System for access control Choose specific standards based on your use case: NFT Trading : Diamond-Enhanced Marketplace Token Sales : Multi-Token Sale Standard Financial Products : Collateralized Trade Deal Standard Environmental Assets : Carbon Credit Standard For Integrators \u00b6 Review the README for a comprehensive overview Examine the interface specifications in each EIP Check security considerations and implementation notes Review test case requirements for compliance Community & Contribution \u00b6 These EIPs represent innovative patterns extracted from production smart contract implementations. We welcome community feedback and contributions to refine these standards before formal submission to the Ethereum community. Next Steps \u00b6 Community Review : Gathering feedback from the Ethereum community Reference Implementations : Completing and auditing reference implementations Test Suites : Developing comprehensive test suites Documentation : Creating developer guides and integration examples Formal Submission : Following the official EIP process Last updated: June 26, 2025","title":"Overview"},{"location":"eips/#gemforce-eips-ethereum-improvement-proposals","text":"Welcome to the comprehensive collection of Ethereum Improvement Proposals developed by the Gemforce team. These EIPs represent innovative blockchain standards and patterns extracted from real-world smart contract implementations.","title":"Gemforce EIPs (Ethereum Improvement Proposals)"},{"location":"eips/#overview","text":"The Gemforce EIP suite consists of six interconnected standards that work together to create a comprehensive blockchain ecosystem for digital identity, asset management, and environmental sustainability.","title":"Overview"},{"location":"eips/#eip-collection","text":"","title":"EIP Collection"},{"location":"eips/#diamond-enhanced-nft-marketplace","text":"Status : Draft | Category : Standards Track - ERC A standardized interface for NFT marketplaces built on the Diamond Standard (EIP-2535) with advanced features: Configurable Fee Distribution : Parts-per-million precision for multiple fee receivers Multi-Payment Support : Both ETH and ERC20 token payments Identity Verification : Integration with ERC734/ERC735 for buyer verification Security Features : Price protection and reentrancy protection Modularity : Diamond Standard enables upgradeable marketplace functionality","title":"\ud83c\udfea Diamond-Enhanced NFT Marketplace"},{"location":"eips/#multi-token-sale-standard","text":"Status : Draft | Category : Standards Track - ERC A comprehensive standard for token sales supporting multiple token types and advanced purchase mechanisms: Universal Token Support : ERC20, ERC721, and ERC1155 tokens Cryptographic Proofs : Merkle proof-based allowlist purchases Flexible Payments : ETH and ERC20 payments with automatic refunds Purchase Controls : Per-account limits and quantity tracking Batch Operations : Efficient multi-token operations","title":"\ud83d\udcb0 Multi-Token Sale Standard"},{"location":"eips/#collateralized-trade-deal-standard","text":"Status : Draft | Category : Standards Track - ERC A standardized interface for creating and managing collateralized trade deals for invoice financing: Invoice NFTs : Tokenized invoices as collateral Multi-Party Funding : Proportional token distribution Automated Interest : Calculation and distribution systems Identity Controls : Claim-based participation requirements Flexible Operations : Multiple financing scenario modes","title":"\ud83e\udd1d Collateralized Trade Deal Standard"},{"location":"eips/#enhanced-identity-system","text":"Status : Draft | Category : Standards Track - ERC An enhanced identity standard extending ERC734/ERC735 with enterprise-grade features: Trusted Issuer Registry : Centralized claim topic authorization Attribute Management : Typed attributes with verification status Smart Contract Integration : Automated verification for dApps Access Control : Claim topic-based permissions Compliance Features : Verification status tracking","title":"\ud83c\udd94 Enhanced Identity System"},{"location":"eips/#diamond-factory-standard","text":"Status : Draft | Category : Standards Track - ERC A standardized factory pattern for deploying and managing Diamond Standard contracts: Template Deployment : Predefined Diamond configurations Configurable Facets : Flexible facet set management Security Features : Upgrade timelock initialization Event Tracking : Deployment verification and monitoring Tooling Integration : Compatible with existing Diamond infrastructure","title":"\ud83c\udfed Diamond Factory Standard"},{"location":"eips/#carbon-credit-standard","text":"Status : Draft | Category : Standards Track - ERC A comprehensive standard for tokenizing and trading environmental assets: Asset Tokenization : NFTs or fungible tokens for carbon credits Lifecycle Tracking : From issuance to retirement Registry Integration : Compatible with VCS, CDM, Gold Standard Automated Retirement : Smart contract-based offset mechanisms Fractional Trading : Divisible environmental assets","title":"\ud83c\udf31 Carbon Credit Standard"},{"location":"eips/#ecosystem-integration","text":"These EIPs are designed as an interconnected ecosystem: graph TD A[Diamond Factory] --> B[Enhanced Identity] A --> C[Diamond Marketplace] A --> D[Multi-Token Sale] A --> E[Trade Deals] A --> F[Carbon Credits] B --> C B --> D B --> E C --> F D --> F E --> C style A fill:#e1f5fe style B fill:#f3e5f5 style C fill:#e8f5e8 style D fill:#fff3e0 style E fill:#fce4ec style F fill:#e0f2f1","title":"Ecosystem Integration"},{"location":"eips/#integration-patterns","text":"Foundation Layer : Diamond Factory enables deployment of all other standards Identity Layer : Enhanced Identity System provides access control across all systems Asset Layer : Multi-Token Sale enables distribution of tokens used in other systems Trading Layer : Marketplace facilitates trading of all tokenized assets Finance Layer : Trade Deals enable sophisticated financial products Environmental Layer : Carbon Credits enable sustainability features","title":"Integration Patterns"},{"location":"eips/#implementation-status","text":"All EIPs include: \u2705 Complete interface specifications \u2705 Detailed rationale and motivation \u2705 Implementation examples and patterns \u2705 Security considerations \u2705 Reference to actual smart contract implementations \u2705 Test case requirements \u2705 Backwards compatibility analysis","title":"Implementation Status"},{"location":"eips/#standards-compliance","text":"These EIPs build upon and extend existing Ethereum standards: Standard Purpose Integration EIP-2535 Diamond Standard Foundation for all upgradeable contracts EIP-721 Non-Fungible Tokens NFT marketplace and carbon credits EIP-20 Token Standard Payment tokens and fungible assets EIP-1155 Multi Token Standard Hybrid token implementations ERC-734 Key Manager Identity system foundation ERC-735 Claim Holder Identity verification EIP-165 Interface Detection Standard interface support","title":"Standards Compliance"},{"location":"eips/#getting-started","text":"","title":"Getting Started"},{"location":"eips/#for-developers","text":"Start with the Diamond Factory Standard to understand deployment patterns Implement Enhanced Identity System for access control Choose specific standards based on your use case: NFT Trading : Diamond-Enhanced Marketplace Token Sales : Multi-Token Sale Standard Financial Products : Collateralized Trade Deal Standard Environmental Assets : Carbon Credit Standard","title":"For Developers"},{"location":"eips/#for-integrators","text":"Review the README for a comprehensive overview Examine the interface specifications in each EIP Check security considerations and implementation notes Review test case requirements for compliance","title":"For Integrators"},{"location":"eips/#community-contribution","text":"These EIPs represent innovative patterns extracted from production smart contract implementations. We welcome community feedback and contributions to refine these standards before formal submission to the Ethereum community.","title":"Community &amp; Contribution"},{"location":"eips/#next-steps","text":"Community Review : Gathering feedback from the Ethereum community Reference Implementations : Completing and auditing reference implementations Test Suites : Developing comprehensive test suites Documentation : Creating developer guides and integration examples Formal Submission : Following the official EIP process Last updated: June 26, 2025","title":"Next Steps"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/","text":"EIP-DRAFT: Carbon Credit Standard for Tokenized Environmental Assets \u00b6 Simple Summary \u00b6 A standardized interface for tokenizing, trading, and retiring carbon credits and other environmental assets on the Ethereum blockchain with full lifecycle tracking and verification. Abstract \u00b6 This EIP proposes a comprehensive standard for carbon credits that enables: - Tokenization of verified carbon credits as NFTs or fungible tokens - Lifecycle tracking from issuance to retirement - Integration with carbon registries and verification bodies - Automated retirement and offset mechanisms - Fractional ownership and trading capabilities - Compliance with international carbon credit standards Motivation \u00b6 The carbon credit market lacks standardization and transparency, making it difficult to verify the authenticity and prevent double-counting of credits. A blockchain-based standard can provide immutable tracking, automated verification, and seamless integration with DeFi protocols while maintaining compliance with existing carbon credit frameworks. Specification \u00b6 Core Interface \u00b6 interface ICarbonCredit { enum CreditStatus { ISSUED , ACTIVE , RETIRED , CANCELLED } enum CreditType { REMOVAL , AVOIDANCE , REDUCTION } enum Standard { VCS , CDM , GOLD_STANDARD , CAR , ACR , CUSTOM } struct CarbonCreditData { uint256 creditId ; string projectId ; Standard standard ; CreditType creditType ; uint256 vintage ; // Year of carbon impact uint256 quantity ; // Tonnes of CO2 equivalent string methodology ; string verifier ; string registry ; uint256 issuanceDate ; CreditStatus status ; address currentOwner ; string metadata ; // IPFS hash or URI } struct RetirementData { uint256 creditId ; uint256 quantity ; address retiringEntity ; string beneficiary ; string retirementReason ; uint256 retirementDate ; string retirementCertificate ; // IPFS hash } // Events event CarbonCreditIssued ( uint256 indexed creditId , string projectId , Standard standard , uint256 quantity , uint256 vintage ); event CarbonCreditTransferred ( uint256 indexed creditId , address indexed from , address indexed to , uint256 quantity ); event CarbonCreditRetired ( uint256 indexed creditId , address indexed retiringEntity , uint256 quantity , string beneficiary ); event CarbonCreditCancelled ( uint256 indexed creditId , uint256 quantity , string reason ); event CarbonCreditFractionalized ( uint256 indexed creditId , address indexed fractionalToken , uint256 totalShares ); event OffsetClaimed ( address indexed entity , uint256 totalQuantity , uint256 [] creditIds , string offsetClaim ); // Core Functions function issueCarbonCredit ( CarbonCreditData memory creditData ) external returns ( uint256 creditId ); function transferCredit ( uint256 creditId , address to , uint256 quantity ) external ; function retireCredit ( uint256 creditId , uint256 quantity , string memory beneficiary , string memory reason ) external returns ( bytes32 retirementId ); function cancelCredit ( uint256 creditId , uint256 quantity , string memory reason ) external ; // Fractionalization function fractionalizeCarbonCredit ( uint256 creditId , uint256 totalShares , string memory tokenName , string memory tokenSymbol ) external returns ( address fractionalToken ); function redeemFractionalShares ( address fractionalToken , uint256 shares ) external ; // Offset Claims function claimOffset ( uint256 [] memory creditIds , uint256 [] memory quantities , string memory offsetClaim ) external ; function getOffsetHistory ( address entity ) external view returns ( RetirementData [] memory ); // View Functions function getCarbonCreditData ( uint256 creditId ) external view returns ( CarbonCreditData memory ); function getRetirementData ( bytes32 retirementId ) external view returns ( RetirementData memory ); function getCreditsByOwner ( address owner ) external view returns ( uint256 [] memory ); function getCreditsByProject ( string memory projectId ) external view returns ( uint256 [] memory ); function getCreditsByVintage ( uint256 vintage ) external view returns ( uint256 [] memory ); function getTotalSupply () external view returns ( uint256 ); function getTotalRetired () external view returns ( uint256 ); function getAvailableCredits () external view returns ( uint256 ); // Verification function verifyCreditAuthenticity ( uint256 creditId ) external view returns ( bool isValid , string memory verificationDetails ); function checkDoubleSpending ( uint256 creditId ) external view returns ( bool hasDoubleSpending ); } interface ICarbonCreditRegistry { struct ProjectData { string projectId ; string name ; string description ; string location ; string methodology ; address projectDeveloper ; Standard standard ; CreditType creditType ; uint256 estimatedCredits ; uint256 issuedCredits ; bool active ; string verificationBody ; string registryUrl ; } // Events event ProjectRegistered ( string indexed projectId , address indexed developer , Standard standard ); event ProjectUpdated ( string indexed projectId , bool active ); event VerificationBodyAdded ( address indexed verifier , string name ); // Core Functions function registerProject ( ProjectData memory projectData ) external ; function updateProject ( string memory projectId , ProjectData memory projectData ) external ; function addVerificationBody ( address verifier , string memory name , Standard [] memory authorizedStandards ) external ; function isAuthorizedVerifier ( address verifier , Standard standard ) external view returns ( bool ); function getProjectData ( string memory projectId ) external view returns ( ProjectData memory ); function getAllProjects () external view returns ( string [] memory ); } Key Features \u00b6 1. Comprehensive Credit Tracking \u00b6 Full Lifecycle : Track credits from issuance through retirement Immutable Records : Blockchain-based immutable tracking Status Management : Clear status transitions and validation Metadata Integration : IPFS integration for detailed documentation 2. Multiple Credit Standards \u00b6 Standard Compliance : Support for VCS, CDM, Gold Standard, and others Flexible Framework : Extensible to new standards and methodologies Verification Integration : Integration with recognized verification bodies 3. Fractionalization Support \u00b6 Fractional Ownership : Enable fractional ownership of large credits ERC20 Integration : Create fungible tokens for fractional shares Redemption Mechanism : Convert fractional shares back to whole credits 4. Automated Offset Claims \u00b6 Batch Retirement : Retire multiple credits in single transaction Offset Tracking : Track offset claims and retirement history Certificate Generation : Generate retirement certificates Credit Lifecycle \u00b6 // 1. Register Project ProjectData memory project = ProjectData ({ projectId : \"PROJ-001\" , name : \"Reforestation Project\" , methodology : \"VM0006\" , // ... other fields }); registry . registerProject ( project ); // 2. Issue Credits CarbonCreditData memory credit = CarbonCreditData ({ projectId : \"PROJ-001\" , standard : Standard . VCS , creditType : CreditType . REMOVAL , vintage : 2024 , quantity : 1000 , // ... other fields }); uint256 creditId = carbonCredit . issueCarbonCredit ( credit ); // 3. Transfer Credits carbonCredit . transferCredit ( creditId , buyer , 500 ); // 4. Retire Credits for Offset bytes32 retirementId = carbonCredit . retireCredit ( creditId , 250 , \"Company XYZ\" , \"Annual carbon neutrality\" ); // 5. Claim Offset uint256 [] memory creditIds = new uint256 []( 1 ); creditIds [ 0 ] = creditId ; uint256 [] memory quantities = new uint256 []( 1 ); quantities [ 0 ] = 250 ; carbonCredit . claimOffset ( creditIds , quantities , \"2024 Carbon Neutrality Claim\" ); Rationale \u00b6 NFT vs Fungible Token Approach \u00b6 The standard supports both approaches: - NFT Approach : Each credit batch is unique with specific vintage, project, and verification data - Fungible Approach : Credits with identical characteristics can be fungible - Hybrid Approach : NFTs can be fractionalized into fungible tokens Immutable Retirement \u00b6 Once credits are retired, they cannot be transferred or used again, preventing double-counting and ensuring offset integrity. Registry Integration \u00b6 Integration with existing carbon registries ensures compliance with established standards and verification processes. Metadata Standards \u00b6 Using IPFS for metadata storage ensures decentralized, permanent storage of verification documents and project details. Implementation Details \u00b6 Credit Issuance \u00b6 function issueCarbonCredit ( CarbonCreditData memory creditData ) external returns ( uint256 creditId ) { require ( isAuthorizedIssuer ( msg.sender ), \"Unauthorized issuer\" ); require ( registry . getProjectData ( creditData . projectId ). active , \"Project not active\" ); creditId = nextCreditId ++ ; creditData . creditId = creditId ; creditData . status = CreditStatus . ACTIVE ; creditData . currentOwner = msg.sender ; creditData . issuanceDate = block.timestamp ; credits [ creditId ] = creditData ; ownerCredits [ msg.sender ]. push ( creditId ); emit CarbonCreditIssued ( creditId , creditData . projectId , creditData . standard , creditData . quantity , creditData . vintage ); } Credit Retirement \u00b6 function retireCredit ( uint256 creditId , uint256 quantity , string memory beneficiary , string memory reason ) external returns ( bytes32 retirementId ) { CarbonCreditData storage credit = credits [ creditId ]; require ( credit . currentOwner == msg.sender , \"Not credit owner\" ); require ( credit . status == CreditStatus . ACTIVE , \"Credit not active\" ); require ( quantity <= credit . quantity , \"Insufficient quantity\" ); retirementId = keccak256 ( abi . encodePacked ( creditId , quantity , block.timestamp , msg.sender )); RetirementData memory retirement = RetirementData ({ creditId : creditId , quantity : quantity , retiringEntity : msg.sender , beneficiary : beneficiary , retirementReason : reason , retirementDate : block.timestamp , retirementCertificate : \"\" // Generated off-chain }); retirements [ retirementId ] = retirement ; credit . quantity -= quantity ; if ( credit . quantity == 0 ) { credit . status = CreditStatus . RETIRED ; } emit CarbonCreditRetired ( creditId , msg.sender , quantity , beneficiary ); } Security Considerations \u00b6 Authorization : Proper authorization for credit issuance and management Double-Spending Prevention : Mechanisms to prevent double-counting of credits Verification : Integration with trusted verification bodies Immutable Retirement : Ensure retired credits cannot be reused Registry Validation : Validate project registration and status Compliance Considerations \u00b6 International Standards : Compliance with VCS, CDM, and other standards Regulatory Requirements : Consideration of emerging regulations Audit Trails : Complete audit trails for compliance reporting Verification Requirements : Integration with recognized verification bodies Integration Examples \u00b6 With DeFi Protocols \u00b6 contract CarbonOffsetDeFi { ICarbonCredit public carbonCredit ; function offsetTransaction ( uint256 creditId , uint256 quantity ) external { // Retire credits to offset transaction carbonCredit . retireCredit ( creditId , quantity , \"DeFi Transaction Offset\" , \"Automated offset\" ); } } With Corporate Sustainability \u00b6 contract CorporateOffsetManager { ICarbonCredit public carbonCredit ; mapping ( address => uint256 ) public annualOffsets ; function executeAnnualOffset ( uint256 [] memory creditIds , uint256 [] memory quantities ) external { uint256 totalOffset = 0 ; for ( uint256 i = 0 ; i < quantities . length ; i ++ ) { totalOffset += quantities [ i ]; } carbonCredit . claimOffset ( creditIds , quantities , \"Annual Carbon Neutrality\" ); annualOffsets [ msg.sender ] += totalOffset ; } } Test Cases \u00b6 Comprehensive test cases should cover: - Credit issuance and lifecycle management - Transfer and ownership tracking - Retirement and offset claiming - Fractionalization and redemption - Registry integration - Verification and compliance - Edge cases and error conditions Reference Implementation \u00b6 The reference implementation includes: - CarbonCreditFacet.sol - Core carbon credit functionality - ICarbonCredit.sol - Interface definition - CarbonCreditLib.sol - Supporting library functions Copyright \u00b6 Copyright and related rights waived via CC0 .","title":"Carbon Credit Standard"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#eip-draft-carbon-credit-standard-for-tokenized-environmental-assets","text":"","title":"EIP-DRAFT: Carbon Credit Standard for Tokenized Environmental Assets"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#simple-summary","text":"A standardized interface for tokenizing, trading, and retiring carbon credits and other environmental assets on the Ethereum blockchain with full lifecycle tracking and verification.","title":"Simple Summary"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#abstract","text":"This EIP proposes a comprehensive standard for carbon credits that enables: - Tokenization of verified carbon credits as NFTs or fungible tokens - Lifecycle tracking from issuance to retirement - Integration with carbon registries and verification bodies - Automated retirement and offset mechanisms - Fractional ownership and trading capabilities - Compliance with international carbon credit standards","title":"Abstract"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#motivation","text":"The carbon credit market lacks standardization and transparency, making it difficult to verify the authenticity and prevent double-counting of credits. A blockchain-based standard can provide immutable tracking, automated verification, and seamless integration with DeFi protocols while maintaining compliance with existing carbon credit frameworks.","title":"Motivation"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#specification","text":"","title":"Specification"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#core-interface","text":"interface ICarbonCredit { enum CreditStatus { ISSUED , ACTIVE , RETIRED , CANCELLED } enum CreditType { REMOVAL , AVOIDANCE , REDUCTION } enum Standard { VCS , CDM , GOLD_STANDARD , CAR , ACR , CUSTOM } struct CarbonCreditData { uint256 creditId ; string projectId ; Standard standard ; CreditType creditType ; uint256 vintage ; // Year of carbon impact uint256 quantity ; // Tonnes of CO2 equivalent string methodology ; string verifier ; string registry ; uint256 issuanceDate ; CreditStatus status ; address currentOwner ; string metadata ; // IPFS hash or URI } struct RetirementData { uint256 creditId ; uint256 quantity ; address retiringEntity ; string beneficiary ; string retirementReason ; uint256 retirementDate ; string retirementCertificate ; // IPFS hash } // Events event CarbonCreditIssued ( uint256 indexed creditId , string projectId , Standard standard , uint256 quantity , uint256 vintage ); event CarbonCreditTransferred ( uint256 indexed creditId , address indexed from , address indexed to , uint256 quantity ); event CarbonCreditRetired ( uint256 indexed creditId , address indexed retiringEntity , uint256 quantity , string beneficiary ); event CarbonCreditCancelled ( uint256 indexed creditId , uint256 quantity , string reason ); event CarbonCreditFractionalized ( uint256 indexed creditId , address indexed fractionalToken , uint256 totalShares ); event OffsetClaimed ( address indexed entity , uint256 totalQuantity , uint256 [] creditIds , string offsetClaim ); // Core Functions function issueCarbonCredit ( CarbonCreditData memory creditData ) external returns ( uint256 creditId ); function transferCredit ( uint256 creditId , address to , uint256 quantity ) external ; function retireCredit ( uint256 creditId , uint256 quantity , string memory beneficiary , string memory reason ) external returns ( bytes32 retirementId ); function cancelCredit ( uint256 creditId , uint256 quantity , string memory reason ) external ; // Fractionalization function fractionalizeCarbonCredit ( uint256 creditId , uint256 totalShares , string memory tokenName , string memory tokenSymbol ) external returns ( address fractionalToken ); function redeemFractionalShares ( address fractionalToken , uint256 shares ) external ; // Offset Claims function claimOffset ( uint256 [] memory creditIds , uint256 [] memory quantities , string memory offsetClaim ) external ; function getOffsetHistory ( address entity ) external view returns ( RetirementData [] memory ); // View Functions function getCarbonCreditData ( uint256 creditId ) external view returns ( CarbonCreditData memory ); function getRetirementData ( bytes32 retirementId ) external view returns ( RetirementData memory ); function getCreditsByOwner ( address owner ) external view returns ( uint256 [] memory ); function getCreditsByProject ( string memory projectId ) external view returns ( uint256 [] memory ); function getCreditsByVintage ( uint256 vintage ) external view returns ( uint256 [] memory ); function getTotalSupply () external view returns ( uint256 ); function getTotalRetired () external view returns ( uint256 ); function getAvailableCredits () external view returns ( uint256 ); // Verification function verifyCreditAuthenticity ( uint256 creditId ) external view returns ( bool isValid , string memory verificationDetails ); function checkDoubleSpending ( uint256 creditId ) external view returns ( bool hasDoubleSpending ); } interface ICarbonCreditRegistry { struct ProjectData { string projectId ; string name ; string description ; string location ; string methodology ; address projectDeveloper ; Standard standard ; CreditType creditType ; uint256 estimatedCredits ; uint256 issuedCredits ; bool active ; string verificationBody ; string registryUrl ; } // Events event ProjectRegistered ( string indexed projectId , address indexed developer , Standard standard ); event ProjectUpdated ( string indexed projectId , bool active ); event VerificationBodyAdded ( address indexed verifier , string name ); // Core Functions function registerProject ( ProjectData memory projectData ) external ; function updateProject ( string memory projectId , ProjectData memory projectData ) external ; function addVerificationBody ( address verifier , string memory name , Standard [] memory authorizedStandards ) external ; function isAuthorizedVerifier ( address verifier , Standard standard ) external view returns ( bool ); function getProjectData ( string memory projectId ) external view returns ( ProjectData memory ); function getAllProjects () external view returns ( string [] memory ); }","title":"Core Interface"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#key-features","text":"","title":"Key Features"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#1-comprehensive-credit-tracking","text":"Full Lifecycle : Track credits from issuance through retirement Immutable Records : Blockchain-based immutable tracking Status Management : Clear status transitions and validation Metadata Integration : IPFS integration for detailed documentation","title":"1. Comprehensive Credit Tracking"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#2-multiple-credit-standards","text":"Standard Compliance : Support for VCS, CDM, Gold Standard, and others Flexible Framework : Extensible to new standards and methodologies Verification Integration : Integration with recognized verification bodies","title":"2. Multiple Credit Standards"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#3-fractionalization-support","text":"Fractional Ownership : Enable fractional ownership of large credits ERC20 Integration : Create fungible tokens for fractional shares Redemption Mechanism : Convert fractional shares back to whole credits","title":"3. Fractionalization Support"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#4-automated-offset-claims","text":"Batch Retirement : Retire multiple credits in single transaction Offset Tracking : Track offset claims and retirement history Certificate Generation : Generate retirement certificates","title":"4. Automated Offset Claims"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#credit-lifecycle","text":"// 1. Register Project ProjectData memory project = ProjectData ({ projectId : \"PROJ-001\" , name : \"Reforestation Project\" , methodology : \"VM0006\" , // ... other fields }); registry . registerProject ( project ); // 2. Issue Credits CarbonCreditData memory credit = CarbonCreditData ({ projectId : \"PROJ-001\" , standard : Standard . VCS , creditType : CreditType . REMOVAL , vintage : 2024 , quantity : 1000 , // ... other fields }); uint256 creditId = carbonCredit . issueCarbonCredit ( credit ); // 3. Transfer Credits carbonCredit . transferCredit ( creditId , buyer , 500 ); // 4. Retire Credits for Offset bytes32 retirementId = carbonCredit . retireCredit ( creditId , 250 , \"Company XYZ\" , \"Annual carbon neutrality\" ); // 5. Claim Offset uint256 [] memory creditIds = new uint256 []( 1 ); creditIds [ 0 ] = creditId ; uint256 [] memory quantities = new uint256 []( 1 ); quantities [ 0 ] = 250 ; carbonCredit . claimOffset ( creditIds , quantities , \"2024 Carbon Neutrality Claim\" );","title":"Credit Lifecycle"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#rationale","text":"","title":"Rationale"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#nft-vs-fungible-token-approach","text":"The standard supports both approaches: - NFT Approach : Each credit batch is unique with specific vintage, project, and verification data - Fungible Approach : Credits with identical characteristics can be fungible - Hybrid Approach : NFTs can be fractionalized into fungible tokens","title":"NFT vs Fungible Token Approach"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#immutable-retirement","text":"Once credits are retired, they cannot be transferred or used again, preventing double-counting and ensuring offset integrity.","title":"Immutable Retirement"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#registry-integration","text":"Integration with existing carbon registries ensures compliance with established standards and verification processes.","title":"Registry Integration"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#metadata-standards","text":"Using IPFS for metadata storage ensures decentralized, permanent storage of verification documents and project details.","title":"Metadata Standards"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#implementation-details","text":"","title":"Implementation Details"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#credit-issuance","text":"function issueCarbonCredit ( CarbonCreditData memory creditData ) external returns ( uint256 creditId ) { require ( isAuthorizedIssuer ( msg.sender ), \"Unauthorized issuer\" ); require ( registry . getProjectData ( creditData . projectId ). active , \"Project not active\" ); creditId = nextCreditId ++ ; creditData . creditId = creditId ; creditData . status = CreditStatus . ACTIVE ; creditData . currentOwner = msg.sender ; creditData . issuanceDate = block.timestamp ; credits [ creditId ] = creditData ; ownerCredits [ msg.sender ]. push ( creditId ); emit CarbonCreditIssued ( creditId , creditData . projectId , creditData . standard , creditData . quantity , creditData . vintage ); }","title":"Credit Issuance"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#credit-retirement","text":"function retireCredit ( uint256 creditId , uint256 quantity , string memory beneficiary , string memory reason ) external returns ( bytes32 retirementId ) { CarbonCreditData storage credit = credits [ creditId ]; require ( credit . currentOwner == msg.sender , \"Not credit owner\" ); require ( credit . status == CreditStatus . ACTIVE , \"Credit not active\" ); require ( quantity <= credit . quantity , \"Insufficient quantity\" ); retirementId = keccak256 ( abi . encodePacked ( creditId , quantity , block.timestamp , msg.sender )); RetirementData memory retirement = RetirementData ({ creditId : creditId , quantity : quantity , retiringEntity : msg.sender , beneficiary : beneficiary , retirementReason : reason , retirementDate : block.timestamp , retirementCertificate : \"\" // Generated off-chain }); retirements [ retirementId ] = retirement ; credit . quantity -= quantity ; if ( credit . quantity == 0 ) { credit . status = CreditStatus . RETIRED ; } emit CarbonCreditRetired ( creditId , msg.sender , quantity , beneficiary ); }","title":"Credit Retirement"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#security-considerations","text":"Authorization : Proper authorization for credit issuance and management Double-Spending Prevention : Mechanisms to prevent double-counting of credits Verification : Integration with trusted verification bodies Immutable Retirement : Ensure retired credits cannot be reused Registry Validation : Validate project registration and status","title":"Security Considerations"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#compliance-considerations","text":"International Standards : Compliance with VCS, CDM, and other standards Regulatory Requirements : Consideration of emerging regulations Audit Trails : Complete audit trails for compliance reporting Verification Requirements : Integration with recognized verification bodies","title":"Compliance Considerations"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#integration-examples","text":"","title":"Integration Examples"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#with-defi-protocols","text":"contract CarbonOffsetDeFi { ICarbonCredit public carbonCredit ; function offsetTransaction ( uint256 creditId , uint256 quantity ) external { // Retire credits to offset transaction carbonCredit . retireCredit ( creditId , quantity , \"DeFi Transaction Offset\" , \"Automated offset\" ); } }","title":"With DeFi Protocols"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#with-corporate-sustainability","text":"contract CorporateOffsetManager { ICarbonCredit public carbonCredit ; mapping ( address => uint256 ) public annualOffsets ; function executeAnnualOffset ( uint256 [] memory creditIds , uint256 [] memory quantities ) external { uint256 totalOffset = 0 ; for ( uint256 i = 0 ; i < quantities . length ; i ++ ) { totalOffset += quantities [ i ]; } carbonCredit . claimOffset ( creditIds , quantities , \"Annual Carbon Neutrality\" ); annualOffsets [ msg.sender ] += totalOffset ; } }","title":"With Corporate Sustainability"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#test-cases","text":"Comprehensive test cases should cover: - Credit issuance and lifecycle management - Transfer and ownership tracking - Retirement and offset claiming - Fractionalization and redemption - Registry integration - Verification and compliance - Edge cases and error conditions","title":"Test Cases"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#reference-implementation","text":"The reference implementation includes: - CarbonCreditFacet.sol - Core carbon credit functionality - ICarbonCredit.sol - Interface definition - CarbonCreditLib.sol - Supporting library functions","title":"Reference Implementation"},{"location":"eips/EIP-DRAFT-Carbon-Credit-Standard/#copyright","text":"Copyright and related rights waived via CC0 .","title":"Copyright"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/","text":"EIP-DRAFT: Collateralized Trade Deal Standard for Invoice Financing \u00b6 Simple Summary \u00b6 A standardized interface for creating and managing collateralized trade deals that enable invoice financing through tokenized collateral, interest distribution, and automated repayment mechanisms. Abstract \u00b6 This EIP proposes a comprehensive standard for trade deals that enables: - Creation of collateralized financing arrangements using invoice NFTs - Tokenized collateral and interest distribution systems - Multi-party funding with proportional token distribution - Automated interest calculations and distributions - Identity-based participation controls with claim requirements - Multiple operation modes for different financing scenarios Motivation \u00b6 Traditional invoice financing lacks transparency, standardization, and programmable automation. This standard addresses these limitations by providing a decentralized, transparent, and automated system for invoice financing that can be implemented across different platforms while maintaining interoperability. Specification \u00b6 Core Interface \u00b6 interface ICollateralizedTradeDeal { enum OperationMode { STANDARD , ADVANCED , CUSTOM } struct TradeDeal { string name ; string symbol ; uint256 interestRate ; // In basis points (100 = 1%) uint256 collateralToInterestRatio ; bool active ; address nftAddress ; address collateralAddress ; address interestAddress ; address usdcAddress ; OperationMode operationMode ; uint256 [] requiredClaimTopics ; } // Events event TradeDealCreated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address nftAddress , address collateralAddress , address interestAddress , address usdcAddress , OperationMode operationMode ); event TradeDealFullyFunded ( uint256 indexed tradeDealId , uint256 fundingTarget ); event TradeDealFundingWithdrawn ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount ); event TradeDealRepaid ( uint256 indexed tradeDealId , address indexed repayer , uint256 amount , bool fullyRepaid ); event CollateralTokensDistributed ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount ); event CollateralTokensRedeemed ( uint256 indexed tradeDealId , address indexed redeemer , uint256 collateralAmount , uint256 usdcAmount ); event InterestDistributedForTradeDeal ( uint256 indexed tradeDealId , uint256 totalInterest , uint256 invoicePoolInterest , uint256 interestInterest , uint256 interestTokensMinted ); event InvoiceDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event InvoiceWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event USDCDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 amount , address depositor ); event TradeDealRequiredClaimTopicsSet ( uint256 indexed tradeDealId , uint256 [] claimTopics ); // Core Functions function createTradeDeal ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , uint256 [] memory requiredClaimTopics , address collateralAddress , address interestAddress , address usdcAddress , OperationMode operationMode ) external returns ( uint256 ); function updateTradeDeal ( uint256 tradeDealId , string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , address collateralAddress , address interestAddress , address usdcAddress ) external ; function activateTradeDeal ( uint256 tradeDealId ) external ; function deactivateTradeDeal ( uint256 tradeDealId ) external ; // Funding Operations function tdDepositUSDC ( uint256 tradeDealId , uint256 amount ) external ; function tdWithdrawUSDC ( uint256 tradeDealId , uint256 amount ) external ; function withdrawTradeDealFundingForBorrower ( uint256 tradeDealId , address borrowerAddress ) external ; // Collateral Operations function tdDepositInvoice ( uint256 tradeDealId , uint256 tokenId ) external ; function tdWithdrawInvoice ( uint256 tradeDealId , uint256 tokenId ) external ; // Repayment Operations function repayTradeDeal ( uint256 tradeDealId , uint256 amount ) external ; function repayTradeDealForBorrower ( uint256 tradeDealId , address borrower , uint256 amount ) external ; function redeemCollateralTokens ( uint256 tradeDealId , uint256 collateralAmount ) external ; // Interest Distribution function tdDistributeInterest ( uint256 tradeDealId ) external ; // Access Control function setTradeDealRequiredClaimTopics ( uint256 tradeDealId , uint256 [] memory claimTopics ) external ; function getTradeDealRequiredClaimTopics ( uint256 tradeDealId ) external view returns ( uint256 [] memory ); // View Functions function getTradeDealInfo ( uint256 tradeDealId ) external view returns ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , OperationMode operationMode ); function getTradeDealFullStatus ( uint256 tradeDealId ) external view returns ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ); function isTradeDealParticipant ( uint256 tradeDealId , address user ) external view returns ( bool ); function isTradeDealFunded ( uint256 tradeDealId ) external view returns ( bool ); function isTradeDealRepaid ( uint256 tradeDealId ) external view returns ( bool ); function getAllTradeDealIds () external view returns ( uint256 [] memory ); } Key Features \u00b6 1. Collateralized Financing \u00b6 Invoice NFTs as Collateral : Use tokenized invoices as collateral for financing Proportional Token Distribution : Distribute collateral tokens based on funding contributions Automated Collateral Management : Handle collateral deposits and withdrawals 2. Multi-Token System \u00b6 Collateral Tokens : Represent funding contributions and ownership stakes Interest Tokens : Represent earned interest and distribution rights USDC Integration : Standardized stablecoin for funding and repayments 3. Interest Distribution \u00b6 Automated Calculations : Calculate interest based on configurable rates Proportional Distribution : Distribute interest based on token holdings Dual Distribution : Split between invoice pool and interest token holders 4. Identity-Based Access Control \u00b6 Claim Requirements : Require specific identity claims for participation Trusted Issuer Validation : Verify claims through trusted issuer system Flexible Access Control : Configure different requirements per trade deal Operation Modes \u00b6 The standard supports multiple operation modes: STANDARD : Basic invoice financing with standard terms ADVANCED : Enhanced features with complex interest structures CUSTOM : Fully customizable parameters for specialized use cases Funding Lifecycle \u00b6 // 1. Create Trade Deal uint256 tradeDealId = createTradeDeal ( \"Invoice Deal #1\" , \"ID1\" , 500 , 10000 , claimTopics , collateralToken , interestToken , usdcToken , OperationMode . STANDARD ); // 2. Deposit Invoices as Collateral tdDepositInvoice ( tradeDealId , invoiceTokenId ); // 3. Fund the Deal tdDepositUSDC ( tradeDealId , fundingAmount ); // 4. Withdraw Funding (when fully funded) withdrawTradeDealFundingForBorrower ( tradeDealId , borrowerAddress ); // 5. Distribute Interest (periodically) tdDistributeInterest ( tradeDealId ); // 6. Repay the Deal repayTradeDeal ( tradeDealId , repaymentAmount ); // 7. Redeem Collateral Tokens redeemCollateralTokens ( tradeDealId , collateralAmount ); Rationale \u00b6 Tokenized Collateral System \u00b6 Using ERC20 tokens to represent collateral ownership enables fractional ownership, transferability, and automated distribution mechanisms. Interest Rate in Basis Points \u00b6 Using basis points (1/100th of a percent) provides sufficient precision for interest calculations while remaining human-readable. Identity Integration \u00b6 Integration with ERC734/ERC735 identity standards enables compliance with regulatory requirements and sophisticated access control. Multi-Mode Operation \u00b6 Different operation modes allow the standard to accommodate various financing scenarios while maintaining a consistent interface. Implementation Details \u00b6 Interest Calculation \u00b6 function calculateInterest ( uint256 principal , uint256 rate , uint256 timeElapsed ) internal pure returns ( uint256 ) { // rate is in basis points (100 = 1%) // timeElapsed is in seconds // Returns interest for the time period return ( principal * rate * timeElapsed ) / ( 10000 * 365 days ); } Collateral Token Distribution \u00b6 function distributeCollateralTokens ( uint256 tradeDealId , address recipient , uint256 usdcAmount ) internal { TradeDeal storage deal = tradeDeals [ tradeDealId ]; uint256 collateralAmount = usdcAmount ; // 1:1 ratio, can be customized IERC20Mint ( deal . collateralAddress ). mintTo ( recipient , collateralAmount ); emit CollateralTokensDistributed ( tradeDealId , recipient , collateralAmount ); } Security Considerations \u00b6 Access Control : Proper validation of participant eligibility and claim requirements Integer Overflow : Use SafeMath or Solidity 0.8+ overflow protection Reentrancy Protection : Guard against reentrancy attacks in funding operations Interest Calculation : Prevent manipulation of interest calculations Collateral Management : Secure handling of collateral deposits and withdrawals Gas Optimization \u00b6 Batch operations for multiple participants Efficient storage patterns for trade deal data Optimized interest calculation algorithms Minimal external calls during operations Backwards Compatibility \u00b6 This standard is designed to work with existing ERC20, ERC721, and identity standard implementations. Test Cases \u00b6 Comprehensive test cases should cover: - Trade deal lifecycle management - Funding and withdrawal operations - Interest calculation and distribution - Collateral token management - Identity-based access control - Edge cases and error conditions Reference Implementation \u00b6 The reference implementation includes: - TradeDealManagementFacet.sol - Core management functionality - TradeDealOperationsFacet.sol - Operational functions - ITradeDeal.sol - Interface definition - TradeDealLib.sol - Supporting library functions Copyright \u00b6 Copyright and related rights waived via CC0 .","title":"Collateralized Trade Deal Standard"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#eip-draft-collateralized-trade-deal-standard-for-invoice-financing","text":"","title":"EIP-DRAFT: Collateralized Trade Deal Standard for Invoice Financing"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#simple-summary","text":"A standardized interface for creating and managing collateralized trade deals that enable invoice financing through tokenized collateral, interest distribution, and automated repayment mechanisms.","title":"Simple Summary"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#abstract","text":"This EIP proposes a comprehensive standard for trade deals that enables: - Creation of collateralized financing arrangements using invoice NFTs - Tokenized collateral and interest distribution systems - Multi-party funding with proportional token distribution - Automated interest calculations and distributions - Identity-based participation controls with claim requirements - Multiple operation modes for different financing scenarios","title":"Abstract"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#motivation","text":"Traditional invoice financing lacks transparency, standardization, and programmable automation. This standard addresses these limitations by providing a decentralized, transparent, and automated system for invoice financing that can be implemented across different platforms while maintaining interoperability.","title":"Motivation"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#specification","text":"","title":"Specification"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#core-interface","text":"interface ICollateralizedTradeDeal { enum OperationMode { STANDARD , ADVANCED , CUSTOM } struct TradeDeal { string name ; string symbol ; uint256 interestRate ; // In basis points (100 = 1%) uint256 collateralToInterestRatio ; bool active ; address nftAddress ; address collateralAddress ; address interestAddress ; address usdcAddress ; OperationMode operationMode ; uint256 [] requiredClaimTopics ; } // Events event TradeDealCreated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address nftAddress , address collateralAddress , address interestAddress , address usdcAddress , OperationMode operationMode ); event TradeDealFullyFunded ( uint256 indexed tradeDealId , uint256 fundingTarget ); event TradeDealFundingWithdrawn ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount ); event TradeDealRepaid ( uint256 indexed tradeDealId , address indexed repayer , uint256 amount , bool fullyRepaid ); event CollateralTokensDistributed ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount ); event CollateralTokensRedeemed ( uint256 indexed tradeDealId , address indexed redeemer , uint256 collateralAmount , uint256 usdcAmount ); event InterestDistributedForTradeDeal ( uint256 indexed tradeDealId , uint256 totalInterest , uint256 invoicePoolInterest , uint256 interestInterest , uint256 interestTokensMinted ); event InvoiceDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event InvoiceWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event USDCDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 amount , address depositor ); event TradeDealRequiredClaimTopicsSet ( uint256 indexed tradeDealId , uint256 [] claimTopics ); // Core Functions function createTradeDeal ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , uint256 [] memory requiredClaimTopics , address collateralAddress , address interestAddress , address usdcAddress , OperationMode operationMode ) external returns ( uint256 ); function updateTradeDeal ( uint256 tradeDealId , string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , address collateralAddress , address interestAddress , address usdcAddress ) external ; function activateTradeDeal ( uint256 tradeDealId ) external ; function deactivateTradeDeal ( uint256 tradeDealId ) external ; // Funding Operations function tdDepositUSDC ( uint256 tradeDealId , uint256 amount ) external ; function tdWithdrawUSDC ( uint256 tradeDealId , uint256 amount ) external ; function withdrawTradeDealFundingForBorrower ( uint256 tradeDealId , address borrowerAddress ) external ; // Collateral Operations function tdDepositInvoice ( uint256 tradeDealId , uint256 tokenId ) external ; function tdWithdrawInvoice ( uint256 tradeDealId , uint256 tokenId ) external ; // Repayment Operations function repayTradeDeal ( uint256 tradeDealId , uint256 amount ) external ; function repayTradeDealForBorrower ( uint256 tradeDealId , address borrower , uint256 amount ) external ; function redeemCollateralTokens ( uint256 tradeDealId , uint256 collateralAmount ) external ; // Interest Distribution function tdDistributeInterest ( uint256 tradeDealId ) external ; // Access Control function setTradeDealRequiredClaimTopics ( uint256 tradeDealId , uint256 [] memory claimTopics ) external ; function getTradeDealRequiredClaimTopics ( uint256 tradeDealId ) external view returns ( uint256 [] memory ); // View Functions function getTradeDealInfo ( uint256 tradeDealId ) external view returns ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , OperationMode operationMode ); function getTradeDealFullStatus ( uint256 tradeDealId ) external view returns ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ); function isTradeDealParticipant ( uint256 tradeDealId , address user ) external view returns ( bool ); function isTradeDealFunded ( uint256 tradeDealId ) external view returns ( bool ); function isTradeDealRepaid ( uint256 tradeDealId ) external view returns ( bool ); function getAllTradeDealIds () external view returns ( uint256 [] memory ); }","title":"Core Interface"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#key-features","text":"","title":"Key Features"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#1-collateralized-financing","text":"Invoice NFTs as Collateral : Use tokenized invoices as collateral for financing Proportional Token Distribution : Distribute collateral tokens based on funding contributions Automated Collateral Management : Handle collateral deposits and withdrawals","title":"1. Collateralized Financing"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#2-multi-token-system","text":"Collateral Tokens : Represent funding contributions and ownership stakes Interest Tokens : Represent earned interest and distribution rights USDC Integration : Standardized stablecoin for funding and repayments","title":"2. Multi-Token System"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#3-interest-distribution","text":"Automated Calculations : Calculate interest based on configurable rates Proportional Distribution : Distribute interest based on token holdings Dual Distribution : Split between invoice pool and interest token holders","title":"3. Interest Distribution"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#4-identity-based-access-control","text":"Claim Requirements : Require specific identity claims for participation Trusted Issuer Validation : Verify claims through trusted issuer system Flexible Access Control : Configure different requirements per trade deal","title":"4. Identity-Based Access Control"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#operation-modes","text":"The standard supports multiple operation modes: STANDARD : Basic invoice financing with standard terms ADVANCED : Enhanced features with complex interest structures CUSTOM : Fully customizable parameters for specialized use cases","title":"Operation Modes"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#funding-lifecycle","text":"// 1. Create Trade Deal uint256 tradeDealId = createTradeDeal ( \"Invoice Deal #1\" , \"ID1\" , 500 , 10000 , claimTopics , collateralToken , interestToken , usdcToken , OperationMode . STANDARD ); // 2. Deposit Invoices as Collateral tdDepositInvoice ( tradeDealId , invoiceTokenId ); // 3. Fund the Deal tdDepositUSDC ( tradeDealId , fundingAmount ); // 4. Withdraw Funding (when fully funded) withdrawTradeDealFundingForBorrower ( tradeDealId , borrowerAddress ); // 5. Distribute Interest (periodically) tdDistributeInterest ( tradeDealId ); // 6. Repay the Deal repayTradeDeal ( tradeDealId , repaymentAmount ); // 7. Redeem Collateral Tokens redeemCollateralTokens ( tradeDealId , collateralAmount );","title":"Funding Lifecycle"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#rationale","text":"","title":"Rationale"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#tokenized-collateral-system","text":"Using ERC20 tokens to represent collateral ownership enables fractional ownership, transferability, and automated distribution mechanisms.","title":"Tokenized Collateral System"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#interest-rate-in-basis-points","text":"Using basis points (1/100th of a percent) provides sufficient precision for interest calculations while remaining human-readable.","title":"Interest Rate in Basis Points"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#identity-integration","text":"Integration with ERC734/ERC735 identity standards enables compliance with regulatory requirements and sophisticated access control.","title":"Identity Integration"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#multi-mode-operation","text":"Different operation modes allow the standard to accommodate various financing scenarios while maintaining a consistent interface.","title":"Multi-Mode Operation"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#implementation-details","text":"","title":"Implementation Details"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#interest-calculation","text":"function calculateInterest ( uint256 principal , uint256 rate , uint256 timeElapsed ) internal pure returns ( uint256 ) { // rate is in basis points (100 = 1%) // timeElapsed is in seconds // Returns interest for the time period return ( principal * rate * timeElapsed ) / ( 10000 * 365 days ); }","title":"Interest Calculation"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#collateral-token-distribution","text":"function distributeCollateralTokens ( uint256 tradeDealId , address recipient , uint256 usdcAmount ) internal { TradeDeal storage deal = tradeDeals [ tradeDealId ]; uint256 collateralAmount = usdcAmount ; // 1:1 ratio, can be customized IERC20Mint ( deal . collateralAddress ). mintTo ( recipient , collateralAmount ); emit CollateralTokensDistributed ( tradeDealId , recipient , collateralAmount ); }","title":"Collateral Token Distribution"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#security-considerations","text":"Access Control : Proper validation of participant eligibility and claim requirements Integer Overflow : Use SafeMath or Solidity 0.8+ overflow protection Reentrancy Protection : Guard against reentrancy attacks in funding operations Interest Calculation : Prevent manipulation of interest calculations Collateral Management : Secure handling of collateral deposits and withdrawals","title":"Security Considerations"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#gas-optimization","text":"Batch operations for multiple participants Efficient storage patterns for trade deal data Optimized interest calculation algorithms Minimal external calls during operations","title":"Gas Optimization"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#backwards-compatibility","text":"This standard is designed to work with existing ERC20, ERC721, and identity standard implementations.","title":"Backwards Compatibility"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#test-cases","text":"Comprehensive test cases should cover: - Trade deal lifecycle management - Funding and withdrawal operations - Interest calculation and distribution - Collateral token management - Identity-based access control - Edge cases and error conditions","title":"Test Cases"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#reference-implementation","text":"The reference implementation includes: - TradeDealManagementFacet.sol - Core management functionality - TradeDealOperationsFacet.sol - Operational functions - ITradeDeal.sol - Interface definition - TradeDealLib.sol - Supporting library functions","title":"Reference Implementation"},{"location":"eips/EIP-DRAFT-Collateralized-Trade-Deal-Standard/#copyright","text":"Copyright and related rights waived via CC0 .","title":"Copyright"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/","text":"EIP-DRAFT: Diamond-Enhanced NFT Marketplace with Fee Distribution \u00b6 Simple Summary \u00b6 A standardized interface for NFT marketplaces built on the Diamond Standard (EIP-2535) that supports configurable fee distribution, multiple payment methods, and identity-based access control. Abstract \u00b6 This EIP proposes a standard interface for NFT marketplaces that leverages the Diamond Standard's modularity while providing advanced features including: - Configurable fee distribution to multiple receivers - Support for both ETH and ERC20 token payments - Identity-based buyer verification - Price protection mechanisms - Reentrancy protection for all payment operations Motivation \u00b6 Current NFT marketplace implementations often lack standardization and advanced features like flexible fee distribution and identity verification. This standard addresses these limitations by providing a comprehensive marketplace interface that can be implemented as a Diamond facet, enabling upgradeable and modular marketplace functionality. Specification \u00b6 Core Interface \u00b6 interface IEnhancedMarketplace { struct FeeReceiver { address receiver ; uint256 sharePerMillion ; // Parts per million (e.g., 10,000 = 1%) } struct MarketItem { address nftContract ; uint256 tokenId ; address seller ; address owner ; uint256 price ; bool sold ; address receiver ; address paymentToken ; } // Events event MarketplaceInitialized ( FeeReceiver [] feeReceivers ); event PaymentDistributed ( address token , address receiver , uint256 amount ); event Listings ( address indexed nftContract , uint256 indexed tokenId , address indexed seller , address receiver , address buyer , uint256 price , bool sold , address paymentToken ); event Sales ( address indexed nftContract , uint256 indexed tokenId , address indexed buyer ); event Delisted ( uint256 indexed tokenId ); // Core Functions function initializeMarketplace ( FeeReceiver [] memory _feeReceivers ) external ; function listItem ( address nftContract , address payable receiver , uint256 tokenId , uint256 price , bool transferNFT , address paymentToken ) external payable ; function purchaseItem ( address nftContract , uint256 tokenId , uint256 maxPrice ) external payable ; function delistItem ( address nftContract , uint256 tokenId ) external ; function fetchItem ( address nftContract , uint256 tokenId ) external view returns ( MarketItem memory ); function fetchItems () external view returns ( MarketItem [] memory ); function getMarketplaceFeeReceivers () external view returns ( FeeReceiver [] memory ); } Key Features \u00b6 1. Fee Distribution System \u00b6 Configurable fee receivers with parts-per-million precision Automatic distribution during purchases Support for both ETH and ERC20 payments Transparent fee tracking via events 2. Payment Methods \u00b6 Native ETH payments ERC20 token payments Price protection with maximum acceptable price Automatic refund of excess ETH 3. Identity Integration \u00b6 Buyer verification through identity registry Claim-based access control Trusted issuer validation 4. Security Features \u00b6 Reentrancy protection on all payment functions Checks-effects-interactions pattern Ownership verification before listing Rationale \u00b6 Diamond Standard Integration \u00b6 Using the Diamond Standard allows marketplaces to be upgradeable and modular, enabling new features to be added without disrupting existing functionality. Fee Distribution Precision \u00b6 The parts-per-million system provides sufficient precision for fee calculations while remaining gas-efficient. Identity-Based Access Control \u00b6 Integration with ERC734/ERC735 identity standards enables sophisticated access control and compliance features. Backwards Compatibility \u00b6 This standard is designed to be compatible with existing ERC721 and ERC20 tokens. The Diamond Standard ensures that existing marketplace functionality can be preserved while adding new features. Implementation \u00b6 Reference Implementation \u00b6 The reference implementation includes: - MarketplaceFacet.sol - Core marketplace functionality - IMarketplace.sol - Interface definition - IdentityStorage.sol - Identity integration Gas Considerations \u00b6 Fee distribution adds minimal gas overhead Identity verification adds verification costs Diamond proxy adds small delegatecall overhead Security Considerations \u00b6 Reentrancy Protection : All payment functions use the nonReentrant modifier Integer Overflow : Uses SafeMath or Solidity 0.8+ overflow protection Access Control : Proper ownership verification before operations Payment Validation : Validates payment amounts and methods Identity Verification : Ensures buyers are registered in identity system Test Cases \u00b6 Test cases should cover: - Fee distribution accuracy - Payment method handling - Identity verification - Reentrancy attack prevention - Edge cases for price protection Copyright \u00b6 Copyright and related rights waived via CC0 .","title":"Diamond-Enhanced Marketplace"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#eip-draft-diamond-enhanced-nft-marketplace-with-fee-distribution","text":"","title":"EIP-DRAFT: Diamond-Enhanced NFT Marketplace with Fee Distribution"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#simple-summary","text":"A standardized interface for NFT marketplaces built on the Diamond Standard (EIP-2535) that supports configurable fee distribution, multiple payment methods, and identity-based access control.","title":"Simple Summary"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#abstract","text":"This EIP proposes a standard interface for NFT marketplaces that leverages the Diamond Standard's modularity while providing advanced features including: - Configurable fee distribution to multiple receivers - Support for both ETH and ERC20 token payments - Identity-based buyer verification - Price protection mechanisms - Reentrancy protection for all payment operations","title":"Abstract"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#motivation","text":"Current NFT marketplace implementations often lack standardization and advanced features like flexible fee distribution and identity verification. This standard addresses these limitations by providing a comprehensive marketplace interface that can be implemented as a Diamond facet, enabling upgradeable and modular marketplace functionality.","title":"Motivation"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#specification","text":"","title":"Specification"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#core-interface","text":"interface IEnhancedMarketplace { struct FeeReceiver { address receiver ; uint256 sharePerMillion ; // Parts per million (e.g., 10,000 = 1%) } struct MarketItem { address nftContract ; uint256 tokenId ; address seller ; address owner ; uint256 price ; bool sold ; address receiver ; address paymentToken ; } // Events event MarketplaceInitialized ( FeeReceiver [] feeReceivers ); event PaymentDistributed ( address token , address receiver , uint256 amount ); event Listings ( address indexed nftContract , uint256 indexed tokenId , address indexed seller , address receiver , address buyer , uint256 price , bool sold , address paymentToken ); event Sales ( address indexed nftContract , uint256 indexed tokenId , address indexed buyer ); event Delisted ( uint256 indexed tokenId ); // Core Functions function initializeMarketplace ( FeeReceiver [] memory _feeReceivers ) external ; function listItem ( address nftContract , address payable receiver , uint256 tokenId , uint256 price , bool transferNFT , address paymentToken ) external payable ; function purchaseItem ( address nftContract , uint256 tokenId , uint256 maxPrice ) external payable ; function delistItem ( address nftContract , uint256 tokenId ) external ; function fetchItem ( address nftContract , uint256 tokenId ) external view returns ( MarketItem memory ); function fetchItems () external view returns ( MarketItem [] memory ); function getMarketplaceFeeReceivers () external view returns ( FeeReceiver [] memory ); }","title":"Core Interface"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#key-features","text":"","title":"Key Features"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#1-fee-distribution-system","text":"Configurable fee receivers with parts-per-million precision Automatic distribution during purchases Support for both ETH and ERC20 payments Transparent fee tracking via events","title":"1. Fee Distribution System"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#2-payment-methods","text":"Native ETH payments ERC20 token payments Price protection with maximum acceptable price Automatic refund of excess ETH","title":"2. Payment Methods"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#3-identity-integration","text":"Buyer verification through identity registry Claim-based access control Trusted issuer validation","title":"3. Identity Integration"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#4-security-features","text":"Reentrancy protection on all payment functions Checks-effects-interactions pattern Ownership verification before listing","title":"4. Security Features"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#rationale","text":"","title":"Rationale"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#diamond-standard-integration","text":"Using the Diamond Standard allows marketplaces to be upgradeable and modular, enabling new features to be added without disrupting existing functionality.","title":"Diamond Standard Integration"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#fee-distribution-precision","text":"The parts-per-million system provides sufficient precision for fee calculations while remaining gas-efficient.","title":"Fee Distribution Precision"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#identity-based-access-control","text":"Integration with ERC734/ERC735 identity standards enables sophisticated access control and compliance features.","title":"Identity-Based Access Control"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#backwards-compatibility","text":"This standard is designed to be compatible with existing ERC721 and ERC20 tokens. The Diamond Standard ensures that existing marketplace functionality can be preserved while adding new features.","title":"Backwards Compatibility"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#implementation","text":"","title":"Implementation"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#reference-implementation","text":"The reference implementation includes: - MarketplaceFacet.sol - Core marketplace functionality - IMarketplace.sol - Interface definition - IdentityStorage.sol - Identity integration","title":"Reference Implementation"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#gas-considerations","text":"Fee distribution adds minimal gas overhead Identity verification adds verification costs Diamond proxy adds small delegatecall overhead","title":"Gas Considerations"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#security-considerations","text":"Reentrancy Protection : All payment functions use the nonReentrant modifier Integer Overflow : Uses SafeMath or Solidity 0.8+ overflow protection Access Control : Proper ownership verification before operations Payment Validation : Validates payment amounts and methods Identity Verification : Ensures buyers are registered in identity system","title":"Security Considerations"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#test-cases","text":"Test cases should cover: - Fee distribution accuracy - Payment method handling - Identity verification - Reentrancy attack prevention - Edge cases for price protection","title":"Test Cases"},{"location":"eips/EIP-DRAFT-Diamond-Enhanced-Marketplace/#copyright","text":"Copyright and related rights waived via CC0 .","title":"Copyright"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/","text":"EIP-DRAFT: Diamond Factory Standard for Upgradeable Contract Deployment \u00b6 Simple Summary \u00b6 A standardized factory pattern for deploying and managing Diamond Standard (EIP-2535) contracts with configurable facets, initialization parameters, and upgrade timelock mechanisms. Abstract \u00b6 This EIP proposes a standard factory interface for creating Diamond Standard contracts that enables: - Standardized Diamond deployment with configurable facet sets - Template-based Diamond creation with predefined configurations - Upgrade timelock initialization for security - Event-driven deployment tracking - Integration with existing Diamond tooling and infrastructure Motivation \u00b6 While the Diamond Standard (EIP-2535) provides excellent modularity and upgradeability, there is no standardized way to deploy Diamond contracts with consistent configurations. This leads to fragmented deployment patterns and makes it difficult to build tooling that works across different Diamond implementations. A standardized factory pattern addresses these issues by providing a consistent deployment interface. Specification \u00b6 Core Interface \u00b6 interface IDiamondFactory { struct DiamondSettings { string name ; string symbol ; address owner ; // Additional settings can be extended } struct FacetDeployment { address facetAddress ; bytes4 [] functionSelectors ; bytes initCalldata ; } struct DiamondTemplate { string name ; string description ; FacetDeployment [] facets ; DiamondSettings defaultSettings ; bool active ; } // Events event DiamondCreated ( address indexed diamond , address indexed owner , DiamondSettings settings , uint256 templateId ); event DiamondTemplateCreated ( uint256 indexed templateId , string name , string description ); event DiamondTemplateUpdated ( uint256 indexed templateId , string name , string description , bool active ); event FacetDeployed ( address indexed facet , string name , bytes4 [] selectors ); // Core Functions function createDiamond ( DiamondSettings memory settings , FacetDeployment [] memory facets , address diamondInit , bytes memory initCalldata ) external returns ( address diamond ); function createDiamondFromTemplate ( uint256 templateId , DiamondSettings memory settings , bytes memory customInitCalldata ) external returns ( address diamond ); // Template Management function createDiamondTemplate ( string memory name , string memory description , FacetDeployment [] memory facets , DiamondSettings memory defaultSettings ) external returns ( uint256 templateId ); function updateDiamondTemplate ( uint256 templateId , string memory name , string memory description , FacetDeployment [] memory facets , DiamondSettings memory defaultSettings , bool active ) external ; function getDiamondTemplate ( uint256 templateId ) external view returns ( DiamondTemplate memory ); function getAllTemplateIds () external view returns ( uint256 [] memory ); // Deployment Tracking function getDiamondsCreatedBy ( address creator ) external view returns ( address [] memory ); function getDiamondInfo ( address diamond ) external view returns ( DiamondSettings memory settings , uint256 templateId , address creator , uint256 createdAt ); function isDiamondFromFactory ( address diamond ) external view returns ( bool ); // Facet Management function deployFacet ( string memory name , bytes memory bytecode , bytes4 [] memory selectors ) external returns ( address facet ); function getFacetInfo ( address facet ) external view returns ( string memory name , bytes4 [] memory selectors , address deployer , uint256 deployedAt ); function getAllFacets () external view returns ( address [] memory ); } Key Features \u00b6 1. Standardized Diamond Deployment \u00b6 Consistent Interface : Uniform deployment interface across implementations Configurable Facets : Deploy Diamonds with custom facet configurations Initialization Support : Handle complex initialization scenarios 2. Template System \u00b6 Predefined Configurations : Create reusable Diamond templates Template Management : Add, update, and manage Diamond templates Template-based Deployment : Deploy Diamonds from predefined templates 3. Deployment Tracking \u00b6 Creator Tracking : Track which addresses created which Diamonds Deployment History : Maintain history of all deployments Diamond Verification : Verify if a Diamond was created by the factory 4. Facet Management \u00b6 Facet Deployment : Deploy and register facets Facet Registry : Maintain registry of available facets Selector Tracking : Track function selectors for each facet Template-Based Deployment \u00b6 // Create a template for NFT marketplaces FacetDeployment [] memory facets = new FacetDeployment []( 3 ); facets [ 0 ] = FacetDeployment ( marketplaceFacet , marketplaceSelectors , \"\" ); facets [ 1 ] = FacetDeployment ( erc721Facet , erc721Selectors , \"\" ); facets [ 2 ] = FacetDeployment ( ownershipFacet , ownershipSelectors , \"\" ); DiamondSettings memory defaultSettings = DiamondSettings ( \"NFT Marketplace\" , \"NFTM\" , address ( 0 )); uint256 templateId = factory . createDiamondTemplate ( \"NFT Marketplace\" , \"Standard NFT marketplace with ERC721 support\" , facets , defaultSettings ); // Deploy from template DiamondSettings memory customSettings = DiamondSettings ( \"My Marketplace\" , \"MYM\" , msg.sender ); address diamond = factory . createDiamondFromTemplate ( templateId , customSettings , \"\" ); Upgrade Timelock Integration \u00b6 contract DiamondFactory is IDiamondFactory { uint256 public constant DEFAULT_UPGRADE_TIMELOCK = 48 hours ; function createDiamond ( DiamondSettings memory settings , FacetDeployment [] memory facets , address diamondInit , bytes memory initCalldata ) external returns ( address diamond ) { // Deploy Diamond diamond = address ( new Diamond ()); // Initialize with facets IDiamondCut . FacetCut [] memory cuts = _prepareFacetCuts ( facets ); IDiamond ( diamond ). initialize ( settings . owner , settings , cuts , diamondInit , initCalldata ); // Set upgrade timelock IUpgradeTimelock ( diamond ). initializeUpgradeTimelock ( DEFAULT_UPGRADE_TIMELOCK ); // Track deployment _trackDeployment ( diamond , settings , 0 , msg.sender ); emit DiamondCreated ( diamond , settings . owner , settings , 0 ); return diamond ; } } Rationale \u00b6 Factory Pattern Benefits \u00b6 The factory pattern provides several advantages: - Consistency : Ensures all Diamonds are deployed with proper initialization - Security : Enforces security best practices like upgrade timelocks - Tracking : Enables tracking and verification of deployments - Tooling : Enables better tooling and infrastructure development Template System \u00b6 Templates reduce deployment complexity and ensure consistent configurations for common use cases while still allowing customization. Upgrade Timelock Integration \u00b6 Automatic upgrade timelock initialization ensures that deployed Diamonds have proper security measures in place from the start. Implementation Details \u00b6 Diamond Deployment \u00b6 function _prepareFacetCuts ( FacetDeployment [] memory facets ) internal pure returns ( IDiamondCut . FacetCut [] memory cuts ) { cuts = new IDiamondCut . FacetCut []( facets . length ); for ( uint256 i = 0 ; i < facets . length ; i ++ ) { cuts [ i ] = IDiamondCut . FacetCut ({ facetAddress : facets [ i ]. facetAddress , action : IDiamondCut . FacetCutAction . Add , functionSelectors : facets [ i ]. functionSelectors }); } } Template Storage \u00b6 mapping ( uint256 => DiamondTemplate ) private templates ; mapping ( address => uint256 []) private creatorToTemplates ; uint256 private nextTemplateId = 1 ; function createDiamondTemplate ( string memory name , string memory description , FacetDeployment [] memory facets , DiamondSettings memory defaultSettings ) external returns ( uint256 templateId ) { templateId = nextTemplateId ++ ; templates [ templateId ] = DiamondTemplate ({ name : name , description : description , facets : facets , defaultSettings : defaultSettings , active : true }); creatorToTemplates [ msg.sender ]. push ( templateId ); emit DiamondTemplateCreated ( templateId , name , description ); } Security Considerations \u00b6 Access Control : Proper access control for template management and facet deployment Initialization Security : Secure handling of initialization parameters and calldata Upgrade Timelock : Automatic enforcement of upgrade timelocks Facet Validation : Validation of facet addresses and selectors Template Integrity : Ensure template configurations are valid and secure Gas Optimization \u00b6 Efficient storage patterns for templates and deployment tracking Batch operations for multiple facet deployments Optimized Diamond initialization process Minimal redundant storage Backwards Compatibility \u00b6 This standard is designed to work with existing Diamond Standard implementations and does not modify the core Diamond functionality. Integration Examples \u00b6 With Development Tools \u00b6 // Hardhat deployment script const factory = await ethers . getContractAt ( \"IDiamondFactory\" , factoryAddress ); const diamond = await factory . createDiamondFromTemplate ( templateId , settings , initData ); With Frontend Applications \u00b6 // Web3 integration const factory = new web3 . eth . Contract ( IDiamondFactory . abi , factoryAddress ); const result = await factory . methods . createDiamondFromTemplate ( templateId , settings , initData ). send ({ from : account }); const diamondAddress = result . events . DiamondCreated . returnValues . diamond ; Test Cases \u00b6 Comprehensive test cases should cover: - Diamond deployment with various facet configurations - Template creation and management - Template-based deployment - Deployment tracking and verification - Access control mechanisms - Edge cases and error conditions Reference Implementation \u00b6 The reference implementation includes: - DiamondFactory.sol - Core factory contract - IDiamondFactory.sol - Interface definition - DiamondFactoryLib.sol - Supporting library functions Copyright \u00b6 Copyright and related rights waived via CC0 .","title":"Diamond Factory Standard"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#eip-draft-diamond-factory-standard-for-upgradeable-contract-deployment","text":"","title":"EIP-DRAFT: Diamond Factory Standard for Upgradeable Contract Deployment"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#simple-summary","text":"A standardized factory pattern for deploying and managing Diamond Standard (EIP-2535) contracts with configurable facets, initialization parameters, and upgrade timelock mechanisms.","title":"Simple Summary"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#abstract","text":"This EIP proposes a standard factory interface for creating Diamond Standard contracts that enables: - Standardized Diamond deployment with configurable facet sets - Template-based Diamond creation with predefined configurations - Upgrade timelock initialization for security - Event-driven deployment tracking - Integration with existing Diamond tooling and infrastructure","title":"Abstract"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#motivation","text":"While the Diamond Standard (EIP-2535) provides excellent modularity and upgradeability, there is no standardized way to deploy Diamond contracts with consistent configurations. This leads to fragmented deployment patterns and makes it difficult to build tooling that works across different Diamond implementations. A standardized factory pattern addresses these issues by providing a consistent deployment interface.","title":"Motivation"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#specification","text":"","title":"Specification"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#core-interface","text":"interface IDiamondFactory { struct DiamondSettings { string name ; string symbol ; address owner ; // Additional settings can be extended } struct FacetDeployment { address facetAddress ; bytes4 [] functionSelectors ; bytes initCalldata ; } struct DiamondTemplate { string name ; string description ; FacetDeployment [] facets ; DiamondSettings defaultSettings ; bool active ; } // Events event DiamondCreated ( address indexed diamond , address indexed owner , DiamondSettings settings , uint256 templateId ); event DiamondTemplateCreated ( uint256 indexed templateId , string name , string description ); event DiamondTemplateUpdated ( uint256 indexed templateId , string name , string description , bool active ); event FacetDeployed ( address indexed facet , string name , bytes4 [] selectors ); // Core Functions function createDiamond ( DiamondSettings memory settings , FacetDeployment [] memory facets , address diamondInit , bytes memory initCalldata ) external returns ( address diamond ); function createDiamondFromTemplate ( uint256 templateId , DiamondSettings memory settings , bytes memory customInitCalldata ) external returns ( address diamond ); // Template Management function createDiamondTemplate ( string memory name , string memory description , FacetDeployment [] memory facets , DiamondSettings memory defaultSettings ) external returns ( uint256 templateId ); function updateDiamondTemplate ( uint256 templateId , string memory name , string memory description , FacetDeployment [] memory facets , DiamondSettings memory defaultSettings , bool active ) external ; function getDiamondTemplate ( uint256 templateId ) external view returns ( DiamondTemplate memory ); function getAllTemplateIds () external view returns ( uint256 [] memory ); // Deployment Tracking function getDiamondsCreatedBy ( address creator ) external view returns ( address [] memory ); function getDiamondInfo ( address diamond ) external view returns ( DiamondSettings memory settings , uint256 templateId , address creator , uint256 createdAt ); function isDiamondFromFactory ( address diamond ) external view returns ( bool ); // Facet Management function deployFacet ( string memory name , bytes memory bytecode , bytes4 [] memory selectors ) external returns ( address facet ); function getFacetInfo ( address facet ) external view returns ( string memory name , bytes4 [] memory selectors , address deployer , uint256 deployedAt ); function getAllFacets () external view returns ( address [] memory ); }","title":"Core Interface"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#key-features","text":"","title":"Key Features"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#1-standardized-diamond-deployment","text":"Consistent Interface : Uniform deployment interface across implementations Configurable Facets : Deploy Diamonds with custom facet configurations Initialization Support : Handle complex initialization scenarios","title":"1. Standardized Diamond Deployment"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#2-template-system","text":"Predefined Configurations : Create reusable Diamond templates Template Management : Add, update, and manage Diamond templates Template-based Deployment : Deploy Diamonds from predefined templates","title":"2. Template System"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#3-deployment-tracking","text":"Creator Tracking : Track which addresses created which Diamonds Deployment History : Maintain history of all deployments Diamond Verification : Verify if a Diamond was created by the factory","title":"3. Deployment Tracking"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#4-facet-management","text":"Facet Deployment : Deploy and register facets Facet Registry : Maintain registry of available facets Selector Tracking : Track function selectors for each facet","title":"4. Facet Management"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#template-based-deployment","text":"// Create a template for NFT marketplaces FacetDeployment [] memory facets = new FacetDeployment []( 3 ); facets [ 0 ] = FacetDeployment ( marketplaceFacet , marketplaceSelectors , \"\" ); facets [ 1 ] = FacetDeployment ( erc721Facet , erc721Selectors , \"\" ); facets [ 2 ] = FacetDeployment ( ownershipFacet , ownershipSelectors , \"\" ); DiamondSettings memory defaultSettings = DiamondSettings ( \"NFT Marketplace\" , \"NFTM\" , address ( 0 )); uint256 templateId = factory . createDiamondTemplate ( \"NFT Marketplace\" , \"Standard NFT marketplace with ERC721 support\" , facets , defaultSettings ); // Deploy from template DiamondSettings memory customSettings = DiamondSettings ( \"My Marketplace\" , \"MYM\" , msg.sender ); address diamond = factory . createDiamondFromTemplate ( templateId , customSettings , \"\" );","title":"Template-Based Deployment"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#upgrade-timelock-integration","text":"contract DiamondFactory is IDiamondFactory { uint256 public constant DEFAULT_UPGRADE_TIMELOCK = 48 hours ; function createDiamond ( DiamondSettings memory settings , FacetDeployment [] memory facets , address diamondInit , bytes memory initCalldata ) external returns ( address diamond ) { // Deploy Diamond diamond = address ( new Diamond ()); // Initialize with facets IDiamondCut . FacetCut [] memory cuts = _prepareFacetCuts ( facets ); IDiamond ( diamond ). initialize ( settings . owner , settings , cuts , diamondInit , initCalldata ); // Set upgrade timelock IUpgradeTimelock ( diamond ). initializeUpgradeTimelock ( DEFAULT_UPGRADE_TIMELOCK ); // Track deployment _trackDeployment ( diamond , settings , 0 , msg.sender ); emit DiamondCreated ( diamond , settings . owner , settings , 0 ); return diamond ; } }","title":"Upgrade Timelock Integration"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#rationale","text":"","title":"Rationale"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#factory-pattern-benefits","text":"The factory pattern provides several advantages: - Consistency : Ensures all Diamonds are deployed with proper initialization - Security : Enforces security best practices like upgrade timelocks - Tracking : Enables tracking and verification of deployments - Tooling : Enables better tooling and infrastructure development","title":"Factory Pattern Benefits"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#template-system","text":"Templates reduce deployment complexity and ensure consistent configurations for common use cases while still allowing customization.","title":"Template System"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#upgrade-timelock-integration_1","text":"Automatic upgrade timelock initialization ensures that deployed Diamonds have proper security measures in place from the start.","title":"Upgrade Timelock Integration"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#implementation-details","text":"","title":"Implementation Details"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#diamond-deployment","text":"function _prepareFacetCuts ( FacetDeployment [] memory facets ) internal pure returns ( IDiamondCut . FacetCut [] memory cuts ) { cuts = new IDiamondCut . FacetCut []( facets . length ); for ( uint256 i = 0 ; i < facets . length ; i ++ ) { cuts [ i ] = IDiamondCut . FacetCut ({ facetAddress : facets [ i ]. facetAddress , action : IDiamondCut . FacetCutAction . Add , functionSelectors : facets [ i ]. functionSelectors }); } }","title":"Diamond Deployment"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#template-storage","text":"mapping ( uint256 => DiamondTemplate ) private templates ; mapping ( address => uint256 []) private creatorToTemplates ; uint256 private nextTemplateId = 1 ; function createDiamondTemplate ( string memory name , string memory description , FacetDeployment [] memory facets , DiamondSettings memory defaultSettings ) external returns ( uint256 templateId ) { templateId = nextTemplateId ++ ; templates [ templateId ] = DiamondTemplate ({ name : name , description : description , facets : facets , defaultSettings : defaultSettings , active : true }); creatorToTemplates [ msg.sender ]. push ( templateId ); emit DiamondTemplateCreated ( templateId , name , description ); }","title":"Template Storage"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#security-considerations","text":"Access Control : Proper access control for template management and facet deployment Initialization Security : Secure handling of initialization parameters and calldata Upgrade Timelock : Automatic enforcement of upgrade timelocks Facet Validation : Validation of facet addresses and selectors Template Integrity : Ensure template configurations are valid and secure","title":"Security Considerations"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#gas-optimization","text":"Efficient storage patterns for templates and deployment tracking Batch operations for multiple facet deployments Optimized Diamond initialization process Minimal redundant storage","title":"Gas Optimization"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#backwards-compatibility","text":"This standard is designed to work with existing Diamond Standard implementations and does not modify the core Diamond functionality.","title":"Backwards Compatibility"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#integration-examples","text":"","title":"Integration Examples"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#with-development-tools","text":"// Hardhat deployment script const factory = await ethers . getContractAt ( \"IDiamondFactory\" , factoryAddress ); const diamond = await factory . createDiamondFromTemplate ( templateId , settings , initData );","title":"With Development Tools"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#with-frontend-applications","text":"// Web3 integration const factory = new web3 . eth . Contract ( IDiamondFactory . abi , factoryAddress ); const result = await factory . methods . createDiamondFromTemplate ( templateId , settings , initData ). send ({ from : account }); const diamondAddress = result . events . DiamondCreated . returnValues . diamond ;","title":"With Frontend Applications"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#test-cases","text":"Comprehensive test cases should cover: - Diamond deployment with various facet configurations - Template creation and management - Template-based deployment - Deployment tracking and verification - Access control mechanisms - Edge cases and error conditions","title":"Test Cases"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#reference-implementation","text":"The reference implementation includes: - DiamondFactory.sol - Core factory contract - IDiamondFactory.sol - Interface definition - DiamondFactoryLib.sol - Supporting library functions","title":"Reference Implementation"},{"location":"eips/EIP-DRAFT-Diamond-Factory-Standard/#copyright","text":"Copyright and related rights waived via CC0 .","title":"Copyright"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/","text":"EIP-DRAFT: Enhanced Identity System with Trusted Issuers and Attribute Management \u00b6 Simple Summary \u00b6 An enhanced identity standard that extends ERC734/ERC735 with trusted issuer management, attribute-based access control, and integration with decentralized applications for compliance and verification purposes. Abstract \u00b6 This EIP proposes an enhanced identity system that builds upon the ERC734 (Key Management) and ERC735 (Claim Holder) standards to provide: - Trusted issuer registry with claim topic authorization - Attribute-based identity management with typed attributes - Integration with smart contract systems for automated verification - Claim topic-based access control for decentralized applications - Verification status tracking and management Motivation \u00b6 While ERC734 and ERC735 provide basic identity functionality, they lack standardized mechanisms for trusted issuer management and attribute handling. This enhanced system addresses these gaps by providing a comprehensive identity framework suitable for regulatory compliance and sophisticated access control in DeFi and other applications. Specification \u00b6 Core Interface \u00b6 interface IEnhancedIdentity is IERC734 , IERC735 { enum AttributeType { STRING , NUMBER , BOOLEAN , ADDRESS , BYTES } struct Attribute { string key ; AttributeType attributeType ; string value ; } // Events event AttributeSet ( string key , AttributeType attributeType , string value ); event TrustedIssuerAdded ( address indexed issuer , uint256 [] claimTopics ); event TrustedIssuerRemoved ( address indexed issuer ); event ClaimTopicAuthorized ( address indexed issuer , uint256 indexed claimTopic ); event ClaimTopicRevoked ( address indexed issuer , uint256 indexed claimTopic ); // Attribute Management function getAttribute ( string memory key ) external view returns ( Attribute memory ); function setAttribute ( string memory key , AttributeType attributeType , string memory value ) external ; function getAttributesByType ( AttributeType attributeType ) external view returns ( string [] memory keys ); // Verification Status function isVerified () external view returns ( bool ); function getClaimTopics () external view returns ( uint256 [] memory ); function hasClaimTopic ( uint256 claimTopic ) external view returns ( bool ); // Trusted Issuer Integration function isTrustedIssuer ( address issuer ) external view returns ( bool ); function hasTrustedIssuerClaimTopic ( address issuer , uint256 claimTopic ) external view returns ( bool ); } interface ITrustedIssuerRegistry { struct TrustedIssuer { address issuer ; uint256 [] claimTopics ; bool active ; } // Events event TrustedIssuerAdded ( address indexed issuer , uint256 [] claimTopics ); event TrustedIssuerRemoved ( address indexed issuer ); event TrustedIssuerClaimTopicsUpdated ( address indexed issuer , uint256 [] claimTopics ); // Core Functions function addTrustedIssuer ( address issuer , uint256 [] memory claimTopics ) external ; function removeTrustedIssuer ( address issuer ) external ; function updateTrustedIssuerClaimTopics ( address issuer , uint256 [] memory claimTopics ) external ; function isTrustedIssuer ( address issuer ) external view returns ( bool ); function getTrustedIssuerClaimTopics ( address issuer ) external view returns ( uint256 [] memory ); function hasTrustedIssuerClaimTopic ( address issuer , uint256 claimTopic ) external view returns ( bool ); function getAllTrustedIssuers () external view returns ( address [] memory ); } interface IIdentityRegistry { // Events event IdentityRegistered ( address indexed wallet , address indexed identity ); event IdentityUpdated ( address indexed wallet , address indexed identity ); event IdentityRemoved ( address indexed wallet ); // Core Functions function registerIdentity ( address wallet , address identity ) external ; function updateIdentity ( address wallet , address identity ) external ; function removeIdentity ( address wallet ) external ; function getIdentity ( address wallet ) external view returns ( address ); function isRegistered ( address wallet ) external view returns ( bool ); function hasValidClaim ( address wallet , uint256 claimTopic ) external view returns ( bool ); } Key Features \u00b6 1. Enhanced Attribute System \u00b6 Typed Attributes : Support for different data types (string, number, boolean, address, bytes) Structured Storage : Organized attribute management with type-based queries Trusted Issuer Control : Only trusted issuers can set attributes 2. Trusted Issuer Management \u00b6 Claim Topic Authorization : Issuers are authorized for specific claim topics Centralized Registry : Shared trusted issuer registry across applications Dynamic Management : Add, remove, and update issuer permissions 3. Verification Integration \u00b6 Automated Verification : Smart contracts can verify identity claims Claim Topic Validation : Check for specific required claims Status Tracking : Track overall verification status 4. Access Control Integration \u00b6 Claim-Based Access : Use identity claims for application access control Flexible Requirements : Configure different claim requirements per application Real-time Validation : Validate claims during transaction execution Claim Topics \u00b6 Standard claim topics for common use cases: library ClaimTopics { uint256 public constant KYC_VERIFIED = 1 ; uint256 public constant AML_CLEARED = 2 ; uint256 public constant ACCREDITED_INVESTOR = 3 ; uint256 public constant COUNTRY_VERIFICATION = 4 ; uint256 public constant AGE_VERIFICATION = 5 ; uint256 public constant PROFESSIONAL_VERIFICATION = 6 ; uint256 public constant INSTITUTION_VERIFICATION = 7 ; uint256 public constant SANCTIONS_CLEARED = 8 ; } Integration Pattern \u00b6 contract DeFiApplication { IIdentityRegistry public identityRegistry ; modifier requiresClaim ( uint256 claimTopic ) { require ( identityRegistry . hasValidClaim ( msg.sender , claimTopic ), \"Required claim not found\" ); _ ; } function restrictedFunction () external requiresClaim ( ClaimTopics . KYC_VERIFIED ) { // Function logic here } } Rationale \u00b6 Trusted Issuer System \u00b6 A centralized trusted issuer registry enables consistent validation across applications while maintaining decentralization of the identity system itself. Typed Attributes \u00b6 Supporting different attribute types enables more sophisticated identity data management and reduces parsing overhead in applications. Claim Topic Authorization \u00b6 Restricting issuers to specific claim topics prevents unauthorized claim issuance and maintains the integrity of the verification system. Registry Pattern \u00b6 Using a registry pattern for identities enables wallet-to-identity mapping while keeping identity contracts upgradeable and transferable. Implementation Details \u00b6 Attribute Storage \u00b6 mapping ( string => Attribute ) private attributes ; mapping ( uint256 => string []) private attributeKeys ; // AttributeType => keys function setAttribute ( string memory key , AttributeType attributeType , string memory value ) external onlyTrustedIssuer { attributes [ key ] = Attribute ( key , attributeType , value ); attributeKeys [ uint256 ( attributeType )]. push ( key ); emit AttributeSet ( key , attributeType , value ); } Claim Validation \u00b6 function hasValidClaim ( address wallet , uint256 claimTopic ) external view returns ( bool ) { address identity = getIdentity ( wallet ); if ( identity == address ( 0 )) return false ; bytes32 [] memory claimIds = IEnhancedIdentity ( identity ). getClaimIdsByTopic ( claimTopic ); for ( uint256 i = 0 ; i < claimIds . length ; i ++ ) { (, , address issuer , , ,) = IEnhancedIdentity ( identity ). getClaim ( claimIds [ i ]); if ( trustedIssuerRegistry . hasTrustedIssuerClaimTopic ( issuer , claimTopic )) { return true ; } } return false ; } Security Considerations \u00b6 Trusted Issuer Management : Secure management of trusted issuer permissions Claim Validation : Proper validation of claim signatures and issuer authorization Access Control : Secure attribute and claim management functions Privacy : Consider privacy implications of on-chain identity data Key Management : Secure key management for identity operations Gas Optimization \u00b6 Efficient storage patterns for attributes and claims Batch operations for multiple claim validations Optimized lookup mechanisms for trusted issuers Minimal external calls during verification Backwards Compatibility \u00b6 This standard extends ERC734 and ERC735 while maintaining compatibility with existing implementations. Applications can gradually adopt enhanced features while continuing to work with basic ERC734/ERC735 identities. Privacy Considerations \u00b6 While this standard enables powerful identity verification, implementations should consider: - Minimal data disclosure principles - Off-chain storage for sensitive attributes - Zero-knowledge proof integration for privacy-preserving verification - User consent mechanisms for data sharing Test Cases \u00b6 Comprehensive test cases should cover: - Identity registration and management - Trusted issuer operations - Claim validation and verification - Attribute management - Access control integration - Edge cases and error conditions Reference Implementation \u00b6 The reference implementation includes: - Identity.sol - Core identity contract - IIdentity.sol - Interface definition - TrustedIssuersRegistryFacet.sol - Trusted issuer management - IdentityRegistryFacet.sol - Identity registry Copyright \u00b6 Copyright and related rights waived via CC0 .","title":"Enhanced Identity System"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#eip-draft-enhanced-identity-system-with-trusted-issuers-and-attribute-management","text":"","title":"EIP-DRAFT: Enhanced Identity System with Trusted Issuers and Attribute Management"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#simple-summary","text":"An enhanced identity standard that extends ERC734/ERC735 with trusted issuer management, attribute-based access control, and integration with decentralized applications for compliance and verification purposes.","title":"Simple Summary"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#abstract","text":"This EIP proposes an enhanced identity system that builds upon the ERC734 (Key Management) and ERC735 (Claim Holder) standards to provide: - Trusted issuer registry with claim topic authorization - Attribute-based identity management with typed attributes - Integration with smart contract systems for automated verification - Claim topic-based access control for decentralized applications - Verification status tracking and management","title":"Abstract"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#motivation","text":"While ERC734 and ERC735 provide basic identity functionality, they lack standardized mechanisms for trusted issuer management and attribute handling. This enhanced system addresses these gaps by providing a comprehensive identity framework suitable for regulatory compliance and sophisticated access control in DeFi and other applications.","title":"Motivation"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#specification","text":"","title":"Specification"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#core-interface","text":"interface IEnhancedIdentity is IERC734 , IERC735 { enum AttributeType { STRING , NUMBER , BOOLEAN , ADDRESS , BYTES } struct Attribute { string key ; AttributeType attributeType ; string value ; } // Events event AttributeSet ( string key , AttributeType attributeType , string value ); event TrustedIssuerAdded ( address indexed issuer , uint256 [] claimTopics ); event TrustedIssuerRemoved ( address indexed issuer ); event ClaimTopicAuthorized ( address indexed issuer , uint256 indexed claimTopic ); event ClaimTopicRevoked ( address indexed issuer , uint256 indexed claimTopic ); // Attribute Management function getAttribute ( string memory key ) external view returns ( Attribute memory ); function setAttribute ( string memory key , AttributeType attributeType , string memory value ) external ; function getAttributesByType ( AttributeType attributeType ) external view returns ( string [] memory keys ); // Verification Status function isVerified () external view returns ( bool ); function getClaimTopics () external view returns ( uint256 [] memory ); function hasClaimTopic ( uint256 claimTopic ) external view returns ( bool ); // Trusted Issuer Integration function isTrustedIssuer ( address issuer ) external view returns ( bool ); function hasTrustedIssuerClaimTopic ( address issuer , uint256 claimTopic ) external view returns ( bool ); } interface ITrustedIssuerRegistry { struct TrustedIssuer { address issuer ; uint256 [] claimTopics ; bool active ; } // Events event TrustedIssuerAdded ( address indexed issuer , uint256 [] claimTopics ); event TrustedIssuerRemoved ( address indexed issuer ); event TrustedIssuerClaimTopicsUpdated ( address indexed issuer , uint256 [] claimTopics ); // Core Functions function addTrustedIssuer ( address issuer , uint256 [] memory claimTopics ) external ; function removeTrustedIssuer ( address issuer ) external ; function updateTrustedIssuerClaimTopics ( address issuer , uint256 [] memory claimTopics ) external ; function isTrustedIssuer ( address issuer ) external view returns ( bool ); function getTrustedIssuerClaimTopics ( address issuer ) external view returns ( uint256 [] memory ); function hasTrustedIssuerClaimTopic ( address issuer , uint256 claimTopic ) external view returns ( bool ); function getAllTrustedIssuers () external view returns ( address [] memory ); } interface IIdentityRegistry { // Events event IdentityRegistered ( address indexed wallet , address indexed identity ); event IdentityUpdated ( address indexed wallet , address indexed identity ); event IdentityRemoved ( address indexed wallet ); // Core Functions function registerIdentity ( address wallet , address identity ) external ; function updateIdentity ( address wallet , address identity ) external ; function removeIdentity ( address wallet ) external ; function getIdentity ( address wallet ) external view returns ( address ); function isRegistered ( address wallet ) external view returns ( bool ); function hasValidClaim ( address wallet , uint256 claimTopic ) external view returns ( bool ); }","title":"Core Interface"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#key-features","text":"","title":"Key Features"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#1-enhanced-attribute-system","text":"Typed Attributes : Support for different data types (string, number, boolean, address, bytes) Structured Storage : Organized attribute management with type-based queries Trusted Issuer Control : Only trusted issuers can set attributes","title":"1. Enhanced Attribute System"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#2-trusted-issuer-management","text":"Claim Topic Authorization : Issuers are authorized for specific claim topics Centralized Registry : Shared trusted issuer registry across applications Dynamic Management : Add, remove, and update issuer permissions","title":"2. Trusted Issuer Management"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#3-verification-integration","text":"Automated Verification : Smart contracts can verify identity claims Claim Topic Validation : Check for specific required claims Status Tracking : Track overall verification status","title":"3. Verification Integration"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#4-access-control-integration","text":"Claim-Based Access : Use identity claims for application access control Flexible Requirements : Configure different claim requirements per application Real-time Validation : Validate claims during transaction execution","title":"4. Access Control Integration"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#claim-topics","text":"Standard claim topics for common use cases: library ClaimTopics { uint256 public constant KYC_VERIFIED = 1 ; uint256 public constant AML_CLEARED = 2 ; uint256 public constant ACCREDITED_INVESTOR = 3 ; uint256 public constant COUNTRY_VERIFICATION = 4 ; uint256 public constant AGE_VERIFICATION = 5 ; uint256 public constant PROFESSIONAL_VERIFICATION = 6 ; uint256 public constant INSTITUTION_VERIFICATION = 7 ; uint256 public constant SANCTIONS_CLEARED = 8 ; }","title":"Claim Topics"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#integration-pattern","text":"contract DeFiApplication { IIdentityRegistry public identityRegistry ; modifier requiresClaim ( uint256 claimTopic ) { require ( identityRegistry . hasValidClaim ( msg.sender , claimTopic ), \"Required claim not found\" ); _ ; } function restrictedFunction () external requiresClaim ( ClaimTopics . KYC_VERIFIED ) { // Function logic here } }","title":"Integration Pattern"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#rationale","text":"","title":"Rationale"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#trusted-issuer-system","text":"A centralized trusted issuer registry enables consistent validation across applications while maintaining decentralization of the identity system itself.","title":"Trusted Issuer System"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#typed-attributes","text":"Supporting different attribute types enables more sophisticated identity data management and reduces parsing overhead in applications.","title":"Typed Attributes"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#claim-topic-authorization","text":"Restricting issuers to specific claim topics prevents unauthorized claim issuance and maintains the integrity of the verification system.","title":"Claim Topic Authorization"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#registry-pattern","text":"Using a registry pattern for identities enables wallet-to-identity mapping while keeping identity contracts upgradeable and transferable.","title":"Registry Pattern"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#implementation-details","text":"","title":"Implementation Details"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#attribute-storage","text":"mapping ( string => Attribute ) private attributes ; mapping ( uint256 => string []) private attributeKeys ; // AttributeType => keys function setAttribute ( string memory key , AttributeType attributeType , string memory value ) external onlyTrustedIssuer { attributes [ key ] = Attribute ( key , attributeType , value ); attributeKeys [ uint256 ( attributeType )]. push ( key ); emit AttributeSet ( key , attributeType , value ); }","title":"Attribute Storage"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#claim-validation","text":"function hasValidClaim ( address wallet , uint256 claimTopic ) external view returns ( bool ) { address identity = getIdentity ( wallet ); if ( identity == address ( 0 )) return false ; bytes32 [] memory claimIds = IEnhancedIdentity ( identity ). getClaimIdsByTopic ( claimTopic ); for ( uint256 i = 0 ; i < claimIds . length ; i ++ ) { (, , address issuer , , ,) = IEnhancedIdentity ( identity ). getClaim ( claimIds [ i ]); if ( trustedIssuerRegistry . hasTrustedIssuerClaimTopic ( issuer , claimTopic )) { return true ; } } return false ; }","title":"Claim Validation"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#security-considerations","text":"Trusted Issuer Management : Secure management of trusted issuer permissions Claim Validation : Proper validation of claim signatures and issuer authorization Access Control : Secure attribute and claim management functions Privacy : Consider privacy implications of on-chain identity data Key Management : Secure key management for identity operations","title":"Security Considerations"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#gas-optimization","text":"Efficient storage patterns for attributes and claims Batch operations for multiple claim validations Optimized lookup mechanisms for trusted issuers Minimal external calls during verification","title":"Gas Optimization"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#backwards-compatibility","text":"This standard extends ERC734 and ERC735 while maintaining compatibility with existing implementations. Applications can gradually adopt enhanced features while continuing to work with basic ERC734/ERC735 identities.","title":"Backwards Compatibility"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#privacy-considerations","text":"While this standard enables powerful identity verification, implementations should consider: - Minimal data disclosure principles - Off-chain storage for sensitive attributes - Zero-knowledge proof integration for privacy-preserving verification - User consent mechanisms for data sharing","title":"Privacy Considerations"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#test-cases","text":"Comprehensive test cases should cover: - Identity registration and management - Trusted issuer operations - Claim validation and verification - Attribute management - Access control integration - Edge cases and error conditions","title":"Test Cases"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#reference-implementation","text":"The reference implementation includes: - Identity.sol - Core identity contract - IIdentity.sol - Interface definition - TrustedIssuersRegistryFacet.sol - Trusted issuer management - IdentityRegistryFacet.sol - Identity registry","title":"Reference Implementation"},{"location":"eips/EIP-DRAFT-Enhanced-Identity-System/#copyright","text":"Copyright and related rights waived via CC0 .","title":"Copyright"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/","text":"EIP-DRAFT: Multi-Token Sale Standard with Proof-Based Purchases \u00b6 Simple Summary \u00b6 A standardized interface for conducting token sales that supports multiple token types (ERC20, ERC721, ERC1155), multiple payment methods, and cryptographic proof-based purchases for allowlists and presales. Abstract \u00b6 This EIP proposes a comprehensive standard for token sales that enables: - Sales of ERC20, ERC721, and ERC1155 tokens through a unified interface - Support for ETH and ERC20 token payments - Cryptographic proof-based purchases (e.g., Merkle proofs for allowlists) - Per-account purchase limits - Variable pricing mechanisms - Integration with identity systems for access control Motivation \u00b6 Current token sale implementations are fragmented across different token types and lack standardization for advanced features like proof-based purchases and multi-payment support. This standard provides a unified approach that can handle various token sale scenarios while maintaining security and flexibility. Specification \u00b6 Core Interface \u00b6 interface IMultiTokenSale { enum TokenType { ERC20 , ERC721 , ERC1155 } enum PaymentMethod { ETH , ERC20 } struct PriceSettings { uint256 price ; // Additional price configuration can be extended } struct MultiSaleSettings { address token ; TokenType tokenType ; address owner ; PriceSettings price ; PaymentMethod paymentMethod ; address paymentToken ; uint256 maxQuantityPerAccount ; // Additional settings... } struct MultiSalePurchase { uint256 multiSaleId ; address purchaser ; address receiver ; uint256 quantity ; } struct MultiSaleProof { bytes proof ; bytes data ; } // Events event MultiSaleCreated ( uint256 indexed tokenSaleId , MultiSaleSettings settings ); event MultiSaleUpdated ( uint256 indexed tokenSaleId , MultiSaleSettings settings ); event MultiSaleSold ( uint256 indexed multiSaleId , address indexed purchaser , uint256 [] tokenIds , bytes data ); // Core Functions function createTokenSale ( MultiSaleSettings memory tokenSaleInit ) external returns ( uint256 tokenSaleId ); function updateTokenSaleSettings ( uint256 tokenSaleId , MultiSaleSettings memory settings ) external ; function purchaseProof ( MultiSalePurchase memory purchaseInfo , MultiSaleProof memory purchaseProofParam ) external payable returns ( uint256 [] memory ids ); function purchase ( uint256 multiSaleId , address purchaser , address receiver , uint256 quantity , bytes memory data ) external payable returns ( uint256 [] memory ids ); function getTokenSaleSettings ( uint256 tokenSaleId ) external view returns ( MultiSaleSettings memory settings ); function getTokenSaleIds () external view returns ( uint256 [] memory ); function listTokenSales () external view returns ( MultiSaleSettings [] memory ); } Key Features \u00b6 1. Multi-Token Support \u00b6 ERC20 : Fungible token sales with quantity-based purchases ERC721 : NFT sales with unique token ID generation ERC1155 : Semi-fungible token sales with ID-based minting 2. Proof-Based Purchases \u00b6 Support for cryptographic proofs (e.g., Merkle proofs) Enables allowlist functionality Presale and whitelist implementations Flexible proof validation system 3. Payment Flexibility \u00b6 Native ETH payments with automatic refunds ERC20 token payments with approval-based transfers Per-sale payment method configuration 4. Purchase Controls \u00b6 Per-account quantity limits Total sale quantity tracking Owner-based access control for sale management Proof System \u00b6 The proof system enables sophisticated access control: // Example Merkle proof verification function verifyMerkleProof ( bytes32 [] memory proof , bytes32 root , bytes32 leaf ) internal pure returns ( bool ) { bytes32 computedHash = leaf ; for ( uint256 i = 0 ; i < proof . length ; i ++ ) { bytes32 proofElement = proof [ i ]; if ( computedHash <= proofElement ) { computedHash = keccak256 ( abi . encodePacked ( computedHash , proofElement )); } else { computedHash = keccak256 ( abi . encodePacked ( proofElement , computedHash )); } } return computedHash == root ; } Rationale \u00b6 Unified Interface \u00b6 A single interface for multiple token types reduces complexity and improves interoperability between different sale implementations. Proof-Based Access Control \u00b6 Cryptographic proofs enable sophisticated access control without requiring on-chain storage of allowlists, reducing gas costs. Flexible Payment System \u00b6 Supporting both ETH and ERC20 payments provides maximum flexibility for different use cases and user preferences. Modular Design \u00b6 The standard is designed to be extensible, allowing implementations to add custom features while maintaining compatibility. Implementation Details \u00b6 Token Minting Strategy \u00b6 function _mintPurchasedTokens ( uint256 multiSaleId , address recipient , uint256 amount , bytes memory data ) internal returns ( uint256 [] memory tokenIds ) { MultiSaleContract storage sale = _tokenSales [ multiSaleId ]; if ( sale . settings . tokenType == TokenType . ERC20 ) { IERC20Mint ( sale . settings . token ). mintTo ( recipient , amount ); return new uint256 []( 0 ); // No specific token IDs for ERC20 } else if ( sale . settings . tokenType == TokenType . ERC721 ) { tokenIds = new uint256 []( amount ); for ( uint256 i = 0 ; i < amount ; i ++ ) { uint256 tokenId = _getNextTokenId (); IERC721Mint ( sale . settings . token ). mintTo ( recipient , 1 , data ); tokenIds [ i ] = tokenId ; } } else if ( sale . settings . tokenType == TokenType . ERC1155 ) { tokenIds = new uint256 []( 1 ); tokenIds [ 0 ] = sale . nonce ++ ; IERC1155Mint ( sale . settings . token ). mintTo ( recipient , tokenIds [ 0 ], amount , data ); } } Security Considerations \u00b6 Reentrancy Protection : All purchase functions must use reentrancy guards Integer Overflow : Use SafeMath or Solidity 0.8+ overflow protection Access Control : Proper validation of sale ownership and permissions Payment Validation : Verify payment amounts and handle excess payments Proof Validation : Secure implementation of proof verification systems Gas Optimization \u00b6 Batch operations where possible Efficient storage patterns Minimal external calls during purchases Optimized proof verification algorithms Backwards Compatibility \u00b6 This standard is designed to work with existing ERC20, ERC721, and ERC1155 token contracts that implement the respective minting interfaces. Test Cases \u00b6 Comprehensive test cases should cover: - Multi-token type sales - Proof-based purchase validation - Payment method handling - Purchase limit enforcement - Access control mechanisms - Edge cases and error conditions Reference Implementation \u00b6 The reference implementation includes: - MultiSaleFacet.sol - Core multi-sale functionality - IMultiSale.sol - Interface definition - MultiSaleLib.sol - Supporting library functions Copyright \u00b6 Copyright and related rights waived via CC0 .","title":"Multi-Token Sale Standard"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#eip-draft-multi-token-sale-standard-with-proof-based-purchases","text":"","title":"EIP-DRAFT: Multi-Token Sale Standard with Proof-Based Purchases"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#simple-summary","text":"A standardized interface for conducting token sales that supports multiple token types (ERC20, ERC721, ERC1155), multiple payment methods, and cryptographic proof-based purchases for allowlists and presales.","title":"Simple Summary"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#abstract","text":"This EIP proposes a comprehensive standard for token sales that enables: - Sales of ERC20, ERC721, and ERC1155 tokens through a unified interface - Support for ETH and ERC20 token payments - Cryptographic proof-based purchases (e.g., Merkle proofs for allowlists) - Per-account purchase limits - Variable pricing mechanisms - Integration with identity systems for access control","title":"Abstract"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#motivation","text":"Current token sale implementations are fragmented across different token types and lack standardization for advanced features like proof-based purchases and multi-payment support. This standard provides a unified approach that can handle various token sale scenarios while maintaining security and flexibility.","title":"Motivation"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#specification","text":"","title":"Specification"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#core-interface","text":"interface IMultiTokenSale { enum TokenType { ERC20 , ERC721 , ERC1155 } enum PaymentMethod { ETH , ERC20 } struct PriceSettings { uint256 price ; // Additional price configuration can be extended } struct MultiSaleSettings { address token ; TokenType tokenType ; address owner ; PriceSettings price ; PaymentMethod paymentMethod ; address paymentToken ; uint256 maxQuantityPerAccount ; // Additional settings... } struct MultiSalePurchase { uint256 multiSaleId ; address purchaser ; address receiver ; uint256 quantity ; } struct MultiSaleProof { bytes proof ; bytes data ; } // Events event MultiSaleCreated ( uint256 indexed tokenSaleId , MultiSaleSettings settings ); event MultiSaleUpdated ( uint256 indexed tokenSaleId , MultiSaleSettings settings ); event MultiSaleSold ( uint256 indexed multiSaleId , address indexed purchaser , uint256 [] tokenIds , bytes data ); // Core Functions function createTokenSale ( MultiSaleSettings memory tokenSaleInit ) external returns ( uint256 tokenSaleId ); function updateTokenSaleSettings ( uint256 tokenSaleId , MultiSaleSettings memory settings ) external ; function purchaseProof ( MultiSalePurchase memory purchaseInfo , MultiSaleProof memory purchaseProofParam ) external payable returns ( uint256 [] memory ids ); function purchase ( uint256 multiSaleId , address purchaser , address receiver , uint256 quantity , bytes memory data ) external payable returns ( uint256 [] memory ids ); function getTokenSaleSettings ( uint256 tokenSaleId ) external view returns ( MultiSaleSettings memory settings ); function getTokenSaleIds () external view returns ( uint256 [] memory ); function listTokenSales () external view returns ( MultiSaleSettings [] memory ); }","title":"Core Interface"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#key-features","text":"","title":"Key Features"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#1-multi-token-support","text":"ERC20 : Fungible token sales with quantity-based purchases ERC721 : NFT sales with unique token ID generation ERC1155 : Semi-fungible token sales with ID-based minting","title":"1. Multi-Token Support"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#2-proof-based-purchases","text":"Support for cryptographic proofs (e.g., Merkle proofs) Enables allowlist functionality Presale and whitelist implementations Flexible proof validation system","title":"2. Proof-Based Purchases"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#3-payment-flexibility","text":"Native ETH payments with automatic refunds ERC20 token payments with approval-based transfers Per-sale payment method configuration","title":"3. Payment Flexibility"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#4-purchase-controls","text":"Per-account quantity limits Total sale quantity tracking Owner-based access control for sale management","title":"4. Purchase Controls"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#proof-system","text":"The proof system enables sophisticated access control: // Example Merkle proof verification function verifyMerkleProof ( bytes32 [] memory proof , bytes32 root , bytes32 leaf ) internal pure returns ( bool ) { bytes32 computedHash = leaf ; for ( uint256 i = 0 ; i < proof . length ; i ++ ) { bytes32 proofElement = proof [ i ]; if ( computedHash <= proofElement ) { computedHash = keccak256 ( abi . encodePacked ( computedHash , proofElement )); } else { computedHash = keccak256 ( abi . encodePacked ( proofElement , computedHash )); } } return computedHash == root ; }","title":"Proof System"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#rationale","text":"","title":"Rationale"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#unified-interface","text":"A single interface for multiple token types reduces complexity and improves interoperability between different sale implementations.","title":"Unified Interface"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#proof-based-access-control","text":"Cryptographic proofs enable sophisticated access control without requiring on-chain storage of allowlists, reducing gas costs.","title":"Proof-Based Access Control"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#flexible-payment-system","text":"Supporting both ETH and ERC20 payments provides maximum flexibility for different use cases and user preferences.","title":"Flexible Payment System"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#modular-design","text":"The standard is designed to be extensible, allowing implementations to add custom features while maintaining compatibility.","title":"Modular Design"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#implementation-details","text":"","title":"Implementation Details"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#token-minting-strategy","text":"function _mintPurchasedTokens ( uint256 multiSaleId , address recipient , uint256 amount , bytes memory data ) internal returns ( uint256 [] memory tokenIds ) { MultiSaleContract storage sale = _tokenSales [ multiSaleId ]; if ( sale . settings . tokenType == TokenType . ERC20 ) { IERC20Mint ( sale . settings . token ). mintTo ( recipient , amount ); return new uint256 []( 0 ); // No specific token IDs for ERC20 } else if ( sale . settings . tokenType == TokenType . ERC721 ) { tokenIds = new uint256 []( amount ); for ( uint256 i = 0 ; i < amount ; i ++ ) { uint256 tokenId = _getNextTokenId (); IERC721Mint ( sale . settings . token ). mintTo ( recipient , 1 , data ); tokenIds [ i ] = tokenId ; } } else if ( sale . settings . tokenType == TokenType . ERC1155 ) { tokenIds = new uint256 []( 1 ); tokenIds [ 0 ] = sale . nonce ++ ; IERC1155Mint ( sale . settings . token ). mintTo ( recipient , tokenIds [ 0 ], amount , data ); } }","title":"Token Minting Strategy"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#security-considerations","text":"Reentrancy Protection : All purchase functions must use reentrancy guards Integer Overflow : Use SafeMath or Solidity 0.8+ overflow protection Access Control : Proper validation of sale ownership and permissions Payment Validation : Verify payment amounts and handle excess payments Proof Validation : Secure implementation of proof verification systems","title":"Security Considerations"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#gas-optimization","text":"Batch operations where possible Efficient storage patterns Minimal external calls during purchases Optimized proof verification algorithms","title":"Gas Optimization"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#backwards-compatibility","text":"This standard is designed to work with existing ERC20, ERC721, and ERC1155 token contracts that implement the respective minting interfaces.","title":"Backwards Compatibility"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#test-cases","text":"Comprehensive test cases should cover: - Multi-token type sales - Proof-based purchase validation - Payment method handling - Purchase limit enforcement - Access control mechanisms - Edge cases and error conditions","title":"Test Cases"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#reference-implementation","text":"The reference implementation includes: - MultiSaleFacet.sol - Core multi-sale functionality - IMultiSale.sol - Interface definition - MultiSaleLib.sol - Supporting library functions","title":"Reference Implementation"},{"location":"eips/EIP-DRAFT-Multi-Token-Sale-Standard/#copyright","text":"Copyright and related rights waived via CC0 .","title":"Copyright"},{"location":"external-services/gemforce-external-services/","text":"Gemforce External Services Integration \u00b6 This document provides detailed information about the external services and third-party integrations used by the Gemforce platform. Understanding these services is essential for developers working with the Gemforce API. DFNS Wallet-as-a-Service \u00b6 DFNS provides a secure and user-friendly wallet management system that Gemforce uses for managing blockchain transactions. Overview \u00b6 DFNS is a wallet-as-a-service platform that offers: - Non-custodial wallet management - WebAuthn-based authentication - Transaction signing without exposing private keys - Delegated transaction execution Integration Points \u00b6 Gemforce integrates with DFNS via: - DFNS API Client - DFNS Delegated API Client Key Features Used \u00b6 User Registration & Authentication WebAuthn-based registration Passwordless authentication Recovery mechanisms Wallet Management Wallet creation Asset listing Transaction history Transaction Signing Challenge-based signing Two-step transaction process (Init/Complete) Delegated transaction execution API Flow \u00b6 Client App <-> Gemforce Cloud Functions <-> DFNS API Client initiates a request to Gemforce Cloud Functions Gemforce creates a transaction payload and requests a challenge from DFNS Challenge is passed to the client for signing with WebAuthn Signed challenge is sent back to Gemforce Gemforce completes the transaction with DFNS DFNS broadcasts the transaction to the blockchain Configuration \u00b6 DFNS requires the following environment variables: - DFNS_APP_ID : Application ID for DFNS - DFNS_API_URL : Base URL for DFNS API - DFNS_CRED_ID : Credential ID for DFNS - DFNS_AUTH_TOKEN : Authentication token (for server operations) Bridge API Integration \u00b6 Bridge API provides financial services integration for Gemforce, enabling external account management, transfers, and KYC processes. Overview \u00b6 Bridge API offers: - External account management - Transfer operations between traditional finance and crypto - KYC verification - Plaid integration for banking connections Integration Points \u00b6 Gemforce integrates with Bridge API via RESTful HTTP endpoints. Key Features Used \u00b6 External Account Management Creation of external accounts Multiple account types (US, IBAN) Account listing and retrieval Account deletion Transfer Operations Cross-currency transfers Multiple payment rails (ACH, SEPA, Wire, Blockchain) Transfer status tracking Idempotent operations KYC Management KYC link generation KYC status tracking Individual and business verification Plaid Integration Link token generation Token exchange Account verification API Flow \u00b6 Client App <-> Gemforce Cloud Functions <-> Bridge API Client app calls Gemforce Cloud Functions Gemforce validates and formats the request Gemforce calls Bridge API with appropriate headers Bridge API processes the request and returns a response Gemforce processes and returns the response to the client Configuration \u00b6 Bridge API requires the following environment variables: - BASE_BRIDGE_URL : Base URL for Bridge API - BRIDGE_API_KEY : API key for authentication Parse Server \u00b6 Parse Server provides the backend infrastructure for Gemforce's cloud functions and data storage. Overview \u00b6 Parse Server offers: - User authentication and management - Cloud functions - Database operations - File storage - Push notifications Integration Points \u00b6 Gemforce uses Parse Server as the primary backend platform. Key Features Used \u00b6 User Management Registration Email verification Password reset Session management Cloud Functions Blockchain operations DFNS integration Bridge API integration Business logic Data Storage User profiles Blockchain data Identity information Transaction history Role-Based Access Control User roles Permission management Object-level ACLs Configuration \u00b6 Parse Server requires the following environment variables: - APP_ID : Parse application ID - MASTER_KEY : Parse master key - DATABASE_URI : MongoDB connection string - SERVER_URL : Parse Server URL - PROJECT_WIZARD_URL : URL for the project wizard Ethereum Blockchain Networks \u00b6 Gemforce interacts with multiple Ethereum-compatible blockchain networks. Overview \u00b6 Gemforce supports multiple blockchain networks including: - Ethereum Mainnet - BaseSepolia - Other EVM-compatible networks Integration Points \u00b6 Gemforce interacts with blockchain networks via: - JSON-RPC providers - WebSocket connections Key Features Used \u00b6 Smart Contract Deployment Diamond contract deployment Facet deployment Contract initialization Transaction Submission Method calls Value transfers Contract interactions Event Monitoring WebSocket subscriptions Event filtering Log parsing State Reading View function calls State synchronization Configuration \u00b6 Blockchain integration requires the following environment variables: - ETH_NODE_URI_[NETWORK] : JSON-RPC endpoint for each network - CHAIN_ID : ID of the default chain - METADATA_BASE_URI : Base URI for token metadata SendGrid Email Service \u00b6 SendGrid is used for transactional email communications. Overview \u00b6 SendGrid provides email delivery services for: - User verification - Password reset - Notifications - Other transactional emails Integration Points \u00b6 Gemforce uses SendGrid's Node.js SDK. Key Features Used \u00b6 Email Templates EJS templating HTML email content Dynamic content insertion Email Sending Transactional emails HTML content Attachments Configuration \u00b6 SendGrid requires the following environment variables: - SendGrid API key (configured through environment variables) - From email address Plaid (via Bridge API) \u00b6 Plaid is integrated through Bridge API to provide banking connection services. Overview \u00b6 Plaid offers: - Bank account verification - Account linking - Transaction history - Balance information Integration Points \u00b6 Gemforce interacts with Plaid through Bridge API. Key Features Used \u00b6 Link Token Creation Generated for each user session Configured for specific use cases Public Token Exchange Convert public tokens to access tokens Securely store access tokens API Flow \u00b6 Client App <-> Plaid Link <-> Client App <-> Gemforce <-> Bridge API <-> Plaid Client requests a Plaid link token from Gemforce Gemforce obtains the token through Bridge API Client uses the token with Plaid Link Plaid Link provides a public token to the client Client sends the public token to Gemforce Gemforce exchanges it via Bridge API Bridge API handles Plaid API communication Integration Diagram \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Client App \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 Parse Server \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba DFNS \u2502 \u2502 (Cloud Functions)\u2502 \u2502 Wallet-as-Service \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 Blockchain \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Networks \u2502 \u2502 \u2502 Bridge API \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - Ethereum Mainnet \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 - BaseSepolia \u2502 \u2502 \u2502 \u2502 \u2502 - Others \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Plaid \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25b2 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Smart Contracts \u2502 \u2502 \u2502 \u2502 - Diamond \u2502 \u2502 - Identity System \u2502 \u2502 - Asset Management \u2502 \u2502 - Carbon Credits \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Authentication Flows \u00b6 User Registration & Login \u00b6 User registers through Parse Server Email verification is sent via SendGrid User verifies email User logs in with username/password Parse Server creates a session token DFNS Registration \u00b6 User initiates DFNS registration Gemforce requests a registration challenge from DFNS User completes WebAuthn registration on client Signed challenge is sent to Gemforce Gemforce completes registration with DFNS DFNS creates a wallet for the user Bridge API Authentication \u00b6 Bridge API authentication is handled server-side with API keys. The client never interacts directly with Bridge API credentials. Security Considerations \u00b6 API Keys & Secrets \u00b6 All API keys and secrets are stored as environment variables API keys are never exposed to clients All external API calls are made server-side Delegated Authentication \u00b6 DFNS uses delegated authentication Client never has access to private keys WebAuthn provides phishing-resistant authentication Idempotency \u00b6 Bridge API calls use idempotency keys Prevents duplicate transactions Allows safe retries Rate Limiting \u00b6 DFNS \u00b6 DFNS imposes rate limits on API calls Gemforce implements exponential backoff for retries Bridge API \u00b6 Bridge API has rate limits based on API key Gemforce handles rate limit errors Error Handling \u00b6 DFNS Errors \u00b6 Challenge-related errors WebAuthn errors Transaction errors Bridge API Errors \u00b6 Validation errors Processing errors External account errors KYC errors Blockchain Errors \u00b6 Gas-related errors Transaction failure Network congestion Monitoring & Logging \u00b6 All external service interactions are logged for: - Debugging - Audit trails - Performance monitoring - Error tracking Conclusion \u00b6 Gemforce integrates with several external services to provide a comprehensive platform. Understanding these integrations is crucial for effectively working with the Gemforce API.","title":"External Services"},{"location":"external-services/gemforce-external-services/#gemforce-external-services-integration","text":"This document provides detailed information about the external services and third-party integrations used by the Gemforce platform. Understanding these services is essential for developers working with the Gemforce API.","title":"Gemforce External Services Integration"},{"location":"external-services/gemforce-external-services/#dfns-wallet-as-a-service","text":"DFNS provides a secure and user-friendly wallet management system that Gemforce uses for managing blockchain transactions.","title":"DFNS Wallet-as-a-Service"},{"location":"external-services/gemforce-external-services/#overview","text":"DFNS is a wallet-as-a-service platform that offers: - Non-custodial wallet management - WebAuthn-based authentication - Transaction signing without exposing private keys - Delegated transaction execution","title":"Overview"},{"location":"external-services/gemforce-external-services/#integration-points","text":"Gemforce integrates with DFNS via: - DFNS API Client - DFNS Delegated API Client","title":"Integration Points"},{"location":"external-services/gemforce-external-services/#key-features-used","text":"User Registration & Authentication WebAuthn-based registration Passwordless authentication Recovery mechanisms Wallet Management Wallet creation Asset listing Transaction history Transaction Signing Challenge-based signing Two-step transaction process (Init/Complete) Delegated transaction execution","title":"Key Features Used"},{"location":"external-services/gemforce-external-services/#api-flow","text":"Client App <-> Gemforce Cloud Functions <-> DFNS API Client initiates a request to Gemforce Cloud Functions Gemforce creates a transaction payload and requests a challenge from DFNS Challenge is passed to the client for signing with WebAuthn Signed challenge is sent back to Gemforce Gemforce completes the transaction with DFNS DFNS broadcasts the transaction to the blockchain","title":"API Flow"},{"location":"external-services/gemforce-external-services/#configuration","text":"DFNS requires the following environment variables: - DFNS_APP_ID : Application ID for DFNS - DFNS_API_URL : Base URL for DFNS API - DFNS_CRED_ID : Credential ID for DFNS - DFNS_AUTH_TOKEN : Authentication token (for server operations)","title":"Configuration"},{"location":"external-services/gemforce-external-services/#bridge-api-integration","text":"Bridge API provides financial services integration for Gemforce, enabling external account management, transfers, and KYC processes.","title":"Bridge API Integration"},{"location":"external-services/gemforce-external-services/#overview_1","text":"Bridge API offers: - External account management - Transfer operations between traditional finance and crypto - KYC verification - Plaid integration for banking connections","title":"Overview"},{"location":"external-services/gemforce-external-services/#integration-points_1","text":"Gemforce integrates with Bridge API via RESTful HTTP endpoints.","title":"Integration Points"},{"location":"external-services/gemforce-external-services/#key-features-used_1","text":"External Account Management Creation of external accounts Multiple account types (US, IBAN) Account listing and retrieval Account deletion Transfer Operations Cross-currency transfers Multiple payment rails (ACH, SEPA, Wire, Blockchain) Transfer status tracking Idempotent operations KYC Management KYC link generation KYC status tracking Individual and business verification Plaid Integration Link token generation Token exchange Account verification","title":"Key Features Used"},{"location":"external-services/gemforce-external-services/#api-flow_1","text":"Client App <-> Gemforce Cloud Functions <-> Bridge API Client app calls Gemforce Cloud Functions Gemforce validates and formats the request Gemforce calls Bridge API with appropriate headers Bridge API processes the request and returns a response Gemforce processes and returns the response to the client","title":"API Flow"},{"location":"external-services/gemforce-external-services/#configuration_1","text":"Bridge API requires the following environment variables: - BASE_BRIDGE_URL : Base URL for Bridge API - BRIDGE_API_KEY : API key for authentication","title":"Configuration"},{"location":"external-services/gemforce-external-services/#parse-server","text":"Parse Server provides the backend infrastructure for Gemforce's cloud functions and data storage.","title":"Parse Server"},{"location":"external-services/gemforce-external-services/#overview_2","text":"Parse Server offers: - User authentication and management - Cloud functions - Database operations - File storage - Push notifications","title":"Overview"},{"location":"external-services/gemforce-external-services/#integration-points_2","text":"Gemforce uses Parse Server as the primary backend platform.","title":"Integration Points"},{"location":"external-services/gemforce-external-services/#key-features-used_2","text":"User Management Registration Email verification Password reset Session management Cloud Functions Blockchain operations DFNS integration Bridge API integration Business logic Data Storage User profiles Blockchain data Identity information Transaction history Role-Based Access Control User roles Permission management Object-level ACLs","title":"Key Features Used"},{"location":"external-services/gemforce-external-services/#configuration_2","text":"Parse Server requires the following environment variables: - APP_ID : Parse application ID - MASTER_KEY : Parse master key - DATABASE_URI : MongoDB connection string - SERVER_URL : Parse Server URL - PROJECT_WIZARD_URL : URL for the project wizard","title":"Configuration"},{"location":"external-services/gemforce-external-services/#ethereum-blockchain-networks","text":"Gemforce interacts with multiple Ethereum-compatible blockchain networks.","title":"Ethereum Blockchain Networks"},{"location":"external-services/gemforce-external-services/#overview_3","text":"Gemforce supports multiple blockchain networks including: - Ethereum Mainnet - BaseSepolia - Other EVM-compatible networks","title":"Overview"},{"location":"external-services/gemforce-external-services/#integration-points_3","text":"Gemforce interacts with blockchain networks via: - JSON-RPC providers - WebSocket connections","title":"Integration Points"},{"location":"external-services/gemforce-external-services/#key-features-used_3","text":"Smart Contract Deployment Diamond contract deployment Facet deployment Contract initialization Transaction Submission Method calls Value transfers Contract interactions Event Monitoring WebSocket subscriptions Event filtering Log parsing State Reading View function calls State synchronization","title":"Key Features Used"},{"location":"external-services/gemforce-external-services/#configuration_3","text":"Blockchain integration requires the following environment variables: - ETH_NODE_URI_[NETWORK] : JSON-RPC endpoint for each network - CHAIN_ID : ID of the default chain - METADATA_BASE_URI : Base URI for token metadata","title":"Configuration"},{"location":"external-services/gemforce-external-services/#sendgrid-email-service","text":"SendGrid is used for transactional email communications.","title":"SendGrid Email Service"},{"location":"external-services/gemforce-external-services/#overview_4","text":"SendGrid provides email delivery services for: - User verification - Password reset - Notifications - Other transactional emails","title":"Overview"},{"location":"external-services/gemforce-external-services/#integration-points_4","text":"Gemforce uses SendGrid's Node.js SDK.","title":"Integration Points"},{"location":"external-services/gemforce-external-services/#key-features-used_4","text":"Email Templates EJS templating HTML email content Dynamic content insertion Email Sending Transactional emails HTML content Attachments","title":"Key Features Used"},{"location":"external-services/gemforce-external-services/#configuration_4","text":"SendGrid requires the following environment variables: - SendGrid API key (configured through environment variables) - From email address","title":"Configuration"},{"location":"external-services/gemforce-external-services/#plaid-via-bridge-api","text":"Plaid is integrated through Bridge API to provide banking connection services.","title":"Plaid (via Bridge API)"},{"location":"external-services/gemforce-external-services/#overview_5","text":"Plaid offers: - Bank account verification - Account linking - Transaction history - Balance information","title":"Overview"},{"location":"external-services/gemforce-external-services/#integration-points_5","text":"Gemforce interacts with Plaid through Bridge API.","title":"Integration Points"},{"location":"external-services/gemforce-external-services/#key-features-used_5","text":"Link Token Creation Generated for each user session Configured for specific use cases Public Token Exchange Convert public tokens to access tokens Securely store access tokens","title":"Key Features Used"},{"location":"external-services/gemforce-external-services/#api-flow_2","text":"Client App <-> Plaid Link <-> Client App <-> Gemforce <-> Bridge API <-> Plaid Client requests a Plaid link token from Gemforce Gemforce obtains the token through Bridge API Client uses the token with Plaid Link Plaid Link provides a public token to the client Client sends the public token to Gemforce Gemforce exchanges it via Bridge API Bridge API handles Plaid API communication","title":"API Flow"},{"location":"external-services/gemforce-external-services/#integration-diagram","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Client App \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 Parse Server \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba DFNS \u2502 \u2502 (Cloud Functions)\u2502 \u2502 Wallet-as-Service \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 Blockchain \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Networks \u2502 \u2502 \u2502 Bridge API \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - Ethereum Mainnet \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 - BaseSepolia \u2502 \u2502 \u2502 \u2502 \u2502 - Others \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Plaid \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25b2 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Smart Contracts \u2502 \u2502 \u2502 \u2502 - Diamond \u2502 \u2502 - Identity System \u2502 \u2502 - Asset Management \u2502 \u2502 - Carbon Credits \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Integration Diagram"},{"location":"external-services/gemforce-external-services/#authentication-flows","text":"","title":"Authentication Flows"},{"location":"external-services/gemforce-external-services/#user-registration-login","text":"User registers through Parse Server Email verification is sent via SendGrid User verifies email User logs in with username/password Parse Server creates a session token","title":"User Registration &amp; Login"},{"location":"external-services/gemforce-external-services/#dfns-registration","text":"User initiates DFNS registration Gemforce requests a registration challenge from DFNS User completes WebAuthn registration on client Signed challenge is sent to Gemforce Gemforce completes registration with DFNS DFNS creates a wallet for the user","title":"DFNS Registration"},{"location":"external-services/gemforce-external-services/#bridge-api-authentication","text":"Bridge API authentication is handled server-side with API keys. The client never interacts directly with Bridge API credentials.","title":"Bridge API Authentication"},{"location":"external-services/gemforce-external-services/#security-considerations","text":"","title":"Security Considerations"},{"location":"external-services/gemforce-external-services/#api-keys-secrets","text":"All API keys and secrets are stored as environment variables API keys are never exposed to clients All external API calls are made server-side","title":"API Keys &amp; Secrets"},{"location":"external-services/gemforce-external-services/#delegated-authentication","text":"DFNS uses delegated authentication Client never has access to private keys WebAuthn provides phishing-resistant authentication","title":"Delegated Authentication"},{"location":"external-services/gemforce-external-services/#idempotency","text":"Bridge API calls use idempotency keys Prevents duplicate transactions Allows safe retries","title":"Idempotency"},{"location":"external-services/gemforce-external-services/#rate-limiting","text":"","title":"Rate Limiting"},{"location":"external-services/gemforce-external-services/#dfns","text":"DFNS imposes rate limits on API calls Gemforce implements exponential backoff for retries","title":"DFNS"},{"location":"external-services/gemforce-external-services/#bridge-api","text":"Bridge API has rate limits based on API key Gemforce handles rate limit errors","title":"Bridge API"},{"location":"external-services/gemforce-external-services/#error-handling","text":"","title":"Error Handling"},{"location":"external-services/gemforce-external-services/#dfns-errors","text":"Challenge-related errors WebAuthn errors Transaction errors","title":"DFNS Errors"},{"location":"external-services/gemforce-external-services/#bridge-api-errors","text":"Validation errors Processing errors External account errors KYC errors","title":"Bridge API Errors"},{"location":"external-services/gemforce-external-services/#blockchain-errors","text":"Gas-related errors Transaction failure Network congestion","title":"Blockchain Errors"},{"location":"external-services/gemforce-external-services/#monitoring-logging","text":"All external service interactions are logged for: - Debugging - Audit trails - Performance monitoring - Error tracking","title":"Monitoring &amp; Logging"},{"location":"external-services/gemforce-external-services/#conclusion","text":"Gemforce integrates with several external services to provide a comprehensive platform. Understanding these integrations is crucial for effectively working with the Gemforce API.","title":"Conclusion"},{"location":"integrator-guide/authentication/","text":"Integrator's Guide: Authentication \u00b6 Authentication is a critical component for any application integrating with the Gemforce platform. This guide outlines the various authentication mechanisms available, focusing on how your application can securely interact with Gemforce's public APIs, cloud functions, and smart contracts. Overview of Gemforce Authentication \u00b6 Gemforce provides a multi-layered authentication strategy to accommodate different integration scenarios: User Authentication (Parse Server Backend) : For client-side applications (web, mobile) that need to manage user accounts, sessions, and interact with cloud functions on behalf of a specific user. This often involves username/password, email/password, or social logins. API Key Authentication : For server-to-server integrations or trusted backend services that need programmatic access to Gemforce's cloud functions and data, typically without a specific end-user context. Smart Contract Interaction (Wallet-based) : Direct interaction with on-chain smart contracts requires users to sign transactions using their blockchain wallets (e.g., MetaMask, WalletConnect). This is not a direct \"authentication\" to Gemforce's backend but rather a cryptographic signature validating an on-chain action. DFNS Integration : For enhanced security and enterprise-grade key management, Gemforce supports integration with DFNS for secure transaction signing. 1. User Authentication (Parse Server Backend) \u00b6 Gemforce's cloud functions utilize a Parse Server backend. Client applications typically authenticate users directly with the Parse Server instance. Authentication Methods \u00b6 Username/Email & Password : The most common method for user login. Social Logins : Support for third-party authentication providers (e.g., Google, Facebook) can be configured. Session Tokens : After successful login, the Parse Server returns a session token that should be stored securely on the client-side and included in subsequent API requests. Flow for Client Applications \u00b6 Sign Up : POST /users (Parse Server REST API) Example: Register a new user with username and password. Log In : GET /login (Parse Server REST API) Send username/password in _ApplicationId , _ClientKey , _Username , _Password headers. Receive sessionToken in response. Authenticated Requests : Include the X-Parse-Session-Token header in all subsequent requests to cloud functions or protected data. Example (JavaScript/TypeScript) \u00b6 // Assuming you have Parse SDK initialized or using direct REST calls // Example using Fetch API for direct REST call const PARSE_SERVER_URL = \"YOUR_GEMFORCE_PARSE_SERVER_URL/parse\" ; const APP_ID = \"YOUR_PARSE_APP_ID\" ; const CLIENT_KEY = \"YOUR_PARSE_CLIENT_KEY\" ; // Or Master Key for backend // User Sign Up async function signUp ( username , password , email ) { const response = await fetch ( ` ${ PARSE_SERVER_URL } /users` , { method : 'POST' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : CLIENT_KEY , 'Content-Type' : 'application/json' }, body : JSON . stringify ({ username : username , password : password , email : email }) }); const data = await response . json (); if ( ! response . ok ) { throw new Error ( data . error || 'Sign up failed' ); } console . log ( \"Sign up successful:\" , data ); return data ; // Contains sessionToken } // User Log In async function login ( username , password ) { const response = await fetch ( ` ${ PARSE_SERVER_URL } /login?username= ${ username } &password= ${ password } ` , { method : 'GET' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : CLIENT_KEY // Use Client Key for client-side API } }); const data = await response . json (); if ( ! response . ok ) { throw new Error ( data . error || 'Login failed' ); } console . log ( \"Login successful, session token:\" , data . sessionToken ); return data . sessionToken ; } // Authenticated Request to a Cloud Function async function callCloudFunction ( functionName , params , sessionToken ) { const response = await fetch ( ` ${ PARSE_SERVER_URL } /functions/ ${ functionName } ` , { method : 'POST' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : CLIENT_KEY , 'X-Parse-Session-Token' : sessionToken , // Include session token 'Content-Type' : 'application/json' }, body : JSON . stringify ( params ) }); const data = await response . json (); if ( ! response . ok ) { throw new Error ( data . error || `Cloud function ${ functionName } failed` ); } console . log ( `Cloud function ${ functionName } response:` , data . result ); return data . result ; } // Example usage: ( async () => { try { // await signUp(\"testuser1\", \"password123\", \"test1@example.com\"); const token = await login ( \"testuser1\" , \"password123\" ); const result = await callCloudFunction ( \"helloWorld\" , { message : \"from integrator\" }, token ); } catch ( e ) { console . error ( \"Authentication error:\" , e . message ); } })(); 2. API Key Authentication (Server-to-Server) \u00b6 For backend services or scripts that need direct access to cloud functions without an explicit user session, Gemforce uses API keys. These keys are configured on the Parse Server and grant specific permissions. Types of API Keys \u00b6 REST API Key ( X-Parse-REST-API-Key ) : Used for access from trusted client applications (if masterKeyAsUser is false ) or for read-only access. Master Key ( X-Parse-Master-Key ) : Grants full administrative privileges and bypasses all Class-Level Permissions (CLPs) and Access Control Lists (ACLs). Use with extreme caution and only in secure server environments. Example (Node.js) \u00b6 const express = require ( 'express' ); const ParseServer = require ( 'parse-server' ). ParseServer ; const Parse = require ( 'parse/node' ); // Import Parse SDK for Node.js environments // --- Initialize Parse SDK (usually done globally once) --- Parse . initialize ( \"YOUR_PARSE_APP_ID\" , \"YOUR_PARSE_JAVASCRIPT_KEY\" , \"YOUR_PARSE_MASTER_KEY\" ); Parse . serverURL = \"YOUR_GEMFORCE_PARSE_SERVER_URL/parse\" ; async function callCloudFunctionWithMasterKey ( functionName , params ) { try { // Use Parse.Cloud.run directly in Node.js, it will use the initialized Master Key const result = await Parse . Cloud . run ( functionName , params , { useMasterKey : true // Use Master Key for this request }); console . log ( `Cloud function ${ functionName } response:` , result ); return result ; } catch ( e ) { console . error ( `Cloud function ${ functionName } failed:` , e . message ); throw e ; } } // Example usage: ( async () => { try { const adminResult = await callCloudFunctionWithMasterKey ( \"processAdminTask\" , { userId : \"someUserId\" }); } catch ( e ) { console . error ( \"Admin task error:\" , e . message ); } })(); 3. Smart Contract Interaction (Wallet-based) \u00b6 Direct interaction with Gemforce's smart contracts (Diamond, Facets, ERC-20/721/1155) occurs directly on the blockchain. This involves: Connecting a Web3 wallet : Users connect their browser-based or mobile wallets (e.g., MetaMask, WalletConnect) to your dApp. Signing Transactions : Users sign transactions using their private keys to perform on-chain operations (e.g., mint NFT, transfer tokens, interact with a trade deal). No Centralized Authentication : There is no centralized authentication for smart contract calls; the blockchain validates the cryptographic signature against the sender's address. Key Tools & Libraries \u00b6 Ethers.js / Web3.js : JavaScript libraries for interacting with the Ethereum blockchain. Wagmi / Web3Modal : Libraries for simplifying wallet connection in frontend applications. Hardhat / Foundry : Development environments for smart contract testing and deployment. Example (Ethers.js for signing a transaction) \u00b6 import { ethers } from 'ethers' ; // Assuming you have the ABI for the smart contract you want to interact with import MyContractABI from './MyContract.json' ; const CONTRACT_ADDRESS = \"0x...\" ; // Address of the deployed Gemforce smart contract const PROVIDER_URL = \"https://sepolia.base.org\" ; // Or use window.ethereum for browser dApps async function interactWithSmartContract () { try { // Connect to the user's wallet // For browser environments, use window.ethereum // const provider = new ethers.providers.Web3Provider(window.ethereum); // await provider.send(\"eth_requestAccounts\", []); // Request account access // const signer = provider.getSigner(); // For Node.js/backend automation (using a private key) const provider = new ethers . JsonRpcProvider ( PROVIDER_URL ); const privateKey = \"YOUR_PRIVATE_KEY\" ; // Keep this secure! For demo only. const signer = new ethers . Wallet ( privateKey , provider ); // Create a contract instance const myContract = new ethers . Contract ( CONTRACT_ADDRESS , MyContractABI , signer ); // Example: Call a function that changes state (requires gas) const tx = await myContract . someStateChangingFunction ( \"some_parameter\" , { value : ethers.parseEther ( \"0.1\" ) }); console . log ( \"Transaction sent:\" , tx . hash ); // Wait for the transaction to be mined const receipt = await tx . wait (); console . log ( \"Transaction confirmed in block:\" , receipt . blockNumber ); // Example: Call a read-only function (does not require gas, no transaction) const result = await myContract . someViewFunction (); console . log ( \"View function result:\" , result ); } catch ( error ) { console . error ( \"Smart contract interaction error:\" , error ); } } // interactWithSmartContract(); 4. DFNS Integration \u00b6 DFNS provides a secure, MPC-based Wallet-as-a-Service solution used within Gemforce. For integrators requiring advanced key management, higher security assurances, or compliance needs, direct integration with DFNS may be an option. Key Benefits \u00b6 Multi-Party Computation (MPC) : Keys are split and never entirely reside in one place, enhancing security. Policy Engine : Define granular policies for transaction signing (e.g., multi-signature approvals). Audit Trails : Comprehensive logs of all key operations. Integration Approach \u00b6 Typically, your backend service would communicate with the DFNS API, which then orchestrates the secure signing of blockchain transactions. API Keys/Authentication : Authenticate with DFNS using their SDKs and API keys. Transaction Requests : Submit transaction payloads to DFNS for signing. Policy Enforcement : DFNS applies predefined policies (e.g., requiring multiple approvals) before signing. Signed Transaction : DFNS returns a signed transaction that your service can then broadcast to the blockchain. Example (Conceptual with DFNS SDK) \u00b6 // This is a conceptual example, actual DFNS SDK usage may vary. import { DfnsApiClient , AsymmetricKeys , SignatureMechanism , SignTransactionRequest } from '@dfns/sdk' ; const DFNS_API_URL = \"https://api.dfns.io\" ; const DFNS_APP_ID = \"YOUR_DFNS_APP_ID\" ; const DFNS_AUTH_TOKEN = \"YOUR_DFNS_AUTH_TOKEN\" ; // Generated from a private key & secret async function signTransactionWithDFNS ( walletId : string , chainId : string , transactionPayload : any ) { try { const dfnsClient = new DfnsApiClient ({ baseUrl : DFNS_API_URL , appId : DFNS_APP_ID , authToken : DFNS_AUTH_TOKEN , // Or use a signing key provider authMethod : new AsymmetricKeys ({ // This would involve loading private keys securely in a real app privateKey : \"...\" , signingKeyId : \"...\" , }) }); const signRequest : SignTransactionRequest = { walletId : walletId , chainId : chainId , payload : JSON.stringify ( transactionPayload ), signatureMechanism : SignatureMechanism.JsonRpc , transactionType : \"EvmTransaction\" , // or other types }; const response = await dfnsClient . wallet . signTransaction ( signRequest ); console . log ( \"DFNS Signed Transaction:\" , response . signedData ); return response . signedData ; // Contains the raw signed transaction to broadcast } catch ( error ) { console . error ( \"DFNS signing error:\" , error ); throw error ; } } // Example usage: // const signedTx = await signTransactionWithDFNS( // \"some-dfns-wallet-uuid\", // \"eip155:11155111\", // Sepolia chain ID // { // to: \"0x...\", // value: \"0\", // gasLimit: \"21000\", // data: \"0x...\" // } // ); // // Then broadcast signedTx to the blockchain Related Documentation \u00b6 Cloud Functions: Authentication Functions Cloud Functions: DFNS Functions Parse Server REST API Documentation (External) DFNS Documentation (External)","title":"Authentication"},{"location":"integrator-guide/authentication/#integrators-guide-authentication","text":"Authentication is a critical component for any application integrating with the Gemforce platform. This guide outlines the various authentication mechanisms available, focusing on how your application can securely interact with Gemforce's public APIs, cloud functions, and smart contracts.","title":"Integrator's Guide: Authentication"},{"location":"integrator-guide/authentication/#overview-of-gemforce-authentication","text":"Gemforce provides a multi-layered authentication strategy to accommodate different integration scenarios: User Authentication (Parse Server Backend) : For client-side applications (web, mobile) that need to manage user accounts, sessions, and interact with cloud functions on behalf of a specific user. This often involves username/password, email/password, or social logins. API Key Authentication : For server-to-server integrations or trusted backend services that need programmatic access to Gemforce's cloud functions and data, typically without a specific end-user context. Smart Contract Interaction (Wallet-based) : Direct interaction with on-chain smart contracts requires users to sign transactions using their blockchain wallets (e.g., MetaMask, WalletConnect). This is not a direct \"authentication\" to Gemforce's backend but rather a cryptographic signature validating an on-chain action. DFNS Integration : For enhanced security and enterprise-grade key management, Gemforce supports integration with DFNS for secure transaction signing.","title":"Overview of Gemforce Authentication"},{"location":"integrator-guide/authentication/#1-user-authentication-parse-server-backend","text":"Gemforce's cloud functions utilize a Parse Server backend. Client applications typically authenticate users directly with the Parse Server instance.","title":"1. User Authentication (Parse Server Backend)"},{"location":"integrator-guide/authentication/#authentication-methods","text":"Username/Email & Password : The most common method for user login. Social Logins : Support for third-party authentication providers (e.g., Google, Facebook) can be configured. Session Tokens : After successful login, the Parse Server returns a session token that should be stored securely on the client-side and included in subsequent API requests.","title":"Authentication Methods"},{"location":"integrator-guide/authentication/#flow-for-client-applications","text":"Sign Up : POST /users (Parse Server REST API) Example: Register a new user with username and password. Log In : GET /login (Parse Server REST API) Send username/password in _ApplicationId , _ClientKey , _Username , _Password headers. Receive sessionToken in response. Authenticated Requests : Include the X-Parse-Session-Token header in all subsequent requests to cloud functions or protected data.","title":"Flow for Client Applications"},{"location":"integrator-guide/authentication/#example-javascripttypescript","text":"// Assuming you have Parse SDK initialized or using direct REST calls // Example using Fetch API for direct REST call const PARSE_SERVER_URL = \"YOUR_GEMFORCE_PARSE_SERVER_URL/parse\" ; const APP_ID = \"YOUR_PARSE_APP_ID\" ; const CLIENT_KEY = \"YOUR_PARSE_CLIENT_KEY\" ; // Or Master Key for backend // User Sign Up async function signUp ( username , password , email ) { const response = await fetch ( ` ${ PARSE_SERVER_URL } /users` , { method : 'POST' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : CLIENT_KEY , 'Content-Type' : 'application/json' }, body : JSON . stringify ({ username : username , password : password , email : email }) }); const data = await response . json (); if ( ! response . ok ) { throw new Error ( data . error || 'Sign up failed' ); } console . log ( \"Sign up successful:\" , data ); return data ; // Contains sessionToken } // User Log In async function login ( username , password ) { const response = await fetch ( ` ${ PARSE_SERVER_URL } /login?username= ${ username } &password= ${ password } ` , { method : 'GET' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : CLIENT_KEY // Use Client Key for client-side API } }); const data = await response . json (); if ( ! response . ok ) { throw new Error ( data . error || 'Login failed' ); } console . log ( \"Login successful, session token:\" , data . sessionToken ); return data . sessionToken ; } // Authenticated Request to a Cloud Function async function callCloudFunction ( functionName , params , sessionToken ) { const response = await fetch ( ` ${ PARSE_SERVER_URL } /functions/ ${ functionName } ` , { method : 'POST' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : CLIENT_KEY , 'X-Parse-Session-Token' : sessionToken , // Include session token 'Content-Type' : 'application/json' }, body : JSON . stringify ( params ) }); const data = await response . json (); if ( ! response . ok ) { throw new Error ( data . error || `Cloud function ${ functionName } failed` ); } console . log ( `Cloud function ${ functionName } response:` , data . result ); return data . result ; } // Example usage: ( async () => { try { // await signUp(\"testuser1\", \"password123\", \"test1@example.com\"); const token = await login ( \"testuser1\" , \"password123\" ); const result = await callCloudFunction ( \"helloWorld\" , { message : \"from integrator\" }, token ); } catch ( e ) { console . error ( \"Authentication error:\" , e . message ); } })();","title":"Example (JavaScript/TypeScript)"},{"location":"integrator-guide/authentication/#2-api-key-authentication-server-to-server","text":"For backend services or scripts that need direct access to cloud functions without an explicit user session, Gemforce uses API keys. These keys are configured on the Parse Server and grant specific permissions.","title":"2. API Key Authentication (Server-to-Server)"},{"location":"integrator-guide/authentication/#types-of-api-keys","text":"REST API Key ( X-Parse-REST-API-Key ) : Used for access from trusted client applications (if masterKeyAsUser is false ) or for read-only access. Master Key ( X-Parse-Master-Key ) : Grants full administrative privileges and bypasses all Class-Level Permissions (CLPs) and Access Control Lists (ACLs). Use with extreme caution and only in secure server environments.","title":"Types of API Keys"},{"location":"integrator-guide/authentication/#example-nodejs","text":"const express = require ( 'express' ); const ParseServer = require ( 'parse-server' ). ParseServer ; const Parse = require ( 'parse/node' ); // Import Parse SDK for Node.js environments // --- Initialize Parse SDK (usually done globally once) --- Parse . initialize ( \"YOUR_PARSE_APP_ID\" , \"YOUR_PARSE_JAVASCRIPT_KEY\" , \"YOUR_PARSE_MASTER_KEY\" ); Parse . serverURL = \"YOUR_GEMFORCE_PARSE_SERVER_URL/parse\" ; async function callCloudFunctionWithMasterKey ( functionName , params ) { try { // Use Parse.Cloud.run directly in Node.js, it will use the initialized Master Key const result = await Parse . Cloud . run ( functionName , params , { useMasterKey : true // Use Master Key for this request }); console . log ( `Cloud function ${ functionName } response:` , result ); return result ; } catch ( e ) { console . error ( `Cloud function ${ functionName } failed:` , e . message ); throw e ; } } // Example usage: ( async () => { try { const adminResult = await callCloudFunctionWithMasterKey ( \"processAdminTask\" , { userId : \"someUserId\" }); } catch ( e ) { console . error ( \"Admin task error:\" , e . message ); } })();","title":"Example (Node.js)"},{"location":"integrator-guide/authentication/#3-smart-contract-interaction-wallet-based","text":"Direct interaction with Gemforce's smart contracts (Diamond, Facets, ERC-20/721/1155) occurs directly on the blockchain. This involves: Connecting a Web3 wallet : Users connect their browser-based or mobile wallets (e.g., MetaMask, WalletConnect) to your dApp. Signing Transactions : Users sign transactions using their private keys to perform on-chain operations (e.g., mint NFT, transfer tokens, interact with a trade deal). No Centralized Authentication : There is no centralized authentication for smart contract calls; the blockchain validates the cryptographic signature against the sender's address.","title":"3. Smart Contract Interaction (Wallet-based)"},{"location":"integrator-guide/authentication/#key-tools-libraries","text":"Ethers.js / Web3.js : JavaScript libraries for interacting with the Ethereum blockchain. Wagmi / Web3Modal : Libraries for simplifying wallet connection in frontend applications. Hardhat / Foundry : Development environments for smart contract testing and deployment.","title":"Key Tools &amp; Libraries"},{"location":"integrator-guide/authentication/#example-ethersjs-for-signing-a-transaction","text":"import { ethers } from 'ethers' ; // Assuming you have the ABI for the smart contract you want to interact with import MyContractABI from './MyContract.json' ; const CONTRACT_ADDRESS = \"0x...\" ; // Address of the deployed Gemforce smart contract const PROVIDER_URL = \"https://sepolia.base.org\" ; // Or use window.ethereum for browser dApps async function interactWithSmartContract () { try { // Connect to the user's wallet // For browser environments, use window.ethereum // const provider = new ethers.providers.Web3Provider(window.ethereum); // await provider.send(\"eth_requestAccounts\", []); // Request account access // const signer = provider.getSigner(); // For Node.js/backend automation (using a private key) const provider = new ethers . JsonRpcProvider ( PROVIDER_URL ); const privateKey = \"YOUR_PRIVATE_KEY\" ; // Keep this secure! For demo only. const signer = new ethers . Wallet ( privateKey , provider ); // Create a contract instance const myContract = new ethers . Contract ( CONTRACT_ADDRESS , MyContractABI , signer ); // Example: Call a function that changes state (requires gas) const tx = await myContract . someStateChangingFunction ( \"some_parameter\" , { value : ethers.parseEther ( \"0.1\" ) }); console . log ( \"Transaction sent:\" , tx . hash ); // Wait for the transaction to be mined const receipt = await tx . wait (); console . log ( \"Transaction confirmed in block:\" , receipt . blockNumber ); // Example: Call a read-only function (does not require gas, no transaction) const result = await myContract . someViewFunction (); console . log ( \"View function result:\" , result ); } catch ( error ) { console . error ( \"Smart contract interaction error:\" , error ); } } // interactWithSmartContract();","title":"Example (Ethers.js for signing a transaction)"},{"location":"integrator-guide/authentication/#4-dfns-integration","text":"DFNS provides a secure, MPC-based Wallet-as-a-Service solution used within Gemforce. For integrators requiring advanced key management, higher security assurances, or compliance needs, direct integration with DFNS may be an option.","title":"4. DFNS Integration"},{"location":"integrator-guide/authentication/#key-benefits","text":"Multi-Party Computation (MPC) : Keys are split and never entirely reside in one place, enhancing security. Policy Engine : Define granular policies for transaction signing (e.g., multi-signature approvals). Audit Trails : Comprehensive logs of all key operations.","title":"Key Benefits"},{"location":"integrator-guide/authentication/#integration-approach","text":"Typically, your backend service would communicate with the DFNS API, which then orchestrates the secure signing of blockchain transactions. API Keys/Authentication : Authenticate with DFNS using their SDKs and API keys. Transaction Requests : Submit transaction payloads to DFNS for signing. Policy Enforcement : DFNS applies predefined policies (e.g., requiring multiple approvals) before signing. Signed Transaction : DFNS returns a signed transaction that your service can then broadcast to the blockchain.","title":"Integration Approach"},{"location":"integrator-guide/authentication/#example-conceptual-with-dfns-sdk","text":"// This is a conceptual example, actual DFNS SDK usage may vary. import { DfnsApiClient , AsymmetricKeys , SignatureMechanism , SignTransactionRequest } from '@dfns/sdk' ; const DFNS_API_URL = \"https://api.dfns.io\" ; const DFNS_APP_ID = \"YOUR_DFNS_APP_ID\" ; const DFNS_AUTH_TOKEN = \"YOUR_DFNS_AUTH_TOKEN\" ; // Generated from a private key & secret async function signTransactionWithDFNS ( walletId : string , chainId : string , transactionPayload : any ) { try { const dfnsClient = new DfnsApiClient ({ baseUrl : DFNS_API_URL , appId : DFNS_APP_ID , authToken : DFNS_AUTH_TOKEN , // Or use a signing key provider authMethod : new AsymmetricKeys ({ // This would involve loading private keys securely in a real app privateKey : \"...\" , signingKeyId : \"...\" , }) }); const signRequest : SignTransactionRequest = { walletId : walletId , chainId : chainId , payload : JSON.stringify ( transactionPayload ), signatureMechanism : SignatureMechanism.JsonRpc , transactionType : \"EvmTransaction\" , // or other types }; const response = await dfnsClient . wallet . signTransaction ( signRequest ); console . log ( \"DFNS Signed Transaction:\" , response . signedData ); return response . signedData ; // Contains the raw signed transaction to broadcast } catch ( error ) { console . error ( \"DFNS signing error:\" , error ); throw error ; } } // Example usage: // const signedTx = await signTransactionWithDFNS( // \"some-dfns-wallet-uuid\", // \"eip155:11155111\", // Sepolia chain ID // { // to: \"0x...\", // value: \"0\", // gasLimit: \"21000\", // data: \"0x...\" // } // ); // // Then broadcast signedTx to the blockchain","title":"Example (Conceptual with DFNS SDK)"},{"location":"integrator-guide/authentication/#related-documentation","text":"Cloud Functions: Authentication Functions Cloud Functions: DFNS Functions Parse Server REST API Documentation (External) DFNS Documentation (External)","title":"Related Documentation"},{"location":"integrator-guide/dfns/","text":"Integrator's Guide: DFNS Integration \u00b6 DFNS provides a highly secure Wallet-as-a-Service solution that Gemforce utilizes for cryptographic operations, particularly secure key management and transaction signing. For integrators working with sensitive operations that require advanced security, regulatory compliance, or robust policy enforcement, direct integration with the DFNS API through Gemforce's ecosystem is crucial. Overview of DFNS in Gemforce \u00b6 DFNS offers: Multi-Party Computation (MPC) : Keys are never held in one place, significantly reducing the risk of single points of failure and theft. Policy Engine : Define precise rules for transaction approvals, including multi-signature requirements, whitelisting/blacklisting, and spend limits. Comprehensive Audit Trails : All cryptographic actions are logged, providing an immutable record for compliance and security monitoring. Scalability : Supports high-volume transaction signing for enterprise applications. Gemforce integrates with DFNS primarily through its Cloud Functions, abstracting some of the direct DFNS API interactions. However, understanding the underlying DFNS capabilities is beneficial for deeper integrations. Core DFNS Concepts \u00b6 Wallets : DFNS manages virtual \"wallets,\" which are essentially key pairs (or key shares in MPC). Signing Keys : Used for API authentication with DFNS. Policies : Rules attached to wallets that dictate when a transaction can be signed and by whom. Signer Authentication : DFNS supports various methods to authenticate the \"signer\" (the human or system authorizing an action), including FIDO, API keys, and more. Integration Methods \u00b6 You can interact with DFNS through Gemforce in two primary ways: Via Gemforce Cloud Functions (Recommended for most cases) : Gemforce's Cloud Functions (e.g., dfns.ts ) encapsulate common DFNS operations, making it simpler to: Create and manage DFNS wallets. Initiate transaction signing requests. Monitor the status of signing operations. This method abstracts the direct DFNS API calls, allowing you to use your existing Parse Server authentication. Direct DFNS API Integration (For advanced users) : For highly customized workflows or scenarios where fine-grained control over DFNS is required, you can integrate directly with the DFNS API. This involves: Obtaining your own DFNS API credentials. Implementing DFNS SDKs or building direct API calls. Managing DFNS wallet IDs and policies externally. Integration via Gemforce Cloud Functions \u00b6 Gemforce provides several Cloud Functions that wrap DFNS operations. These functions require appropriate authentication (Parse session token or Master Key) to be invoked. Example: Signing a Transaction via Gemforce Cloud Function \u00b6 Let's assume a Gemforce Cloud Function named dfnsSignTransaction exists, which takes a transaction payload and returns a signed transaction. // Function: callCloudFunction (from Authentication guide) // This example assumes 'targetWalletId' and 'transactionDetails' are prepared by your backend service. async function signTransactionViaGemforce ( sessionToken , targetWalletId , transactionDetails ) { try { const result = await callCloudFunction ( \"dfnsSignTransaction\" , { walletId : targetWalletId , payload : transactionDetails // e.g., { to: \"0x...\", value: \"0\", data: \"0x...\" } }, sessionToken ); console . log ( \"Signed transaction from Gemforce Cloud Function:\" , result ); return result ; // The signed, raw transaction string (e.g., \"0x...\") } catch ( error ) { console . error ( \"Error signing transaction via Gemforce Cloud Function:\" , error ); throw error ; } } // Example usage (assuming 'sessionToken' is obtained from user login) // (async () => { // const token = \"YOUR_SESSION_TOKEN\"; // Replace with actual session token // const walletId = \"YOUR_DFNS_WALLET_UUID\"; // const txPayload = { // to: \"0xRecipientAddress\", // value: \"10000000000000000\", // 0.01 ETH in wei // gasLimit: \"21000\", // chainId: 11155111, // Sepolia // nonce: 5, // Get current nonce // // Add other fields like gasPrice, maxFeePerGas, maxPriorityFeePerGas for EIP-1559 // }; // try { // const signedTx = await signTransactionViaGemforce(token, walletId, txPayload); // // Now broadcast this signedTx to the blockchain using an Ethers.js or Web3.js provider // // const provider = new ethers.providers.JsonRpcProvider(\"YOUR_RPC_URL\"); // // await provider.sendTransaction(signedTx); // // console.log(\"Transaction broadcasted:\", signedTx); // } catch (e) { // console.error(\"DFNS Integration Example Failed:\", e.message); // } // })(); Direct DFNS API Integration (Advanced) \u00b6 If using Gemforce Cloud Functions doesn't meet your specific needs, you can integrate directly with the DFNS API. This path gives you full control but requires careful management of DFNS credentials and a deeper understanding of their SDK. Prerequisites \u00b6 A DFNS Account and Console Access. Your DFNS Application ID and a long-lived API signing key pair. DFNS SDK for your preferred language (e.g., TypeScript/JavaScript). Steps Involved \u00b6 DFNS Client Initialization : Authenticate your application with the DFNS API using your signing key. Wallet Management (Optional) : If you need to programmatically create or manage DFNS wallets, use their API. Transaction Draft Creation : Prepare the transaction object (e.g., Ethereum transaction details). Signing Request : Submit the transaction draft to DFNS for signing, potentially specifying policies or required authenticators. Signer Authentication : Depending on your policy, DFNS might require additional authentication from a human signer (e.g., via FIDO device). This part is usually handled out-of-band by the DFNS platform. Receive Signed Transaction : Once policies are met and signers authenticated, DFNS returns the cryptographically signed transaction. Broadcast : Broadcast the signed transaction to the relevant blockchain network. Example (Conceptual Direct DFNS SDK Usage - TypeScript) \u00b6 This example extends the conceptual example from the Authentication Guide . import { DfnsApiClient , AsymmetricKeys , SignatureMechanism , SignTransactionRequest } from '@dfns/sdk' ; import { EvmTransaction } from '@dfns/sdk/codegen/datamodel/EvmTransaction' ; // Import specific type const DFNS_API_URL = \"https://api.dfns.io\" ; // or your specific DFNS API endpoint const DFNS_APP_ID = \"YOUR_DFNS_APP_ID\" ; const DFNS_PRIVATE_KEY = `-----BEGIN PRIVATE KEY----- ... YOUR PRIVATE KEY ... -----END PRIVATE KEY-----` ; // Load securely from environment variables, not hardcoded! const DFNS_SIGNING_KEY_ID = \"sk-xxxxxxxxxxxxxxxxx\" ; // Your API Signing Key ID from DFNS Console async function signEvmTransactionDirectlyWithDFNS ( walletId : string , chainId : string , rawTransaction : EvmTransaction ) { try { // 1. Initialize DFNS API Client with Asymmetric Key Authentication const dfnsClient = new DfnsApiClient ({ baseUrl : DFNS_API_URL , appId : DFNS_APP_ID , authMethod : new AsymmetricKeys ({ privateKey : DFNS_PRIVATE_KEY , signingKeyId : DFNS_SIGNING_KEY_ID , }) }); // 2. Prepare the signing request const signRequest : SignTransactionRequest = { walletId : walletId , chainId : chainId , // e.g., \"eip155:11155111\" for Sepolia payload : JSON.stringify ( rawTransaction ), // DFNS expects stringified payload signatureMechanism : SignatureMechanism.JsonRpc , // Or other mechanism like Eip1559, Legacy transactionType : \"EvmTransaction\" , // Specify EVM transaction }; // 3. Send the signing request const response = await dfnsClient . wallet . signTransaction ( signRequest ); console . log ( \"DFNS direct signed data:\" , response . signedData ); // response.signedData contains the fully signed transaction in hex format (e.g., \"0x...\") return response . signedData ; } catch ( error ) { console . error ( \"DFNS direct signing failed:\" , error ); throw error ; } } // Example Raw EVM Transaction Payload (fields depend on transaction type) // const exampleEvmTx: EvmTransaction = { // from: \"0x...\", // Optional, but good practice // to: \"0xTargetContractAddress\", // value: \"0x00\", // Hex value for 0 ETH // data: \"0x...\", // Calldata for contract interaction // gasLimit: \"0x5208\", // Hex value for 21000 // nonce: \"0x0\", // Hex value for nonce // gasPrice: \"0x...\", // or maxFeePerGas/maxPriorityFeePerGas for EIP-1559 // type: \"0x0\" // For legacy transaction, \"0x2\" for EIP-1559 // }; // Example Usage: // (async () => { // try { // const dfnsWalletUuid = \"YOUR_DFNS_WALLET_UUID\"; // const sepoliaChainId = \"eip155:11155111\"; // DFNS chain ID format // const signedTxHex = await signEvmTransactionDirectlyWithDFNS(dfnsWalletUuid, sepoliaChainId, exampleEvmTx); // console.log(\"Transaction ready to broadcast:\", signedTxHex); // } catch (e) { // console.error(\"Direct DFNS Example Failed:\", e.message); // } // })(); Security Considerations \u00b6 Master Key / Private Key Management : Never hardcode Master Keys or private keys into your application. Use environment variables, secure secret management services (like AWS Secrets Manager, HashiCorp Vault), or DFNS itself for storing and accessing sensitive credentials. DFNS Policy Enforcement : Thoroughly define and test your DFNS policies to ensure that transactions are only signed under approved conditions. API Key Rotation : Regularly rotate your DFNS API keys and any other API credentials you use. Audit Logs : Regularly review DFNS audit trails for any suspicious activity. Error Handling : Implement robust error handling for all DFNS API calls, as failures could indicate policy violations, service issues, or incorrect requests. Related Documentation \u00b6 integrators-guide/authentication.md Cloud Functions: DFNS Functions DFNS Documentation (External)","title":"DFNS Integration"},{"location":"integrator-guide/dfns/#integrators-guide-dfns-integration","text":"DFNS provides a highly secure Wallet-as-a-Service solution that Gemforce utilizes for cryptographic operations, particularly secure key management and transaction signing. For integrators working with sensitive operations that require advanced security, regulatory compliance, or robust policy enforcement, direct integration with the DFNS API through Gemforce's ecosystem is crucial.","title":"Integrator's Guide: DFNS Integration"},{"location":"integrator-guide/dfns/#overview-of-dfns-in-gemforce","text":"DFNS offers: Multi-Party Computation (MPC) : Keys are never held in one place, significantly reducing the risk of single points of failure and theft. Policy Engine : Define precise rules for transaction approvals, including multi-signature requirements, whitelisting/blacklisting, and spend limits. Comprehensive Audit Trails : All cryptographic actions are logged, providing an immutable record for compliance and security monitoring. Scalability : Supports high-volume transaction signing for enterprise applications. Gemforce integrates with DFNS primarily through its Cloud Functions, abstracting some of the direct DFNS API interactions. However, understanding the underlying DFNS capabilities is beneficial for deeper integrations.","title":"Overview of DFNS in Gemforce"},{"location":"integrator-guide/dfns/#core-dfns-concepts","text":"Wallets : DFNS manages virtual \"wallets,\" which are essentially key pairs (or key shares in MPC). Signing Keys : Used for API authentication with DFNS. Policies : Rules attached to wallets that dictate when a transaction can be signed and by whom. Signer Authentication : DFNS supports various methods to authenticate the \"signer\" (the human or system authorizing an action), including FIDO, API keys, and more.","title":"Core DFNS Concepts"},{"location":"integrator-guide/dfns/#integration-methods","text":"You can interact with DFNS through Gemforce in two primary ways: Via Gemforce Cloud Functions (Recommended for most cases) : Gemforce's Cloud Functions (e.g., dfns.ts ) encapsulate common DFNS operations, making it simpler to: Create and manage DFNS wallets. Initiate transaction signing requests. Monitor the status of signing operations. This method abstracts the direct DFNS API calls, allowing you to use your existing Parse Server authentication. Direct DFNS API Integration (For advanced users) : For highly customized workflows or scenarios where fine-grained control over DFNS is required, you can integrate directly with the DFNS API. This involves: Obtaining your own DFNS API credentials. Implementing DFNS SDKs or building direct API calls. Managing DFNS wallet IDs and policies externally.","title":"Integration Methods"},{"location":"integrator-guide/dfns/#integration-via-gemforce-cloud-functions","text":"Gemforce provides several Cloud Functions that wrap DFNS operations. These functions require appropriate authentication (Parse session token or Master Key) to be invoked.","title":"Integration via Gemforce Cloud Functions"},{"location":"integrator-guide/dfns/#example-signing-a-transaction-via-gemforce-cloud-function","text":"Let's assume a Gemforce Cloud Function named dfnsSignTransaction exists, which takes a transaction payload and returns a signed transaction. // Function: callCloudFunction (from Authentication guide) // This example assumes 'targetWalletId' and 'transactionDetails' are prepared by your backend service. async function signTransactionViaGemforce ( sessionToken , targetWalletId , transactionDetails ) { try { const result = await callCloudFunction ( \"dfnsSignTransaction\" , { walletId : targetWalletId , payload : transactionDetails // e.g., { to: \"0x...\", value: \"0\", data: \"0x...\" } }, sessionToken ); console . log ( \"Signed transaction from Gemforce Cloud Function:\" , result ); return result ; // The signed, raw transaction string (e.g., \"0x...\") } catch ( error ) { console . error ( \"Error signing transaction via Gemforce Cloud Function:\" , error ); throw error ; } } // Example usage (assuming 'sessionToken' is obtained from user login) // (async () => { // const token = \"YOUR_SESSION_TOKEN\"; // Replace with actual session token // const walletId = \"YOUR_DFNS_WALLET_UUID\"; // const txPayload = { // to: \"0xRecipientAddress\", // value: \"10000000000000000\", // 0.01 ETH in wei // gasLimit: \"21000\", // chainId: 11155111, // Sepolia // nonce: 5, // Get current nonce // // Add other fields like gasPrice, maxFeePerGas, maxPriorityFeePerGas for EIP-1559 // }; // try { // const signedTx = await signTransactionViaGemforce(token, walletId, txPayload); // // Now broadcast this signedTx to the blockchain using an Ethers.js or Web3.js provider // // const provider = new ethers.providers.JsonRpcProvider(\"YOUR_RPC_URL\"); // // await provider.sendTransaction(signedTx); // // console.log(\"Transaction broadcasted:\", signedTx); // } catch (e) { // console.error(\"DFNS Integration Example Failed:\", e.message); // } // })();","title":"Example: Signing a Transaction via Gemforce Cloud Function"},{"location":"integrator-guide/dfns/#direct-dfns-api-integration-advanced","text":"If using Gemforce Cloud Functions doesn't meet your specific needs, you can integrate directly with the DFNS API. This path gives you full control but requires careful management of DFNS credentials and a deeper understanding of their SDK.","title":"Direct DFNS API Integration (Advanced)"},{"location":"integrator-guide/dfns/#prerequisites","text":"A DFNS Account and Console Access. Your DFNS Application ID and a long-lived API signing key pair. DFNS SDK for your preferred language (e.g., TypeScript/JavaScript).","title":"Prerequisites"},{"location":"integrator-guide/dfns/#steps-involved","text":"DFNS Client Initialization : Authenticate your application with the DFNS API using your signing key. Wallet Management (Optional) : If you need to programmatically create or manage DFNS wallets, use their API. Transaction Draft Creation : Prepare the transaction object (e.g., Ethereum transaction details). Signing Request : Submit the transaction draft to DFNS for signing, potentially specifying policies or required authenticators. Signer Authentication : Depending on your policy, DFNS might require additional authentication from a human signer (e.g., via FIDO device). This part is usually handled out-of-band by the DFNS platform. Receive Signed Transaction : Once policies are met and signers authenticated, DFNS returns the cryptographically signed transaction. Broadcast : Broadcast the signed transaction to the relevant blockchain network.","title":"Steps Involved"},{"location":"integrator-guide/dfns/#example-conceptual-direct-dfns-sdk-usage-typescript","text":"This example extends the conceptual example from the Authentication Guide . import { DfnsApiClient , AsymmetricKeys , SignatureMechanism , SignTransactionRequest } from '@dfns/sdk' ; import { EvmTransaction } from '@dfns/sdk/codegen/datamodel/EvmTransaction' ; // Import specific type const DFNS_API_URL = \"https://api.dfns.io\" ; // or your specific DFNS API endpoint const DFNS_APP_ID = \"YOUR_DFNS_APP_ID\" ; const DFNS_PRIVATE_KEY = `-----BEGIN PRIVATE KEY----- ... YOUR PRIVATE KEY ... -----END PRIVATE KEY-----` ; // Load securely from environment variables, not hardcoded! const DFNS_SIGNING_KEY_ID = \"sk-xxxxxxxxxxxxxxxxx\" ; // Your API Signing Key ID from DFNS Console async function signEvmTransactionDirectlyWithDFNS ( walletId : string , chainId : string , rawTransaction : EvmTransaction ) { try { // 1. Initialize DFNS API Client with Asymmetric Key Authentication const dfnsClient = new DfnsApiClient ({ baseUrl : DFNS_API_URL , appId : DFNS_APP_ID , authMethod : new AsymmetricKeys ({ privateKey : DFNS_PRIVATE_KEY , signingKeyId : DFNS_SIGNING_KEY_ID , }) }); // 2. Prepare the signing request const signRequest : SignTransactionRequest = { walletId : walletId , chainId : chainId , // e.g., \"eip155:11155111\" for Sepolia payload : JSON.stringify ( rawTransaction ), // DFNS expects stringified payload signatureMechanism : SignatureMechanism.JsonRpc , // Or other mechanism like Eip1559, Legacy transactionType : \"EvmTransaction\" , // Specify EVM transaction }; // 3. Send the signing request const response = await dfnsClient . wallet . signTransaction ( signRequest ); console . log ( \"DFNS direct signed data:\" , response . signedData ); // response.signedData contains the fully signed transaction in hex format (e.g., \"0x...\") return response . signedData ; } catch ( error ) { console . error ( \"DFNS direct signing failed:\" , error ); throw error ; } } // Example Raw EVM Transaction Payload (fields depend on transaction type) // const exampleEvmTx: EvmTransaction = { // from: \"0x...\", // Optional, but good practice // to: \"0xTargetContractAddress\", // value: \"0x00\", // Hex value for 0 ETH // data: \"0x...\", // Calldata for contract interaction // gasLimit: \"0x5208\", // Hex value for 21000 // nonce: \"0x0\", // Hex value for nonce // gasPrice: \"0x...\", // or maxFeePerGas/maxPriorityFeePerGas for EIP-1559 // type: \"0x0\" // For legacy transaction, \"0x2\" for EIP-1559 // }; // Example Usage: // (async () => { // try { // const dfnsWalletUuid = \"YOUR_DFNS_WALLET_UUID\"; // const sepoliaChainId = \"eip155:11155111\"; // DFNS chain ID format // const signedTxHex = await signEvmTransactionDirectlyWithDFNS(dfnsWalletUuid, sepoliaChainId, exampleEvmTx); // console.log(\"Transaction ready to broadcast:\", signedTxHex); // } catch (e) { // console.error(\"Direct DFNS Example Failed:\", e.message); // } // })();","title":"Example (Conceptual Direct DFNS SDK Usage - TypeScript)"},{"location":"integrator-guide/dfns/#security-considerations","text":"Master Key / Private Key Management : Never hardcode Master Keys or private keys into your application. Use environment variables, secure secret management services (like AWS Secrets Manager, HashiCorp Vault), or DFNS itself for storing and accessing sensitive credentials. DFNS Policy Enforcement : Thoroughly define and test your DFNS policies to ensure that transactions are only signed under approved conditions. API Key Rotation : Regularly rotate your DFNS API keys and any other API credentials you use. Audit Logs : Regularly review DFNS audit trails for any suspicious activity. Error Handling : Implement robust error handling for all DFNS API calls, as failures could indicate policy violations, service issues, or incorrect requests.","title":"Security Considerations"},{"location":"integrator-guide/dfns/#related-documentation","text":"integrators-guide/authentication.md Cloud Functions: DFNS Functions DFNS Documentation (External)","title":"Related Documentation"},{"location":"integrator-guide/error-handling/","text":"Integrator's Guide: Error Handling \u00b6 Robust error handling is crucial for building reliable integrations with the Gemforce platform. This guide provides an overview of common error types you might encounter when interacting with Gemforce's smart contracts, REST API, and cloud functions, along with strategies and best practices for managing them. Overview of Error Types \u00b6 Errors in the Gemforce ecosystem can primarily originate from three layers: Blockchain/Smart Contract Errors : Occur during on-chain transactions or calls. These include reverted transactions, out-of-gas errors, or custom revert messages from smart contracts. REST API Errors (Parse Server) : Standard HTTP errors and custom Parse Server errors returned by the backend API. Cloud Function Errors : Specific errors returned by Gemforce's custom Cloud Functions, often indicating business logic failures or invalid input. Network/Infrastructure Errors : General network connectivity issues, timeouts, or problems with RPC providers. 1. Smart Contract Error Handling \u00b6 When interacting with Gemforce smart contracts, transactions can fail for several reasons. Web3 libraries like Ethers.js and Web3.js provide mechanisms to catch and interpret these errors. Common Smart Contract Error Scenarios: \u00b6 Transaction Revert : The most common error. A smart contract function execution fails due to a require() , revert() , or other exception. Out of Gas : The transaction runs out of gas before completing. Invalid Input : Parameters passed to a contract function are incorrect (e.g., wrong type, out of range). Access Control Violations : The calling address does not have the necessary permissions (e.g., Ownable modifier failing). Example (Ethers.js) \u00b6 import { ethers } from 'ethers' ; // Assuming ABI for a Gemforce contract with a `performAction` function that might revert import GemforceContractABI from './GemforceContract.json' ; const CONTRACT_ADDRESS = \"0x...\" ; // Your Gemforce Diamond/facet address const PROVIDER_URL = \"https://sepolia.base.org\" ; const PRIVATE_KEY = \"YOUR_PRIVATE_KEY\" ; // For demonstration, use secure methods in production async function executeSmartContractAction () { const provider = new ethers . JsonRpcProvider ( PROVIDER_URL ); const signer = new ethers . Wallet ( PRIVATE_KEY , provider ); const myContract = new ethers . Contract ( CONTRACT_ADDRESS , GemforceContractABI , signer ); try { console . log ( \"Attempting to execute smart contract action...\" ); const tx = await myContract . performAction ( \"invalid_param\" , { gasLimit : 300000 }); // Example with potentially invalid param const receipt = await tx . wait (); // Wait for transaction to be mined console . log ( \"Transaction successful:\" , receipt ); } catch ( error : any ) { console . error ( \"Smart Contract Transaction Failed!\" ); console . error ( \"Error message:\" , error . message ); // Ethers.js specific error parsing if ( error . code === ethers . errors . CALL_EXCEPTION ) { console . error ( \"This is a contract call exception (revert).\" ); // Attempt to decode revert message (if available and standard) if ( error . data ) { try { // This often works for custom revert strings if using ethers v5+ and target chain supports it const decodedError = myContract . interface . parseError ( error . data ); if ( decodedError ) { console . error ( \"Decoded Revert Reason (Ethers.js v5+):\" , decodedError . args [ 0 ]); } } catch ( decodeError ) { console . error ( \"Could not decode revert reason from error.data\" ); // Fallback for older ethers versions or non-standard reverts const revertReasonMatch = error . message . match ( /reverted with reason string '([^']*)'/ ); if ( revertReasonMatch && revertReasonMatch [ 1 ]) { console . error ( \"Fallback Revert Reason:\" , revertReasonMatch [ 1 ]); } } } else if ( error . reason ) { // Ethers.js v5 error.reason console . error ( \"Revert Reason:\" , error . reason ); } } else if ( error . code === ethers . errors . UNPREDICTABLE_GAS_LIMIT ) { console . error ( \"Gas limit could not be estimated. This often implies a revert in a dry-run.\" ); console . error ( \"Raw error response:\" , error . error ? . message || error . data ); } else if ( error . code === 'INSUFFICIENT_FUNDS' ) { console . error ( \"Account has insufficient funds for transaction.\" ); } else if ( error . code === 'NETWORK_ERROR' ) { console . error ( \"Network error encountered:\" , error . reason ); } else { console . error ( \"An unknown blockchain error occurred.\" ); } // Provide user-friendly feedback based on error type } } // executeSmartContractAction(); Best Practices for Smart Contract Errors: \u00b6 Catch All Errors : Always wrap transaction calls in try-catch blocks. Parse Revert Messages : If possible, extract and display the custom revert reason string defined in require(\"reason string\") within the contract. Distinguish Errors : Differentiate between network errors, gas errors, and transaction reverts to provide precise feedback. Gas Estimation : Use contract.estimateGas.functionName() before sending transactions to catch potential reverts early. If estimateGas fails, the transaction will almost certainly revert. On-chain Validation : Ensure comprehensive validation within smart contracts using require() and revert() with informative messages. 2. REST API Error Handling (Parse Server) \u00b6 Gemforce's Parse Server REST API adheres to standard HTTP status codes but also includes specific JSON error payloads for more detail. Common REST API Error Status Codes: \u00b6 400 Bad Request : Invalid input format, missing required parameters. 401 Unauthorized : Missing or invalid X-Parse-Application-Id , X-Parse-Session-Token , or other authentication headers. 403 Forbidden : Insufficient permissions (ACL/CLP violation) for the authenticated user/keys. 404 Not Found : Endpoint or object not found. 500 Internal Server Error : General server-side error, often caused by uncaught exceptions in Cloud Functions. Standard Parse Server Error Payload: \u00b6 { \"code\" : 101 , // Parse-specific error code \"error\" : \"Object not found.\" // Human-readable error message } Example (JavaScript Fetch API) \u00b6 const PARSE_SERVER_URL = \"YOUR_GEMFORCE_PARSE_SERVER_URL/parse\" ; const APP_ID = \"YOUR_PARSE_APP_ID\" ; const REST_API_KEY = \"YOUR_PARSE_REST_API_KEY\" ; // or session token for user const SESSION_TOKEN = \"YOUR_SESSION_TOKEN\" ; // if authenticated user async function fetchProjectData ( projectId : string ) { try { const response = await fetch ( ` ${ PARSE_SERVER_URL } /classes/Project/ ${ projectId } ` , { method : 'GET' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : REST_API_KEY , 'X-Parse-Session-Token' : SESSION_TOKEN // Include if fetching protected data } }); if ( ! response . ok ) { // Check for HTTP error status codes (4xx, 5xx) const errorData = await response . json (); console . error ( `API Error: HTTP Status ${ response . status } , Parse Code ${ errorData . code || 'N/A' } ` ); throw new Error ( `Failed to fetch project: ${ errorData . error || 'Unknown API error' } ` ); } const data = await response . json (); console . log ( \"Project data:\" , data ); return data ; } catch ( error ) { console . error ( \"Network or parsing error:\" , error ); throw error ; // Re-throw to propagate for higher-level handling } } // Example usage: // fetchProjectData(\"nonexistentProjectId\") // .catch(err => console.error(\"Caught error:\", err.message)); Best Practices for REST API Errors: \u00b6 Check response.ok : Always check response.ok (or equivalent in your HTTP client) before parsing the JSON body. Parse Error Payloads : Always parse the JSON error payload to extract the code and error messages for specific handling and user feedback. Retry Logic : For transient errors (e.g., network issues, 5xx server errors), implement exponential backoff and retry mechanisms. Logging/Monitoring : Log API errors on your server-side for debugging and monitoring. Set up alerts for critical errors. 3. Cloud Function Error Handling \u00b6 Cloud Functions are custom code executed on the Parse Server. Errors from Cloud Functions are returned via the standard Parse REST API error payload, but their error messages can be more specific to your business logic. Example (JavaScript Parse SDK - Node.js) \u00b6 const Parse = require ( 'parse/node' ); // Assuming Parse SDK is initialized Parse . initialize ( \"YOUR_APP_ID\" , \"YOUR_JAVASCRIPT_KEY\" , \"YOUR_MASTER_KEY\" ); Parse . serverURL = \"YOUR_GEMFORCE_PARSE_SERVER_URL/parse\" ; async function callCustomCloudFunction ( functionName : string , params : object ) { try { // Assume this cloud function 'processTradeDeal' can throw specific errors const result = await Parse . Cloud . run ( functionName , params , { useMasterKey : true }); // Example using Master Key console . log ( `Cloud function ${ functionName } result:` , result ); return result ; } catch ( error : any ) { console . error ( `Cloud function ${ functionName } failed:` ); console . error ( `Parse Error Code: ${ error . code } ` ); console . error ( `Error Message: ${ error . message } ` ); // Handle specific Parse error codes or custom messages if ( error . code === 141 ) { // Example: Cloud Code function failed with specific error if ( error . message . includes ( \"Invalid Trade Deal ID\" )) { console . error ( \"User-friendly message: The trade deal ID provided is not valid.\" ); } else if ( error . message . includes ( \"Insufficient collateral\" )) { console . error ( \"User-friendly message: Not enough collateral for this trade deal.\" ); } } else if ( error . code === 209 ) { // Session Token Expired console . error ( \"User-friendly message: Your session has expired. Please log in again.\" ); // Trigger re-authentication flow } throw error ; // Re-throw to propagate if needed } } // Example usage: // callCustomCloudFunction(\"processTradeDeal\", { tradeDealId: \"invalid\", amount: 100 }) // .catch(err => console.error(\"Cloud function call failed at top level:\", err.message)); Best Practices for Cloud Function Errors: \u00b6 Consistent Error Responses : Design your Cloud Functions to return consistent error structures (e.g., throw new Parse.Error(Parse.Error.SCRIPT_FAILED, \"Custom error message\"); ) to make client-side handling predictable. Informative Messages : Provide clear, descriptive error messages that help integrators understand the cause of the failure. Specific Error Codes : For critical business logic failures, consider mapping them to custom error codes if Parse.Error doesn't cover them. 4. Network and Infrastructure Error Handling \u00b6 These are general issues that prevent successful communication with the Gemforce platform. Common Scenarios: \u00b6 Connection Refused : Server is down or inaccessible. Timeout : Request takes too long to respond. DNS Resolution Failure : Domain name cannot be resolved. Best Practices: \u00b6 Retry Logic : Implement robust retry mechanisms with exponential backoff and jitter for transient network failures. Circuit Breaker Pattern : For persistent failures, consider a circuit breaker to prevent overwhelming a failing service and to fail fast. Monitoring : Have monitoring and alerting in place for your integration points to detect widespread network issues. Fallback Mechanisms : If critical, consider fallback mechanisms (e.g., alternative RPC providers, cached data) when the primary service is unavailable. General Error Handling Principles \u00b6 Fail Gracefully : Your application should not crash due to an expected error. User Feedback : Translate technical errors into user-friendly messages. Logging : Implement comprehensive logging (client-side and server-side) to record errors for debugging and analysis. Alerting : Set up automated alerts for critical errors in production environments. Debugging Tools : Utilize browser developer tools, server logs, and blockchain explorers (for smart contract transactions) to debug issues. Related Documentation \u00b6 integrators-guide/authentication.md Parse Server Error Codes (External) Ethers.js Errors (External)","title":"Error Handling"},{"location":"integrator-guide/error-handling/#integrators-guide-error-handling","text":"Robust error handling is crucial for building reliable integrations with the Gemforce platform. This guide provides an overview of common error types you might encounter when interacting with Gemforce's smart contracts, REST API, and cloud functions, along with strategies and best practices for managing them.","title":"Integrator's Guide: Error Handling"},{"location":"integrator-guide/error-handling/#overview-of-error-types","text":"Errors in the Gemforce ecosystem can primarily originate from three layers: Blockchain/Smart Contract Errors : Occur during on-chain transactions or calls. These include reverted transactions, out-of-gas errors, or custom revert messages from smart contracts. REST API Errors (Parse Server) : Standard HTTP errors and custom Parse Server errors returned by the backend API. Cloud Function Errors : Specific errors returned by Gemforce's custom Cloud Functions, often indicating business logic failures or invalid input. Network/Infrastructure Errors : General network connectivity issues, timeouts, or problems with RPC providers.","title":"Overview of Error Types"},{"location":"integrator-guide/error-handling/#1-smart-contract-error-handling","text":"When interacting with Gemforce smart contracts, transactions can fail for several reasons. Web3 libraries like Ethers.js and Web3.js provide mechanisms to catch and interpret these errors.","title":"1. Smart Contract Error Handling"},{"location":"integrator-guide/error-handling/#common-smart-contract-error-scenarios","text":"Transaction Revert : The most common error. A smart contract function execution fails due to a require() , revert() , or other exception. Out of Gas : The transaction runs out of gas before completing. Invalid Input : Parameters passed to a contract function are incorrect (e.g., wrong type, out of range). Access Control Violations : The calling address does not have the necessary permissions (e.g., Ownable modifier failing).","title":"Common Smart Contract Error Scenarios:"},{"location":"integrator-guide/error-handling/#example-ethersjs","text":"import { ethers } from 'ethers' ; // Assuming ABI for a Gemforce contract with a `performAction` function that might revert import GemforceContractABI from './GemforceContract.json' ; const CONTRACT_ADDRESS = \"0x...\" ; // Your Gemforce Diamond/facet address const PROVIDER_URL = \"https://sepolia.base.org\" ; const PRIVATE_KEY = \"YOUR_PRIVATE_KEY\" ; // For demonstration, use secure methods in production async function executeSmartContractAction () { const provider = new ethers . JsonRpcProvider ( PROVIDER_URL ); const signer = new ethers . Wallet ( PRIVATE_KEY , provider ); const myContract = new ethers . Contract ( CONTRACT_ADDRESS , GemforceContractABI , signer ); try { console . log ( \"Attempting to execute smart contract action...\" ); const tx = await myContract . performAction ( \"invalid_param\" , { gasLimit : 300000 }); // Example with potentially invalid param const receipt = await tx . wait (); // Wait for transaction to be mined console . log ( \"Transaction successful:\" , receipt ); } catch ( error : any ) { console . error ( \"Smart Contract Transaction Failed!\" ); console . error ( \"Error message:\" , error . message ); // Ethers.js specific error parsing if ( error . code === ethers . errors . CALL_EXCEPTION ) { console . error ( \"This is a contract call exception (revert).\" ); // Attempt to decode revert message (if available and standard) if ( error . data ) { try { // This often works for custom revert strings if using ethers v5+ and target chain supports it const decodedError = myContract . interface . parseError ( error . data ); if ( decodedError ) { console . error ( \"Decoded Revert Reason (Ethers.js v5+):\" , decodedError . args [ 0 ]); } } catch ( decodeError ) { console . error ( \"Could not decode revert reason from error.data\" ); // Fallback for older ethers versions or non-standard reverts const revertReasonMatch = error . message . match ( /reverted with reason string '([^']*)'/ ); if ( revertReasonMatch && revertReasonMatch [ 1 ]) { console . error ( \"Fallback Revert Reason:\" , revertReasonMatch [ 1 ]); } } } else if ( error . reason ) { // Ethers.js v5 error.reason console . error ( \"Revert Reason:\" , error . reason ); } } else if ( error . code === ethers . errors . UNPREDICTABLE_GAS_LIMIT ) { console . error ( \"Gas limit could not be estimated. This often implies a revert in a dry-run.\" ); console . error ( \"Raw error response:\" , error . error ? . message || error . data ); } else if ( error . code === 'INSUFFICIENT_FUNDS' ) { console . error ( \"Account has insufficient funds for transaction.\" ); } else if ( error . code === 'NETWORK_ERROR' ) { console . error ( \"Network error encountered:\" , error . reason ); } else { console . error ( \"An unknown blockchain error occurred.\" ); } // Provide user-friendly feedback based on error type } } // executeSmartContractAction();","title":"Example (Ethers.js)"},{"location":"integrator-guide/error-handling/#best-practices-for-smart-contract-errors","text":"Catch All Errors : Always wrap transaction calls in try-catch blocks. Parse Revert Messages : If possible, extract and display the custom revert reason string defined in require(\"reason string\") within the contract. Distinguish Errors : Differentiate between network errors, gas errors, and transaction reverts to provide precise feedback. Gas Estimation : Use contract.estimateGas.functionName() before sending transactions to catch potential reverts early. If estimateGas fails, the transaction will almost certainly revert. On-chain Validation : Ensure comprehensive validation within smart contracts using require() and revert() with informative messages.","title":"Best Practices for Smart Contract Errors:"},{"location":"integrator-guide/error-handling/#2-rest-api-error-handling-parse-server","text":"Gemforce's Parse Server REST API adheres to standard HTTP status codes but also includes specific JSON error payloads for more detail.","title":"2. REST API Error Handling (Parse Server)"},{"location":"integrator-guide/error-handling/#common-rest-api-error-status-codes","text":"400 Bad Request : Invalid input format, missing required parameters. 401 Unauthorized : Missing or invalid X-Parse-Application-Id , X-Parse-Session-Token , or other authentication headers. 403 Forbidden : Insufficient permissions (ACL/CLP violation) for the authenticated user/keys. 404 Not Found : Endpoint or object not found. 500 Internal Server Error : General server-side error, often caused by uncaught exceptions in Cloud Functions.","title":"Common REST API Error Status Codes:"},{"location":"integrator-guide/error-handling/#standard-parse-server-error-payload","text":"{ \"code\" : 101 , // Parse-specific error code \"error\" : \"Object not found.\" // Human-readable error message }","title":"Standard Parse Server Error Payload:"},{"location":"integrator-guide/error-handling/#example-javascript-fetch-api","text":"const PARSE_SERVER_URL = \"YOUR_GEMFORCE_PARSE_SERVER_URL/parse\" ; const APP_ID = \"YOUR_PARSE_APP_ID\" ; const REST_API_KEY = \"YOUR_PARSE_REST_API_KEY\" ; // or session token for user const SESSION_TOKEN = \"YOUR_SESSION_TOKEN\" ; // if authenticated user async function fetchProjectData ( projectId : string ) { try { const response = await fetch ( ` ${ PARSE_SERVER_URL } /classes/Project/ ${ projectId } ` , { method : 'GET' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : REST_API_KEY , 'X-Parse-Session-Token' : SESSION_TOKEN // Include if fetching protected data } }); if ( ! response . ok ) { // Check for HTTP error status codes (4xx, 5xx) const errorData = await response . json (); console . error ( `API Error: HTTP Status ${ response . status } , Parse Code ${ errorData . code || 'N/A' } ` ); throw new Error ( `Failed to fetch project: ${ errorData . error || 'Unknown API error' } ` ); } const data = await response . json (); console . log ( \"Project data:\" , data ); return data ; } catch ( error ) { console . error ( \"Network or parsing error:\" , error ); throw error ; // Re-throw to propagate for higher-level handling } } // Example usage: // fetchProjectData(\"nonexistentProjectId\") // .catch(err => console.error(\"Caught error:\", err.message));","title":"Example (JavaScript Fetch API)"},{"location":"integrator-guide/error-handling/#best-practices-for-rest-api-errors","text":"Check response.ok : Always check response.ok (or equivalent in your HTTP client) before parsing the JSON body. Parse Error Payloads : Always parse the JSON error payload to extract the code and error messages for specific handling and user feedback. Retry Logic : For transient errors (e.g., network issues, 5xx server errors), implement exponential backoff and retry mechanisms. Logging/Monitoring : Log API errors on your server-side for debugging and monitoring. Set up alerts for critical errors.","title":"Best Practices for REST API Errors:"},{"location":"integrator-guide/error-handling/#3-cloud-function-error-handling","text":"Cloud Functions are custom code executed on the Parse Server. Errors from Cloud Functions are returned via the standard Parse REST API error payload, but their error messages can be more specific to your business logic.","title":"3. Cloud Function Error Handling"},{"location":"integrator-guide/error-handling/#example-javascript-parse-sdk-nodejs","text":"const Parse = require ( 'parse/node' ); // Assuming Parse SDK is initialized Parse . initialize ( \"YOUR_APP_ID\" , \"YOUR_JAVASCRIPT_KEY\" , \"YOUR_MASTER_KEY\" ); Parse . serverURL = \"YOUR_GEMFORCE_PARSE_SERVER_URL/parse\" ; async function callCustomCloudFunction ( functionName : string , params : object ) { try { // Assume this cloud function 'processTradeDeal' can throw specific errors const result = await Parse . Cloud . run ( functionName , params , { useMasterKey : true }); // Example using Master Key console . log ( `Cloud function ${ functionName } result:` , result ); return result ; } catch ( error : any ) { console . error ( `Cloud function ${ functionName } failed:` ); console . error ( `Parse Error Code: ${ error . code } ` ); console . error ( `Error Message: ${ error . message } ` ); // Handle specific Parse error codes or custom messages if ( error . code === 141 ) { // Example: Cloud Code function failed with specific error if ( error . message . includes ( \"Invalid Trade Deal ID\" )) { console . error ( \"User-friendly message: The trade deal ID provided is not valid.\" ); } else if ( error . message . includes ( \"Insufficient collateral\" )) { console . error ( \"User-friendly message: Not enough collateral for this trade deal.\" ); } } else if ( error . code === 209 ) { // Session Token Expired console . error ( \"User-friendly message: Your session has expired. Please log in again.\" ); // Trigger re-authentication flow } throw error ; // Re-throw to propagate if needed } } // Example usage: // callCustomCloudFunction(\"processTradeDeal\", { tradeDealId: \"invalid\", amount: 100 }) // .catch(err => console.error(\"Cloud function call failed at top level:\", err.message));","title":"Example (JavaScript Parse SDK - Node.js)"},{"location":"integrator-guide/error-handling/#best-practices-for-cloud-function-errors","text":"Consistent Error Responses : Design your Cloud Functions to return consistent error structures (e.g., throw new Parse.Error(Parse.Error.SCRIPT_FAILED, \"Custom error message\"); ) to make client-side handling predictable. Informative Messages : Provide clear, descriptive error messages that help integrators understand the cause of the failure. Specific Error Codes : For critical business logic failures, consider mapping them to custom error codes if Parse.Error doesn't cover them.","title":"Best Practices for Cloud Function Errors:"},{"location":"integrator-guide/error-handling/#4-network-and-infrastructure-error-handling","text":"These are general issues that prevent successful communication with the Gemforce platform.","title":"4. Network and Infrastructure Error Handling"},{"location":"integrator-guide/error-handling/#common-scenarios","text":"Connection Refused : Server is down or inaccessible. Timeout : Request takes too long to respond. DNS Resolution Failure : Domain name cannot be resolved.","title":"Common Scenarios:"},{"location":"integrator-guide/error-handling/#best-practices","text":"Retry Logic : Implement robust retry mechanisms with exponential backoff and jitter for transient network failures. Circuit Breaker Pattern : For persistent failures, consider a circuit breaker to prevent overwhelming a failing service and to fail fast. Monitoring : Have monitoring and alerting in place for your integration points to detect widespread network issues. Fallback Mechanisms : If critical, consider fallback mechanisms (e.g., alternative RPC providers, cached data) when the primary service is unavailable.","title":"Best Practices:"},{"location":"integrator-guide/error-handling/#general-error-handling-principles","text":"Fail Gracefully : Your application should not crash due to an expected error. User Feedback : Translate technical errors into user-friendly messages. Logging : Implement comprehensive logging (client-side and server-side) to record errors for debugging and analysis. Alerting : Set up automated alerts for critical errors in production environments. Debugging Tools : Utilize browser developer tools, server logs, and blockchain explorers (for smart contract transactions) to debug issues.","title":"General Error Handling Principles"},{"location":"integrator-guide/error-handling/#related-documentation","text":"integrators-guide/authentication.md Parse Server Error Codes (External) Ethers.js Errors (External)","title":"Related Documentation"},{"location":"integrator-guide/integration-patterns/","text":"Integrator's Guide: Integration Patterns \u00b6 Designing robust and scalable integrations with the Gemforce platform requires adhering to established patterns. This guide explores common integration patterns, providing architectural recommendations and considerations for various scenarios, from simple dApp connections to complex enterprise systems. Overview of Integration Patterns \u00b6 Effective integration patterns help you to: Improve Reliability : Design systems that are resilient to failures and data inconsistencies. Enhance Scalability : Build components that can handle increasing load efficiently. Simplify Maintenance : Create modular and understandable integrations that are easier to update. Optimize Performance : Minimize latency and resource consumption. This guide covers patterns for: Frontend/Backend Separation for Blockchain Interaction Event-Driven Architectures Data Synchronization Patterns Transaction Management Patterns Microservices with Blockchain Integration 1. Frontend/Backend Separation for Blockchain Interaction \u00b6 This pattern advocates for separating blockchain interaction logic. Pattern Description \u00b6 Frontend (Client-side) : Primarily handles user interaction, wallet connection (e.g., MetaMask, WalletConnect), and direct view or pure smart contract calls. It might also initiate send transaction requests, but typically delegates complex transaction building or state changes to a backend. Backend (Server-side) : Manages sensitive operations, private keys, heavy computations, data indexing, and interaction with external services (like DFNS, traditional databases). It can also broadcast signed transactions received from the frontend or generated internally. Advantages \u00b6 Security : Private keys are never exposed to the client. Performance : Offloads heavy computations from the client. Scalability : Backend can be scaled independently. Control : Centralized logic for complex transactions and data validation. Considerations \u00b6 Latency : Introducing a backend might add slight latency for operations that could be done purely client-side. State Management : Requires careful synchronization of on-chain and off-chain state. Example Architecture \u00b6 +----------------+ +-------------------+ +--------------------+ | | | Node.js / Python | | | | | | Backend Service | | Gemforce Smart | | User Frontend | <---->| | <---->| Contracts | | (React/Vue/JS) | | - Private Key Mgmt| |(Diamond, Facets...) | | | | - Transaction API | | | | - Wallet Connect|<----> | - Data Indexing | | | | - View Calls | | - DFNS Integration| | | +----------------+ +-------------------+ +---------^----------+ | | Real-time Events | +-----------------+ | Blockchain Node | | / RPC Provider | +-----------------+ 2. Event-Driven Architectures \u00b6 This pattern focuses on reacting to events emitted by smart contracts or the Gemforce cloud platform. Pattern Description \u00b6 Deploy dedicated services (listeners) that monitor blockchain events (via RPC providers like Infura, Alchemy, or specialized indexing solutions like The Graph, Moralis) or Gemforce webhooks. When an event is detected, the listener triggers downstream processes (e.g., updates a database, sends notifications, initiates complex business logic). Advantages \u00b6 Real-time Updates : Immediate reaction to on-chain or platform state changes. Decoupling : Different services can operate independently, reducing inter-dependency. Scalability : Listeners and processing services can be scaled to handle event volume. Auditability : Events provide a clear audit trail of significant actions. Considerations \u00b6 Event Ordering : Ensuring correct processing order for events can be complex. Duplicate Events : Handle potential duplicate event receipts (idempotency). Indexing Lag : Be aware of potential delays between event emission and detection by your listener. Example Flow \u00b6 graph TD A[Gemforce Smart Contract] -- Emits Event --> B(Blockchain Node/RPC) B -- Event Stream --> C[Event Listener Service] C -- Publishes to Queue --> D(Message Queue: Kafka/RabbitMQ) D -- Consumers Pick Up --> E[Data Processing Service] E -- Updates --> F[Backend Database] 3. Data Synchronization Patterns \u00b6 Ensuring consistency between on-chain data and your off-chain databases. Pattern Description \u00b6 Event-Sourcing : The most robust approach. The canonical source of truth for certain data remains on-chain (events). Your off-chain database is a projection of these events. Snapshotting : Periodically read the full state from smart contracts and update your database. Less real-time, but simpler for static or slowly changing data. Hybrid : Combine event listening for real-time updates with periodic full synchronization for resilience or complex data. Advantages \u00b6 Consistency : Maintains coherent data across distributed systems. Resilience : Can rebuild off-chain state from on-chain data. Considerations \u00b6 Read/Write Performance : Queries on raw blockchain data can be slow; off-chain indexing improves read performance. Complexity : Requires careful design to handle reorgs (blockchain reorganizations) and ensure eventual consistency. Example \u00b6 Listening to TradeDealCreated events and saving them to a MongoDB. // From Trade Deal Listener example (simplified) tradeDealManagement . on ( \"TradeDealCreated\" , async ( tradeDealId , creator , amount , assetToken , event ) => { // Save to MongoDB via Mongoose const newTradeDeal = new TradeDealModel ({ _id : tradeDealId , // Use tradeDealId as primary key creatorAddress : creator , amount : ethers . utils . formatEther ( amount ), assetTokenAddress : assetToken , createdAtBlock : event . blockNumber , transactionHash : event . transactionHash }); await newTradeDeal . save (); console . log ( `Saved new trade deal ${ tradeDealId } to MongoDB.` ); }); 4. Transaction Management Patterns \u00b6 Handling the lifecycle of blockchain transactions. Pattern Description \u00b6 Client-Side Signing, Backend Broadcasting : Frontend gets user signature, passes signed transaction to backend, which broadcasts it. (Good for privacy/user control). Backend Signing (via DFNS/Private Key) : Backend creates and signs transactions (using DFNS or its own secure private keys), then broadcasts. (For automated processes, admin tools). Transaction Relayers : Users sign a meta-transaction, and a relayer pays gas to execute it on their behalf. (For gas abstraction, improving UX). Advantages \u00b6 Enhanced Security : Protects private keys. Improved UX : Can abstract gas fees or complex signing. Automated Operations : Enables programmatic control over on-chain actions. Considerations \u00b6 Latency : Relayers or backend signing can add latency. Trust : Requires trusting the backend or relayer with transaction details. Gas Management : Backend/relayer needs robust gas estimation and management. 5. Microservices with Blockchain Integration \u00b6 Structuring your application as small, independently deployable services, with some integrating specifically with blockchain. Pattern Description \u00b6 Each microservice (e.g., User Service, Marketplace Service, Identity Service) owns its data and business logic. Blockchain interaction is encapsulated within dedicated \"blockchain microservices\" or \"blockchain adapters\" that handle communication with smart contracts and event listening. These services communicate via APIs, message queues, or shared databases (if applicable). Advantages \u00b6 Modularity : Services are isolated and easier to develop, test, and deploy. Scalability : Individual services can be scaled based on demand. Technology Flexibility : Different services can use different technologies. Resilience : Failure in one service is less likely to affect the entire system. Considerations \u00b6 Distributed Transactions : Managing consistency across multiple services and the blockchain can be challenging. Operational Overhead : More services mean more operational complexity (deployment, monitoring). Data Consistency : Careful design needed to ensure eventual consistency between services. Example Architecture \u00b6 +------------+ +-------------------+ +---------------------+ +-----------------+ | User Micro |<->| Auth Microservice |<->| Blockchain Micro (SC) |<->| Smart Contracts | | Service | | (Parse Server) | | - On-chain Writes | +-----------------+ +------------+ +-------------------+ | - Tx Status Mgmt | | +---------------------+ | /\\ /\\ V | | Event Stream +-----------+ +---------------------+ +-----/--+ +--\\----+ | Other App |<->| Marketplace Micro |<->| Events Listener | | Blockchain Node | | Microservices | | Service | | (Indexer) | | / RPC Provider | +-----------+ +---------------------+ +-----------------+ +-----------------+ Related Documentation \u00b6 integrators-guide/authentication.md integrators-guide/smart-contracts.md integrators-guide/rest-api.md integrators-guide/webhooks.md System Architecture: Gemforce System Architecture","title":"Integration Patterns"},{"location":"integrator-guide/integration-patterns/#integrators-guide-integration-patterns","text":"Designing robust and scalable integrations with the Gemforce platform requires adhering to established patterns. This guide explores common integration patterns, providing architectural recommendations and considerations for various scenarios, from simple dApp connections to complex enterprise systems.","title":"Integrator's Guide: Integration Patterns"},{"location":"integrator-guide/integration-patterns/#overview-of-integration-patterns","text":"Effective integration patterns help you to: Improve Reliability : Design systems that are resilient to failures and data inconsistencies. Enhance Scalability : Build components that can handle increasing load efficiently. Simplify Maintenance : Create modular and understandable integrations that are easier to update. Optimize Performance : Minimize latency and resource consumption. This guide covers patterns for: Frontend/Backend Separation for Blockchain Interaction Event-Driven Architectures Data Synchronization Patterns Transaction Management Patterns Microservices with Blockchain Integration","title":"Overview of Integration Patterns"},{"location":"integrator-guide/integration-patterns/#1-frontendbackend-separation-for-blockchain-interaction","text":"This pattern advocates for separating blockchain interaction logic.","title":"1. Frontend/Backend Separation for Blockchain Interaction"},{"location":"integrator-guide/integration-patterns/#pattern-description","text":"Frontend (Client-side) : Primarily handles user interaction, wallet connection (e.g., MetaMask, WalletConnect), and direct view or pure smart contract calls. It might also initiate send transaction requests, but typically delegates complex transaction building or state changes to a backend. Backend (Server-side) : Manages sensitive operations, private keys, heavy computations, data indexing, and interaction with external services (like DFNS, traditional databases). It can also broadcast signed transactions received from the frontend or generated internally.","title":"Pattern Description"},{"location":"integrator-guide/integration-patterns/#advantages","text":"Security : Private keys are never exposed to the client. Performance : Offloads heavy computations from the client. Scalability : Backend can be scaled independently. Control : Centralized logic for complex transactions and data validation.","title":"Advantages"},{"location":"integrator-guide/integration-patterns/#considerations","text":"Latency : Introducing a backend might add slight latency for operations that could be done purely client-side. State Management : Requires careful synchronization of on-chain and off-chain state.","title":"Considerations"},{"location":"integrator-guide/integration-patterns/#example-architecture","text":"+----------------+ +-------------------+ +--------------------+ | | | Node.js / Python | | | | | | Backend Service | | Gemforce Smart | | User Frontend | <---->| | <---->| Contracts | | (React/Vue/JS) | | - Private Key Mgmt| |(Diamond, Facets...) | | | | - Transaction API | | | | - Wallet Connect|<----> | - Data Indexing | | | | - View Calls | | - DFNS Integration| | | +----------------+ +-------------------+ +---------^----------+ | | Real-time Events | +-----------------+ | Blockchain Node | | / RPC Provider | +-----------------+","title":"Example Architecture"},{"location":"integrator-guide/integration-patterns/#2-event-driven-architectures","text":"This pattern focuses on reacting to events emitted by smart contracts or the Gemforce cloud platform.","title":"2. Event-Driven Architectures"},{"location":"integrator-guide/integration-patterns/#pattern-description_1","text":"Deploy dedicated services (listeners) that monitor blockchain events (via RPC providers like Infura, Alchemy, or specialized indexing solutions like The Graph, Moralis) or Gemforce webhooks. When an event is detected, the listener triggers downstream processes (e.g., updates a database, sends notifications, initiates complex business logic).","title":"Pattern Description"},{"location":"integrator-guide/integration-patterns/#advantages_1","text":"Real-time Updates : Immediate reaction to on-chain or platform state changes. Decoupling : Different services can operate independently, reducing inter-dependency. Scalability : Listeners and processing services can be scaled to handle event volume. Auditability : Events provide a clear audit trail of significant actions.","title":"Advantages"},{"location":"integrator-guide/integration-patterns/#considerations_1","text":"Event Ordering : Ensuring correct processing order for events can be complex. Duplicate Events : Handle potential duplicate event receipts (idempotency). Indexing Lag : Be aware of potential delays between event emission and detection by your listener.","title":"Considerations"},{"location":"integrator-guide/integration-patterns/#example-flow","text":"graph TD A[Gemforce Smart Contract] -- Emits Event --> B(Blockchain Node/RPC) B -- Event Stream --> C[Event Listener Service] C -- Publishes to Queue --> D(Message Queue: Kafka/RabbitMQ) D -- Consumers Pick Up --> E[Data Processing Service] E -- Updates --> F[Backend Database]","title":"Example Flow"},{"location":"integrator-guide/integration-patterns/#3-data-synchronization-patterns","text":"Ensuring consistency between on-chain data and your off-chain databases.","title":"3. Data Synchronization Patterns"},{"location":"integrator-guide/integration-patterns/#pattern-description_2","text":"Event-Sourcing : The most robust approach. The canonical source of truth for certain data remains on-chain (events). Your off-chain database is a projection of these events. Snapshotting : Periodically read the full state from smart contracts and update your database. Less real-time, but simpler for static or slowly changing data. Hybrid : Combine event listening for real-time updates with periodic full synchronization for resilience or complex data.","title":"Pattern Description"},{"location":"integrator-guide/integration-patterns/#advantages_2","text":"Consistency : Maintains coherent data across distributed systems. Resilience : Can rebuild off-chain state from on-chain data.","title":"Advantages"},{"location":"integrator-guide/integration-patterns/#considerations_2","text":"Read/Write Performance : Queries on raw blockchain data can be slow; off-chain indexing improves read performance. Complexity : Requires careful design to handle reorgs (blockchain reorganizations) and ensure eventual consistency.","title":"Considerations"},{"location":"integrator-guide/integration-patterns/#example","text":"Listening to TradeDealCreated events and saving them to a MongoDB. // From Trade Deal Listener example (simplified) tradeDealManagement . on ( \"TradeDealCreated\" , async ( tradeDealId , creator , amount , assetToken , event ) => { // Save to MongoDB via Mongoose const newTradeDeal = new TradeDealModel ({ _id : tradeDealId , // Use tradeDealId as primary key creatorAddress : creator , amount : ethers . utils . formatEther ( amount ), assetTokenAddress : assetToken , createdAtBlock : event . blockNumber , transactionHash : event . transactionHash }); await newTradeDeal . save (); console . log ( `Saved new trade deal ${ tradeDealId } to MongoDB.` ); });","title":"Example"},{"location":"integrator-guide/integration-patterns/#4-transaction-management-patterns","text":"Handling the lifecycle of blockchain transactions.","title":"4. Transaction Management Patterns"},{"location":"integrator-guide/integration-patterns/#pattern-description_3","text":"Client-Side Signing, Backend Broadcasting : Frontend gets user signature, passes signed transaction to backend, which broadcasts it. (Good for privacy/user control). Backend Signing (via DFNS/Private Key) : Backend creates and signs transactions (using DFNS or its own secure private keys), then broadcasts. (For automated processes, admin tools). Transaction Relayers : Users sign a meta-transaction, and a relayer pays gas to execute it on their behalf. (For gas abstraction, improving UX).","title":"Pattern Description"},{"location":"integrator-guide/integration-patterns/#advantages_3","text":"Enhanced Security : Protects private keys. Improved UX : Can abstract gas fees or complex signing. Automated Operations : Enables programmatic control over on-chain actions.","title":"Advantages"},{"location":"integrator-guide/integration-patterns/#considerations_3","text":"Latency : Relayers or backend signing can add latency. Trust : Requires trusting the backend or relayer with transaction details. Gas Management : Backend/relayer needs robust gas estimation and management.","title":"Considerations"},{"location":"integrator-guide/integration-patterns/#5-microservices-with-blockchain-integration","text":"Structuring your application as small, independently deployable services, with some integrating specifically with blockchain.","title":"5. Microservices with Blockchain Integration"},{"location":"integrator-guide/integration-patterns/#pattern-description_4","text":"Each microservice (e.g., User Service, Marketplace Service, Identity Service) owns its data and business logic. Blockchain interaction is encapsulated within dedicated \"blockchain microservices\" or \"blockchain adapters\" that handle communication with smart contracts and event listening. These services communicate via APIs, message queues, or shared databases (if applicable).","title":"Pattern Description"},{"location":"integrator-guide/integration-patterns/#advantages_4","text":"Modularity : Services are isolated and easier to develop, test, and deploy. Scalability : Individual services can be scaled based on demand. Technology Flexibility : Different services can use different technologies. Resilience : Failure in one service is less likely to affect the entire system.","title":"Advantages"},{"location":"integrator-guide/integration-patterns/#considerations_4","text":"Distributed Transactions : Managing consistency across multiple services and the blockchain can be challenging. Operational Overhead : More services mean more operational complexity (deployment, monitoring). Data Consistency : Careful design needed to ensure eventual consistency between services.","title":"Considerations"},{"location":"integrator-guide/integration-patterns/#example-architecture_1","text":"+------------+ +-------------------+ +---------------------+ +-----------------+ | User Micro |<->| Auth Microservice |<->| Blockchain Micro (SC) |<->| Smart Contracts | | Service | | (Parse Server) | | - On-chain Writes | +-----------------+ +------------+ +-------------------+ | - Tx Status Mgmt | | +---------------------+ | /\\ /\\ V | | Event Stream +-----------+ +---------------------+ +-----/--+ +--\\----+ | Other App |<->| Marketplace Micro |<->| Events Listener | | Blockchain Node | | Microservices | | Service | | (Indexer) | | / RPC Provider | +-----------+ +---------------------+ +-----------------+ +-----------------+","title":"Example Architecture"},{"location":"integrator-guide/integration-patterns/#related-documentation","text":"integrators-guide/authentication.md integrators-guide/smart-contracts.md integrators-guide/rest-api.md integrators-guide/webhooks.md System Architecture: Gemforce System Architecture","title":"Related Documentation"},{"location":"integrator-guide/overview/","text":"Integrator's Guide: Overview \u00b6 Welcome to the Gemforce Integrator's Guide! This document provides a comprehensive overview for developers looking to integrate with the Gemforce platform. Whether you're building a new dApp, extending existing systems, or simply want to interact with Gemforce's smart contracts and cloud functions, this guide will walk you through the essential steps and concepts. Gemforce is a robust blockchain platform designed for decentralized applications, focusing on digital asset management, carbon credits, trade deals, and identity solutions. It leverages the Diamond Standard (EIP-2535) for modular smart contract architecture and a powerful cloud functions layer for off-chain capabilities. What You'll Find in This Guide \u00b6 This guide is structured to help you understand various integration points and best practices: Authentication : How to authenticate your applications and users with the Gemforce platform and its underlying services. REST API : Interacting with Gemforce's core functionalities via its RESTful API endpoints. Smart Contracts : Direct interaction with Gemforce's on-chain logic, including Diamond contracts, facets, and libraries. DFNS Integration : Leveraging DFNS Wallet-as-a-Service for secure key management and transaction signing. Webhooks : Receiving real-time notifications about events occurring on the Gemforce platform. Error Handling : Understanding and effectively handling errors across different integration layers. Sample Code : Practical code examples to jumpstart your development. Integration Patterns : Recommended architectural patterns for common integration scenarios. Testing : Strategies and tools for thorough testing of your integrations. Security : Best practices for securing your integrated applications. Compliance : Guidance on regulatory and compliance considerations. Key Concepts to Understand \u00b6 Before diving into specific integration details, it's beneficial to grasp these core Gemforce concepts: Diamond Standard (EIP-2535) : Gemforce's smart contracts are built using the Diamond Standard. This means functionalities are separated into \"facets\" which are attached to a central \"Diamond\" contract. This modularity allows for upgrades and extensions without redeploying the entire contract. Learn more : Diamond Standard Overview Cloud Functions (Parse Server) : Many of Gemforce's advanced features and user-facing functionalities are exposed through a cloud functions layer powered by Parse Server. This provides a traditional API interface for interacting with blockchain functionalities, managing user data, and handling complex business logic off-chain. Learn more : Cloud Functions Overview Multi-Network Support : Gemforce supports multiple blockchain networks (e.g., Base Sepolia, Optimism Sepolia, Sepolia). Your integration should be designed to handle multi-network considerations. Identity System (ERC-734/ERC-735) : Gemforce incorporates a robust identity management system based on ERC-734 (Key Manager) and ERC-735 (Claim Holder) for verifiable credentials and decentralized identity. Learn more : IIdentity Interface Key Technical Concepts : Familiarize yourself with Gemforce's core features like Carbon Credit Management, Trade Deal System, Multi-Token Sales, and SVG Templating, as these will likely be areas of integration. Learn more : System Architecture Getting Started \u00b6 To ensure a smooth integration process, we recommend the following initial steps: Review the System Architecture : Gain a high-level understanding of how Gemforce components interact. Set up Your Development Environment : Follow the Developer Setup Guide to prepare your local machine. Explore Core API Endpoints : Begin by understanding the basic authentication and data retrieval methods described in the REST API section. Examine Sample Code : Look at the provided Sample Code to see practical implementations across different integration types. Support \u00b6 If you encounter any issues or have questions that aren't covered in this guide, please refer to our Support Documentation (coming soon) or reach out to the Gemforce developer community. We are excited to see what you build with Gemforce!","title":"Overview"},{"location":"integrator-guide/overview/#integrators-guide-overview","text":"Welcome to the Gemforce Integrator's Guide! This document provides a comprehensive overview for developers looking to integrate with the Gemforce platform. Whether you're building a new dApp, extending existing systems, or simply want to interact with Gemforce's smart contracts and cloud functions, this guide will walk you through the essential steps and concepts. Gemforce is a robust blockchain platform designed for decentralized applications, focusing on digital asset management, carbon credits, trade deals, and identity solutions. It leverages the Diamond Standard (EIP-2535) for modular smart contract architecture and a powerful cloud functions layer for off-chain capabilities.","title":"Integrator's Guide: Overview"},{"location":"integrator-guide/overview/#what-youll-find-in-this-guide","text":"This guide is structured to help you understand various integration points and best practices: Authentication : How to authenticate your applications and users with the Gemforce platform and its underlying services. REST API : Interacting with Gemforce's core functionalities via its RESTful API endpoints. Smart Contracts : Direct interaction with Gemforce's on-chain logic, including Diamond contracts, facets, and libraries. DFNS Integration : Leveraging DFNS Wallet-as-a-Service for secure key management and transaction signing. Webhooks : Receiving real-time notifications about events occurring on the Gemforce platform. Error Handling : Understanding and effectively handling errors across different integration layers. Sample Code : Practical code examples to jumpstart your development. Integration Patterns : Recommended architectural patterns for common integration scenarios. Testing : Strategies and tools for thorough testing of your integrations. Security : Best practices for securing your integrated applications. Compliance : Guidance on regulatory and compliance considerations.","title":"What You'll Find in This Guide"},{"location":"integrator-guide/overview/#key-concepts-to-understand","text":"Before diving into specific integration details, it's beneficial to grasp these core Gemforce concepts: Diamond Standard (EIP-2535) : Gemforce's smart contracts are built using the Diamond Standard. This means functionalities are separated into \"facets\" which are attached to a central \"Diamond\" contract. This modularity allows for upgrades and extensions without redeploying the entire contract. Learn more : Diamond Standard Overview Cloud Functions (Parse Server) : Many of Gemforce's advanced features and user-facing functionalities are exposed through a cloud functions layer powered by Parse Server. This provides a traditional API interface for interacting with blockchain functionalities, managing user data, and handling complex business logic off-chain. Learn more : Cloud Functions Overview Multi-Network Support : Gemforce supports multiple blockchain networks (e.g., Base Sepolia, Optimism Sepolia, Sepolia). Your integration should be designed to handle multi-network considerations. Identity System (ERC-734/ERC-735) : Gemforce incorporates a robust identity management system based on ERC-734 (Key Manager) and ERC-735 (Claim Holder) for verifiable credentials and decentralized identity. Learn more : IIdentity Interface Key Technical Concepts : Familiarize yourself with Gemforce's core features like Carbon Credit Management, Trade Deal System, Multi-Token Sales, and SVG Templating, as these will likely be areas of integration. Learn more : System Architecture","title":"Key Concepts to Understand"},{"location":"integrator-guide/overview/#getting-started","text":"To ensure a smooth integration process, we recommend the following initial steps: Review the System Architecture : Gain a high-level understanding of how Gemforce components interact. Set up Your Development Environment : Follow the Developer Setup Guide to prepare your local machine. Explore Core API Endpoints : Begin by understanding the basic authentication and data retrieval methods described in the REST API section. Examine Sample Code : Look at the provided Sample Code to see practical implementations across different integration types.","title":"Getting Started"},{"location":"integrator-guide/overview/#support","text":"If you encounter any issues or have questions that aren't covered in this guide, please refer to our Support Documentation (coming soon) or reach out to the Gemforce developer community. We are excited to see what you build with Gemforce!","title":"Support"},{"location":"integrator-guide/parse-server/","text":"Parse Server Integration Guide \u00b6 Connecting to Parse Server \u00b6 Server Configuration (src/lib/parse-server.ts) \u00b6 const config = { server : { appId : 'YOUR_APP_ID' , masterKey : 'YOUR_MASTER_KEY' , serverURL : 'http://localhost:1337/parse' , port : 1337 } }; const parseServer = await parseServerLoad ( config ); Client Initialization (src/lib/parse.ts) \u00b6 import { parseClientConnect } from '../lib/parse' ; const gemforceConfig = { server : { appId : 'YOUR_APP_ID' , javascriptKey : 'YOUR_JS_KEY' , masterKey : 'YOUR_MASTER_KEY' , serverURL : 'http://localhost:1337/parse' } }; await parseClientConnect ( gemforceConfig ); CRUD Operations \u00b6 Create Record \u00b6 import { createRecord } from '../lib/parse' ; const newUser = await createRecord ( 'User' , [ 'email' ], [ 'user@example.com' ], { username : 'jdoe' , email : 'user@example.com' , password : 'securepassword' }); Query Records \u00b6 import { getRecords } from '../lib/parse' ; // Get all users created after 2024 const users = await getRecords ( 'User' , [ 'createdAt' ], [{ $gt : new Date ( '2024-01-01' ) }], [], 100 , 0 , 'createdAt' , 'desc' ); Update Record \u00b6 import { updateExistingRecord } from '../lib/parse' ; await updateExistingRecord ( 'User' , [ 'objectId' ], [ 'xK9sL3mZ' ], { lastLogin : new Date () } ); LiveQuery Setup for User Insertions \u00b6 Server Configuration \u00b6 Enable LiveQuery in parse-server.ts: config . server . liveQuery = { classNames : [ 'User' ] // Enable for User class }; Client Subscription \u00b6 const query = new Parse . Query ( 'User' ); const subscription = await query . subscribe (); subscription . on ( 'create' , ( user ) => { console . log ( 'New user created:' , user . get ( 'email' )); // Init identity workflow Parse . Cloud . run ( 'dfnsCreateIdentityInit' , { userId : user . id , walletAddress : user . get ( 'walletAddress' ) }); }); Identity Management Integration \u00b6 User Identity Workflow \u00b6 User registration triggers identity creation: Parse . Cloud . afterSave ( 'User' , async ( request ) => { const user = request . object ; if ( ! user . existed ()) { await Parse . Cloud . run ( 'dfnsCreateIdentityComplete' , { userId : user . id , publicKey : user . get ( 'publicKey' ) }); } }); Adding claims to identity: await Parse . Cloud . run ( 'dfnsSetClaimsComplete' , { userId : 'xK9sL3mZ' , claims : [{ topic : 'KYC_VERIFICATION' , value : 'VERIFIED' , issuer : 'TRUSTED_KYC_PROVIDER' }] }); Best Practices \u00b6 Always use master key for backend operations: Parse . Cloud . useMasterKey (); Handle errors in LiveQuery subscriptions: subscription . on ( 'error' , ( error ) => { console . error ( 'LiveQuery Error:' , error ); }); Use include for related objects: ```javascript const query = new Parse.Query('Identity'); query.include('user');","title":"Parse Server Integration Guide"},{"location":"integrator-guide/parse-server/#parse-server-integration-guide","text":"","title":"Parse Server Integration Guide"},{"location":"integrator-guide/parse-server/#connecting-to-parse-server","text":"","title":"Connecting to Parse Server"},{"location":"integrator-guide/parse-server/#server-configuration-srclibparse-serverts","text":"const config = { server : { appId : 'YOUR_APP_ID' , masterKey : 'YOUR_MASTER_KEY' , serverURL : 'http://localhost:1337/parse' , port : 1337 } }; const parseServer = await parseServerLoad ( config );","title":"Server Configuration (src/lib/parse-server.ts)"},{"location":"integrator-guide/parse-server/#client-initialization-srclibparsets","text":"import { parseClientConnect } from '../lib/parse' ; const gemforceConfig = { server : { appId : 'YOUR_APP_ID' , javascriptKey : 'YOUR_JS_KEY' , masterKey : 'YOUR_MASTER_KEY' , serverURL : 'http://localhost:1337/parse' } }; await parseClientConnect ( gemforceConfig );","title":"Client Initialization (src/lib/parse.ts)"},{"location":"integrator-guide/parse-server/#crud-operations","text":"","title":"CRUD Operations"},{"location":"integrator-guide/parse-server/#create-record","text":"import { createRecord } from '../lib/parse' ; const newUser = await createRecord ( 'User' , [ 'email' ], [ 'user@example.com' ], { username : 'jdoe' , email : 'user@example.com' , password : 'securepassword' });","title":"Create Record"},{"location":"integrator-guide/parse-server/#query-records","text":"import { getRecords } from '../lib/parse' ; // Get all users created after 2024 const users = await getRecords ( 'User' , [ 'createdAt' ], [{ $gt : new Date ( '2024-01-01' ) }], [], 100 , 0 , 'createdAt' , 'desc' );","title":"Query Records"},{"location":"integrator-guide/parse-server/#update-record","text":"import { updateExistingRecord } from '../lib/parse' ; await updateExistingRecord ( 'User' , [ 'objectId' ], [ 'xK9sL3mZ' ], { lastLogin : new Date () } );","title":"Update Record"},{"location":"integrator-guide/parse-server/#livequery-setup-for-user-insertions","text":"","title":"LiveQuery Setup for User Insertions"},{"location":"integrator-guide/parse-server/#server-configuration","text":"Enable LiveQuery in parse-server.ts: config . server . liveQuery = { classNames : [ 'User' ] // Enable for User class };","title":"Server Configuration"},{"location":"integrator-guide/parse-server/#client-subscription","text":"const query = new Parse . Query ( 'User' ); const subscription = await query . subscribe (); subscription . on ( 'create' , ( user ) => { console . log ( 'New user created:' , user . get ( 'email' )); // Init identity workflow Parse . Cloud . run ( 'dfnsCreateIdentityInit' , { userId : user . id , walletAddress : user . get ( 'walletAddress' ) }); });","title":"Client Subscription"},{"location":"integrator-guide/parse-server/#identity-management-integration","text":"","title":"Identity Management Integration"},{"location":"integrator-guide/parse-server/#user-identity-workflow","text":"User registration triggers identity creation: Parse . Cloud . afterSave ( 'User' , async ( request ) => { const user = request . object ; if ( ! user . existed ()) { await Parse . Cloud . run ( 'dfnsCreateIdentityComplete' , { userId : user . id , publicKey : user . get ( 'publicKey' ) }); } }); Adding claims to identity: await Parse . Cloud . run ( 'dfnsSetClaimsComplete' , { userId : 'xK9sL3mZ' , claims : [{ topic : 'KYC_VERIFICATION' , value : 'VERIFIED' , issuer : 'TRUSTED_KYC_PROVIDER' }] });","title":"User Identity Workflow"},{"location":"integrator-guide/parse-server/#best-practices","text":"Always use master key for backend operations: Parse . Cloud . useMasterKey (); Handle errors in LiveQuery subscriptions: subscription . on ( 'error' , ( error ) => { console . error ( 'LiveQuery Error:' , error ); }); Use include for related objects: ```javascript const query = new Parse.Query('Identity'); query.include('user');","title":"Best Practices"},{"location":"integrator-guide/rest-api/","text":"Integrator's Guide: REST API \u00b6 The Gemforce platform exposes much of its functionality through a rich RESTful API, powered by a Parse Server backend. This guide will walk you through how to interact with these endpoints, covering basic requests, common operations, and best practices for consuming the Gemforce REST API. Overview \u00b6 The Gemforce REST API provides: Data Management : CRUD (Create, Read, Update, Delete) operations for various data objects (e.g., users, projects, custom classes). Cloud Function Invocation : Execute custom server-side logic defined as Cloud Functions. File Storage : Upload and retrieve files. User Management : Sign up, log in, manage user sessions, and reset passwords. ACLs and CLPs : Access Control Lists (ACLs) and Class Level Permissions (CLPs) to secure your data. Base URL \u00b6 All REST API requests should be made to your Gemforce Parse Server instance's /parse endpoint. YOUR_GEMFORCE_PARSE_SERVER_URL/parse Authentication \u00b6 Every request to the Parse Server REST API requires specific headers for authentication. X-Parse-Application-Id : Your Parse Application ID. X-Parse-REST-API-Key : Your REST API Key. For client-side applications, this is generally safe to include. For server-side, you might use your Master Key (see section on Authentication). X-Parse-Master-Key : (Server-side only) Your Parse Master Key. Grants full access and bypasses security. Use with extreme caution. X-Parse-Session-Token : (Optional) Required for requests on behalf of an authenticated user. For more details checkout the Authentication Guide . Making Requests \u00b6 You can use any HTTP client (e.g., curl , Postman , axios in JavaScript, requests in Python) to interact with the Gemforce REST API. Let's look at some common operations. 1. Invoking Cloud Functions \u00b6 Cloud Functions allow you to execute server-side logic remotely. Endpoint : /functions/{functionName} Method : POST Body : JSON object containing parameters for the Cloud Function. curl -X POST \\ YOUR_GEMFORCE_PARSE_SERVER_URL/parse/functions/helloWorld \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-REST-API-Key: YOUR_PARSE_REST_API_KEY' \\ -H 'Content-Type: application/json' \\ -d '{ \"message\": \"Hello from API!\" }' Response Example: { \"result\" : \"Hello from API! You sent: Hello from API!\" } 2. Creating an Object (e.g., a \"Project\" in a custom class) \u00b6 You can create new objects in any custom Parse Class. Endpoint : /classes/{ClassName} Method : POST Body : JSON object representing the object data. curl -X POST \\ YOUR_GEMFORCE_PARSE_SERVER_URL/parse/classes/Project \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-REST-API-Key: YOUR_PARSE_REST_API_KEY' \\ -H 'Content-Type: application/json' \\ -d '{ \"name\": \"My First Gemforce Project\", \"status\": \"pending\", \"budget\": 100000 }' Response Example: { \"objectId\" : \"oZ5jV6QJ59\" , \"createdAt\" : \"2025-06-26T14:30:00.000Z\" } 3. Retrieving Objects \u00b6 Retrieve objects from a Parse Class. You can use query parameters for filtering, sorting, and pagination. Endpoint : /classes/{ClassName} or /classes/{ClassName}/{objectId} Method : GET Query Parameters : - where : JSON encoded query constraints (e.g., {\"status\": \"active\"} ). - limit : Maximum number of results to return. - skip : Number of results to skip (for pagination). - order : Field to sort by (e.g., -createdAt for descending). - keys : Comma-separated list of keys to return (for projection). - include : Comma-separated list of pointer fields to include the full object. Get all Projects \u00b6 curl -X GET \\ YOUR_GEMFORCE_PARSE_SERVER_URL/parse/classes/Project \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-REST-API-Key: YOUR_PARSE_REST_API_KEY' Get a specific Project by objectId \u00b6 curl -X GET \\ YOUR_GEMFORCE_PARSE_SERVER_URL/parse/classes/Project/oZ5jV6QJ59 \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-REST-API-Key: YOUR_PARSE_REST_API_KEY' Query Projects with a specific status \u00b6 curl -X GET \\ 'YOUR_GEMFORCE_PARSE_SERVER_URL/parse/classes/Project?where={\"status\": \"pending\"}' \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-REST-API-Key: YOUR_PARSE_REST_API_KEY' Response Example: { \"results\" : [ { \"name\" : \"My First Gemforce Project\" , \"status\" : \"pending\" , \"budget\" : 100000 , \"objectId\" : \"oZ5jV6QJ59\" , \"createdAt\" : \"2025-06-26T14:30:00.000Z\" , \"updatedAt\" : \"2025-06-26T14:30:00.000Z\" } ] } 4. Updating an Object \u00b6 Modify existing objects in a Parse Class. Endpoint : /classes/{ClassName}/{objectId} Method : PUT Body : JSON object containing the fields to update. curl -X PUT \\ YOUR_GEMFORCE_PARSE_SERVER_URL/parse/classes/Project/oZ5jV6QJ59 \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-REST-API-Key: YOUR_PARSE_REST_API_KEY' \\ -H 'Content-Type: application/json' \\ -d '{ \"status\": \"approved\", \"approvedBy\": \"admin_user_id\" }' Response Example: { \"updatedAt\" : \"2025-06-26T14:45:00.000Z\" } 5. Deleting an Object \u00b6 Remove an object from a Parse Class. Endpoint : /classes/{ClassName}/{objectId} Method : DELETE curl -X DELETE \\ YOUR_GEMFORCE_PARSE_SERVER_URL/parse/classes/Project/oZ5jV6QJ59 \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-Master-Key: YOUR_PARSE_MASTER_KEY' # Often requires Master Key for delete Response Example: {} Best Practices \u00b6 Error Handling : Always check the response status and gracefully handle errors returned by the API. Parse Server returns JSON objects with code and error fields for failures. (See Error Handling guide) Session Tokens : For user-facing applications, manage session tokens securely. Store them in localStorage (Web) or Keychain (Mobile) and include them in all authenticated requests. Master Key Security : Never expose your Master Key in client-side code. Use it only in secure, server-side environments. Rate Limiting : Be aware of any rate limits imposed by your Parse Server instance to prevent abuse and ensure fair usage. Parse SDKs : For rich client applications (Web, iOS, Android, etc.), consider using the official Parse SDKs (JavaScript, Java, Swift/Objective-C) which simplify API interactions, handle session management, and provide offline capabilities. Cloud Functions for Complex Logic : For complex business logic, data transformations, or interactions with external services, prefer creating and invoking Cloud Functions. This keeps your client code cleaner and your business logic secure on the server. Security : Implement appropriate Access Control Lists (ACLs) and Class Level Permissions (CLPs) on your Parse Server schema to protect your data. Related Documentation \u00b6 integrators-guide/authentication.md Cloud Functions: Overview Parse Server REST API Guide (External)","title":"REST API"},{"location":"integrator-guide/rest-api/#integrators-guide-rest-api","text":"The Gemforce platform exposes much of its functionality through a rich RESTful API, powered by a Parse Server backend. This guide will walk you through how to interact with these endpoints, covering basic requests, common operations, and best practices for consuming the Gemforce REST API.","title":"Integrator's Guide: REST API"},{"location":"integrator-guide/rest-api/#overview","text":"The Gemforce REST API provides: Data Management : CRUD (Create, Read, Update, Delete) operations for various data objects (e.g., users, projects, custom classes). Cloud Function Invocation : Execute custom server-side logic defined as Cloud Functions. File Storage : Upload and retrieve files. User Management : Sign up, log in, manage user sessions, and reset passwords. ACLs and CLPs : Access Control Lists (ACLs) and Class Level Permissions (CLPs) to secure your data.","title":"Overview"},{"location":"integrator-guide/rest-api/#base-url","text":"All REST API requests should be made to your Gemforce Parse Server instance's /parse endpoint. YOUR_GEMFORCE_PARSE_SERVER_URL/parse","title":"Base URL"},{"location":"integrator-guide/rest-api/#authentication","text":"Every request to the Parse Server REST API requires specific headers for authentication. X-Parse-Application-Id : Your Parse Application ID. X-Parse-REST-API-Key : Your REST API Key. For client-side applications, this is generally safe to include. For server-side, you might use your Master Key (see section on Authentication). X-Parse-Master-Key : (Server-side only) Your Parse Master Key. Grants full access and bypasses security. Use with extreme caution. X-Parse-Session-Token : (Optional) Required for requests on behalf of an authenticated user. For more details checkout the Authentication Guide .","title":"Authentication"},{"location":"integrator-guide/rest-api/#making-requests","text":"You can use any HTTP client (e.g., curl , Postman , axios in JavaScript, requests in Python) to interact with the Gemforce REST API. Let's look at some common operations.","title":"Making Requests"},{"location":"integrator-guide/rest-api/#1-invoking-cloud-functions","text":"Cloud Functions allow you to execute server-side logic remotely. Endpoint : /functions/{functionName} Method : POST Body : JSON object containing parameters for the Cloud Function. curl -X POST \\ YOUR_GEMFORCE_PARSE_SERVER_URL/parse/functions/helloWorld \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-REST-API-Key: YOUR_PARSE_REST_API_KEY' \\ -H 'Content-Type: application/json' \\ -d '{ \"message\": \"Hello from API!\" }' Response Example: { \"result\" : \"Hello from API! You sent: Hello from API!\" }","title":"1. Invoking Cloud Functions"},{"location":"integrator-guide/rest-api/#2-creating-an-object-eg-a-project-in-a-custom-class","text":"You can create new objects in any custom Parse Class. Endpoint : /classes/{ClassName} Method : POST Body : JSON object representing the object data. curl -X POST \\ YOUR_GEMFORCE_PARSE_SERVER_URL/parse/classes/Project \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-REST-API-Key: YOUR_PARSE_REST_API_KEY' \\ -H 'Content-Type: application/json' \\ -d '{ \"name\": \"My First Gemforce Project\", \"status\": \"pending\", \"budget\": 100000 }' Response Example: { \"objectId\" : \"oZ5jV6QJ59\" , \"createdAt\" : \"2025-06-26T14:30:00.000Z\" }","title":"2. Creating an Object (e.g., a \"Project\" in a custom class)"},{"location":"integrator-guide/rest-api/#3-retrieving-objects","text":"Retrieve objects from a Parse Class. You can use query parameters for filtering, sorting, and pagination. Endpoint : /classes/{ClassName} or /classes/{ClassName}/{objectId} Method : GET Query Parameters : - where : JSON encoded query constraints (e.g., {\"status\": \"active\"} ). - limit : Maximum number of results to return. - skip : Number of results to skip (for pagination). - order : Field to sort by (e.g., -createdAt for descending). - keys : Comma-separated list of keys to return (for projection). - include : Comma-separated list of pointer fields to include the full object.","title":"3. Retrieving Objects"},{"location":"integrator-guide/rest-api/#get-all-projects","text":"curl -X GET \\ YOUR_GEMFORCE_PARSE_SERVER_URL/parse/classes/Project \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-REST-API-Key: YOUR_PARSE_REST_API_KEY'","title":"Get all Projects"},{"location":"integrator-guide/rest-api/#get-a-specific-project-by-objectid","text":"curl -X GET \\ YOUR_GEMFORCE_PARSE_SERVER_URL/parse/classes/Project/oZ5jV6QJ59 \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-REST-API-Key: YOUR_PARSE_REST_API_KEY'","title":"Get a specific Project by objectId"},{"location":"integrator-guide/rest-api/#query-projects-with-a-specific-status","text":"curl -X GET \\ 'YOUR_GEMFORCE_PARSE_SERVER_URL/parse/classes/Project?where={\"status\": \"pending\"}' \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-REST-API-Key: YOUR_PARSE_REST_API_KEY' Response Example: { \"results\" : [ { \"name\" : \"My First Gemforce Project\" , \"status\" : \"pending\" , \"budget\" : 100000 , \"objectId\" : \"oZ5jV6QJ59\" , \"createdAt\" : \"2025-06-26T14:30:00.000Z\" , \"updatedAt\" : \"2025-06-26T14:30:00.000Z\" } ] }","title":"Query Projects with a specific status"},{"location":"integrator-guide/rest-api/#4-updating-an-object","text":"Modify existing objects in a Parse Class. Endpoint : /classes/{ClassName}/{objectId} Method : PUT Body : JSON object containing the fields to update. curl -X PUT \\ YOUR_GEMFORCE_PARSE_SERVER_URL/parse/classes/Project/oZ5jV6QJ59 \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-REST-API-Key: YOUR_PARSE_REST_API_KEY' \\ -H 'Content-Type: application/json' \\ -d '{ \"status\": \"approved\", \"approvedBy\": \"admin_user_id\" }' Response Example: { \"updatedAt\" : \"2025-06-26T14:45:00.000Z\" }","title":"4. Updating an Object"},{"location":"integrator-guide/rest-api/#5-deleting-an-object","text":"Remove an object from a Parse Class. Endpoint : /classes/{ClassName}/{objectId} Method : DELETE curl -X DELETE \\ YOUR_GEMFORCE_PARSE_SERVER_URL/parse/classes/Project/oZ5jV6QJ59 \\ -H 'X-Parse-Application-Id: YOUR_PARSE_APP_ID' \\ -H 'X-Parse-Master-Key: YOUR_PARSE_MASTER_KEY' # Often requires Master Key for delete Response Example: {}","title":"5. Deleting an Object"},{"location":"integrator-guide/rest-api/#best-practices","text":"Error Handling : Always check the response status and gracefully handle errors returned by the API. Parse Server returns JSON objects with code and error fields for failures. (See Error Handling guide) Session Tokens : For user-facing applications, manage session tokens securely. Store them in localStorage (Web) or Keychain (Mobile) and include them in all authenticated requests. Master Key Security : Never expose your Master Key in client-side code. Use it only in secure, server-side environments. Rate Limiting : Be aware of any rate limits imposed by your Parse Server instance to prevent abuse and ensure fair usage. Parse SDKs : For rich client applications (Web, iOS, Android, etc.), consider using the official Parse SDKs (JavaScript, Java, Swift/Objective-C) which simplify API interactions, handle session management, and provide offline capabilities. Cloud Functions for Complex Logic : For complex business logic, data transformations, or interactions with external services, prefer creating and invoking Cloud Functions. This keeps your client code cleaner and your business logic secure on the server. Security : Implement appropriate Access Control Lists (ACLs) and Class Level Permissions (CLPs) on your Parse Server schema to protect your data.","title":"Best Practices"},{"location":"integrator-guide/rest-api/#related-documentation","text":"integrators-guide/authentication.md Cloud Functions: Overview Parse Server REST API Guide (External)","title":"Related Documentation"},{"location":"integrator-guide/sample-code/","text":"Integrator's Guide: Sample Code \u00b6 This section provides practical code samples and snippets to help you quickly get started with integrating your applications with the Gemforce platform. The examples cover common use cases and demonstrate how to interact with various Gemforce components, including smart contracts, cloud functions, and APIs. Overview of Sample Code \u00b6 The samples are categorized by the Gemforce component they demonstrate: Smart Contract Interaction : Examples for deploying, calling functions, and listening to events on Gemforce's Diamond contracts. Cloud Function & REST API Usage : Demonstrations of user authentication, data management (CRUD), and invoking custom cloud logic. Advanced Integrations : Code for features like DFNS transaction signing, webhook handling, and data analytics. Each example is designed to be self-contained where possible, but you may need to refer to other sections of this Integrator's Guide for full context (e.g., Authentication , Smart Contracts ). 1. Smart Contract Interaction Examples \u00b6 1.1 Deploying a Diamond Contract (using Hardhat/Ethers.js) \u00b6 This example shows a simplified Hardhat script to deploy a Gemforce-style Diamond contract with some initial facets. // scripts/deployDiamond.ts import { ethers } from \"hardhat\" ; import { FacetCutAction } from \"../@gemforce-sdk/hardhat-diamond/types\" ; // Assuming SDK provides this enum async function deployGemforceDiamond () { const [ deployer ] = await ethers . getSigners (); console . log ( `Deploying contracts with the account: ${ deployer . address } ` ); // Deploy LibDiamond const LibDiamond = await ethers . getContractFactory ( \"LibDiamond\" ); const libDiamond = await LibDiamond . deploy (); await libDiamond . deployed (); console . log ( `LibDiamond deployed to: ${ libDiamond . address } ` ); // Deploy Diamond const Diamond = await ethers . getContractFactory ( \"Diamond\" , { libraries : { LibDiamond : libDiamond.address , }, }); const diamond = await Diamond . deploy ( deployer . address , true ); // initial owner, whether to add owner as facet await diamond . deployed (); console . log ( `Gemforce Diamond deployed to: ${ diamond . address } ` ); // Deploy Facets const FacetA = await ethers . getContractFactory ( \"FacetA\" ); const facetA = await FacetA . deploy (); await facetA . deployed (); console . log ( `FacetA deployed to: ${ facetA . address } ` ); const FacetB = await ethers . getContractFactory ( \"FacetB\" ); const facetB = await FacetB . deploy (); await facetB . deployed (); console . log ( `FacetB deployed to: ${ facetB . address } ` ); // Get DiamondCutFacet and DiamondLoupeFacet (assuming they are part of the Diamond initially or deployed separately) // For simplicity, let's assume Diamond.sol contains basic DiamondCutFacet functions or these are injected const DiamondCutFacet = await ethers . getContractFactory ( \"DiamondCutFacet\" ); const diamondCutFacet = await DiamondCutFacet . attach ( diamond . address ); // Prepare facet cuts const facetCuts = [ { facetAddress : facetA.address , action : FacetCutAction.Add , functionSelectors : FacetA.interface.getSighash ( \"function1()\" ), // Example selector }, { facetAddress : facetB.address , action : FacetCutAction.Add , functionSelectors : FacetB.interface.getSighash ( \"function2()\" ), // Example selector } ]; // Perform the diamond cut to add facets console . log ( \"Adding facets to Diamond...\" ); const diamondCutTx = await diamondCutFacet . diamondCut ( facetCuts , ethers . constants . AddressZero , // initContract \"0x\" // initData ); await diamondCutTx . wait (); console . log ( \"Facets added to Diamond.\" ); return diamond . address ; } // Call the deployment function // deployGemforceDiamond() // .then((address) => console.log(`Deployment complete. Diamond address: ${address}`)) // .catch((error) => { // console.error(error); // process.exit(1); // }); 1.2 Interacting with Marketplace Listing (Frontend Ethers.js) \u00b6 This example shows how a frontend dApp user might list an ERC721 NFT on the Gemforce marketplace. // frontend/src/components/ListNFT.tsx import React , { useState } from 'react' ; import { ethers , Contract } from 'ethers' ; import MarketplaceFacetABI from '../abi/MarketplaceFacet.json' ; // ABI import ERC721ABI from '../abi/ERC721.json' ; // ERC721 ABI for approval const GEMFORCE_DIAMOND_ADDRESS = \"0x...\" ; // Replace with your deployed Diamond address const MARKETPLACE_FACET_ADDRESS = GEMFORCE_DIAMOND_ADDRESS ; // Interact via the Diamond address const WETH_ADDRESS = \"0x...\" ; // Example WETH address for payment token const ListNFT : React.FC = () => { const [ nftContractAddress , setNftContractAddress ] = useState ( '' ); const [ tokenId , setTokenId ] = useState ( '' ); const [ price , setPrice ] = useState ( '' ); const [ loading , setLoading ] = useState ( false ); const [ message , setMessage ] = useState ( '' ); const connectWallet = async () => { if ( ! window . ethereum ) { setMessage ( \"MetaMask or compatible wallet not detected.\" ); return null ; } await window . ethereum . request ({ method : 'eth_requestAccounts' }); const provider = new ethers . providers . Web3Provider ( window . ethereum ); return provider . getSigner (); }; const handleListNFT = async () => { setLoading ( true ); setMessage ( '' ); try { const signer = await connectWallet (); if ( ! signer ) return ; const nftContract = new Contract ( nftContractAddress , ERC721ABI , signer ); const marketplace = new Contract ( MARKETPLACE_FACET_ADDRESS , MarketplaceFacetABI , signer ); // 1. Approve the Marketplace Facet to transfer the NFT setMessage ( \"Approving NFT transfer...\" ); const approveTx = await nftContract . approve ( MARKETPLACE_FACET_ADDRESS , tokenId ); await approveTx . wait (); setMessage ( `Approval successful. Tx: ${ approveTx . hash } ` ); // 2. List the NFT on the marketplace setMessage ( \"Listing NFT on marketplace...\" ); // Use ethers.utils.parseEther for values in ETH; otherwise convert to Wei const priceInWei = ethers . utils . parseEther ( price ); const listTx = await marketplace . listItem ( nftContractAddress , tokenId , priceInWei , WETH_ADDRESS // Or ethers.constants.AddressZero for native ETH ); await listTx . wait (); setMessage ( `NFT listed successfully! Tx: ${ listTx . hash } ` ); setNftContractAddress ( '' ); setTokenId ( '' ); setPrice ( '' ); } catch ( error : any ) { console . error ( \"Error listing NFT:\" , error ); setMessage ( `Error: ${ error . message || \"Something went wrong.\" } ` ); } finally { setLoading ( false ); } }; return ( < div > < h2 > List NFT on Gemforce Marketplace < /h2> < input type = \"text\" placeholder = \"NFT Contract Address\" value = { nftContractAddress } onChange = {( e ) => setNftContractAddress ( e . target . value )} /> < input type = \"number\" placeholder = \"Token ID\" value = { tokenId } onChange = {( e ) => setTokenId ( e . target . value )} /> < input type = \"text\" placeholder = \"Price (ETH)\" value = { price } onChange = {( e ) => setPrice ( e . target . value )} /> < button onClick = { handleListNFT } disabled = { loading } > { loading ? 'Processing...' : 'List NFT' } < /button> { message && < p > { message } < /p>} < /div> ); }; export default ListNFT ; 1.3 Listening for Smart Contract Events (Backend Node.js) \u00b6 This Node.js example demonstrates how a backend service can listen for TradeDealCreated events from the TradeDealManagementFacet of the Gemforce Diamond. // backend/src/listeners/tradeDealListener.ts import { ethers } from 'ethers' ; import TradeDealManagementFacetABI from '../../abi/TradeDealManagementFacet.json' ; // ABI const GEMFORCE_DIAMOND_ADDRESS = \"0x...\" ; // Replace with your deployed Diamond address const RPC_URL = \"wss://base-sepolia.public.blastapi.io\" ; // Use a WebSocket provider for real-time events const setupTradeDealListener = () => { try { const provider = new ethers . providers . WebSocketProvider ( RPC_URL ); // Create a contract instance focused on the TradeDealManagementFacet's events const tradeDealManagement = new ethers . Contract ( GEMFORCE_DIAMOND_ADDRESS , TradeDealManagementFacetABI , provider ); console . log ( \"Listening for 'TradeDealCreated' events...\" ); // Event signature: event TradeDealCreated(bytes32 indexed tradeDealId, address indexed creator, uint256 indexed amount, address assetToken); tradeDealManagement . on ( \"TradeDealCreated\" , ( tradeDealId , creator , amount , assetToken , event ) => { console . log ( \"\\n--- New Trade Deal Created! ---\" ); console . log ( \" Trade Deal ID:\" , tradeDealId ); console . log ( \" Creator:\" , creator ); console . log ( \" Amount:\" , ethers . utils . formatEther ( amount )); // Assuming amount in Wei console . log ( \" Asset Token:\" , assetToken ); console . log ( \" Transaction Hash:\" , event . transactionHash ); console . log ( \"-------------------------------\" ); // Here, you would typically: // - Update your backend database (e.g., save the new trade deal) // - Trigger notifications (e.g., push notification to users) // - Initiate further off-chain processing }); } catch ( error ) { console . error ( \"Error setting up Trade Deal listener:\" , error ); } }; // Start the listener when the application boots up // setupTradeDealListener(); 2. Cloud Function & REST API Usage Examples \u00b6 2.1 User Authentication (Frontend JavaScript) \u00b6 This example demonstrates user signup and login using direct Parse REST API calls in a web browser. // frontend/src/services/authService.js const PARSE_SERVER_URL = \"YOUR_GEMFORCE_PARSE_SERVER_URL/parse\" ; const APP_ID = \"YOUR_PARSE_APP_ID\" ; const CLIENT_KEY = \"YOUR_PARSE_CLIENT_KEY\" ; export const signUpUser = async ( username , password , email ) => { try { const response = await fetch ( ` ${ PARSE_SERVER_URL } /users` , { method : 'POST' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : CLIENT_KEY , 'Content-Type' : 'application/json' }, body : JSON . stringify ({ username , password , email }) }); const data = await response . json (); if ( ! response . ok ) throw new Error ( data . error || \"Signup failed\" ); console . log ( \"User signed up:\" , data ); return data ; // Contains sessionToken } catch ( error ) { console . error ( \"Signup error:\" , error ); throw error ; } }; export const loginUser = async ( username , password ) => { try { const response = await fetch ( ` ${ PARSE_SERVER_URL } /login?username= ${ username } &password= ${ password } ` , { method : 'GET' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : CLIENT_KEY } }); const data = await response . json (); if ( ! response . ok ) throw new Error ( data . error || \"Login failed\" ); console . log ( \"User logged in, session token:\" , data . sessionToken ); // Store sessionToken securely (e.g., localStorage, secure cookies) localStorage . setItem ( 'sessionToken' , data . sessionToken ); return data . sessionToken ; } catch ( error ) { console . error ( \"Login error:\" , error ); throw error ; } }; export const callAuthenticatedCloudFunction = async ( functionName , params ) => { const sessionToken = localStorage . getItem ( 'sessionToken' ); if ( ! sessionToken ) throw new Error ( \"No active session token found.\" ); try { const response = await fetch ( ` ${ PARSE_SERVER_URL } /functions/ ${ functionName } ` , { method : 'POST' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : CLIENT_KEY , 'X-Parse-Session-Token' : sessionToken , 'Content-Type' : 'application/json' }, body : JSON . stringify ( params ) }); const data = await response . json (); if ( ! response . ok ) throw new Error ( data . error || `Cloud function ${ functionName } failed` ); console . log ( `Cloud function ${ functionName } result:` , data . result ); return data . result ; } catch ( error ) { console . error ( `Cloud function call error for ${ functionName } :` , error ); throw error ; } }; // Example usage: // (async () => { // try { // // await signUpUser(\"sample_user\", \"secure_password\", \"user@example.com\"); // const token = await loginUser(\"sample_user\", \"secure_password\"); // const result = await callAuthenticatedCloudFunction(\"getUserProfile\", { userId: \"someUserId\" }); // } catch (e) { // console.error(\"Auth/Cloud Function Demo Error:\", e.message); // } // })(); 2.2 Managing a Custom Object (Node.js Backend) \u00b6 This Node.js example demonstrates CRUD operations for a custom Parse Product class using the Parse SDK directly. // backend/src/services/productService.js const Parse = require ( 'parse/node' ); // Ensure Parse SDK is initialized (e.g., in your app's entry point) // Parse.initialize(\"YOUR_PARSE_APP_ID\", \"YOUR_PARSE_JAVASCRIPT_KEY\", \"YOUR_PARSE_MASTER_KEY\"); // Parse.serverURL = \"YOUR_GEMFORCE_PARSE_SERVER_URL/parse\"; export const createProduct = async ( name , description , price ) => { try { const Product = Parse . Object . extend ( \"Product\" ); const product = new Product (); product . set ( \"name\" , name ); product . set ( \"description\" , description ); product . set ( \"price\" , price ); product . set ( \"isInStock\" , true ); // Save the object, using Master Key for backend operations const savedProduct = await product . save ( null , { useMasterKey : true }); console . log ( 'New product created with objectId: ' + savedProduct . id ); return savedProduct ; } catch ( error ) { console . error ( 'Error creating product:' , error ); throw error ; } }; export const getProduct = async ( objectId ) => { try { const Product = Parse . Object . extend ( \"Product\" ); const query = new Parse . Query ( Product ); // Use Master Key for backend operations const product = await query . get ( objectId , { useMasterKey : true }); console . log ( 'Retrieved product:' , product . toJSON ()); return product ; } catch ( error ) { console . error ( 'Error getting product:' , error ); throw error ; } }; export const updateProduct = async ( objectId , updates ) => { try { const Product = Parse . Object . extend ( \"Product\" ); const query = new Parse . Query ( Product ); const product = await query . get ( objectId , { useMasterKey : true }); // Retrieve first for ( const key in updates ) { product . set ( key , updates [ key ]); } // Save updates const updatedProduct = await product . save ( null , { useMasterKey : true }); console . log ( 'Product updated:' , updatedProduct . toJSON ()); return updatedProduct ; } catch ( error ) { console . error ( 'Error updating product:' , error ); throw error ; } }; export const deleteProduct = async ( objectId ) => { try { const Product = Parse . Object . extend ( \"Product\" ); const query = new Parse . Query ( Product ); const product = await query . get ( objectId , { useMasterKey : true }); await product . destroy ({ useMasterKey : true }); console . log ( 'Product deleted successfully.' ); } catch ( error ) { console . error ( 'Error deleting product:' , error ); throw error ; } }; // Example Usage: // (async () => { // try { // const newProduct = await createProduct(\"Gemstone\", \"Rare blue sapphire\", 5000); // const productId = newProduct.id; // await getProduct(productId); // await updateProduct(productId, { price: 4500, isInStock: false }); // await deleteProduct(productId); // } catch (e) { // console.error(\"Product Service Demo Error:\", e.message); // } // })(); 3. Advanced Integration Examples \u00b6 3.1 DFNS Transaction Signing (Backend Node.js) \u00b6 This example demonstrates how to use the DFNS SDK to securely sign an EVM transaction on your backend using a DFNS wallet. // backend/src/services/dfnsSigner.ts import { DfnsApiClient , AsymmetricKeys , SignatureMechanism } from '@dfns/sdk' ; import { EvmTransaction } from '@dfns/sdk/codegen/datamodel/EvmTransaction' ; import { ethers } from 'ethers' ; const DFNS_API_URL = process . env . DFNS_API_URL || \"https://api.dfns.io\" ; const DFNS_APP_ID = process . env . DFNS_APP_ID || \"YOUR_DFNS_APP_ID\" ; const DFNS_SIGNING_KEY_ID = process . env . DFNS_SIGNING_KEY_ID || \"sk-xxxxxxxxxxxxxxxxx\" ; const DFNS_PRIVATE_KEY = process . env . DFNS_PRIVATE_KEY || \"YOUR_DFNS_PRIVATE_KEY_PEM\" ; // Absolute path to PEM file or actual PEM string let dfnsClient : DfnsApiClient ; function initializeDfnsClient () { if ( ! dfnsClient ) { dfnsClient = new DfnsApiClient ({ baseUrl : DFNS_API_URL , appId : DFNS_APP_ID , authMethod : new AsymmetricKeys ({ privateKey : DFNS_PRIVATE_KEY , signingKeyId : DFNS_SIGNING_KEY_ID , }) }); } return dfnsClient ; } export const signEvmTransaction = async ( walletId : string , to : string , value : ethers.BigNumberish , data : string , chainId : string , nonce : number , gasLimit : ethers.BigNumberish ) => { initializeDfnsClient (); // Prepare the raw EVM transaction payload const rawTransaction : EvmTransaction = { to : to , value : ethers.BigNumber.from ( value ). toHexString (), // Convert to hex string data : data , gasLimit : ethers.BigNumber.from ( gasLimit ). toHexString (), chainId : ethers.BigNumber.from ( chainId ). toHexString (), nonce : ethers.BigNumber.from ( nonce ). toHexString (), type : \"0x0\" , // Or \"0x2\" for EIP-1559, then include maxFeePerGas, maxPriorityFeePerGas // For simplicity, omitting gasPrice / EIP-1559 fields for now }; try { const signRequest = { walletId : walletId , chainId : chainId , // Format \"eip155:<chain_id>\" for DFNS if needed, otherwise just number payload : JSON.stringify ( rawTransaction ), signatureMechanism : SignatureMechanism.JsonRpc , // Or Eip1559, etc. transactionType : \"EvmTransaction\" , }; const response = await dfnsClient . wallet . signTransaction ( signRequest ); console . log ( \"Transaction signed by DFNS:\" , response . signedData ); return response . signedData ; // This is the fully signed hex string to broadcast } catch ( error ) { console . error ( \"DFNS signing error:\" , error ); throw error ; } }; // Example usage: // (async () => { // try { // const dfnsWalletUuid = \"YOUR_DFNS_WALLET_UUID\"; // const targetChainId = \"11155111\"; // Sepolia // const recipientAddress = \"0x...\"; // const amountToSend = ethers.utils.parseEther(\"0.001\"); // const txData = \"0x\"; // Empty data for simple transfer // // You would typically get nonce and gasLimit from your RPC provider // const provider = new ethers.providers.JsonRpcProvider(\"https://sepolia.base.org\"); // const currentNonce = await provider.getTransactionCount(dfnsWalletUuid); // const gasLimit = 21000; // For simple ETH transfer // const signedTx = await signEvmTransaction( // dfnsWalletUuid, // recipientAddress, // amountToSend, // txData, // targetChainId, // currentNonce, // gasLimit // ); // // Then broadcast the signed transaction // // const broadcastProvider = new ethers.providers.JsonRpcProvider(\"https://sepolia.base.org\"); // // const receipt = await broadcastProvider.sendTransaction(signedTx); // // await receipt.wait(); // // console.log(\"Transaction broadcasted and confirmed:\", receipt.hash); // } catch (e) { // console.error(\"DFNS Sample Demo Error:\", e.message); // } // })(); 3.2 Consuming a Webhook (Node.js with Express) \u00b6 This example provides a basic Node.js Express server to receive and process webhooks from the Gemforce platform. ```javascript // backend/src/webhooks/webhookConsumer.ts const express = require('express'); const bodyParser = require('body-parser'); const crypto = require('crypto'); const app = express(); const PORT = process.env.WEBHOOK_PORT || 3001; // Listen on a different port than main app const WEBHOOK_SECRET = process.env.GEMFORCE_WEBHOOK_SECRET || \"aStrongAndRandomSecretKeyForVerification\"; // Must match config in Gemforce app.use(bodyParser.json()); app.post('/gemforce-webhook', (req, res) => { console.log('Received HTTP POST to /gemforce-webhook'); // 1. Verify Signature (Crucial for security) const signature = req.headers['x-gemforce-signature'] as string; // Header sent by Gemforce if (!signature) { console.warn('Webhook received without signature. Rejecting.'); return res.status(401).send('Signature Missing'); } try { const hmac = crypto.createHmac('sha256', WEBHOOK_SECRET); hmac.update(JSON.stringify(req.body)); const calculatedSignature = hmac.digest('hex'); if (signature !== calculatedSignature) { console.warn('Webhook signature verification failed. Possible tampering.'); return res.status(403).send('Invalid Signature'); } console.log('Webhook signature successfully verified.'); } catch (error) { console.error('Error during signature verification:', error); return res.status(500).send('Signature Verification Error'); } // 2. Process the Payload const eventType = req.body.event?.type; const eventData = req.body.data; if (!eventType || !eventData) { console.warn('Malformed webhook payload received. Missing event type or data.'); return res.status(400).send('Malformed Payload'); } console.log(`Processing event type: ${eventType}`); // console.log('Event Data:', JSON.stringify(eventData, null, 2)); switch (eventType) { case 'user.created': console.log(`New User Created: ${eventData.object?.username} (ID: ${eventData.object?.objectId})`); // Add your logic: e.g., send welcome email, update user stats break; case 'marketplace.itemListed': console.log(`Marketplace Item Listed: NFT ${eventData.tokenId} at price ${ethers.utils.formatEther(eventData.price)} ETH`); // Add your logic: e.g., index item in a search database, notify subscribers break; case 'tradeDeal.statusUpdated': console.log(`Trade Deal ${eventData.tradeDealId} status changed to ${eventData.newStatus}`); // Update internal trade deal status, trigger further payment processing break; // Add more cases for other event types default: console.log(`Received unhandled event type: ${eventType}`); break; } // Acknowledge receipt res.status(200).send('Webhook received and processed'); }); // Start the webhook listener // app.listen(PORT, () => { // console.log( Gemforce Webhook consumer listening on port ${PORT} ); // }); export default app; // Export the app if used in a larger project","title":"Sample Code"},{"location":"integrator-guide/sample-code/#integrators-guide-sample-code","text":"This section provides practical code samples and snippets to help you quickly get started with integrating your applications with the Gemforce platform. The examples cover common use cases and demonstrate how to interact with various Gemforce components, including smart contracts, cloud functions, and APIs.","title":"Integrator's Guide: Sample Code"},{"location":"integrator-guide/sample-code/#overview-of-sample-code","text":"The samples are categorized by the Gemforce component they demonstrate: Smart Contract Interaction : Examples for deploying, calling functions, and listening to events on Gemforce's Diamond contracts. Cloud Function & REST API Usage : Demonstrations of user authentication, data management (CRUD), and invoking custom cloud logic. Advanced Integrations : Code for features like DFNS transaction signing, webhook handling, and data analytics. Each example is designed to be self-contained where possible, but you may need to refer to other sections of this Integrator's Guide for full context (e.g., Authentication , Smart Contracts ).","title":"Overview of Sample Code"},{"location":"integrator-guide/sample-code/#1-smart-contract-interaction-examples","text":"","title":"1. Smart Contract Interaction Examples"},{"location":"integrator-guide/sample-code/#11-deploying-a-diamond-contract-using-hardhatethersjs","text":"This example shows a simplified Hardhat script to deploy a Gemforce-style Diamond contract with some initial facets. // scripts/deployDiamond.ts import { ethers } from \"hardhat\" ; import { FacetCutAction } from \"../@gemforce-sdk/hardhat-diamond/types\" ; // Assuming SDK provides this enum async function deployGemforceDiamond () { const [ deployer ] = await ethers . getSigners (); console . log ( `Deploying contracts with the account: ${ deployer . address } ` ); // Deploy LibDiamond const LibDiamond = await ethers . getContractFactory ( \"LibDiamond\" ); const libDiamond = await LibDiamond . deploy (); await libDiamond . deployed (); console . log ( `LibDiamond deployed to: ${ libDiamond . address } ` ); // Deploy Diamond const Diamond = await ethers . getContractFactory ( \"Diamond\" , { libraries : { LibDiamond : libDiamond.address , }, }); const diamond = await Diamond . deploy ( deployer . address , true ); // initial owner, whether to add owner as facet await diamond . deployed (); console . log ( `Gemforce Diamond deployed to: ${ diamond . address } ` ); // Deploy Facets const FacetA = await ethers . getContractFactory ( \"FacetA\" ); const facetA = await FacetA . deploy (); await facetA . deployed (); console . log ( `FacetA deployed to: ${ facetA . address } ` ); const FacetB = await ethers . getContractFactory ( \"FacetB\" ); const facetB = await FacetB . deploy (); await facetB . deployed (); console . log ( `FacetB deployed to: ${ facetB . address } ` ); // Get DiamondCutFacet and DiamondLoupeFacet (assuming they are part of the Diamond initially or deployed separately) // For simplicity, let's assume Diamond.sol contains basic DiamondCutFacet functions or these are injected const DiamondCutFacet = await ethers . getContractFactory ( \"DiamondCutFacet\" ); const diamondCutFacet = await DiamondCutFacet . attach ( diamond . address ); // Prepare facet cuts const facetCuts = [ { facetAddress : facetA.address , action : FacetCutAction.Add , functionSelectors : FacetA.interface.getSighash ( \"function1()\" ), // Example selector }, { facetAddress : facetB.address , action : FacetCutAction.Add , functionSelectors : FacetB.interface.getSighash ( \"function2()\" ), // Example selector } ]; // Perform the diamond cut to add facets console . log ( \"Adding facets to Diamond...\" ); const diamondCutTx = await diamondCutFacet . diamondCut ( facetCuts , ethers . constants . AddressZero , // initContract \"0x\" // initData ); await diamondCutTx . wait (); console . log ( \"Facets added to Diamond.\" ); return diamond . address ; } // Call the deployment function // deployGemforceDiamond() // .then((address) => console.log(`Deployment complete. Diamond address: ${address}`)) // .catch((error) => { // console.error(error); // process.exit(1); // });","title":"1.1 Deploying a Diamond Contract (using Hardhat/Ethers.js)"},{"location":"integrator-guide/sample-code/#12-interacting-with-marketplace-listing-frontend-ethersjs","text":"This example shows how a frontend dApp user might list an ERC721 NFT on the Gemforce marketplace. // frontend/src/components/ListNFT.tsx import React , { useState } from 'react' ; import { ethers , Contract } from 'ethers' ; import MarketplaceFacetABI from '../abi/MarketplaceFacet.json' ; // ABI import ERC721ABI from '../abi/ERC721.json' ; // ERC721 ABI for approval const GEMFORCE_DIAMOND_ADDRESS = \"0x...\" ; // Replace with your deployed Diamond address const MARKETPLACE_FACET_ADDRESS = GEMFORCE_DIAMOND_ADDRESS ; // Interact via the Diamond address const WETH_ADDRESS = \"0x...\" ; // Example WETH address for payment token const ListNFT : React.FC = () => { const [ nftContractAddress , setNftContractAddress ] = useState ( '' ); const [ tokenId , setTokenId ] = useState ( '' ); const [ price , setPrice ] = useState ( '' ); const [ loading , setLoading ] = useState ( false ); const [ message , setMessage ] = useState ( '' ); const connectWallet = async () => { if ( ! window . ethereum ) { setMessage ( \"MetaMask or compatible wallet not detected.\" ); return null ; } await window . ethereum . request ({ method : 'eth_requestAccounts' }); const provider = new ethers . providers . Web3Provider ( window . ethereum ); return provider . getSigner (); }; const handleListNFT = async () => { setLoading ( true ); setMessage ( '' ); try { const signer = await connectWallet (); if ( ! signer ) return ; const nftContract = new Contract ( nftContractAddress , ERC721ABI , signer ); const marketplace = new Contract ( MARKETPLACE_FACET_ADDRESS , MarketplaceFacetABI , signer ); // 1. Approve the Marketplace Facet to transfer the NFT setMessage ( \"Approving NFT transfer...\" ); const approveTx = await nftContract . approve ( MARKETPLACE_FACET_ADDRESS , tokenId ); await approveTx . wait (); setMessage ( `Approval successful. Tx: ${ approveTx . hash } ` ); // 2. List the NFT on the marketplace setMessage ( \"Listing NFT on marketplace...\" ); // Use ethers.utils.parseEther for values in ETH; otherwise convert to Wei const priceInWei = ethers . utils . parseEther ( price ); const listTx = await marketplace . listItem ( nftContractAddress , tokenId , priceInWei , WETH_ADDRESS // Or ethers.constants.AddressZero for native ETH ); await listTx . wait (); setMessage ( `NFT listed successfully! Tx: ${ listTx . hash } ` ); setNftContractAddress ( '' ); setTokenId ( '' ); setPrice ( '' ); } catch ( error : any ) { console . error ( \"Error listing NFT:\" , error ); setMessage ( `Error: ${ error . message || \"Something went wrong.\" } ` ); } finally { setLoading ( false ); } }; return ( < div > < h2 > List NFT on Gemforce Marketplace < /h2> < input type = \"text\" placeholder = \"NFT Contract Address\" value = { nftContractAddress } onChange = {( e ) => setNftContractAddress ( e . target . value )} /> < input type = \"number\" placeholder = \"Token ID\" value = { tokenId } onChange = {( e ) => setTokenId ( e . target . value )} /> < input type = \"text\" placeholder = \"Price (ETH)\" value = { price } onChange = {( e ) => setPrice ( e . target . value )} /> < button onClick = { handleListNFT } disabled = { loading } > { loading ? 'Processing...' : 'List NFT' } < /button> { message && < p > { message } < /p>} < /div> ); }; export default ListNFT ;","title":"1.2 Interacting with Marketplace Listing (Frontend Ethers.js)"},{"location":"integrator-guide/sample-code/#13-listening-for-smart-contract-events-backend-nodejs","text":"This Node.js example demonstrates how a backend service can listen for TradeDealCreated events from the TradeDealManagementFacet of the Gemforce Diamond. // backend/src/listeners/tradeDealListener.ts import { ethers } from 'ethers' ; import TradeDealManagementFacetABI from '../../abi/TradeDealManagementFacet.json' ; // ABI const GEMFORCE_DIAMOND_ADDRESS = \"0x...\" ; // Replace with your deployed Diamond address const RPC_URL = \"wss://base-sepolia.public.blastapi.io\" ; // Use a WebSocket provider for real-time events const setupTradeDealListener = () => { try { const provider = new ethers . providers . WebSocketProvider ( RPC_URL ); // Create a contract instance focused on the TradeDealManagementFacet's events const tradeDealManagement = new ethers . Contract ( GEMFORCE_DIAMOND_ADDRESS , TradeDealManagementFacetABI , provider ); console . log ( \"Listening for 'TradeDealCreated' events...\" ); // Event signature: event TradeDealCreated(bytes32 indexed tradeDealId, address indexed creator, uint256 indexed amount, address assetToken); tradeDealManagement . on ( \"TradeDealCreated\" , ( tradeDealId , creator , amount , assetToken , event ) => { console . log ( \"\\n--- New Trade Deal Created! ---\" ); console . log ( \" Trade Deal ID:\" , tradeDealId ); console . log ( \" Creator:\" , creator ); console . log ( \" Amount:\" , ethers . utils . formatEther ( amount )); // Assuming amount in Wei console . log ( \" Asset Token:\" , assetToken ); console . log ( \" Transaction Hash:\" , event . transactionHash ); console . log ( \"-------------------------------\" ); // Here, you would typically: // - Update your backend database (e.g., save the new trade deal) // - Trigger notifications (e.g., push notification to users) // - Initiate further off-chain processing }); } catch ( error ) { console . error ( \"Error setting up Trade Deal listener:\" , error ); } }; // Start the listener when the application boots up // setupTradeDealListener();","title":"1.3 Listening for Smart Contract Events (Backend Node.js)"},{"location":"integrator-guide/sample-code/#2-cloud-function-rest-api-usage-examples","text":"","title":"2. Cloud Function &amp; REST API Usage Examples"},{"location":"integrator-guide/sample-code/#21-user-authentication-frontend-javascript","text":"This example demonstrates user signup and login using direct Parse REST API calls in a web browser. // frontend/src/services/authService.js const PARSE_SERVER_URL = \"YOUR_GEMFORCE_PARSE_SERVER_URL/parse\" ; const APP_ID = \"YOUR_PARSE_APP_ID\" ; const CLIENT_KEY = \"YOUR_PARSE_CLIENT_KEY\" ; export const signUpUser = async ( username , password , email ) => { try { const response = await fetch ( ` ${ PARSE_SERVER_URL } /users` , { method : 'POST' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : CLIENT_KEY , 'Content-Type' : 'application/json' }, body : JSON . stringify ({ username , password , email }) }); const data = await response . json (); if ( ! response . ok ) throw new Error ( data . error || \"Signup failed\" ); console . log ( \"User signed up:\" , data ); return data ; // Contains sessionToken } catch ( error ) { console . error ( \"Signup error:\" , error ); throw error ; } }; export const loginUser = async ( username , password ) => { try { const response = await fetch ( ` ${ PARSE_SERVER_URL } /login?username= ${ username } &password= ${ password } ` , { method : 'GET' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : CLIENT_KEY } }); const data = await response . json (); if ( ! response . ok ) throw new Error ( data . error || \"Login failed\" ); console . log ( \"User logged in, session token:\" , data . sessionToken ); // Store sessionToken securely (e.g., localStorage, secure cookies) localStorage . setItem ( 'sessionToken' , data . sessionToken ); return data . sessionToken ; } catch ( error ) { console . error ( \"Login error:\" , error ); throw error ; } }; export const callAuthenticatedCloudFunction = async ( functionName , params ) => { const sessionToken = localStorage . getItem ( 'sessionToken' ); if ( ! sessionToken ) throw new Error ( \"No active session token found.\" ); try { const response = await fetch ( ` ${ PARSE_SERVER_URL } /functions/ ${ functionName } ` , { method : 'POST' , headers : { 'X-Parse-Application-Id' : APP_ID , 'X-Parse-REST-API-Key' : CLIENT_KEY , 'X-Parse-Session-Token' : sessionToken , 'Content-Type' : 'application/json' }, body : JSON . stringify ( params ) }); const data = await response . json (); if ( ! response . ok ) throw new Error ( data . error || `Cloud function ${ functionName } failed` ); console . log ( `Cloud function ${ functionName } result:` , data . result ); return data . result ; } catch ( error ) { console . error ( `Cloud function call error for ${ functionName } :` , error ); throw error ; } }; // Example usage: // (async () => { // try { // // await signUpUser(\"sample_user\", \"secure_password\", \"user@example.com\"); // const token = await loginUser(\"sample_user\", \"secure_password\"); // const result = await callAuthenticatedCloudFunction(\"getUserProfile\", { userId: \"someUserId\" }); // } catch (e) { // console.error(\"Auth/Cloud Function Demo Error:\", e.message); // } // })();","title":"2.1 User Authentication (Frontend JavaScript)"},{"location":"integrator-guide/sample-code/#22-managing-a-custom-object-nodejs-backend","text":"This Node.js example demonstrates CRUD operations for a custom Parse Product class using the Parse SDK directly. // backend/src/services/productService.js const Parse = require ( 'parse/node' ); // Ensure Parse SDK is initialized (e.g., in your app's entry point) // Parse.initialize(\"YOUR_PARSE_APP_ID\", \"YOUR_PARSE_JAVASCRIPT_KEY\", \"YOUR_PARSE_MASTER_KEY\"); // Parse.serverURL = \"YOUR_GEMFORCE_PARSE_SERVER_URL/parse\"; export const createProduct = async ( name , description , price ) => { try { const Product = Parse . Object . extend ( \"Product\" ); const product = new Product (); product . set ( \"name\" , name ); product . set ( \"description\" , description ); product . set ( \"price\" , price ); product . set ( \"isInStock\" , true ); // Save the object, using Master Key for backend operations const savedProduct = await product . save ( null , { useMasterKey : true }); console . log ( 'New product created with objectId: ' + savedProduct . id ); return savedProduct ; } catch ( error ) { console . error ( 'Error creating product:' , error ); throw error ; } }; export const getProduct = async ( objectId ) => { try { const Product = Parse . Object . extend ( \"Product\" ); const query = new Parse . Query ( Product ); // Use Master Key for backend operations const product = await query . get ( objectId , { useMasterKey : true }); console . log ( 'Retrieved product:' , product . toJSON ()); return product ; } catch ( error ) { console . error ( 'Error getting product:' , error ); throw error ; } }; export const updateProduct = async ( objectId , updates ) => { try { const Product = Parse . Object . extend ( \"Product\" ); const query = new Parse . Query ( Product ); const product = await query . get ( objectId , { useMasterKey : true }); // Retrieve first for ( const key in updates ) { product . set ( key , updates [ key ]); } // Save updates const updatedProduct = await product . save ( null , { useMasterKey : true }); console . log ( 'Product updated:' , updatedProduct . toJSON ()); return updatedProduct ; } catch ( error ) { console . error ( 'Error updating product:' , error ); throw error ; } }; export const deleteProduct = async ( objectId ) => { try { const Product = Parse . Object . extend ( \"Product\" ); const query = new Parse . Query ( Product ); const product = await query . get ( objectId , { useMasterKey : true }); await product . destroy ({ useMasterKey : true }); console . log ( 'Product deleted successfully.' ); } catch ( error ) { console . error ( 'Error deleting product:' , error ); throw error ; } }; // Example Usage: // (async () => { // try { // const newProduct = await createProduct(\"Gemstone\", \"Rare blue sapphire\", 5000); // const productId = newProduct.id; // await getProduct(productId); // await updateProduct(productId, { price: 4500, isInStock: false }); // await deleteProduct(productId); // } catch (e) { // console.error(\"Product Service Demo Error:\", e.message); // } // })();","title":"2.2 Managing a Custom Object (Node.js Backend)"},{"location":"integrator-guide/sample-code/#3-advanced-integration-examples","text":"","title":"3. Advanced Integration Examples"},{"location":"integrator-guide/sample-code/#31-dfns-transaction-signing-backend-nodejs","text":"This example demonstrates how to use the DFNS SDK to securely sign an EVM transaction on your backend using a DFNS wallet. // backend/src/services/dfnsSigner.ts import { DfnsApiClient , AsymmetricKeys , SignatureMechanism } from '@dfns/sdk' ; import { EvmTransaction } from '@dfns/sdk/codegen/datamodel/EvmTransaction' ; import { ethers } from 'ethers' ; const DFNS_API_URL = process . env . DFNS_API_URL || \"https://api.dfns.io\" ; const DFNS_APP_ID = process . env . DFNS_APP_ID || \"YOUR_DFNS_APP_ID\" ; const DFNS_SIGNING_KEY_ID = process . env . DFNS_SIGNING_KEY_ID || \"sk-xxxxxxxxxxxxxxxxx\" ; const DFNS_PRIVATE_KEY = process . env . DFNS_PRIVATE_KEY || \"YOUR_DFNS_PRIVATE_KEY_PEM\" ; // Absolute path to PEM file or actual PEM string let dfnsClient : DfnsApiClient ; function initializeDfnsClient () { if ( ! dfnsClient ) { dfnsClient = new DfnsApiClient ({ baseUrl : DFNS_API_URL , appId : DFNS_APP_ID , authMethod : new AsymmetricKeys ({ privateKey : DFNS_PRIVATE_KEY , signingKeyId : DFNS_SIGNING_KEY_ID , }) }); } return dfnsClient ; } export const signEvmTransaction = async ( walletId : string , to : string , value : ethers.BigNumberish , data : string , chainId : string , nonce : number , gasLimit : ethers.BigNumberish ) => { initializeDfnsClient (); // Prepare the raw EVM transaction payload const rawTransaction : EvmTransaction = { to : to , value : ethers.BigNumber.from ( value ). toHexString (), // Convert to hex string data : data , gasLimit : ethers.BigNumber.from ( gasLimit ). toHexString (), chainId : ethers.BigNumber.from ( chainId ). toHexString (), nonce : ethers.BigNumber.from ( nonce ). toHexString (), type : \"0x0\" , // Or \"0x2\" for EIP-1559, then include maxFeePerGas, maxPriorityFeePerGas // For simplicity, omitting gasPrice / EIP-1559 fields for now }; try { const signRequest = { walletId : walletId , chainId : chainId , // Format \"eip155:<chain_id>\" for DFNS if needed, otherwise just number payload : JSON.stringify ( rawTransaction ), signatureMechanism : SignatureMechanism.JsonRpc , // Or Eip1559, etc. transactionType : \"EvmTransaction\" , }; const response = await dfnsClient . wallet . signTransaction ( signRequest ); console . log ( \"Transaction signed by DFNS:\" , response . signedData ); return response . signedData ; // This is the fully signed hex string to broadcast } catch ( error ) { console . error ( \"DFNS signing error:\" , error ); throw error ; } }; // Example usage: // (async () => { // try { // const dfnsWalletUuid = \"YOUR_DFNS_WALLET_UUID\"; // const targetChainId = \"11155111\"; // Sepolia // const recipientAddress = \"0x...\"; // const amountToSend = ethers.utils.parseEther(\"0.001\"); // const txData = \"0x\"; // Empty data for simple transfer // // You would typically get nonce and gasLimit from your RPC provider // const provider = new ethers.providers.JsonRpcProvider(\"https://sepolia.base.org\"); // const currentNonce = await provider.getTransactionCount(dfnsWalletUuid); // const gasLimit = 21000; // For simple ETH transfer // const signedTx = await signEvmTransaction( // dfnsWalletUuid, // recipientAddress, // amountToSend, // txData, // targetChainId, // currentNonce, // gasLimit // ); // // Then broadcast the signed transaction // // const broadcastProvider = new ethers.providers.JsonRpcProvider(\"https://sepolia.base.org\"); // // const receipt = await broadcastProvider.sendTransaction(signedTx); // // await receipt.wait(); // // console.log(\"Transaction broadcasted and confirmed:\", receipt.hash); // } catch (e) { // console.error(\"DFNS Sample Demo Error:\", e.message); // } // })();","title":"3.1 DFNS Transaction Signing (Backend Node.js)"},{"location":"integrator-guide/sample-code/#32-consuming-a-webhook-nodejs-with-express","text":"This example provides a basic Node.js Express server to receive and process webhooks from the Gemforce platform. ```javascript // backend/src/webhooks/webhookConsumer.ts const express = require('express'); const bodyParser = require('body-parser'); const crypto = require('crypto'); const app = express(); const PORT = process.env.WEBHOOK_PORT || 3001; // Listen on a different port than main app const WEBHOOK_SECRET = process.env.GEMFORCE_WEBHOOK_SECRET || \"aStrongAndRandomSecretKeyForVerification\"; // Must match config in Gemforce app.use(bodyParser.json()); app.post('/gemforce-webhook', (req, res) => { console.log('Received HTTP POST to /gemforce-webhook'); // 1. Verify Signature (Crucial for security) const signature = req.headers['x-gemforce-signature'] as string; // Header sent by Gemforce if (!signature) { console.warn('Webhook received without signature. Rejecting.'); return res.status(401).send('Signature Missing'); } try { const hmac = crypto.createHmac('sha256', WEBHOOK_SECRET); hmac.update(JSON.stringify(req.body)); const calculatedSignature = hmac.digest('hex'); if (signature !== calculatedSignature) { console.warn('Webhook signature verification failed. Possible tampering.'); return res.status(403).send('Invalid Signature'); } console.log('Webhook signature successfully verified.'); } catch (error) { console.error('Error during signature verification:', error); return res.status(500).send('Signature Verification Error'); } // 2. Process the Payload const eventType = req.body.event?.type; const eventData = req.body.data; if (!eventType || !eventData) { console.warn('Malformed webhook payload received. Missing event type or data.'); return res.status(400).send('Malformed Payload'); } console.log(`Processing event type: ${eventType}`); // console.log('Event Data:', JSON.stringify(eventData, null, 2)); switch (eventType) { case 'user.created': console.log(`New User Created: ${eventData.object?.username} (ID: ${eventData.object?.objectId})`); // Add your logic: e.g., send welcome email, update user stats break; case 'marketplace.itemListed': console.log(`Marketplace Item Listed: NFT ${eventData.tokenId} at price ${ethers.utils.formatEther(eventData.price)} ETH`); // Add your logic: e.g., index item in a search database, notify subscribers break; case 'tradeDeal.statusUpdated': console.log(`Trade Deal ${eventData.tradeDealId} status changed to ${eventData.newStatus}`); // Update internal trade deal status, trigger further payment processing break; // Add more cases for other event types default: console.log(`Received unhandled event type: ${eventType}`); break; } // Acknowledge receipt res.status(200).send('Webhook received and processed'); }); // Start the webhook listener // app.listen(PORT, () => { // console.log( Gemforce Webhook consumer listening on port ${PORT} ); // }); export default app; // Export the app if used in a larger project","title":"3.2 Consuming a Webhook (Node.js with Express)"},{"location":"integrator-guide/security/","text":"Integrator's Guide: Security \u00b6 Security is paramount when integrating with the Gemforce platform, especially given its blockchain-centric nature and the handling of sensitive digital assets. This guide outlines key security considerations, best practices, and common vulnerabilities to help you build secure and resilient applications. Overview of Gemforce Security \u00b6 Gemforce's security posture is multi-layered, encompassing: Smart Contract Security : Audited contracts, adherence to secure coding standards. Cloud Function Security : Parse Server's built-in security features, secure API key management, robust access control. DFNS Integration : MPC-based key management for enhanced cryptographic security. Platform Operations : Secure deployment, monitoring, and incident response procedures. As an integrator, your application forms a critical link in this security chain. 1. Secure Smart Contract Interaction \u00b6 Direct interaction with blockchain smart contracts requires meticulous attention to security. Common Vulnerabilities \u00b6 Reentrancy : A common attack where a malicious contract repeatedly calls back into a vulnerable contract before the first function call is complete. Integer Overflow/Underflow : Arithmetical operations exceeding the maximum or minimum size of their data type, leading to unexpected values. Access Control Issues : Functions critical for contract state are not properly permissioned, allowing unauthorized users to execute them. Front-Running : An attacker observes a pending advantageous transaction and submits their own transaction with higher gas fees to execute before it. Denial of Service (DoS) : Attacks preventing legitimate users from accessing services, often by exhausting gas or blocking state changes. Delegatecall Vulnerabilities : Incorrect usage of delegatecall can lead to storage collision or unauthorized code execution. Unchecked External Calls : Naively calling external contracts without proper checks (e.g., for reentrancy guards). Best Practices \u00b6 Use Audited Contracts : Always use official, audited Gemforce smart contracts. Do not deploy or use modified versions without independent security review. Least Privilege : Grant only the necessary permissions to smart contract addresses that your application interacts with. Input Validation : Validate all inputs from users before sending them to smart contracts. Even though smart contracts should also validate, client-side/backend validation adds another layer of defense. Secure Transaction Signing : Never expose private keys : Handle private keys only in secure, controlled environments (e.g., hardware wallets, dedicated backend services like DFNS). DFNS Integration : Leverage DFNS for secure, policy-driven transaction signing where possible. \"Blind Signing\" : Educate users about what they are signing. Implement clear transaction details for user confirmation. Gas Management : Properly estimate and manage gas limits to avoid transaction failures (and potential DoS) or excessive costs. Monitor Events/State : Actively monitor for unusual activity by tracking smart contract events and state changes. Emergency Stop/Pause : Understand and utilize emergency stop mechanisms if provided in Gemforce's smart contracts to mitigate ongoing attacks. Upgradability : While Gemforce Diamonds are upgradeable, understand that upgrades themselves pose security risks if not managed properly. Monitor upgrade announcements. 2. Secure API and Cloud Function Integration \u00b6 Gemforce's Parse Server backend and Cloud Functions are critical components. Common Vulnerabilities \u00b6 API Key Exposure : Hardcoding or publicly exposing API keys. Insecure Data Transmission : Using HTTP instead of HTTPS. Weak Authentication : Guessable passwords, lack of multi-factor authentication. Injection Attacks : SQL injection (if using raw queries), NoSQL injection, command injection. Broken Access Control : Improperly configured ACLs/CLPs allowing unauthorized access to data or functions. Rate Limiting Abuse : Lack of rate limiting on API endpoints leading to DoS or brute-force attacks. Sensitive Data Exposure : Logging sensitive information or returning it in API responses. Best Practices \u00b6 HTTPS Everywhere : Always use HTTPS for all communications with Gemforce's REST API and Cloud Functions to encrypt data in transit. Secure API Key Management : Use environment variables or a secrets management service (e.g., AWS Secrets Manager, HashiCorp Vault) for Master Key and other sensitive API keys. Never hardcode API keys directly into client-side code unless explicitly designed for public consumption (e.g., X-Parse-Client-Key for public data). User Authentication : Implement strong password policies, encourage/enforce MFA, and securely manage user sessions. Input Validation : Implement comprehensive server-side input validation for all data received from clients to prevent injection attacks and ensure data integrity. Access Control : Rigorously configure and review Parse Server's built-in ACLs (Access Control Lists) and CLPs (Class Level Permissions) to restrict data access only to authorized users/roles. Error Handling : Avoid verbose error messages in production that could leak sensitive information (e.g., stack traces). Rate Limiting : Implement application-level rate limiting on your API calls to prevent abuse and denial-of-service attacks. Logging and Monitoring : Implement detailed logging for API requests and responses, and monitor for suspicious activity. 3. General Application Security \u00b6 These practices apply to your integrating application as a whole. Best Practices \u00b6 Minimal Dependencies : Use only necessary third-party libraries and keep them updated to minimize attack surface. Regularly audit your dependencies for known vulnerabilities. Principle of Least Privilege : Ensure that all components (applications, services, users) operate with the minimum set of permissions necessary to perform their function. Secure Development Lifecycle (SDL) : Incorporate security considerations at every stage of your development process, from design to deployment and maintenance. Regular Security Audits and Penetration Testing : Periodically engage security professionals to audit your entire integrated application for vulnerabilities. Incident Response Plan : Have a clear plan for identifying, responding to, and recovering from security incidents. This includes communication strategy, data breach procedures, and recovery steps. Data Protection : Ensure sensitive user data (e.g., email addresses, personal identifiers) is stored and transmitted securely, ideally encrypted at rest and in transit. Code Review : Implement mandatory code reviews covering security aspects. Employee Training : Train your development and operations teams on secure coding practices and security awareness. Related Documentation \u00b6 Error Handling Authentication Guide DFNS Integration Guide Parse Server Security Best Practices (External) OWASP Top 10 Web Application Security Risks (External)","title":"Security"},{"location":"integrator-guide/security/#integrators-guide-security","text":"Security is paramount when integrating with the Gemforce platform, especially given its blockchain-centric nature and the handling of sensitive digital assets. This guide outlines key security considerations, best practices, and common vulnerabilities to help you build secure and resilient applications.","title":"Integrator's Guide: Security"},{"location":"integrator-guide/security/#overview-of-gemforce-security","text":"Gemforce's security posture is multi-layered, encompassing: Smart Contract Security : Audited contracts, adherence to secure coding standards. Cloud Function Security : Parse Server's built-in security features, secure API key management, robust access control. DFNS Integration : MPC-based key management for enhanced cryptographic security. Platform Operations : Secure deployment, monitoring, and incident response procedures. As an integrator, your application forms a critical link in this security chain.","title":"Overview of Gemforce Security"},{"location":"integrator-guide/security/#1-secure-smart-contract-interaction","text":"Direct interaction with blockchain smart contracts requires meticulous attention to security.","title":"1. Secure Smart Contract Interaction"},{"location":"integrator-guide/security/#common-vulnerabilities","text":"Reentrancy : A common attack where a malicious contract repeatedly calls back into a vulnerable contract before the first function call is complete. Integer Overflow/Underflow : Arithmetical operations exceeding the maximum or minimum size of their data type, leading to unexpected values. Access Control Issues : Functions critical for contract state are not properly permissioned, allowing unauthorized users to execute them. Front-Running : An attacker observes a pending advantageous transaction and submits their own transaction with higher gas fees to execute before it. Denial of Service (DoS) : Attacks preventing legitimate users from accessing services, often by exhausting gas or blocking state changes. Delegatecall Vulnerabilities : Incorrect usage of delegatecall can lead to storage collision or unauthorized code execution. Unchecked External Calls : Naively calling external contracts without proper checks (e.g., for reentrancy guards).","title":"Common Vulnerabilities"},{"location":"integrator-guide/security/#best-practices","text":"Use Audited Contracts : Always use official, audited Gemforce smart contracts. Do not deploy or use modified versions without independent security review. Least Privilege : Grant only the necessary permissions to smart contract addresses that your application interacts with. Input Validation : Validate all inputs from users before sending them to smart contracts. Even though smart contracts should also validate, client-side/backend validation adds another layer of defense. Secure Transaction Signing : Never expose private keys : Handle private keys only in secure, controlled environments (e.g., hardware wallets, dedicated backend services like DFNS). DFNS Integration : Leverage DFNS for secure, policy-driven transaction signing where possible. \"Blind Signing\" : Educate users about what they are signing. Implement clear transaction details for user confirmation. Gas Management : Properly estimate and manage gas limits to avoid transaction failures (and potential DoS) or excessive costs. Monitor Events/State : Actively monitor for unusual activity by tracking smart contract events and state changes. Emergency Stop/Pause : Understand and utilize emergency stop mechanisms if provided in Gemforce's smart contracts to mitigate ongoing attacks. Upgradability : While Gemforce Diamonds are upgradeable, understand that upgrades themselves pose security risks if not managed properly. Monitor upgrade announcements.","title":"Best Practices"},{"location":"integrator-guide/security/#2-secure-api-and-cloud-function-integration","text":"Gemforce's Parse Server backend and Cloud Functions are critical components.","title":"2. Secure API and Cloud Function Integration"},{"location":"integrator-guide/security/#common-vulnerabilities_1","text":"API Key Exposure : Hardcoding or publicly exposing API keys. Insecure Data Transmission : Using HTTP instead of HTTPS. Weak Authentication : Guessable passwords, lack of multi-factor authentication. Injection Attacks : SQL injection (if using raw queries), NoSQL injection, command injection. Broken Access Control : Improperly configured ACLs/CLPs allowing unauthorized access to data or functions. Rate Limiting Abuse : Lack of rate limiting on API endpoints leading to DoS or brute-force attacks. Sensitive Data Exposure : Logging sensitive information or returning it in API responses.","title":"Common Vulnerabilities"},{"location":"integrator-guide/security/#best-practices_1","text":"HTTPS Everywhere : Always use HTTPS for all communications with Gemforce's REST API and Cloud Functions to encrypt data in transit. Secure API Key Management : Use environment variables or a secrets management service (e.g., AWS Secrets Manager, HashiCorp Vault) for Master Key and other sensitive API keys. Never hardcode API keys directly into client-side code unless explicitly designed for public consumption (e.g., X-Parse-Client-Key for public data). User Authentication : Implement strong password policies, encourage/enforce MFA, and securely manage user sessions. Input Validation : Implement comprehensive server-side input validation for all data received from clients to prevent injection attacks and ensure data integrity. Access Control : Rigorously configure and review Parse Server's built-in ACLs (Access Control Lists) and CLPs (Class Level Permissions) to restrict data access only to authorized users/roles. Error Handling : Avoid verbose error messages in production that could leak sensitive information (e.g., stack traces). Rate Limiting : Implement application-level rate limiting on your API calls to prevent abuse and denial-of-service attacks. Logging and Monitoring : Implement detailed logging for API requests and responses, and monitor for suspicious activity.","title":"Best Practices"},{"location":"integrator-guide/security/#3-general-application-security","text":"These practices apply to your integrating application as a whole.","title":"3. General Application Security"},{"location":"integrator-guide/security/#best-practices_2","text":"Minimal Dependencies : Use only necessary third-party libraries and keep them updated to minimize attack surface. Regularly audit your dependencies for known vulnerabilities. Principle of Least Privilege : Ensure that all components (applications, services, users) operate with the minimum set of permissions necessary to perform their function. Secure Development Lifecycle (SDL) : Incorporate security considerations at every stage of your development process, from design to deployment and maintenance. Regular Security Audits and Penetration Testing : Periodically engage security professionals to audit your entire integrated application for vulnerabilities. Incident Response Plan : Have a clear plan for identifying, responding to, and recovering from security incidents. This includes communication strategy, data breach procedures, and recovery steps. Data Protection : Ensure sensitive user data (e.g., email addresses, personal identifiers) is stored and transmitted securely, ideally encrypted at rest and in transit. Code Review : Implement mandatory code reviews covering security aspects. Employee Training : Train your development and operations teams on secure coding practices and security awareness.","title":"Best Practices"},{"location":"integrator-guide/security/#related-documentation","text":"Error Handling Authentication Guide DFNS Integration Guide Parse Server Security Best Practices (External) OWASP Top 10 Web Application Security Risks (External)","title":"Related Documentation"},{"location":"integrator-guide/smart-contracts/","text":"Integrator's Guide: Smart Contracts \u00b6 Integrating with Gemforce's smart contracts involves direct interaction with the blockchain. This guide will walk you through the essential tools, concepts, and best practices for interacting with Gemforce's Diamond-based smart contract architecture. Overview of Gemforce Smart Contracts \u00b6 Gemforce utilizes the Diamond Standard (EIP-2535) for its core smart contract architecture. This modular approach offers several benefits: Modularity : Functionalities are organized into smaller, self-contained facets . Upgradeability : Facets can be added, replaced, or removed without redeploying the main Diamond contract, allowing for continuous upgrades and bug fixes. No 24KB Limit : Bypasses the 24KB contract size limit, enabling extensive functionality. Shared Storage : All facets share the same storage, ensuring consistent state across the system. Key Gemforce smart contract components include: Diamond : The main entry point, a proxy contract. Facets : Contracts containing the business logic and functions. Libraries : Reusable code used by facets. Interfaces : Define the external functions of contracts. Essential Tools for Smart Contract Integration \u00b6 To interact with Gemforce's smart contracts, you'll need: Web3 Provider : Connects your application to the blockchain (e.g., MetaMask, WalletConnect, Infura, Alchemy, your own node). Web3 Library : JavaScript libraries to interact with Ethereum (e.g., Ethers.js or Web3.js ). Ethers.js is generally preferred for its cleaner API and robust features. Contract ABIs (Application Binary Interfaces) : These JSON files define the functions and events of a smart contract, allowing your application to encode/decode function calls and event logs. You can obtain Gemforce contract ABIs from our deployed contracts or the gem-base project. Interacting with a Diamond Contract \u00b6 A Diamond contract acts as a single address through which you interact with all connected facets. When you call a function on a Diamond, it delegates the call to the appropriate facet containing that function. Steps to Interact: \u00b6 Get the Diamond Address : This is the main address of the deployed Gemforce Diamond contract. Obtain Facet ABIs : While you interact with the Diamond's address, your Web3 library needs the ABI of the facet that contains the function you want to call. This is because the ABI defines the function signatures. Create a Contract Instance : Instantiate your Web3 library's Contract object using the Diamond's address and the relevant Facet's ABI. Call Functions / Listen for Events : Use the contract instance to send transactions or query data. Example (Ethers.js with a Diamond Facet) \u00b6 Suppose you want to interact with the MarketplaceFacet to list an NFT. import { ethers } from 'ethers' ; // Import the ABI for MarketplaceFacet import MarketplaceFacetABI from './MarketplaceFacet.json' ; // Adjust path as needed const GEMFORCE_DIAMOND_ADDRESS = \"0x...\" ; // Replace with the actual deployed Diamond address const YOUR_NFT_CONTRACT_ADDRESS = \"0x...\" ; // Replace with your NFT contract address const NFT_TOKEN_ID = 123 ; const PRICE = ethers . utils . parseEther ( \"0.5\" ); // 0.5 ETH const PAYMENT_TOKEN_ADDRESS = \"0x...\" ; // Address of WETH or other ERC20 accepted payment token, or address(0) for ETH async function listNFTOnGemforceMarketplace () { try { // 1. Connect to a Web3 Provider and Signer (e.g., via MetaMask in a browser) const provider = new ethers . providers . Web3Provider ( window . ethereum ); await provider . send ( \"eth_requestAccounts\" , []); // Prompts user to connect wallet const signer = provider . getSigner (); const userAddress = await signer . getAddress (); console . log ( \"Connected account:\" , userAddress ); // 2. Create a contract instance using the Diamond Address and MarketplaceFacet ABI // Although you call methods on myMarketplace, the transaction goes through the Diamond. const myMarketplace = new ethers . Contract ( GEMFORCE_DIAMOND_ADDRESS , // The Diamond's address MarketplaceFacetABI , // The ABI of the Facet containing the function signer // The signer (user's wallet) ); // 3. Approve the Marketplace to spend your NFT (if it's ERC721) // This assumes you have an ERC721 contract instance. const erc721Abi = [ \"function approve(address to, uint256 tokenId)\" ]; const nftContract = new ethers . Contract ( YOUR_NFT_CONTRACT_ADDRESS , erc721Abi , signer ); console . log ( `Approving MarketplaceFacet for NFT ID ${ NFT_TOKEN_ID } ...` ); const approveTx = await nftContract . approve ( GEMFORCE_DIAMOND_ADDRESS , NFT_TOKEN_ID ); await approveTx . wait (); console . log ( \"Approval successful. Transaction hash:\" , approveTx . hash ); // 4. Call the 'listItem' function from the MarketplaceFacet console . log ( \"Listing NFT on marketplace...\" ); const listItemTx = await myMarketplace . listItem ( YOUR_NFT_CONTRACT_ADDRESS , NFT_TOKEN_ID , PRICE , PAYMENT_TOKEN_ADDRESS ); const receipt = await listItemTx . wait (); console . log ( \"NFT listed successfully! Transaction hash:\" , receipt . hash ); console . log ( \"Events emitted:\" , receipt . events ); } catch ( error ) { console . error ( \"Error listing NFT:\" , error ); } } // Call the function // listNFTOnGemforceMarketplace(); Reading Data from Smart Contracts (View/Pure Functions) \u00b6 view and pure functions do not modify the blockchain state and can be called without sending a transaction (and thus without gas fees). Example (Ethers.js) \u00b6 import { ethers } from 'ethers' ; import DiamondLoupeFacetABI from './DiamondLoupeFacet.json' ; // ABI for DiamondLoupeFacet const GEMFORCE_DIAMOND_ADDRESS = \"0x...\" ; // Replace with the actual Diamond address const PROVIDER_URL = \"https://rpc.sepolia.org\" ; // Example RPC URL async function getFacetAddresses () { try { const provider = new ethers . providers . JsonRpcProvider ( PROVIDER_URL ); // Create a contract instance with DiamondLoupeFacet ABI const diamondLoupe = new ethers . Contract ( GEMFORCE_DIAMOND_ADDRESS , DiamondLoupeFacetABI , provider // No signer needed for view calls ); // Call a view function to get all registered facet addresses const facetAddresses = await diamondLoupe . facetAddresses (); console . log ( \"All Facet Addresses:\" , facetAddresses ); // You can then iterate through facetAddresses to get more details if needed for ( const addr of facetAddresses ) { const selectors = await diamondLoupe . facetFunctionSelectors ( addr ); console . log ( ` Facet ${ addr } has selectors:` , selectors ); } } catch ( error ) { console . error ( \"Error getting facet addresses:\" , error ); } } // Call the function // getFacetAddresses(); Listening for Smart Contract Events \u00b6 Smart contracts emit events to signal significant occurrences. Your application can listen for these events to react in real-time to on-chain changes without constantly polling. Example (Ethers.js) \u00b6 import { ethers } from 'ethers' ; import MarketplaceFacetABI from './MarketplaceFacet.json' ; // ABI for MarketplaceFacet const GEMFORCE_DIAMOND_ADDRESS = \"0x...\" ; // Replace with the actual deployed Diamond address const PROVIDER_URL = \"wss://base-sepolia.public.blastapi.io\" ; // Use a WebSocket provider for real-time events async function listenForNFTListings () { try { const provider = new ethers . providers . WebSocketProvider ( PROVIDER_URL ); // Create a contract instance for listening to events const myMarketplace = new ethers . Contract ( GEMFORCE_DIAMOND_ADDRESS , MarketplaceFacetABI , provider ); console . log ( \"Listening for 'ItemListed' events on the Marketplace...\" ); // Listen for the ItemListed event // The event signature typically looks like: event ItemListed(address indexed nftContract, uint256 indexed tokenId, address indexed seller, uint256 price, address paymentToken); myMarketplace . on ( \"ItemListed\" , ( nftContract , tokenId , seller , price , paymentToken , event ) => { console . log ( \"\\n--- New NFT Listed! ---\" ); console . log ( \" NFT Contract:\" , nftContract ); console . log ( \" Token ID:\" , tokenId . toString ()); console . log ( \" Seller:\" , seller ); console . log ( \" Price:\" , ethers . utils . formatEther ( price ), \"ETH\" ); // Assuming price in Wei // paymentToken might be address(0) for native currency console . log ( \" Payment Token:\" , paymentToken === ethers . constants . AddressZero ? \"ETH\" : paymentToken ); console . log ( \" Transaction Hash:\" , event . transactionHash ); console . log ( \"-----------------------\" ); }); } catch ( error ) { console . error ( \"Error setting up event listener:\" , error ); } } // Call the function // listenForNFTListings(); Best Practices for Smart Contract Integration \u00b6 Gas Management : Account for gas fees. Provide users with clear information about potential costs. For backend automation, ensure your calling account has sufficient funds. Error Handling : Smart contract calls can revert. Implement robust try-catch blocks and parse revert messages for user feedback. Security : Never expose private keys in client-side code. Use secure signing processes (e.g., MetaMask, DFNS). Follow secure coding guidelines for your dApp. Network Agnosticism : Design your application to be configurable for different networks (e.g., Sepolia, Base Sepolia, Optimism Sepolia) by using network IDs, RPC URLs, and contract addresses. Diamond Specifics : Always read the Diamond contract's specific documentation for details on its deployed facets and their expected behaviors. ABIs : Ensure you are using the correct and up-to-date ABIs for the facets you intend to interact with. Optimistic UI/UX : For state-changing transactions, provide immediate visual feedback to the user while waiting for transactions to be mined. Related Documentation \u00b6 Diamond Standard Overview Facets documentation Interfaces documentation Libraries documentation Authentication Guide","title":"Smart Contracts"},{"location":"integrator-guide/smart-contracts/#integrators-guide-smart-contracts","text":"Integrating with Gemforce's smart contracts involves direct interaction with the blockchain. This guide will walk you through the essential tools, concepts, and best practices for interacting with Gemforce's Diamond-based smart contract architecture.","title":"Integrator's Guide: Smart Contracts"},{"location":"integrator-guide/smart-contracts/#overview-of-gemforce-smart-contracts","text":"Gemforce utilizes the Diamond Standard (EIP-2535) for its core smart contract architecture. This modular approach offers several benefits: Modularity : Functionalities are organized into smaller, self-contained facets . Upgradeability : Facets can be added, replaced, or removed without redeploying the main Diamond contract, allowing for continuous upgrades and bug fixes. No 24KB Limit : Bypasses the 24KB contract size limit, enabling extensive functionality. Shared Storage : All facets share the same storage, ensuring consistent state across the system. Key Gemforce smart contract components include: Diamond : The main entry point, a proxy contract. Facets : Contracts containing the business logic and functions. Libraries : Reusable code used by facets. Interfaces : Define the external functions of contracts.","title":"Overview of Gemforce Smart Contracts"},{"location":"integrator-guide/smart-contracts/#essential-tools-for-smart-contract-integration","text":"To interact with Gemforce's smart contracts, you'll need: Web3 Provider : Connects your application to the blockchain (e.g., MetaMask, WalletConnect, Infura, Alchemy, your own node). Web3 Library : JavaScript libraries to interact with Ethereum (e.g., Ethers.js or Web3.js ). Ethers.js is generally preferred for its cleaner API and robust features. Contract ABIs (Application Binary Interfaces) : These JSON files define the functions and events of a smart contract, allowing your application to encode/decode function calls and event logs. You can obtain Gemforce contract ABIs from our deployed contracts or the gem-base project.","title":"Essential Tools for Smart Contract Integration"},{"location":"integrator-guide/smart-contracts/#interacting-with-a-diamond-contract","text":"A Diamond contract acts as a single address through which you interact with all connected facets. When you call a function on a Diamond, it delegates the call to the appropriate facet containing that function.","title":"Interacting with a Diamond Contract"},{"location":"integrator-guide/smart-contracts/#steps-to-interact","text":"Get the Diamond Address : This is the main address of the deployed Gemforce Diamond contract. Obtain Facet ABIs : While you interact with the Diamond's address, your Web3 library needs the ABI of the facet that contains the function you want to call. This is because the ABI defines the function signatures. Create a Contract Instance : Instantiate your Web3 library's Contract object using the Diamond's address and the relevant Facet's ABI. Call Functions / Listen for Events : Use the contract instance to send transactions or query data.","title":"Steps to Interact:"},{"location":"integrator-guide/smart-contracts/#example-ethersjs-with-a-diamond-facet","text":"Suppose you want to interact with the MarketplaceFacet to list an NFT. import { ethers } from 'ethers' ; // Import the ABI for MarketplaceFacet import MarketplaceFacetABI from './MarketplaceFacet.json' ; // Adjust path as needed const GEMFORCE_DIAMOND_ADDRESS = \"0x...\" ; // Replace with the actual deployed Diamond address const YOUR_NFT_CONTRACT_ADDRESS = \"0x...\" ; // Replace with your NFT contract address const NFT_TOKEN_ID = 123 ; const PRICE = ethers . utils . parseEther ( \"0.5\" ); // 0.5 ETH const PAYMENT_TOKEN_ADDRESS = \"0x...\" ; // Address of WETH or other ERC20 accepted payment token, or address(0) for ETH async function listNFTOnGemforceMarketplace () { try { // 1. Connect to a Web3 Provider and Signer (e.g., via MetaMask in a browser) const provider = new ethers . providers . Web3Provider ( window . ethereum ); await provider . send ( \"eth_requestAccounts\" , []); // Prompts user to connect wallet const signer = provider . getSigner (); const userAddress = await signer . getAddress (); console . log ( \"Connected account:\" , userAddress ); // 2. Create a contract instance using the Diamond Address and MarketplaceFacet ABI // Although you call methods on myMarketplace, the transaction goes through the Diamond. const myMarketplace = new ethers . Contract ( GEMFORCE_DIAMOND_ADDRESS , // The Diamond's address MarketplaceFacetABI , // The ABI of the Facet containing the function signer // The signer (user's wallet) ); // 3. Approve the Marketplace to spend your NFT (if it's ERC721) // This assumes you have an ERC721 contract instance. const erc721Abi = [ \"function approve(address to, uint256 tokenId)\" ]; const nftContract = new ethers . Contract ( YOUR_NFT_CONTRACT_ADDRESS , erc721Abi , signer ); console . log ( `Approving MarketplaceFacet for NFT ID ${ NFT_TOKEN_ID } ...` ); const approveTx = await nftContract . approve ( GEMFORCE_DIAMOND_ADDRESS , NFT_TOKEN_ID ); await approveTx . wait (); console . log ( \"Approval successful. Transaction hash:\" , approveTx . hash ); // 4. Call the 'listItem' function from the MarketplaceFacet console . log ( \"Listing NFT on marketplace...\" ); const listItemTx = await myMarketplace . listItem ( YOUR_NFT_CONTRACT_ADDRESS , NFT_TOKEN_ID , PRICE , PAYMENT_TOKEN_ADDRESS ); const receipt = await listItemTx . wait (); console . log ( \"NFT listed successfully! Transaction hash:\" , receipt . hash ); console . log ( \"Events emitted:\" , receipt . events ); } catch ( error ) { console . error ( \"Error listing NFT:\" , error ); } } // Call the function // listNFTOnGemforceMarketplace();","title":"Example (Ethers.js with a Diamond Facet)"},{"location":"integrator-guide/smart-contracts/#reading-data-from-smart-contracts-viewpure-functions","text":"view and pure functions do not modify the blockchain state and can be called without sending a transaction (and thus without gas fees).","title":"Reading Data from Smart Contracts (View/Pure Functions)"},{"location":"integrator-guide/smart-contracts/#example-ethersjs","text":"import { ethers } from 'ethers' ; import DiamondLoupeFacetABI from './DiamondLoupeFacet.json' ; // ABI for DiamondLoupeFacet const GEMFORCE_DIAMOND_ADDRESS = \"0x...\" ; // Replace with the actual Diamond address const PROVIDER_URL = \"https://rpc.sepolia.org\" ; // Example RPC URL async function getFacetAddresses () { try { const provider = new ethers . providers . JsonRpcProvider ( PROVIDER_URL ); // Create a contract instance with DiamondLoupeFacet ABI const diamondLoupe = new ethers . Contract ( GEMFORCE_DIAMOND_ADDRESS , DiamondLoupeFacetABI , provider // No signer needed for view calls ); // Call a view function to get all registered facet addresses const facetAddresses = await diamondLoupe . facetAddresses (); console . log ( \"All Facet Addresses:\" , facetAddresses ); // You can then iterate through facetAddresses to get more details if needed for ( const addr of facetAddresses ) { const selectors = await diamondLoupe . facetFunctionSelectors ( addr ); console . log ( ` Facet ${ addr } has selectors:` , selectors ); } } catch ( error ) { console . error ( \"Error getting facet addresses:\" , error ); } } // Call the function // getFacetAddresses();","title":"Example (Ethers.js)"},{"location":"integrator-guide/smart-contracts/#listening-for-smart-contract-events","text":"Smart contracts emit events to signal significant occurrences. Your application can listen for these events to react in real-time to on-chain changes without constantly polling.","title":"Listening for Smart Contract Events"},{"location":"integrator-guide/smart-contracts/#example-ethersjs_1","text":"import { ethers } from 'ethers' ; import MarketplaceFacetABI from './MarketplaceFacet.json' ; // ABI for MarketplaceFacet const GEMFORCE_DIAMOND_ADDRESS = \"0x...\" ; // Replace with the actual deployed Diamond address const PROVIDER_URL = \"wss://base-sepolia.public.blastapi.io\" ; // Use a WebSocket provider for real-time events async function listenForNFTListings () { try { const provider = new ethers . providers . WebSocketProvider ( PROVIDER_URL ); // Create a contract instance for listening to events const myMarketplace = new ethers . Contract ( GEMFORCE_DIAMOND_ADDRESS , MarketplaceFacetABI , provider ); console . log ( \"Listening for 'ItemListed' events on the Marketplace...\" ); // Listen for the ItemListed event // The event signature typically looks like: event ItemListed(address indexed nftContract, uint256 indexed tokenId, address indexed seller, uint256 price, address paymentToken); myMarketplace . on ( \"ItemListed\" , ( nftContract , tokenId , seller , price , paymentToken , event ) => { console . log ( \"\\n--- New NFT Listed! ---\" ); console . log ( \" NFT Contract:\" , nftContract ); console . log ( \" Token ID:\" , tokenId . toString ()); console . log ( \" Seller:\" , seller ); console . log ( \" Price:\" , ethers . utils . formatEther ( price ), \"ETH\" ); // Assuming price in Wei // paymentToken might be address(0) for native currency console . log ( \" Payment Token:\" , paymentToken === ethers . constants . AddressZero ? \"ETH\" : paymentToken ); console . log ( \" Transaction Hash:\" , event . transactionHash ); console . log ( \"-----------------------\" ); }); } catch ( error ) { console . error ( \"Error setting up event listener:\" , error ); } } // Call the function // listenForNFTListings();","title":"Example (Ethers.js)"},{"location":"integrator-guide/smart-contracts/#best-practices-for-smart-contract-integration","text":"Gas Management : Account for gas fees. Provide users with clear information about potential costs. For backend automation, ensure your calling account has sufficient funds. Error Handling : Smart contract calls can revert. Implement robust try-catch blocks and parse revert messages for user feedback. Security : Never expose private keys in client-side code. Use secure signing processes (e.g., MetaMask, DFNS). Follow secure coding guidelines for your dApp. Network Agnosticism : Design your application to be configurable for different networks (e.g., Sepolia, Base Sepolia, Optimism Sepolia) by using network IDs, RPC URLs, and contract addresses. Diamond Specifics : Always read the Diamond contract's specific documentation for details on its deployed facets and their expected behaviors. ABIs : Ensure you are using the correct and up-to-date ABIs for the facets you intend to interact with. Optimistic UI/UX : For state-changing transactions, provide immediate visual feedback to the user while waiting for transactions to be mined.","title":"Best Practices for Smart Contract Integration"},{"location":"integrator-guide/smart-contracts/#related-documentation","text":"Diamond Standard Overview Facets documentation Interfaces documentation Libraries documentation Authentication Guide","title":"Related Documentation"},{"location":"integrator-guide/testing/","text":"","title":"Testing"},{"location":"integrator-guide/webhooks/","text":"","title":"Webhooks"},{"location":"sdk-libraries/blockchain/","text":"SDK & Libraries: Blockchain Utilities \u00b6 This document describes the blockchain.ts library, a core utility module within the Gemforce SDK designed to simplify interactions with various blockchain networks. It provides a set of helper functions for common tasks such as obtaining RPC providers, managing transactions, estimating gas, and handling network-specific configurations. Overview \u00b6 The blockchain.ts library offers: Provider Management : Convenient access to ethers.js Provider instances for different networks. Transaction Helpers : Functions to build, sign, and send transactions. Gas Estimation : Utilities for accurate gas price and limit estimation. Network Configuration : Centralized management of network-specific details (RPC URLs, chain IDs, contract addresses). Error Handling : Standardized error handling for blockchain interactions. This library aims to abstract away much of the boilerplate associated with direct ethers.js or web3.js usage, making blockchain interactions more developer-friendly within the Gemforce ecosystem. Key Functions \u00b6 1. getProvider(network: string) \u00b6 Retrieves an ethers.js JsonRpcProvider instance for the specified blockchain network. Function Signature : getProvider(network: string): Promise<ethers.providers.JsonRpcProvider> Parameters : network (String, required): The name of the blockchain network (e.g., \"sepolia\", \"base-sepolia\", \"optimism-sepolia\"). Returns : - Promise<ethers.providers.JsonRpcProvider> : A Promise that resolves to an ethers.js provider instance. Example Usage : import { getProvider } from '@gemforce-sdk/blockchain' ; // Assuming this import path async function fetchBlockNumber ( network : string ) { try { const provider = await getProvider ( network ); const blockNumber = await provider . getBlockNumber (); console . log ( `Current block number on ${ network } : ${ blockNumber } ` ); return blockNumber ; } catch ( error ) { console . error ( `Error fetching block number on ${ network } :` , error ); throw error ; } } // Example: fetchBlockNumber(\"sepolia\"); 2. sendSignedTransaction(signedTx: string, network: string) \u00b6 Broadcasts a signed transaction to the specified blockchain network. Function Signature : sendSignedTransaction(signedTx: string, network: string): Promise<ethers.providers.TransactionReceipt> Parameters : signedTx (String, required): The raw, RLP-encoded, signed transaction hex string (e.g., \"0x...\"). network (String, required): The blockchain network where the transaction should be sent. Returns : - Promise<ethers.providers.TransactionReceipt> : A Promise that resolves to the transaction receipt once it's mined. Example Usage : import { sendSignedTransaction } from '@gemforce-sdk/blockchain' ; // Assuming 'rawSignedTransaction' is obtained from a secure signing service like DFNS async function broadcastTransaction ( rawSignedTransaction : string , network : string ) { try { console . log ( \"Broadcasting transaction...\" ); const receipt = await sendSignedTransaction ( rawSignedTransaction , network ); console . log ( \"Transaction confirmed:\" , receipt . transactionHash ); return receipt ; } catch ( error ) { console . error ( \"Error broadcasting transaction:\" , error ); throw error ; } } // Example: broadcastTransaction(\"0x...\", \"base-sepolia\"); 3. getTransactionReceipt(txHash: string, network: string) \u00b6 Retrieves the transaction receipt for a given transaction hash. Function Signature : getTransactionReceipt(txHash: string, network: string): Promise<ethers.providers.TransactionReceipt | null> Parameters : txHash (String, required): The hash of the transaction. network (String, required): The blockchain network where the transaction was sent. Returns : - Promise<ethers.providers.TransactionReceipt | null> : A Promise that resolves to the transaction receipt or null if not found. 4. getGasPrice(network: string) \u00b6 Estimates the current gas price for the specified network. Function Signature : getGasPrice(network: string): Promise<ethers.BigNumber> Parameters : network (String, required): The blockchain network. Returns : - Promise<ethers.BigNumber> : A Promise that resolves to the estimated gas price in Wei. 5. getNetworkConfig(network: string) \u00b6 Retrieves the configuration details for a specific blockchain network, as defined within the SDK. Function Signature : getNetworkConfig(network: string): { rpcUrl: string; chainId: number; contractAddresses: { [key: string]: string } } Parameters : network (String, required): The name of the blockchain network. Returns : - Object : An object containing rpcUrl , chainId , and contractAddresses (mapping contract names to their deployed addresses). 6. callContractFunction(contractAddress: string, abi: any[], functionName: string, args: any[], network: string) \u00b6 Executes a view or pure function on a smart contract. No transaction is sent, and no gas is consumed. Function Signature : callContractFunction(contractAddress: string, abi: any[], functionName: string, args: any[], network: string): Promise<any> Parameters : contractAddress (String, required): The address of the target smart contract. abi (Array, required): The ABI of the contract (or relevant facet). functionName (String, required): The name of the function to call. args (Array, required): An array of arguments for the function. network (String, required): The blockchain network. Returns : - Promise<any> : A Promise that resolves to the result of the contract call. Error Handling \u00b6 The blockchain.ts library internally handles common ethers.js errors and re-throws them, or wraps them with more context-specific messages. Expected errors include: NETWORK_ERROR : Problems connecting to the RPC provider. TRANSACTION_REVERTED : Smart contract function reverted. INSUFFICIENT_FUNDS : Sender account lacks necessary funds for gas. INVALID_ARGUMENT : Invalid parameters passed to a function. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Private Key Management : This library focuses on transaction broadcasting. Private key management (signing) should always be handled by secure external services (like DFNS) or secure local key stores, NOT directly within this utility. RPC Endpoint Security : Ensure that the RPC endpoints configured are trusted and secure to prevent data interception or manipulation. Input Validation : Although the library uses ethers.js for type checking, always validate inputs to functions before calling them to prevent unexpected behavior or errors. Related Documentation \u00b6 Integrator's Guide: Smart Contracts Integrator's Guide: Authentication Ethers.js Documentation (External)","title":"Blockchain Utilities"},{"location":"sdk-libraries/blockchain/#sdk-libraries-blockchain-utilities","text":"This document describes the blockchain.ts library, a core utility module within the Gemforce SDK designed to simplify interactions with various blockchain networks. It provides a set of helper functions for common tasks such as obtaining RPC providers, managing transactions, estimating gas, and handling network-specific configurations.","title":"SDK &amp; Libraries: Blockchain Utilities"},{"location":"sdk-libraries/blockchain/#overview","text":"The blockchain.ts library offers: Provider Management : Convenient access to ethers.js Provider instances for different networks. Transaction Helpers : Functions to build, sign, and send transactions. Gas Estimation : Utilities for accurate gas price and limit estimation. Network Configuration : Centralized management of network-specific details (RPC URLs, chain IDs, contract addresses). Error Handling : Standardized error handling for blockchain interactions. This library aims to abstract away much of the boilerplate associated with direct ethers.js or web3.js usage, making blockchain interactions more developer-friendly within the Gemforce ecosystem.","title":"Overview"},{"location":"sdk-libraries/blockchain/#key-functions","text":"","title":"Key Functions"},{"location":"sdk-libraries/blockchain/#1-getprovidernetwork-string","text":"Retrieves an ethers.js JsonRpcProvider instance for the specified blockchain network. Function Signature : getProvider(network: string): Promise<ethers.providers.JsonRpcProvider> Parameters : network (String, required): The name of the blockchain network (e.g., \"sepolia\", \"base-sepolia\", \"optimism-sepolia\"). Returns : - Promise<ethers.providers.JsonRpcProvider> : A Promise that resolves to an ethers.js provider instance. Example Usage : import { getProvider } from '@gemforce-sdk/blockchain' ; // Assuming this import path async function fetchBlockNumber ( network : string ) { try { const provider = await getProvider ( network ); const blockNumber = await provider . getBlockNumber (); console . log ( `Current block number on ${ network } : ${ blockNumber } ` ); return blockNumber ; } catch ( error ) { console . error ( `Error fetching block number on ${ network } :` , error ); throw error ; } } // Example: fetchBlockNumber(\"sepolia\");","title":"1. getProvider(network: string)"},{"location":"sdk-libraries/blockchain/#2-sendsignedtransactionsignedtx-string-network-string","text":"Broadcasts a signed transaction to the specified blockchain network. Function Signature : sendSignedTransaction(signedTx: string, network: string): Promise<ethers.providers.TransactionReceipt> Parameters : signedTx (String, required): The raw, RLP-encoded, signed transaction hex string (e.g., \"0x...\"). network (String, required): The blockchain network where the transaction should be sent. Returns : - Promise<ethers.providers.TransactionReceipt> : A Promise that resolves to the transaction receipt once it's mined. Example Usage : import { sendSignedTransaction } from '@gemforce-sdk/blockchain' ; // Assuming 'rawSignedTransaction' is obtained from a secure signing service like DFNS async function broadcastTransaction ( rawSignedTransaction : string , network : string ) { try { console . log ( \"Broadcasting transaction...\" ); const receipt = await sendSignedTransaction ( rawSignedTransaction , network ); console . log ( \"Transaction confirmed:\" , receipt . transactionHash ); return receipt ; } catch ( error ) { console . error ( \"Error broadcasting transaction:\" , error ); throw error ; } } // Example: broadcastTransaction(\"0x...\", \"base-sepolia\");","title":"2. sendSignedTransaction(signedTx: string, network: string)"},{"location":"sdk-libraries/blockchain/#3-gettransactionreceipttxhash-string-network-string","text":"Retrieves the transaction receipt for a given transaction hash. Function Signature : getTransactionReceipt(txHash: string, network: string): Promise<ethers.providers.TransactionReceipt | null> Parameters : txHash (String, required): The hash of the transaction. network (String, required): The blockchain network where the transaction was sent. Returns : - Promise<ethers.providers.TransactionReceipt | null> : A Promise that resolves to the transaction receipt or null if not found.","title":"3. getTransactionReceipt(txHash: string, network: string)"},{"location":"sdk-libraries/blockchain/#4-getgaspricenetwork-string","text":"Estimates the current gas price for the specified network. Function Signature : getGasPrice(network: string): Promise<ethers.BigNumber> Parameters : network (String, required): The blockchain network. Returns : - Promise<ethers.BigNumber> : A Promise that resolves to the estimated gas price in Wei.","title":"4. getGasPrice(network: string)"},{"location":"sdk-libraries/blockchain/#5-getnetworkconfignetwork-string","text":"Retrieves the configuration details for a specific blockchain network, as defined within the SDK. Function Signature : getNetworkConfig(network: string): { rpcUrl: string; chainId: number; contractAddresses: { [key: string]: string } } Parameters : network (String, required): The name of the blockchain network. Returns : - Object : An object containing rpcUrl , chainId , and contractAddresses (mapping contract names to their deployed addresses).","title":"5. getNetworkConfig(network: string)"},{"location":"sdk-libraries/blockchain/#6-callcontractfunctioncontractaddress-string-abi-any-functionname-string-args-any-network-string","text":"Executes a view or pure function on a smart contract. No transaction is sent, and no gas is consumed. Function Signature : callContractFunction(contractAddress: string, abi: any[], functionName: string, args: any[], network: string): Promise<any> Parameters : contractAddress (String, required): The address of the target smart contract. abi (Array, required): The ABI of the contract (or relevant facet). functionName (String, required): The name of the function to call. args (Array, required): An array of arguments for the function. network (String, required): The blockchain network. Returns : - Promise<any> : A Promise that resolves to the result of the contract call.","title":"6. callContractFunction(contractAddress: string, abi: any[], functionName: string, args: any[], network: string)"},{"location":"sdk-libraries/blockchain/#error-handling","text":"The blockchain.ts library internally handles common ethers.js errors and re-throws them, or wraps them with more context-specific messages. Expected errors include: NETWORK_ERROR : Problems connecting to the RPC provider. TRANSACTION_REVERTED : Smart contract function reverted. INSUFFICIENT_FUNDS : Sender account lacks necessary funds for gas. INVALID_ARGUMENT : Invalid parameters passed to a function. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"sdk-libraries/blockchain/#security-considerations","text":"Private Key Management : This library focuses on transaction broadcasting. Private key management (signing) should always be handled by secure external services (like DFNS) or secure local key stores, NOT directly within this utility. RPC Endpoint Security : Ensure that the RPC endpoints configured are trusted and secure to prevent data interception or manipulation. Input Validation : Although the library uses ethers.js for type checking, always validate inputs to functions before calling them to prevent unexpected behavior or errors.","title":"Security Considerations"},{"location":"sdk-libraries/blockchain/#related-documentation","text":"Integrator's Guide: Smart Contracts Integrator's Guide: Authentication Ethers.js Documentation (External)","title":"Related Documentation"},{"location":"sdk-libraries/contract/","text":"SDK & Libraries: Contract Utilities \u00b6 This document describes the contract.ts library, a utility module within the Gemforce SDK designed to streamline common interactions with arbitrary smart contracts. It builds upon ethers.js by providing helper functions for instantiating contract objects, handling generic function calls, and managing contract-specific configurations. Overview \u00b6 The contract.ts library offers: Contract Instantiation : Simplified creation of ethers.Contract instances. Generic Call/Transaction : Functions to execute read (view, pure) and write (state-changing) operations on any contract given its address and ABI. ABI Management : Helper for loading or providing contract ABIs. Type-Safe Defaults : Can be used with pre-defined Gemforce contract ABIs for type safety and convenience. This library is particularly useful for interacting with external ERC- \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043e\u0432 or custom contracts beyond the core Gemforce Diamond setup. Key Functions \u00b6 1. getContractInstance(contractAddress: string, abi: any[], network: string, signer?: ethers.Signer) \u00b6 Retrieves an ethers.js Contract instance tailored for the specified contract. Function Signature : getContractInstance(contractAddress: string, abi: any[], network: string, signer?: ethers.Signer): Promise<ethers.Contract> Parameters : contractAddress (String, required): The address of the target smart contract. abi (Array, required): The ABI (Application Binary Interface) of the contract. network (String, required): The blockchain network. signer (ethers.Signer, optional): An ethers.Signer object if state-changing functions are to be called or if a specific account is needed for read calls. If not provided, a Provider is used for read-only access. Returns : - Promise<ethers.Contract> : A Promise that resolves to an ethers.js Contract instance. Example Usage : import { getContractInstance } from '@gemforce-sdk/contract' ; // Assuming this import path import { ethers } from 'ethers' ; // Example: Interacting with a generic ERC-20 token const ERC20_ABI = [ \"function name() view returns (string)\" , \"function symbol() view returns (string)\" , \"function balanceOf(address owner) view returns (uint256)\" , \"function transfer(address to, uint256 amount) returns (bool)\" , \"event Transfer(address indexed from, address indexed to, uint256 value)\" ]; async function getTokenInfo ( tokenAddress : string , userAddress : string , network : string ) { try { const tokenContract = await getContractInstance ( tokenAddress , ERC20_ABI , network ); const name = await tokenContract . name (); const symbol = await tokenContract . symbol (); const balance = await tokenContract . balanceOf ( userAddress ); console . log ( `Token: ${ name } ( ${ symbol } )` ); console . log ( `Balance of ${ userAddress } : ${ ethers . utils . formatUnits ( balance , 18 ) } ${ symbol } ` ); // Assuming 18 decimals return { name , symbol , balance }; } catch ( error ) { console . error ( `Error fetching token info for ${ tokenAddress } :` , error ); throw error ; } } // Example: getTokenInfo(\"0x...USDC_Address...\", \"0xYourWalletAddress\", \"sepolia\"); 2. callContractRead(contract: ethers.Contract, functionName: string, args?: any[]) \u00b6 Executes a view or pure function (read-only) on an already instantiated contract. Function Signature : callContractRead(contract: ethers.Contract, functionName: string, args?: any[]): Promise<any> Parameters : contract (ethers.Contract, required): An ethers.js Contract instance (obtained via getContractInstance or similar). functionName (String, required): The name of the function to call. args (Array, optional): An array of arguments for the function. Returns : - Promise<any> : A Promise that resolves to the result of the contract call. 3. executeContractWrite(contract: ethers.Contract, functionName: string, args: any[], txOverrides?: ethers.Overrides) \u00b6 Executes a state-changing function (write operation) on an already instantiated contract, typically requiring a signer in the contract instance. Function Signature : executeContractWrite(contract: ethers.Contract, functionName: string, args: any[], txOverrides?: ethers.Overrides): Promise<ethers.providers.TransactionReceipt> Parameters : contract (ethers.Contract, required): An ethers.js Contract instance that includes a Signer . functionName (String, required): The name of the function to call. args (Array, required): An array of arguments for the function. txOverrides (ethers.Overrides, optional): An object containing transaction overrides like gasLimit , gasPrice , value (for payable functions). Returns : - Promise<ethers.providers.TransactionReceipt> : A Promise that resolves to the transaction receipt once it's mined. Example Usage (Continuing ERC-20 example) : import { getContractInstance , executeContractWrite } from '@gemforce-sdk/contract' ; import { ethers } from 'ethers' ; async function transferTokens ( tokenAddress : string , fromSigner : ethers.Signer , toAddress : string , amount : ethers.BigNumberish , network : string ) { try { const ERC20_ABI_TRANSFER = [ \"function transfer(address to, uint256 amount) returns (bool)\" , ]; // Get instance with a signer const tokenContract = await getContractInstance ( tokenAddress , ERC20_ABI_TRANSFER , network , fromSigner ); console . log ( `Transferring ${ ethers . utils . formatUnits ( amount , 18 ) } tokens from ${ await fromSigner . getAddress () } to ${ toAddress } ...` ); const receipt = await executeContractWrite ( tokenContract , \"transfer\" , [ toAddress , amount ]); console . log ( \"Transfer successful! Transaction hash:\" , receipt . transactionHash ); return receipt ; } catch ( error ) { console . error ( \"Error transferring tokens:\" , error ); throw error ; } } // Example: // const signer = // ... obtain a connected ethers.Signer (e.g., from MetaMask or a Wallet); // transferTokens(\"0x...USDC_Address...\", signer, \"0xAnotherWalletAddress\", ethers.utils.parseUnits(\"10\", 6), \"sepolia\"); // Assuming 6 decimals for USDC Error Handling \u00b6 The contract.ts library propagates ethers.js errors, providing a consistent way to handle blockchain-related exceptions. Common errors include those related to network issues, transaction reverts, insufficient funds, and invalid contract interactions. Refer to the Integrator's Guide: Error Handling for detailed error handling strategies. Security Considerations \u00b6 ABI Trust : Always ensure the ABI provided to getContractInstance is correct and from a trusted source. A malicious ABI could lead to unexpected behavior. Signer Security : Any function that performs write operations relies heavily on the signer provided. Ensure private key management is handled securely outside this library (e.g., via DFNS or user's browser wallet). Input Validation : Thoroughly validate all arguments passed to contract functions to prevent common smart contract vulnerabilities. Related Documentation \u00b6 SDK & Libraries: Blockchain Utilities Integrator's Guide: Smart Contracts Ethers.js Documentation (External)","title":"Contract Utilities"},{"location":"sdk-libraries/contract/#sdk-libraries-contract-utilities","text":"This document describes the contract.ts library, a utility module within the Gemforce SDK designed to streamline common interactions with arbitrary smart contracts. It builds upon ethers.js by providing helper functions for instantiating contract objects, handling generic function calls, and managing contract-specific configurations.","title":"SDK &amp; Libraries: Contract Utilities"},{"location":"sdk-libraries/contract/#overview","text":"The contract.ts library offers: Contract Instantiation : Simplified creation of ethers.Contract instances. Generic Call/Transaction : Functions to execute read (view, pure) and write (state-changing) operations on any contract given its address and ABI. ABI Management : Helper for loading or providing contract ABIs. Type-Safe Defaults : Can be used with pre-defined Gemforce contract ABIs for type safety and convenience. This library is particularly useful for interacting with external ERC- \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043e\u0432 or custom contracts beyond the core Gemforce Diamond setup.","title":"Overview"},{"location":"sdk-libraries/contract/#key-functions","text":"","title":"Key Functions"},{"location":"sdk-libraries/contract/#1-getcontractinstancecontractaddress-string-abi-any-network-string-signer-etherssigner","text":"Retrieves an ethers.js Contract instance tailored for the specified contract. Function Signature : getContractInstance(contractAddress: string, abi: any[], network: string, signer?: ethers.Signer): Promise<ethers.Contract> Parameters : contractAddress (String, required): The address of the target smart contract. abi (Array, required): The ABI (Application Binary Interface) of the contract. network (String, required): The blockchain network. signer (ethers.Signer, optional): An ethers.Signer object if state-changing functions are to be called or if a specific account is needed for read calls. If not provided, a Provider is used for read-only access. Returns : - Promise<ethers.Contract> : A Promise that resolves to an ethers.js Contract instance. Example Usage : import { getContractInstance } from '@gemforce-sdk/contract' ; // Assuming this import path import { ethers } from 'ethers' ; // Example: Interacting with a generic ERC-20 token const ERC20_ABI = [ \"function name() view returns (string)\" , \"function symbol() view returns (string)\" , \"function balanceOf(address owner) view returns (uint256)\" , \"function transfer(address to, uint256 amount) returns (bool)\" , \"event Transfer(address indexed from, address indexed to, uint256 value)\" ]; async function getTokenInfo ( tokenAddress : string , userAddress : string , network : string ) { try { const tokenContract = await getContractInstance ( tokenAddress , ERC20_ABI , network ); const name = await tokenContract . name (); const symbol = await tokenContract . symbol (); const balance = await tokenContract . balanceOf ( userAddress ); console . log ( `Token: ${ name } ( ${ symbol } )` ); console . log ( `Balance of ${ userAddress } : ${ ethers . utils . formatUnits ( balance , 18 ) } ${ symbol } ` ); // Assuming 18 decimals return { name , symbol , balance }; } catch ( error ) { console . error ( `Error fetching token info for ${ tokenAddress } :` , error ); throw error ; } } // Example: getTokenInfo(\"0x...USDC_Address...\", \"0xYourWalletAddress\", \"sepolia\");","title":"1. getContractInstance(contractAddress: string, abi: any[], network: string, signer?: ethers.Signer)"},{"location":"sdk-libraries/contract/#2-callcontractreadcontract-etherscontract-functionname-string-args-any","text":"Executes a view or pure function (read-only) on an already instantiated contract. Function Signature : callContractRead(contract: ethers.Contract, functionName: string, args?: any[]): Promise<any> Parameters : contract (ethers.Contract, required): An ethers.js Contract instance (obtained via getContractInstance or similar). functionName (String, required): The name of the function to call. args (Array, optional): An array of arguments for the function. Returns : - Promise<any> : A Promise that resolves to the result of the contract call.","title":"2. callContractRead(contract: ethers.Contract, functionName: string, args?: any[])"},{"location":"sdk-libraries/contract/#3-executecontractwritecontract-etherscontract-functionname-string-args-any-txoverrides-ethersoverrides","text":"Executes a state-changing function (write operation) on an already instantiated contract, typically requiring a signer in the contract instance. Function Signature : executeContractWrite(contract: ethers.Contract, functionName: string, args: any[], txOverrides?: ethers.Overrides): Promise<ethers.providers.TransactionReceipt> Parameters : contract (ethers.Contract, required): An ethers.js Contract instance that includes a Signer . functionName (String, required): The name of the function to call. args (Array, required): An array of arguments for the function. txOverrides (ethers.Overrides, optional): An object containing transaction overrides like gasLimit , gasPrice , value (for payable functions). Returns : - Promise<ethers.providers.TransactionReceipt> : A Promise that resolves to the transaction receipt once it's mined. Example Usage (Continuing ERC-20 example) : import { getContractInstance , executeContractWrite } from '@gemforce-sdk/contract' ; import { ethers } from 'ethers' ; async function transferTokens ( tokenAddress : string , fromSigner : ethers.Signer , toAddress : string , amount : ethers.BigNumberish , network : string ) { try { const ERC20_ABI_TRANSFER = [ \"function transfer(address to, uint256 amount) returns (bool)\" , ]; // Get instance with a signer const tokenContract = await getContractInstance ( tokenAddress , ERC20_ABI_TRANSFER , network , fromSigner ); console . log ( `Transferring ${ ethers . utils . formatUnits ( amount , 18 ) } tokens from ${ await fromSigner . getAddress () } to ${ toAddress } ...` ); const receipt = await executeContractWrite ( tokenContract , \"transfer\" , [ toAddress , amount ]); console . log ( \"Transfer successful! Transaction hash:\" , receipt . transactionHash ); return receipt ; } catch ( error ) { console . error ( \"Error transferring tokens:\" , error ); throw error ; } } // Example: // const signer = // ... obtain a connected ethers.Signer (e.g., from MetaMask or a Wallet); // transferTokens(\"0x...USDC_Address...\", signer, \"0xAnotherWalletAddress\", ethers.utils.parseUnits(\"10\", 6), \"sepolia\"); // Assuming 6 decimals for USDC","title":"3. executeContractWrite(contract: ethers.Contract, functionName: string, args: any[], txOverrides?: ethers.Overrides)"},{"location":"sdk-libraries/contract/#error-handling","text":"The contract.ts library propagates ethers.js errors, providing a consistent way to handle blockchain-related exceptions. Common errors include those related to network issues, transaction reverts, insufficient funds, and invalid contract interactions. Refer to the Integrator's Guide: Error Handling for detailed error handling strategies.","title":"Error Handling"},{"location":"sdk-libraries/contract/#security-considerations","text":"ABI Trust : Always ensure the ABI provided to getContractInstance is correct and from a trusted source. A malicious ABI could lead to unexpected behavior. Signer Security : Any function that performs write operations relies heavily on the signer provided. Ensure private key management is handled securely outside this library (e.g., via DFNS or user's browser wallet). Input Validation : Thoroughly validate all arguments passed to contract functions to prevent common smart contract vulnerabilities.","title":"Security Considerations"},{"location":"sdk-libraries/contract/#related-documentation","text":"SDK & Libraries: Blockchain Utilities Integrator's Guide: Smart Contracts Ethers.js Documentation (External)","title":"Related Documentation"},{"location":"sdk-libraries/deploy/","text":"SDK & Libraries: Deployment Utilities \u00b6 This document describes the deploy.ts library, a utility module within the Gemforce SDK designed to simplify and automate smart contract deployment processes. It provides functions to deploy new contract instances, verify deployments on block explorers, and manage deployment configurations across various blockchain networks. Overview \u00b6 The deploy.ts library offers: Contract Deployment : Programmatic deployment of compiled smart contracts. Deployment Verification : Tools to verify deployed contracts on block explorers (e.g., Etherscan). Configuration Management : Integration with deployment configurations (network-specific settings, contract linkages). Gas Management : Automated gas estimation and handling during deployment. This library is particularly useful for CI/CD pipelines, automated testing environments, and any scenario requiring reliable, repeatable contract deployments. Key Functions \u00b6 1. deployContract(contractFactory: ethers.ContractFactory, args: any[], network: string) \u00b6 Deploys a new instance of a smart contract. Throws an error if deployment fails. Function Signature : deployContract(contractFactory: ethers.ContractFactory, args: any[], network: string): Promise<{ address: string; transactionHash: string; }> Parameters : contractFactory (ethers.ContractFactory, required): An ethers.ContractFactory instance for the contract to be deployed (obtained from Hardhat, Truffle, or new ethers.ContractFactory(abi, bytecode, signer) ). args (Array, required): An array of constructor arguments for the contract. network (String, required): The blockchain network to deploy to. Returns : - Promise<{ address: string; transactionHash: string; }> : A Promise that resolves to an object containing the deployed contract's address and the deployment transaction hash. Example Usage : import { deployContract } from '@gemforce-sdk/deploy' ; // Assuming this import path import { ethers } from 'ethers' ; import { getProvider } from '@gemforce-sdk/blockchain' ; // From blockchain utilities import MyContractABI from './MyContract.json' ; // Compiled contract ABI import MyContractBytecode from './MyContract.bytecode.json' ; // Compiled contract bytecode async function deployMyNewContract ( network : string , constructorArg : string ) { try { const provider = await getProvider ( network ); // Assuming a signer is available (e.g., from a connected wallet or private key) const signer = new ethers . Wallet ( process . env . PRIVATE_KEY ! , provider ); // Securely manage private keys const MyContractFactory = new ethers . ContractFactory ( MyContractABI , MyContractBytecode , signer ); console . log ( `Deploying MyContract on ${ network } ...` ); const deployment = await deployContract ( MyContractFactory , [ constructorArg ], network ); console . log ( `MyContract deployed to: ${ deployment . address } ` ); console . log ( `Deployment transaction hash: ${ deployment . transactionHash } ` ); return deployment . address ; } catch ( error ) { console . error ( `Error deploying MyContract on ${ network } :` , error ); throw error ; } } // Example: deployMyNewContract(\"sepolia\", \"initialValue\"); 2. verifyContract(contractAddress: string, constructorArgs: any[], network: string, options?: { compilerVersion?: string; libraries?: { [name: string]: string } }) \u00b6 Verifies a deployed smart contract's source code on a block explorer (e.g., Etherscan, Basescan). This function typically integrates with block explorer APIs. Function Signature : verifyContract(contractAddress: string, constructorArgs: any[], network: string, options?: { compilerVersion?: string; libraries?: { [name: string]: string } }): Promise<boolean> Parameters : contractAddress (String, required): The address of the deployed contract. constructorArgs (Array, required): Array of original constructor arguments. network (String, required): The blockchain network. options (Object, optional): compilerVersion (String): Specific Solidity compiler version. libraries (Object): An object mapping linked library names to their deployed addresses. Returns : - Promise<boolean> : true if verification was successful, false otherwise. Example Usage : import { verifyContract } from '@gemforce-sdk/deploy' ; async function verifyDeployedContract ( deployedAddress : string , initialArg : string ) { try { console . log ( `Verifying contract ${ deployedAddress } ...` ); const success = await verifyContract ( deployedAddress , [ initialArg ], \"sepolia\" ); if ( success ) { console . log ( \"Contract verified successfully on Etherscan!\" ); } else { console . warn ( \"Contract verification failed.\" ); } } catch ( error ) { console . error ( \"Error during contract verification:\" , error ); } } // Example: verifyDeployedContract(\"0xDeployedContractAddress\", \"initialValue\"); 3. getDeployedAddress(contractName: string, network: string) \u00b6 Retrieves the pre-configured deployed address of a known Gemforce contract by name and network. This relies on an internal configuration. Function Signature : getDeployedAddress(contractName: string, network: string): string | undefined Parameters : contractName (String, required): The name of the contract (e.g., \"Diamond\", \"MarketplaceFacet\"). network (String, required): The blockchain network. Returns : - String | undefined : The deployed address if found, otherwise undefined . Error Handling \u00b6 Deployment utilities can encounter errors such as: Transaction Failures : Due to insufficient gas, reverts in constructor, or network issues. Verification Failures : Explorer API issues, incorrect constructor arguments, or mismatched source code. Configuration Errors : Missing network configurations or contract addresses. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Private Key Management : Deployment requires a Signer with access to a private key. Ensure this private key is managed securely (e.g., through environment variables, secret management services, or dedicated deployment services). Never hardcode private keys. Constructor Arguments : Carefully review and validate constructor arguments for production deployments. Errors here can lead to security vulnerabilities or misconfigured contracts. Verification : Always strive to verify your deployed contracts on block explorers. This provides transparency and allows others to audit the deployed bytecode. Network Trust : Ensure the RPC endpoints used for deployment are trusted and reliable. Related Documentation \u00b6 SDK & Libraries: Blockchain Utilities Integrator's Guide: Deployment (coming soon) Hardhat Documentation (External)","title":"Deployment Utilities"},{"location":"sdk-libraries/deploy/#sdk-libraries-deployment-utilities","text":"This document describes the deploy.ts library, a utility module within the Gemforce SDK designed to simplify and automate smart contract deployment processes. It provides functions to deploy new contract instances, verify deployments on block explorers, and manage deployment configurations across various blockchain networks.","title":"SDK &amp; Libraries: Deployment Utilities"},{"location":"sdk-libraries/deploy/#overview","text":"The deploy.ts library offers: Contract Deployment : Programmatic deployment of compiled smart contracts. Deployment Verification : Tools to verify deployed contracts on block explorers (e.g., Etherscan). Configuration Management : Integration with deployment configurations (network-specific settings, contract linkages). Gas Management : Automated gas estimation and handling during deployment. This library is particularly useful for CI/CD pipelines, automated testing environments, and any scenario requiring reliable, repeatable contract deployments.","title":"Overview"},{"location":"sdk-libraries/deploy/#key-functions","text":"","title":"Key Functions"},{"location":"sdk-libraries/deploy/#1-deploycontractcontractfactory-etherscontractfactory-args-any-network-string","text":"Deploys a new instance of a smart contract. Throws an error if deployment fails. Function Signature : deployContract(contractFactory: ethers.ContractFactory, args: any[], network: string): Promise<{ address: string; transactionHash: string; }> Parameters : contractFactory (ethers.ContractFactory, required): An ethers.ContractFactory instance for the contract to be deployed (obtained from Hardhat, Truffle, or new ethers.ContractFactory(abi, bytecode, signer) ). args (Array, required): An array of constructor arguments for the contract. network (String, required): The blockchain network to deploy to. Returns : - Promise<{ address: string; transactionHash: string; }> : A Promise that resolves to an object containing the deployed contract's address and the deployment transaction hash. Example Usage : import { deployContract } from '@gemforce-sdk/deploy' ; // Assuming this import path import { ethers } from 'ethers' ; import { getProvider } from '@gemforce-sdk/blockchain' ; // From blockchain utilities import MyContractABI from './MyContract.json' ; // Compiled contract ABI import MyContractBytecode from './MyContract.bytecode.json' ; // Compiled contract bytecode async function deployMyNewContract ( network : string , constructorArg : string ) { try { const provider = await getProvider ( network ); // Assuming a signer is available (e.g., from a connected wallet or private key) const signer = new ethers . Wallet ( process . env . PRIVATE_KEY ! , provider ); // Securely manage private keys const MyContractFactory = new ethers . ContractFactory ( MyContractABI , MyContractBytecode , signer ); console . log ( `Deploying MyContract on ${ network } ...` ); const deployment = await deployContract ( MyContractFactory , [ constructorArg ], network ); console . log ( `MyContract deployed to: ${ deployment . address } ` ); console . log ( `Deployment transaction hash: ${ deployment . transactionHash } ` ); return deployment . address ; } catch ( error ) { console . error ( `Error deploying MyContract on ${ network } :` , error ); throw error ; } } // Example: deployMyNewContract(\"sepolia\", \"initialValue\");","title":"1. deployContract(contractFactory: ethers.ContractFactory, args: any[], network: string)"},{"location":"sdk-libraries/deploy/#2-verifycontractcontractaddress-string-constructorargs-any-network-string-options-compilerversion-string-libraries-name-string-string","text":"Verifies a deployed smart contract's source code on a block explorer (e.g., Etherscan, Basescan). This function typically integrates with block explorer APIs. Function Signature : verifyContract(contractAddress: string, constructorArgs: any[], network: string, options?: { compilerVersion?: string; libraries?: { [name: string]: string } }): Promise<boolean> Parameters : contractAddress (String, required): The address of the deployed contract. constructorArgs (Array, required): Array of original constructor arguments. network (String, required): The blockchain network. options (Object, optional): compilerVersion (String): Specific Solidity compiler version. libraries (Object): An object mapping linked library names to their deployed addresses. Returns : - Promise<boolean> : true if verification was successful, false otherwise. Example Usage : import { verifyContract } from '@gemforce-sdk/deploy' ; async function verifyDeployedContract ( deployedAddress : string , initialArg : string ) { try { console . log ( `Verifying contract ${ deployedAddress } ...` ); const success = await verifyContract ( deployedAddress , [ initialArg ], \"sepolia\" ); if ( success ) { console . log ( \"Contract verified successfully on Etherscan!\" ); } else { console . warn ( \"Contract verification failed.\" ); } } catch ( error ) { console . error ( \"Error during contract verification:\" , error ); } } // Example: verifyDeployedContract(\"0xDeployedContractAddress\", \"initialValue\");","title":"2. verifyContract(contractAddress: string, constructorArgs: any[], network: string, options?: { compilerVersion?: string; libraries?: { [name: string]: string } })"},{"location":"sdk-libraries/deploy/#3-getdeployedaddresscontractname-string-network-string","text":"Retrieves the pre-configured deployed address of a known Gemforce contract by name and network. This relies on an internal configuration. Function Signature : getDeployedAddress(contractName: string, network: string): string | undefined Parameters : contractName (String, required): The name of the contract (e.g., \"Diamond\", \"MarketplaceFacet\"). network (String, required): The blockchain network. Returns : - String | undefined : The deployed address if found, otherwise undefined .","title":"3. getDeployedAddress(contractName: string, network: string)"},{"location":"sdk-libraries/deploy/#error-handling","text":"Deployment utilities can encounter errors such as: Transaction Failures : Due to insufficient gas, reverts in constructor, or network issues. Verification Failures : Explorer API issues, incorrect constructor arguments, or mismatched source code. Configuration Errors : Missing network configurations or contract addresses. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"sdk-libraries/deploy/#security-considerations","text":"Private Key Management : Deployment requires a Signer with access to a private key. Ensure this private key is managed securely (e.g., through environment variables, secret management services, or dedicated deployment services). Never hardcode private keys. Constructor Arguments : Carefully review and validate constructor arguments for production deployments. Errors here can lead to security vulnerabilities or misconfigured contracts. Verification : Always strive to verify your deployed contracts on block explorers. This provides transparency and allows others to audit the deployed bytecode. Network Trust : Ensure the RPC endpoints used for deployment are trusted and reliable.","title":"Security Considerations"},{"location":"sdk-libraries/deploy/#related-documentation","text":"SDK & Libraries: Blockchain Utilities Integrator's Guide: Deployment (coming soon) Hardhat Documentation (External)","title":"Related Documentation"},{"location":"sdk-libraries/diamond/","text":"SDK & Libraries: Diamond Utilities \u00b6 This document describes the diamond.ts library, a crucial utility module within the Gemforce SDK specifically designed to facilitate interactions with the Gemforce Diamond smart contract architecture. It provides functions to query Diamond structure, interact with its facets, and manage various aspects of a Diamond deployment programmatically. Overview \u00b6 The diamond.ts library offers: Diamond Introspection : Functions to discover facets and their associated function selectors. Facet Interaction : Simplified methods to call functions on specific facets through the Diamond. Helper Utilities : Tools for common Diamond-related operations, like parsing Diamond ABI. This library aims to abstract the complexities of the Diamond Standard for developers, allowing them to focus on business logic rather than the intricate details of Diamond proxy patterns. Key Functions \u00b6 1. getFacetAddresses(diamondAddress: string, network: string) \u00b6 Retrieves a list of all facet addresses currently connected to a given Diamond contract. Function Signature : getFacetAddresses(diamondAddress: string, network: string): Promise<string[]> Parameters : diamondAddress (String, required): The address of the Diamond contract. network (String, required): The blockchain network where the Diamond is deployed. Returns : - Promise<string[]> : A Promise that resolves to an array of facet addresses (hex strings). Example Usage : import { getFacetAddresses } from '@gemforce-sdk/diamond' ; // Assuming this import path async function listAllFacets ( diamondAddr : string , network : string ) { try { const addresses = await getFacetAddresses ( diamondAddr , network ); console . log ( `Facets for Diamond ${ diamondAddr } on ${ network } :` , addresses ); return addresses ; } catch ( error ) { console . error ( `Error getting facet addresses for ${ diamondAddr } :` , error ); throw error ; } } // Example: listAllFacets(\"0xYourDiamondAddress\", \"sepolia\"); 2. getFacetFunctionSelectors(diamondAddress: string, facetAddress: string, network: string) \u00b6 Retrieves all function selectors associated with a specific facet address within a Diamond. Function Signature : getFacetFunctionSelectors(diamondAddress: string, facetAddress: string, network: string): Promise<string[]> Parameters : diamondAddress (String, required): The address of the Diamond contract. facetAddress (String, required): The address of the facet to query. network (String, required): The blockchain network. Returns : - Promise<string[]> : A Promise that resolves to an array of function selectors (hex strings). 3. getDiamondCut(diamondAddress: string, network: string) \u00b6 Returns the DiamondCut information, including which facets are associated with which selectors. Function Signature : getDiamondCut(diamondAddress: string, network: string): Promise<FacetCut[]> Parameters : diamondAddress (String, required): The address of the Diamond contract. network (String, required): The blockchain network. Returns : - Promise<FacetCut[]> : A Promise that resolves to an array of FacetCut objects, each detailing a facet's functions. 4. getDiamondABI(diamondAddress: string, network: string, options?: { includeLibraries?: boolean }) \u00b6 Constructs a consolidated ABI for a Diamond contract by combining the ABIs of all its currently attached facets. Function Signature : getDiamondABI(diamondAddress: string, network: string, options?: { includeLibraries?: boolean }): Promise<any[]> Parameters : diamondAddress (String, required): The address of the Diamond contract. network (String, required): The blockchain network. options (Object, optional): Configuration for building the ABI. includeLibraries (Boolean): Whether to include ABIs of linked libraries if available. Returns : - Promise<any[]> : A Promise that resolves to a combined ABI array suitable for ethers.Contract instantiation. Example Usage : import { getDiamondABI } from '@gemforce-sdk/diamond' ; import { ethers } from 'ethers' ; async function interactWithDiamond ( diamondAddr : string , network : string ) { try { const provider = new ethers . providers . JsonRpcProvider ( \"YOUR_RPC_URL\" ); const signer = new ethers . Wallet ( \"YOUR_PRIVATE_KEY\" , provider ); // Replace securely // Get the combined ABI for the Diamond const combinedAbi = await getDiamondABI ( diamondAddr , network ); // Instantiate the Diamond contract using the combined ABI const diamondContract = new ethers . Contract ( diamondAddr , combinedAbi , signer ); // Now you can call any function from any attached facet directly through 'diamondContract' const owner = await diamondContract . owner (); // Assuming an OwnershipFacet is attached console . log ( `Diamond owner: ${ owner } ` ); // Example: Call a marketplace function (assuming MarketplaceFacet is attached) // const listings = await diamondContract.getAllListings(); // console.log(\"Current listings:\", listings); return diamondContract ; } catch ( error ) { console . error ( `Error interacting with Diamond ${ diamondAddr } :` , error ); throw error ; } } // Example: interactWithDiamond(\"0xYourDiamondAddress\", \"sepolia\"); Error Handling \u00b6 Errors from the Diamond utilities library typically include: Network Issues : Problems connecting to RPC providers. Invalid Addresses : Non-existent Diamond or facet addresses. ABI Fetching Failures : Unable to retrieve ABIs for facets. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 ABI Source : Ensure that the ABIs used for getDiamondABI are retrieved from a trusted source to prevent malicious function signature manipulation. Network Trust : All interactions rely on the trustworthiness of the chosen blockchain network and RPC provider. Private Key Management : While this library doesn't manage private keys directly, the usage examples demonstrate that any transaction-sending operations require a securely managed Signer . Related Documentation \u00b6 Smart Contracts: Diamond Contract Smart Contracts: Diamond Loupe Facet Integrator's Guide: Smart Contracts SDK & Libraries: Blockchain Utilities","title":"Diamond Utilities"},{"location":"sdk-libraries/diamond/#sdk-libraries-diamond-utilities","text":"This document describes the diamond.ts library, a crucial utility module within the Gemforce SDK specifically designed to facilitate interactions with the Gemforce Diamond smart contract architecture. It provides functions to query Diamond structure, interact with its facets, and manage various aspects of a Diamond deployment programmatically.","title":"SDK &amp; Libraries: Diamond Utilities"},{"location":"sdk-libraries/diamond/#overview","text":"The diamond.ts library offers: Diamond Introspection : Functions to discover facets and their associated function selectors. Facet Interaction : Simplified methods to call functions on specific facets through the Diamond. Helper Utilities : Tools for common Diamond-related operations, like parsing Diamond ABI. This library aims to abstract the complexities of the Diamond Standard for developers, allowing them to focus on business logic rather than the intricate details of Diamond proxy patterns.","title":"Overview"},{"location":"sdk-libraries/diamond/#key-functions","text":"","title":"Key Functions"},{"location":"sdk-libraries/diamond/#1-getfacetaddressesdiamondaddress-string-network-string","text":"Retrieves a list of all facet addresses currently connected to a given Diamond contract. Function Signature : getFacetAddresses(diamondAddress: string, network: string): Promise<string[]> Parameters : diamondAddress (String, required): The address of the Diamond contract. network (String, required): The blockchain network where the Diamond is deployed. Returns : - Promise<string[]> : A Promise that resolves to an array of facet addresses (hex strings). Example Usage : import { getFacetAddresses } from '@gemforce-sdk/diamond' ; // Assuming this import path async function listAllFacets ( diamondAddr : string , network : string ) { try { const addresses = await getFacetAddresses ( diamondAddr , network ); console . log ( `Facets for Diamond ${ diamondAddr } on ${ network } :` , addresses ); return addresses ; } catch ( error ) { console . error ( `Error getting facet addresses for ${ diamondAddr } :` , error ); throw error ; } } // Example: listAllFacets(\"0xYourDiamondAddress\", \"sepolia\");","title":"1. getFacetAddresses(diamondAddress: string, network: string)"},{"location":"sdk-libraries/diamond/#2-getfacetfunctionselectorsdiamondaddress-string-facetaddress-string-network-string","text":"Retrieves all function selectors associated with a specific facet address within a Diamond. Function Signature : getFacetFunctionSelectors(diamondAddress: string, facetAddress: string, network: string): Promise<string[]> Parameters : diamondAddress (String, required): The address of the Diamond contract. facetAddress (String, required): The address of the facet to query. network (String, required): The blockchain network. Returns : - Promise<string[]> : A Promise that resolves to an array of function selectors (hex strings).","title":"2. getFacetFunctionSelectors(diamondAddress: string, facetAddress: string, network: string)"},{"location":"sdk-libraries/diamond/#3-getdiamondcutdiamondaddress-string-network-string","text":"Returns the DiamondCut information, including which facets are associated with which selectors. Function Signature : getDiamondCut(diamondAddress: string, network: string): Promise<FacetCut[]> Parameters : diamondAddress (String, required): The address of the Diamond contract. network (String, required): The blockchain network. Returns : - Promise<FacetCut[]> : A Promise that resolves to an array of FacetCut objects, each detailing a facet's functions.","title":"3. getDiamondCut(diamondAddress: string, network: string)"},{"location":"sdk-libraries/diamond/#4-getdiamondabidiamondaddress-string-network-string-options-includelibraries-boolean","text":"Constructs a consolidated ABI for a Diamond contract by combining the ABIs of all its currently attached facets. Function Signature : getDiamondABI(diamondAddress: string, network: string, options?: { includeLibraries?: boolean }): Promise<any[]> Parameters : diamondAddress (String, required): The address of the Diamond contract. network (String, required): The blockchain network. options (Object, optional): Configuration for building the ABI. includeLibraries (Boolean): Whether to include ABIs of linked libraries if available. Returns : - Promise<any[]> : A Promise that resolves to a combined ABI array suitable for ethers.Contract instantiation. Example Usage : import { getDiamondABI } from '@gemforce-sdk/diamond' ; import { ethers } from 'ethers' ; async function interactWithDiamond ( diamondAddr : string , network : string ) { try { const provider = new ethers . providers . JsonRpcProvider ( \"YOUR_RPC_URL\" ); const signer = new ethers . Wallet ( \"YOUR_PRIVATE_KEY\" , provider ); // Replace securely // Get the combined ABI for the Diamond const combinedAbi = await getDiamondABI ( diamondAddr , network ); // Instantiate the Diamond contract using the combined ABI const diamondContract = new ethers . Contract ( diamondAddr , combinedAbi , signer ); // Now you can call any function from any attached facet directly through 'diamondContract' const owner = await diamondContract . owner (); // Assuming an OwnershipFacet is attached console . log ( `Diamond owner: ${ owner } ` ); // Example: Call a marketplace function (assuming MarketplaceFacet is attached) // const listings = await diamondContract.getAllListings(); // console.log(\"Current listings:\", listings); return diamondContract ; } catch ( error ) { console . error ( `Error interacting with Diamond ${ diamondAddr } :` , error ); throw error ; } } // Example: interactWithDiamond(\"0xYourDiamondAddress\", \"sepolia\");","title":"4. getDiamondABI(diamondAddress: string, network: string, options?: { includeLibraries?: boolean })"},{"location":"sdk-libraries/diamond/#error-handling","text":"Errors from the Diamond utilities library typically include: Network Issues : Problems connecting to RPC providers. Invalid Addresses : Non-existent Diamond or facet addresses. ABI Fetching Failures : Unable to retrieve ABIs for facets. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"sdk-libraries/diamond/#security-considerations","text":"ABI Source : Ensure that the ABIs used for getDiamondABI are retrieved from a trusted source to prevent malicious function signature manipulation. Network Trust : All interactions rely on the trustworthiness of the chosen blockchain network and RPC provider. Private Key Management : While this library doesn't manage private keys directly, the usage examples demonstrate that any transaction-sending operations require a securely managed Signer .","title":"Security Considerations"},{"location":"sdk-libraries/diamond/#related-documentation","text":"Smart Contracts: Diamond Contract Smart Contracts: Diamond Loupe Facet Integrator's Guide: Smart Contracts SDK & Libraries: Blockchain Utilities","title":"Related Documentation"},{"location":"sdk-libraries/nft-sale-utils/","text":"SDK & Libraries: NFT Sale Utilities \u00b6 This document describes the nft-sale-utils.ts library, a utility module within the Gemforce SDK designed to simplify interactions related to NFT sales, especially those leveraging the IMultiSale interface or MultiSaleFacet . It provides helper functions for common tasks such as preparing sale parameters, interacting with payment tokens, and managing NFT transfers within a sale context. Overview \u00b6 The nft-sale-utils.ts library offers: Sale Parameter Preparation : Helpers to format and validate data for NFT sale contracts. Token Operations : Simplifies interactions with ERC-20 and ERC-721/1155 tokens relevant to sales (e.g., approvals, balance checks). Price Calculation : Integrates with variable pricing mechanisms (if used) to determine current NFT prices. Sale Status Query : Functions to query the status of active sales. This library aims to reduce the complexity of developing applications that participate in or manage NFT sales on the Gemforce platform. Key Functions \u00b6 1. prepareSaleConfig(config: SaleConfigDraft) \u00b6 Prepares a SaleConfig object for creating a new NFT sale, converting amounts to appropriate formats (e.g., Wei) and performing basic validations. Function Signature : prepareSaleConfig(config: SaleConfigDraft): IMultiSale.SaleConfigStruct Parameters : config (SaleConfigDraft, required): A draft configuration object containing sale details. Returns : - IMultiSale.SaleConfigStruct : A fully prepared SaleConfigStruct ready to be sent to an IMultiSale contract or MultiSaleFacet . Example Usage : import { prepareSaleConfig } from '@gemforce-sdk/nft-sale-utils' ; // Assuming this import path import { ethers } from 'ethers' ; import { IMultiSale } from '@gemforce/interfaces' ; // Import IMultiSale for type definition interface SaleConfigDraft { sellerAddress : string ; nftContractAddress : string ; tokenId? : number ; // For ERC721 specific listings, leave undefined for general sales tokenType : 'ERC721' | 'ERC1155' | 'ERC20' ; totalAmount? : number ; // Total number of items for sale (for ERC721 total supply, or ERC1155/ERC20 amount) pricePerUnit : string ; // As a decimal string (e.g., \"0.1\", \"100\") paymentTokenSymbol : string ; // e.g., \"ETH\", \"USDC\" durationInDays : number ; maxPurchasePerAddress? : number ; isWhitelistedSale? : boolean ; initialReceiverAddress? : string ; feePercentage? : number ; // In basis points, e.g., 500 for 5% name : string ; description : string ; } async function createNewNFTSale ( saleDraft : SaleConfigDraft ) { try { const preparedConfig = prepareSaleConfig ( saleDraft ); // Example: Now send this preparedConfig to your MultiSaleFacet via a Cloud Function // or directly to the smart contract. // await callCloudFunction(\"createNFTSale\", { preparedConfig, network: \"sepolia\" }); console . log ( \"Prepared Sale Config:\" , preparedConfig ); return preparedConfig ; } catch ( error ) { console . error ( \"Error preparing sale config:\" , error ); throw error ; } } // Example: // createNewNFTSale({ // sellerAddress: \"0x...\", // nftContractAddress: \"0x...\", // tokenType: \"ERC721\", // pricePerUnit: \"0.05\", // paymentTokenSymbol: \"ETH\", // durationInDays: 7, // name: \"Limited Edition NFT\", // description: \"A cool new NFT collection.\" // }); 2. approveNFTForSale(nftContractAddress: string, tokenId: string, spenderAddress: string, network: string, signer: ethers.Signer) \u00b6 Ensures that the IMultiSale contract (or MultiSaleFacet ) has the necessary approval to transfer a user's NFT. Function Signature : approveNFTForSale(nftContractAddress: string, tokenId: string, spenderAddress: string, network: string, signer: ethers.Signer): Promise<ethers.providers.TransactionReceipt> Parameters : nftContractAddress (String, required): The address of the NFT contract (ERC721 or ERC1155). tokenId (String, required): The ID of the specific NFT. (For ERC1155, this might be a type ID). spenderAddress (String, required): The address of the marketplace or sale contract that needs approval. network (String, required): The blockchain network. signer (ethers.Signer, required): The ethers.Signer of the NFT owner. Returns : - Promise<ethers.providers.TransactionReceipt> : A Promise that resolves to the transaction receipt for the approval. 3. getNFTCurrentPrice(saleId: string, network: string, quantity?: number) \u00b6 Retrieves the current price of an NFT from a sale, considering potential dynamic pricing mechanisms. Function Signature : getNFTCurrentPrice(saleId: string, network: string, quantity?: number): Promise<ethers.BigNumber> Parameters : saleId (String, required): The unique ID of the sale. network (String, required): The blockchain network. quantity (Number, optional): The quantity for which to calculate the price (defaults to 1). Returns : - Promise<ethers.BigNumber> : A Promise that resolves to the current price in Wei or base units of the payment token. 4. buyNFT(saleId: string, quantity: number, network: string, signer: ethers.Signer, value?: ethers.BigNumberish) \u00b6 Facilitates the purchase of NFTs from a sale. This function handles sending the transaction to the appropriate marketplace contract. Function Signature : buyNFT(saleId: string, quantity: number, network: string, signer: ethers.Signer, value?: ethers.BigNumberish): Promise<ethers.providers.TransactionReceipt> Parameters : saleId (String, required): The ID of the sale from which to buy. quantity (Number, required): The number of NFTs to purchase. network (String, required): The blockchain network. signer (ethers.Signer, required): The ethers.Signer of the buyer. value (ethers.BigNumberish, optional): The amount of native currency (ETH) to send with the transaction, if the payment token is ETH. Returns : - Promise<ethers.providers.TransactionReceipt> : A Promise that resolves to the transaction receipt. Error Handling \u00b6 NFT Sale Utilities can encounter various errors: Approval Failures : If the necessary token approvals are missing. Insufficient Funds/Tokens : Buyer or seller lacks balance. Sale Logic Errors : Issues from the underlying IMultiSale contract (e.g., sale ended, invalid quantity). Network/Transaction Issues : Standard blockchain errors. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Token Approvals : Always guide users through the approval process securely. Ensure approvals are granted to the correct, audited marketplace contract address. Price Sanity Checks : On the client-side, perform sanity checks on the getNFTCurrentPrice return value to prevent unexpected high costs. Phishing/Scam Prevention : Educate users about verifying contract addresses and ensuring they are interacting with the genuine Gemforce marketplace. Private Key Management : All transaction-sending functions ( approveNFTForSale , buyNFT ) rely on a signer . Ensure private keys backing this signer are managed with utmost security. Related Documentation \u00b6 Smart Contracts: IMultiSale Interface Smart Contracts: Multi Sale Facet SDK & Libraries: Blockchain Utilities SDK & Libraries: Contract Utilities","title":"NFT Sale Utilities"},{"location":"sdk-libraries/nft-sale-utils/#sdk-libraries-nft-sale-utilities","text":"This document describes the nft-sale-utils.ts library, a utility module within the Gemforce SDK designed to simplify interactions related to NFT sales, especially those leveraging the IMultiSale interface or MultiSaleFacet . It provides helper functions for common tasks such as preparing sale parameters, interacting with payment tokens, and managing NFT transfers within a sale context.","title":"SDK &amp; Libraries: NFT Sale Utilities"},{"location":"sdk-libraries/nft-sale-utils/#overview","text":"The nft-sale-utils.ts library offers: Sale Parameter Preparation : Helpers to format and validate data for NFT sale contracts. Token Operations : Simplifies interactions with ERC-20 and ERC-721/1155 tokens relevant to sales (e.g., approvals, balance checks). Price Calculation : Integrates with variable pricing mechanisms (if used) to determine current NFT prices. Sale Status Query : Functions to query the status of active sales. This library aims to reduce the complexity of developing applications that participate in or manage NFT sales on the Gemforce platform.","title":"Overview"},{"location":"sdk-libraries/nft-sale-utils/#key-functions","text":"","title":"Key Functions"},{"location":"sdk-libraries/nft-sale-utils/#1-preparesaleconfigconfig-saleconfigdraft","text":"Prepares a SaleConfig object for creating a new NFT sale, converting amounts to appropriate formats (e.g., Wei) and performing basic validations. Function Signature : prepareSaleConfig(config: SaleConfigDraft): IMultiSale.SaleConfigStruct Parameters : config (SaleConfigDraft, required): A draft configuration object containing sale details. Returns : - IMultiSale.SaleConfigStruct : A fully prepared SaleConfigStruct ready to be sent to an IMultiSale contract or MultiSaleFacet . Example Usage : import { prepareSaleConfig } from '@gemforce-sdk/nft-sale-utils' ; // Assuming this import path import { ethers } from 'ethers' ; import { IMultiSale } from '@gemforce/interfaces' ; // Import IMultiSale for type definition interface SaleConfigDraft { sellerAddress : string ; nftContractAddress : string ; tokenId? : number ; // For ERC721 specific listings, leave undefined for general sales tokenType : 'ERC721' | 'ERC1155' | 'ERC20' ; totalAmount? : number ; // Total number of items for sale (for ERC721 total supply, or ERC1155/ERC20 amount) pricePerUnit : string ; // As a decimal string (e.g., \"0.1\", \"100\") paymentTokenSymbol : string ; // e.g., \"ETH\", \"USDC\" durationInDays : number ; maxPurchasePerAddress? : number ; isWhitelistedSale? : boolean ; initialReceiverAddress? : string ; feePercentage? : number ; // In basis points, e.g., 500 for 5% name : string ; description : string ; } async function createNewNFTSale ( saleDraft : SaleConfigDraft ) { try { const preparedConfig = prepareSaleConfig ( saleDraft ); // Example: Now send this preparedConfig to your MultiSaleFacet via a Cloud Function // or directly to the smart contract. // await callCloudFunction(\"createNFTSale\", { preparedConfig, network: \"sepolia\" }); console . log ( \"Prepared Sale Config:\" , preparedConfig ); return preparedConfig ; } catch ( error ) { console . error ( \"Error preparing sale config:\" , error ); throw error ; } } // Example: // createNewNFTSale({ // sellerAddress: \"0x...\", // nftContractAddress: \"0x...\", // tokenType: \"ERC721\", // pricePerUnit: \"0.05\", // paymentTokenSymbol: \"ETH\", // durationInDays: 7, // name: \"Limited Edition NFT\", // description: \"A cool new NFT collection.\" // });","title":"1. prepareSaleConfig(config: SaleConfigDraft)"},{"location":"sdk-libraries/nft-sale-utils/#2-approvenftforsalenftcontractaddress-string-tokenid-string-spenderaddress-string-network-string-signer-etherssigner","text":"Ensures that the IMultiSale contract (or MultiSaleFacet ) has the necessary approval to transfer a user's NFT. Function Signature : approveNFTForSale(nftContractAddress: string, tokenId: string, spenderAddress: string, network: string, signer: ethers.Signer): Promise<ethers.providers.TransactionReceipt> Parameters : nftContractAddress (String, required): The address of the NFT contract (ERC721 or ERC1155). tokenId (String, required): The ID of the specific NFT. (For ERC1155, this might be a type ID). spenderAddress (String, required): The address of the marketplace or sale contract that needs approval. network (String, required): The blockchain network. signer (ethers.Signer, required): The ethers.Signer of the NFT owner. Returns : - Promise<ethers.providers.TransactionReceipt> : A Promise that resolves to the transaction receipt for the approval.","title":"2. approveNFTForSale(nftContractAddress: string, tokenId: string, spenderAddress: string, network: string, signer: ethers.Signer)"},{"location":"sdk-libraries/nft-sale-utils/#3-getnftcurrentpricesaleid-string-network-string-quantity-number","text":"Retrieves the current price of an NFT from a sale, considering potential dynamic pricing mechanisms. Function Signature : getNFTCurrentPrice(saleId: string, network: string, quantity?: number): Promise<ethers.BigNumber> Parameters : saleId (String, required): The unique ID of the sale. network (String, required): The blockchain network. quantity (Number, optional): The quantity for which to calculate the price (defaults to 1). Returns : - Promise<ethers.BigNumber> : A Promise that resolves to the current price in Wei or base units of the payment token.","title":"3. getNFTCurrentPrice(saleId: string, network: string, quantity?: number)"},{"location":"sdk-libraries/nft-sale-utils/#4-buynftsaleid-string-quantity-number-network-string-signer-etherssigner-value-ethersbignumberish","text":"Facilitates the purchase of NFTs from a sale. This function handles sending the transaction to the appropriate marketplace contract. Function Signature : buyNFT(saleId: string, quantity: number, network: string, signer: ethers.Signer, value?: ethers.BigNumberish): Promise<ethers.providers.TransactionReceipt> Parameters : saleId (String, required): The ID of the sale from which to buy. quantity (Number, required): The number of NFTs to purchase. network (String, required): The blockchain network. signer (ethers.Signer, required): The ethers.Signer of the buyer. value (ethers.BigNumberish, optional): The amount of native currency (ETH) to send with the transaction, if the payment token is ETH. Returns : - Promise<ethers.providers.TransactionReceipt> : A Promise that resolves to the transaction receipt.","title":"4. buyNFT(saleId: string, quantity: number, network: string, signer: ethers.Signer, value?: ethers.BigNumberish)"},{"location":"sdk-libraries/nft-sale-utils/#error-handling","text":"NFT Sale Utilities can encounter various errors: Approval Failures : If the necessary token approvals are missing. Insufficient Funds/Tokens : Buyer or seller lacks balance. Sale Logic Errors : Issues from the underlying IMultiSale contract (e.g., sale ended, invalid quantity). Network/Transaction Issues : Standard blockchain errors. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"sdk-libraries/nft-sale-utils/#security-considerations","text":"Token Approvals : Always guide users through the approval process securely. Ensure approvals are granted to the correct, audited marketplace contract address. Price Sanity Checks : On the client-side, perform sanity checks on the getNFTCurrentPrice return value to prevent unexpected high costs. Phishing/Scam Prevention : Educate users about verifying contract addresses and ensuring they are interacting with the genuine Gemforce marketplace. Private Key Management : All transaction-sending functions ( approveNFTForSale , buyNFT ) rely on a signer . Ensure private keys backing this signer are managed with utmost security.","title":"Security Considerations"},{"location":"sdk-libraries/nft-sale-utils/#related-documentation","text":"Smart Contracts: IMultiSale Interface Smart Contracts: Multi Sale Facet SDK & Libraries: Blockchain Utilities SDK & Libraries: Contract Utilities","title":"Related Documentation"},{"location":"sdk-libraries/validation-utils/","text":"SDK & Libraries: Validation Utilities \u00b6 This document describes the validation-utils.ts library, a key utility module within the Gemforce SDK providing a collection of helper functions for data validation. These utilities are essential for ensuring the integrity and correctness of inputs across various layers of your application, from user interfaces to backend logic before interacting with smart contracts or APIs. Overview \u00b6 The validation-utils.ts library offers: Input Data Validation : Functions to validate common data types and formats (e.g., addresses, amounts, dates, strings). Error Reporting : Consistent methods for reporting validation failures. Blockchain-Specific Checks : Utilities for validating parameters relevant to blockchain interactions (e.g., valid ERC-20 amounts, non-zero addresses). This library helps improve application robustness, prevent common integration errors, and enhance security by ensuring that only valid data is processed. Key Functions \u00b6 1. isValidAddress(address: string) \u00b6 Checks if a given string is a valid Ethereum-like blockchain address (e.g., 0x-prefixed, 40 hex characters). Function Signature : isValidAddress(address: string): boolean Parameters : address (String, required): The string to validate as an address. Returns : - boolean : true if the address is valid, false otherwise. Example Usage : import { isValidAddress } from '@gemforce-sdk/validation-utils' ; // Assuming this import path const address1 = \"0x742d35Cc6634C0539Ff34fB5BdCfd2C300f72868\" ; // Valid const address2 = \"0xinvalidAddress\" ; // Invalid console . log ( `' ${ address1 } ' is valid: ${ isValidAddress ( address1 ) } ` ); // true console . log ( `' ${ address2 } ' is valid: ${ isValidAddress ( address2 ) } ` ); // false 2. isValidNonZeroAmount(amount: ethers.BigNumberish) \u00b6 Checks if a given amount (e.g., ethers.BigNumber , string, number) is valid and non-zero. Useful for preventing transactions with zero value. Function Signature : isValidNonZeroAmount(amount: ethers.BigNumberish): boolean Parameters : amount (ethers.BigNumberish, required): The amount to validate. Returns : - boolean : true if the amount is valid and greater than zero, false otherwise. 3. isPositiveNumber(value: number | string) \u00b6 Checks if a given value is a positive number (greater than zero). Function Signature : isPositiveNumber(value: number | string): boolean Parameters : value (Number | String, required): The value to validate. Returns : - boolean : true if the value is a positive number, false otherwise. 4. isHexString(value: string, length?: number) \u00b6 Checks if a given string is a hexadecimal string, optionally verifying its length. Function Signature : isHexString(value: string, length?: number): boolean Parameters : value (String, required): The string to validate as hex. length (Number, optional): The expected length of the hex string (excluding \"0x\" prefix), e.g., 64 for a bytes32 . Returns : - boolean : true if the value is a valid hex string of the specified length (if provided), false otherwise. 5. validateEmail(email: string) \u00b6 Performs a basic validation check on an email string using a regular expression. Function Signature : validateEmail(email: string): boolean Parameters : email (String, required): The email string to validate. Returns : - boolean : true if the email format is valid, false otherwise. 6. throwIfInvalid(condition: boolean, errorMessage: string) \u00b6 A general helper function to throw an error if a condition is false . Useful for consolidating validation logic. Function Signature : throwIfInvalid(condition: boolean, errorMessage: string): void Parameters : condition (Boolean, required): The condition to check. If false , an error is thrown. errorMessage (String, required): The error message to throw. Example Usage : import { isValidAddress , throwIfInvalid } from '@gemforce-sdk/validation-utils' ; function processUserRequest ( userAddress : string , amount : ethers.BigNumberish ) { throwIfInvalid ( isValidAddress ( userAddress ), \"Invalid recipient address provided.\" ); throwIfInvalid ( amount > 0 , \"Amount must be greater than zero.\" ); // Further processing... } // Example: processUserRequest(\"0xValidAddress\", 100); // Example: processUserRequest(\"invalid\", 0); // Throws error Error Handling \u00b6 Validation utilities primarily throw errors when validation fails. These errors should be caught by the calling application layer and translated into user-friendly messages. Refer to the Integrator's Guide: Error Handling for general error handling strategies. Security Considerations \u00b6 Client-Side vs. Server-Side : While client-side validation using this library enhances user experience, always perform server-side validation as well. Client-side checks can be bypassed. Canonical Checks : For critical blockchain-related parameters (like addresses), ensure that the library performs canonical checks (e.g., checksumming for addresses) if applicable. Regular Expressions : Be cautious with overly complex regular expressions for validation, as they can sometimes be vulnerable to ReDoS (Regular expression Denial of Service) attacks. Related Documentation \u00b6 Integrator's Guide: Error Handling","title":"Validation Utilities"},{"location":"sdk-libraries/validation-utils/#sdk-libraries-validation-utilities","text":"This document describes the validation-utils.ts library, a key utility module within the Gemforce SDK providing a collection of helper functions for data validation. These utilities are essential for ensuring the integrity and correctness of inputs across various layers of your application, from user interfaces to backend logic before interacting with smart contracts or APIs.","title":"SDK &amp; Libraries: Validation Utilities"},{"location":"sdk-libraries/validation-utils/#overview","text":"The validation-utils.ts library offers: Input Data Validation : Functions to validate common data types and formats (e.g., addresses, amounts, dates, strings). Error Reporting : Consistent methods for reporting validation failures. Blockchain-Specific Checks : Utilities for validating parameters relevant to blockchain interactions (e.g., valid ERC-20 amounts, non-zero addresses). This library helps improve application robustness, prevent common integration errors, and enhance security by ensuring that only valid data is processed.","title":"Overview"},{"location":"sdk-libraries/validation-utils/#key-functions","text":"","title":"Key Functions"},{"location":"sdk-libraries/validation-utils/#1-isvalidaddressaddress-string","text":"Checks if a given string is a valid Ethereum-like blockchain address (e.g., 0x-prefixed, 40 hex characters). Function Signature : isValidAddress(address: string): boolean Parameters : address (String, required): The string to validate as an address. Returns : - boolean : true if the address is valid, false otherwise. Example Usage : import { isValidAddress } from '@gemforce-sdk/validation-utils' ; // Assuming this import path const address1 = \"0x742d35Cc6634C0539Ff34fB5BdCfd2C300f72868\" ; // Valid const address2 = \"0xinvalidAddress\" ; // Invalid console . log ( `' ${ address1 } ' is valid: ${ isValidAddress ( address1 ) } ` ); // true console . log ( `' ${ address2 } ' is valid: ${ isValidAddress ( address2 ) } ` ); // false","title":"1. isValidAddress(address: string)"},{"location":"sdk-libraries/validation-utils/#2-isvalidnonzeroamountamount-ethersbignumberish","text":"Checks if a given amount (e.g., ethers.BigNumber , string, number) is valid and non-zero. Useful for preventing transactions with zero value. Function Signature : isValidNonZeroAmount(amount: ethers.BigNumberish): boolean Parameters : amount (ethers.BigNumberish, required): The amount to validate. Returns : - boolean : true if the amount is valid and greater than zero, false otherwise.","title":"2. isValidNonZeroAmount(amount: ethers.BigNumberish)"},{"location":"sdk-libraries/validation-utils/#3-ispositivenumbervalue-number-string","text":"Checks if a given value is a positive number (greater than zero). Function Signature : isPositiveNumber(value: number | string): boolean Parameters : value (Number | String, required): The value to validate. Returns : - boolean : true if the value is a positive number, false otherwise.","title":"3. isPositiveNumber(value: number | string)"},{"location":"sdk-libraries/validation-utils/#4-ishexstringvalue-string-length-number","text":"Checks if a given string is a hexadecimal string, optionally verifying its length. Function Signature : isHexString(value: string, length?: number): boolean Parameters : value (String, required): The string to validate as hex. length (Number, optional): The expected length of the hex string (excluding \"0x\" prefix), e.g., 64 for a bytes32 . Returns : - boolean : true if the value is a valid hex string of the specified length (if provided), false otherwise.","title":"4. isHexString(value: string, length?: number)"},{"location":"sdk-libraries/validation-utils/#5-validateemailemail-string","text":"Performs a basic validation check on an email string using a regular expression. Function Signature : validateEmail(email: string): boolean Parameters : email (String, required): The email string to validate. Returns : - boolean : true if the email format is valid, false otherwise.","title":"5. validateEmail(email: string)"},{"location":"sdk-libraries/validation-utils/#6-throwifinvalidcondition-boolean-errormessage-string","text":"A general helper function to throw an error if a condition is false . Useful for consolidating validation logic. Function Signature : throwIfInvalid(condition: boolean, errorMessage: string): void Parameters : condition (Boolean, required): The condition to check. If false , an error is thrown. errorMessage (String, required): The error message to throw. Example Usage : import { isValidAddress , throwIfInvalid } from '@gemforce-sdk/validation-utils' ; function processUserRequest ( userAddress : string , amount : ethers.BigNumberish ) { throwIfInvalid ( isValidAddress ( userAddress ), \"Invalid recipient address provided.\" ); throwIfInvalid ( amount > 0 , \"Amount must be greater than zero.\" ); // Further processing... } // Example: processUserRequest(\"0xValidAddress\", 100); // Example: processUserRequest(\"invalid\", 0); // Throws error","title":"6. throwIfInvalid(condition: boolean, errorMessage: string)"},{"location":"sdk-libraries/validation-utils/#error-handling","text":"Validation utilities primarily throw errors when validation fails. These errors should be caught by the calling application layer and translated into user-friendly messages. Refer to the Integrator's Guide: Error Handling for general error handling strategies.","title":"Error Handling"},{"location":"sdk-libraries/validation-utils/#security-considerations","text":"Client-Side vs. Server-Side : While client-side validation using this library enhances user experience, always perform server-side validation as well. Client-side checks can be bypassed. Canonical Checks : For critical blockchain-related parameters (like addresses), ensure that the library performs canonical checks (e.g., checksumming for addresses) if applicable. Regular Expressions : Be cautious with overly complex regular expressions for validation, as they can sometimes be vulnerable to ReDoS (Regular expression Denial of Service) attacks.","title":"Security Considerations"},{"location":"sdk-libraries/validation-utils/#related-documentation","text":"Integrator's Guide: Error Handling","title":"Related Documentation"},{"location":"sdk-libraries/webhooks/","text":"SDK & Libraries: Webhook Utilities \u00b6 This document describes the webhooks.ts library, a utility module within the Gemforce SDK designed to assist with handling and verifying incoming webhooks from the Gemforce platform. It provides functions to parse webhook payloads, verify their authenticity (via signatures), and standardize webhook processing within your application. Overview \u00b6 The webhooks.ts library offers: Payload Parsing : Standardized parsing of incoming JSON webhook payloads. Signature Verification : Crucial security checks to ensure webhook authenticity using shared secrets (HMAC). Event Type Identification : Helpers to easily identify the type of event contained within the webhook. This library is essential for any application that consumes webhooks from the Gemforce platform, guaranteeing data integrity and security. Key Functions \u00b6 1. verifyWebhookSignature(payload: any, signature: string, secret: string) \u00b6 Verifies the HMAC signature of an incoming webhook payload against a shared secret. Function Signature : verifyWebhookSignature(payload: any, signature: string, secret: string): boolean Parameters : payload (Any, required): The raw JSON payload object received from the webhook. signature (String, required): The signature string, typically found in a custom HTTP header (e.g., X-Gemforce-Signature ). secret (String, required): The shared secret key configured both in your application and on the Gemforce platform for this webhook. Returns : - boolean : true if the signature is valid, false otherwise. Example Usage : import { verifyWebhookSignature } from '@gemforce-sdk/webhooks' ; // Assuming this import path import express from 'express' ; import bodyParser from 'body-parser' ; import crypto from 'crypto' ; const app = express (); const WEBHOOK_SECRET = process . env . GEMFORCE_WEBHOOK_SECRET || \"your_super_secret_webhook_key\" ; app . use ( bodyParser . json ()); app . post ( '/gemforce-webhook-listener' , ( req , res ) => { const signature = req . headers [ 'x-gemforce-signature' ] as string ; // Adjust header name as per Gemforce config if ( ! signature ) { return res . status ( 401 ). send ( 'Signature missing' ); } try { const isVerified = verifyWebhookSignature ( req . body , signature , WEBHOOK_SECRET ); if ( ! isVerified ) { console . warn ( 'Webhook signature mismatch. Potential tampering.' ); return res . status ( 403 ). send ( 'Invalid signature' ); } console . log ( 'Webhook signature verified successfully.' ); // Process webhook payload const eventType = req . body . event ? . type ; const eventData = req . body . data ; console . log ( `Received event: ${ eventType } ` , eventData ); res . status ( 200 ). send ( 'Webhook processed' ); } catch ( error ) { console . error ( 'Error verifying or processing webhook:' , error ); res . status ( 500 ). send ( 'Internal server error' ); // Respond with 500 for internal errors } }); // app.listen(3000, () => console.log('Webhook listener running on port 3000')); 2. getWebhookEventType(payload: any) \u00b6 Extracts and returns the type of event from a given webhook payload. Function Signature : getWebhookEventType(payload: any): string | null Parameters : payload (Any, required): The JSON payload object received from the webhook. Returns : - string | null : The event type string (e.g., \"user.created\", \"marketplace.itemListed\") or null if the type cannot be determined. 3. getWebhookEventData(payload: any) \u00b6 Extracts and returns the data object associated with the webhook event from a given payload. Function Signature : getWebhookEventData(payload: any): any | null Parameters : payload (Any, required): The JSON payload object received from the webhook. Returns : - any | null : The event data object or null if the data cannot be extracted. Error Handling \u00b6 Webhook utilities primarily throw errors if essential parameters are missing or if signature verification fails. These errors indicate a potential security issue or a malformed webhook, and should be handled by your application to log the incident and potentially alert administrators. Security Considerations \u00b6 Secret Management : The secret used for verifyWebhookSignature MUST be kept absolutely secret and should be stored in environment variables or a secure secrets management system (e.g., AWS Secrets Manager, HashiCorp Vault), never hardcoded. Replay Attacks : While HMAC signatures prevent tampering, they don't inherently prevent replay attacks. Consider adding a timestamp or a unique nonce to your webhook payloads and verify these on your server to prevent an attacker from re-sending old webhooks. Idempotency : Your webhook processing logic should be idempotent , meaning that processing the same webhook multiple times has the same effect as processing it once. This is crucial for resilience against retries and accidental duplicate deliveries. SSL/TLS : Ensure your webhook endpoint is served over HTTPS to protect the payload in transit. Input Validation : Even after signature verification, always validate the contents of the payload to protect against logic flaws or unexpected data structures. Response Time : Aim for very fast response times (within a few seconds) for your webhook endpoint. Long response times can cause the sender to retry, leading to duplicate deliveries. Process heavy logic asynchronously. Related Documentation \u00b6 Integrator's Guide: Webhooks Integrator's Guide: Security","title":"SDK &amp; Libraries: Webhook Utilities"},{"location":"sdk-libraries/webhooks/#sdk-libraries-webhook-utilities","text":"This document describes the webhooks.ts library, a utility module within the Gemforce SDK designed to assist with handling and verifying incoming webhooks from the Gemforce platform. It provides functions to parse webhook payloads, verify their authenticity (via signatures), and standardize webhook processing within your application.","title":"SDK &amp; Libraries: Webhook Utilities"},{"location":"sdk-libraries/webhooks/#overview","text":"The webhooks.ts library offers: Payload Parsing : Standardized parsing of incoming JSON webhook payloads. Signature Verification : Crucial security checks to ensure webhook authenticity using shared secrets (HMAC). Event Type Identification : Helpers to easily identify the type of event contained within the webhook. This library is essential for any application that consumes webhooks from the Gemforce platform, guaranteeing data integrity and security.","title":"Overview"},{"location":"sdk-libraries/webhooks/#key-functions","text":"","title":"Key Functions"},{"location":"sdk-libraries/webhooks/#1-verifywebhooksignaturepayload-any-signature-string-secret-string","text":"Verifies the HMAC signature of an incoming webhook payload against a shared secret. Function Signature : verifyWebhookSignature(payload: any, signature: string, secret: string): boolean Parameters : payload (Any, required): The raw JSON payload object received from the webhook. signature (String, required): The signature string, typically found in a custom HTTP header (e.g., X-Gemforce-Signature ). secret (String, required): The shared secret key configured both in your application and on the Gemforce platform for this webhook. Returns : - boolean : true if the signature is valid, false otherwise. Example Usage : import { verifyWebhookSignature } from '@gemforce-sdk/webhooks' ; // Assuming this import path import express from 'express' ; import bodyParser from 'body-parser' ; import crypto from 'crypto' ; const app = express (); const WEBHOOK_SECRET = process . env . GEMFORCE_WEBHOOK_SECRET || \"your_super_secret_webhook_key\" ; app . use ( bodyParser . json ()); app . post ( '/gemforce-webhook-listener' , ( req , res ) => { const signature = req . headers [ 'x-gemforce-signature' ] as string ; // Adjust header name as per Gemforce config if ( ! signature ) { return res . status ( 401 ). send ( 'Signature missing' ); } try { const isVerified = verifyWebhookSignature ( req . body , signature , WEBHOOK_SECRET ); if ( ! isVerified ) { console . warn ( 'Webhook signature mismatch. Potential tampering.' ); return res . status ( 403 ). send ( 'Invalid signature' ); } console . log ( 'Webhook signature verified successfully.' ); // Process webhook payload const eventType = req . body . event ? . type ; const eventData = req . body . data ; console . log ( `Received event: ${ eventType } ` , eventData ); res . status ( 200 ). send ( 'Webhook processed' ); } catch ( error ) { console . error ( 'Error verifying or processing webhook:' , error ); res . status ( 500 ). send ( 'Internal server error' ); // Respond with 500 for internal errors } }); // app.listen(3000, () => console.log('Webhook listener running on port 3000'));","title":"1. verifyWebhookSignature(payload: any, signature: string, secret: string)"},{"location":"sdk-libraries/webhooks/#2-getwebhookeventtypepayload-any","text":"Extracts and returns the type of event from a given webhook payload. Function Signature : getWebhookEventType(payload: any): string | null Parameters : payload (Any, required): The JSON payload object received from the webhook. Returns : - string | null : The event type string (e.g., \"user.created\", \"marketplace.itemListed\") or null if the type cannot be determined.","title":"2. getWebhookEventType(payload: any)"},{"location":"sdk-libraries/webhooks/#3-getwebhookeventdatapayload-any","text":"Extracts and returns the data object associated with the webhook event from a given payload. Function Signature : getWebhookEventData(payload: any): any | null Parameters : payload (Any, required): The JSON payload object received from the webhook. Returns : - any | null : The event data object or null if the data cannot be extracted.","title":"3. getWebhookEventData(payload: any)"},{"location":"sdk-libraries/webhooks/#error-handling","text":"Webhook utilities primarily throw errors if essential parameters are missing or if signature verification fails. These errors indicate a potential security issue or a malformed webhook, and should be handled by your application to log the incident and potentially alert administrators.","title":"Error Handling"},{"location":"sdk-libraries/webhooks/#security-considerations","text":"Secret Management : The secret used for verifyWebhookSignature MUST be kept absolutely secret and should be stored in environment variables or a secure secrets management system (e.g., AWS Secrets Manager, HashiCorp Vault), never hardcoded. Replay Attacks : While HMAC signatures prevent tampering, they don't inherently prevent replay attacks. Consider adding a timestamp or a unique nonce to your webhook payloads and verify these on your server to prevent an attacker from re-sending old webhooks. Idempotency : Your webhook processing logic should be idempotent , meaning that processing the same webhook multiple times has the same effect as processing it once. This is crucial for resilience against retries and accidental duplicate deliveries. SSL/TLS : Ensure your webhook endpoint is served over HTTPS to protect the payload in transit. Input Validation : Even after signature verification, always validate the contents of the payload to protect against logic flaws or unexpected data structures. Response Time : Aim for very fast response times (within a few seconds) for your webhook endpoint. Long response times can cause the sender to retry, leading to duplicate deliveries. Process heavy logic asynchronously.","title":"Security Considerations"},{"location":"sdk-libraries/webhooks/#related-documentation","text":"Integrator's Guide: Webhooks Integrator's Guide: Security","title":"Related Documentation"},{"location":"smart-contracts/","text":"Smart Contract Reference Documentation \u00b6 Overview \u00b6 The Gemforce platform is built on a sophisticated smart contract architecture using the Diamond Standard (EIP-2535) for upgradeable contracts. This documentation provides comprehensive reference material for all smart contracts in the system. Architecture Overview \u00b6 The Gemforce smart contract system consists of: Diamond Contracts : Core proxy contracts implementing EIP-2535 Facets : Modular contract implementations providing specific functionality Libraries : Shared utility code for common operations Interfaces : Standard interfaces for contract interaction Tokens : ERC20, ERC721, and ERC1155 token implementations Utilities : Helper contracts for access control and security Contract Categories \u00b6 Core Diamond System \u00b6 Diamond - Main diamond proxy contract DiamondFactory - Factory for diamond deployment IdentityFactory - Identity contract factory Business Logic Facets \u00b6 CarbonCreditFacet - Carbon credit management MarketplaceFacet - NFT marketplace operations MultiSaleFacet - Multi-token sales TradeDealManagementFacet - Trade deal lifecycle TradeDealOperationsFacet - Trade deal operations IdentityRegistryFacet - Identity management TrustedIssuersRegistryFacet - Trusted issuer management Token Management Facets \u00b6 GemforceMinterFacet - Token minting functionality CollateralTokenFactoryFacet - Collateral token creation FeeDistributorFacet - Fee distribution logic Utility Facets \u00b6 SVGTemplatesFacet - Dynamic SVG generation DiamondCutFacet - Diamond upgrade functionality DiamondLoupeFacet - Diamond introspection OwnershipFacet - Contract ownership management Core Interfaces \u00b6 IDiamond - Diamond standard interface IMarketplace - Marketplace interface ITradeDeal - Trade deal interface ICarbonCredit - Carbon credit interface IIdentity - Identity interface Libraries \u00b6 DiamondLib - Diamond pattern utilities CarbonCreditLib - Carbon credit utilities TradeDealLib - Trade deal utilities MultiSaleLib - Multi-sale utilities Getting Started \u00b6 For Developers \u00b6 Start with the Diamond documentation to understand the core architecture Review the Interfaces to understand contract APIs Examine specific Facets for functionality you need to integrate Check Libraries for utility functions For Integrators \u00b6 Review the Integration Guide Examine relevant interface documentation Check deployment procedures in Deployment Guide Review security considerations in each contract's documentation Security Considerations \u00b6 All contracts implement: - Reentrancy protection using OpenZeppelin's ReentrancyGuard - Access control through role-based permissions - Input validation and sanitization - Event logging for transparency and monitoring Gas Optimization \u00b6 The contracts are optimized for gas efficiency through: - Diamond pattern for reduced deployment costs - Packed structs for storage optimization - Batch operations where applicable - Efficient algorithms in libraries Upgrade Patterns \u00b6 The Diamond Standard enables: - Modular upgrades through facet replacement - Backward compatibility maintenance - Gradual feature rollouts - Emergency upgrade procedures For detailed information about each contract, click on the links above or navigate through the documentation sections.","title":"Overview"},{"location":"smart-contracts/#smart-contract-reference-documentation","text":"","title":"Smart Contract Reference Documentation"},{"location":"smart-contracts/#overview","text":"The Gemforce platform is built on a sophisticated smart contract architecture using the Diamond Standard (EIP-2535) for upgradeable contracts. This documentation provides comprehensive reference material for all smart contracts in the system.","title":"Overview"},{"location":"smart-contracts/#architecture-overview","text":"The Gemforce smart contract system consists of: Diamond Contracts : Core proxy contracts implementing EIP-2535 Facets : Modular contract implementations providing specific functionality Libraries : Shared utility code for common operations Interfaces : Standard interfaces for contract interaction Tokens : ERC20, ERC721, and ERC1155 token implementations Utilities : Helper contracts for access control and security","title":"Architecture Overview"},{"location":"smart-contracts/#contract-categories","text":"","title":"Contract Categories"},{"location":"smart-contracts/#core-diamond-system","text":"Diamond - Main diamond proxy contract DiamondFactory - Factory for diamond deployment IdentityFactory - Identity contract factory","title":"Core Diamond System"},{"location":"smart-contracts/#business-logic-facets","text":"CarbonCreditFacet - Carbon credit management MarketplaceFacet - NFT marketplace operations MultiSaleFacet - Multi-token sales TradeDealManagementFacet - Trade deal lifecycle TradeDealOperationsFacet - Trade deal operations IdentityRegistryFacet - Identity management TrustedIssuersRegistryFacet - Trusted issuer management","title":"Business Logic Facets"},{"location":"smart-contracts/#token-management-facets","text":"GemforceMinterFacet - Token minting functionality CollateralTokenFactoryFacet - Collateral token creation FeeDistributorFacet - Fee distribution logic","title":"Token Management Facets"},{"location":"smart-contracts/#utility-facets","text":"SVGTemplatesFacet - Dynamic SVG generation DiamondCutFacet - Diamond upgrade functionality DiamondLoupeFacet - Diamond introspection OwnershipFacet - Contract ownership management","title":"Utility Facets"},{"location":"smart-contracts/#core-interfaces","text":"IDiamond - Diamond standard interface IMarketplace - Marketplace interface ITradeDeal - Trade deal interface ICarbonCredit - Carbon credit interface IIdentity - Identity interface","title":"Core Interfaces"},{"location":"smart-contracts/#libraries","text":"DiamondLib - Diamond pattern utilities CarbonCreditLib - Carbon credit utilities TradeDealLib - Trade deal utilities MultiSaleLib - Multi-sale utilities","title":"Libraries"},{"location":"smart-contracts/#getting-started","text":"","title":"Getting Started"},{"location":"smart-contracts/#for-developers","text":"Start with the Diamond documentation to understand the core architecture Review the Interfaces to understand contract APIs Examine specific Facets for functionality you need to integrate Check Libraries for utility functions","title":"For Developers"},{"location":"smart-contracts/#for-integrators","text":"Review the Integration Guide Examine relevant interface documentation Check deployment procedures in Deployment Guide Review security considerations in each contract's documentation","title":"For Integrators"},{"location":"smart-contracts/#security-considerations","text":"All contracts implement: - Reentrancy protection using OpenZeppelin's ReentrancyGuard - Access control through role-based permissions - Input validation and sanitization - Event logging for transparency and monitoring","title":"Security Considerations"},{"location":"smart-contracts/#gas-optimization","text":"The contracts are optimized for gas efficiency through: - Diamond pattern for reduced deployment costs - Packed structs for storage optimization - Batch operations where applicable - Efficient algorithms in libraries","title":"Gas Optimization"},{"location":"smart-contracts/#upgrade-patterns","text":"The Diamond Standard enables: - Modular upgrades through facet replacement - Backward compatibility maintenance - Gradual feature rollouts - Emergency upgrade procedures For detailed information about each contract, click on the links above or navigate through the documentation sections.","title":"Upgrade Patterns"},{"location":"smart-contracts/diamond-factory/","text":"Diamond Factory \u00b6 The Diamond Factory is a contract deployment system that creates new diamond contracts with predefined facet configurations. It provides a standardized way to deploy diamonds with consistent initialization and upgrade patterns. Overview \u00b6 The Diamond Factory provides: Standardized Deployment : Deploy diamonds with consistent configurations Template Management : Manage diamond templates and facet combinations Initialization Support : Handle complex initialization sequences Upgrade Patterns : Support for upgradeable diamond deployments Access Control : Manage who can deploy new diamonds Key Features \u00b6 Diamond Deployment \u00b6 Template-Based : Deploy from predefined templates Custom Configuration : Support custom facet combinations Initialization : Handle complex initialization logic Event Tracking : Track all deployed diamonds Template Management \u00b6 Template Registry : Store and manage diamond templates Facet Combinations : Define standard facet sets Version Control : Support multiple template versions Validation : Validate template configurations Factory Patterns \u00b6 Clone Factory : Efficient diamond cloning Minimal Proxy : Gas-efficient deployment patterns Deterministic Addresses : Predictable diamond addresses Batch Deployment : Deploy multiple diamonds efficiently Core Interface \u00b6 interface IDiamondFactory { struct DiamondTemplate { string name ; string version ; FacetCut [] facetCuts ; address initContract ; bytes initData ; bool active ; } struct DeploymentConfig { string templateName ; bytes32 salt ; bytes initData ; address owner ; } event DiamondDeployed ( address indexed diamond , address indexed owner , string templateName , bytes32 salt ); event TemplateRegistered ( string indexed name , string version , address indexed creator ); function deployDiamond ( DeploymentConfig calldata config ) external returns ( address diamond ); function registerTemplate ( DiamondTemplate calldata template ) external ; function getTemplate ( string calldata name ) external view returns ( DiamondTemplate memory ); function predictDiamondAddress ( DeploymentConfig calldata config ) external view returns ( address ); } Core Functions \u00b6 deployDiamond() \u00b6 Deploys a new diamond contract using a registered template. Parameters: - config : Deployment configuration including template name, salt, and initialization data Returns: - address : Address of the deployed diamond Usage: IDiamondFactory . DeploymentConfig memory config = IDiamondFactory . DeploymentConfig ({ templateName : \"StandardNFT\" , salt : keccak256 ( \"unique-identifier\" ), initData : abi . encode ( name , symbol , baseURI ), owner : msg.sender }); address diamond = IDiamondFactory ( factory ). deployDiamond ( config ); registerTemplate() \u00b6 Registers a new diamond template for deployment. Parameters: - template : Template configuration including facets and initialization Access Control: - Restricted to authorized template creators Usage: IDiamondFactory . DiamondTemplate memory template = IDiamondFactory . DiamondTemplate ({ name : \"StandardNFT\" , version : \"1.0.0\" , facetCuts : facetCuts , initContract : initContract , initData : initData , active : true }); IDiamondFactory ( factory ). registerTemplate ( template ); predictDiamondAddress() \u00b6 Predicts the address of a diamond before deployment. Parameters: - config : Deployment configuration Returns: - address : Predicted diamond address Usage: address predictedAddress = IDiamondFactory ( factory ). predictDiamondAddress ( config ); Implementation Example \u00b6 Basic Diamond Factory \u00b6 contract DiamondFactory is IDiamondFactory { using LibDiamondFactory for DiamondTemplate ; mapping ( string => DiamondTemplate ) private templates ; mapping ( address => bool ) public templateCreators ; address [] public deployedDiamonds ; modifier onlyTemplateCreator () { require ( templateCreators [ msg.sender ] || msg.sender == owner (), \"Not authorized\" ); _ ; } function deployDiamond ( DeploymentConfig calldata config ) external override returns ( address diamond ) { DiamondTemplate memory template = templates [ config . templateName ]; require ( template . active , \"Template not active\" ); // Deploy diamond using CREATE2 for deterministic addresses bytes32 salt = keccak256 ( abi . encodePacked ( config . salt , msg.sender )); diamond = Clones . cloneDeterministic ( diamondImplementation , salt ); // Initialize diamond with template configuration IDiamondCut ( diamond ). diamondCut ( template . facetCuts , template . initContract , abi . encodePacked ( template . initData , config . initData ) ); // Transfer ownership to specified owner IOwnership ( diamond ). transferOwnership ( config . owner ); deployedDiamonds . push ( diamond ); emit DiamondDeployed ( diamond , config . owner , config . templateName , config . salt ); } function registerTemplate ( DiamondTemplate calldata template ) external override onlyTemplateCreator { require ( bytes ( template . name ). length > 0 , \"Invalid template name\" ); require ( template . facetCuts . length > 0 , \"No facets specified\" ); templates [ template . name ] = template ; emit TemplateRegistered ( template . name , template . version , msg.sender ); } } Advanced Factory with Versioning \u00b6 contract VersionedDiamondFactory { struct VersionedTemplate { mapping ( string => DiamondTemplate ) versions ; string [] versionList ; string latestVersion ; } mapping ( string => VersionedTemplate ) private templates ; function registerTemplateVersion ( string calldata name , string calldata version , DiamondTemplate calldata template ) external onlyTemplateCreator { VersionedTemplate storage versionedTemplate = templates [ name ]; // Check if version already exists require ( bytes ( versionedTemplate . versions [ version ]. name ). length == 0 , \"Version already exists\" ); versionedTemplate . versions [ version ] = template ; versionedTemplate . versionList . push ( version ); versionedTemplate . latestVersion = version ; emit TemplateVersionRegistered ( name , version , msg.sender ); } function deployDiamondVersion ( string calldata templateName , string calldata version , DeploymentConfig calldata config ) external returns ( address diamond ) { DiamondTemplate memory template = templates [ templateName ]. versions [ version ]; require ( template . active , \"Template version not active\" ); // Deploy with version-specific logic return _deployDiamondFromTemplate ( template , config ); } } Template Patterns \u00b6 Standard NFT Template \u00b6 function createNFTTemplate () internal pure returns ( DiamondTemplate memory ) { FacetCut [] memory facetCuts = new FacetCut []( 4 ); // ERC721 Facet facetCuts [ 0 ] = FacetCut ({ facetAddress : erc721FacetAddress , action : FacetCutAction . Add , functionSelectors : getERC721Selectors () }); // Marketplace Facet facetCuts [ 1 ] = FacetCut ({ facetAddress : marketplaceFacetAddress , action : FacetCutAction . Add , functionSelectors : getMarketplaceSelectors () }); // Metadata Facet facetCuts [ 2 ] = FacetCut ({ facetAddress : metadataFacetAddress , action : FacetCutAction . Add , functionSelectors : getMetadataSelectors () }); // Ownership Facet facetCuts [ 3 ] = FacetCut ({ facetAddress : ownershipFacetAddress , action : FacetCutAction . Add , functionSelectors : getOwnershipSelectors () }); return DiamondTemplate ({ name : \"StandardNFT\" , version : \"1.0.0\" , facetCuts : facetCuts , initContract : nftInitContract , initData : \"\" , active : true }); } DeFi Protocol Template \u00b6 function createDeFiTemplate () internal pure returns ( DiamondTemplate memory ) { FacetCut [] memory facetCuts = new FacetCut []( 5 ); // Token Facet facetCuts [ 0 ] = FacetCut ({ facetAddress : tokenFacetAddress , action : FacetCutAction . Add , functionSelectors : getTokenSelectors () }); // Staking Facet facetCuts [ 1 ] = FacetCut ({ facetAddress : stakingFacetAddress , action : FacetCutAction . Add , functionSelectors : getStakingSelectors () }); // Governance Facet facetCuts [ 2 ] = FacetCut ({ facetAddress : governanceFacetAddress , action : FacetCutAction . Add , functionSelectors : getGovernanceSelectors () }); // Fee Distribution Facet facetCuts [ 3 ] = FacetCut ({ facetAddress : feeDistributorFacetAddress , action : FacetCutAction . Add , functionSelectors : getFeeDistributorSelectors () }); // Treasury Facet facetCuts [ 4 ] = FacetCut ({ facetAddress : treasuryFacetAddress , action : FacetCutAction . Add , functionSelectors : getTreasurySelectors () }); return DiamondTemplate ({ name : \"DeFiProtocol\" , version : \"1.0.0\" , facetCuts : facetCuts , initContract : defiInitContract , initData : \"\" , active : true }); } Security Considerations \u00b6 Access Control \u00b6 Template Creation : Restrict who can register templates Deployment Permissions : Control diamond deployment access Owner Assignment : Validate diamond ownership assignment Template Validation : Validate template configurations Template Security \u00b6 Facet Validation : Ensure facet contracts are secure Initialization Safety : Validate initialization logic Upgrade Restrictions : Consider upgrade limitations Version Control : Manage template versions securely Deployment Safety \u00b6 Address Prediction : Secure address prediction mechanisms Salt Management : Prevent salt collision attacks Initialization Atomicity : Ensure atomic initialization Ownership Transfer : Secure ownership transfer process Best Practices \u00b6 Template Design \u00b6 Modular Facets : Design reusable, modular facets Standard Interfaces : Use standard interfaces for compatibility Initialization Patterns : Follow consistent initialization patterns Documentation : Document template capabilities and limitations Factory Management \u00b6 Access Control : Implement proper access controls Template Validation : Validate all template configurations Event Logging : Log all deployments and template changes Upgrade Planning : Plan for factory upgrades Deployment Patterns \u00b6 Deterministic Addresses : Use CREATE2 for predictable addresses Batch Operations : Support batch deployments for efficiency Gas Optimization : Optimize deployment gas costs Error Handling : Implement comprehensive error handling Integration Examples \u00b6 Frontend Integration \u00b6 class DiamondFactory { private contract : Contract ; constructor ( address : string , provider : Provider ) { this . contract = new Contract ( address , DIAMOND_FACTORY_ABI , provider ); } async deployDiamond ( config : DeploymentConfig ) : Promise < string > { const tx = await this . contract . deployDiamond ( config ); const receipt = await tx . wait (); const event = receipt . events ? . find ( e => e . event === 'DiamondDeployed' ); return event ? . args ? . diamond ; } async predictAddress ( config : DeploymentConfig ) : Promise < string > { return await this . contract . predictDiamondAddress ( config ); } async getTemplate ( name : string ) : Promise < DiamondTemplate > { return await this . contract . getTemplate ( name ); } } CLI Integration \u00b6 # Deploy a diamond using CLI gemforce deploy-diamond \\ --template \"StandardNFT\" \\ --name \"My NFT Collection\" \\ --symbol \"MNC\" \\ --owner \"0x...\" \\ --network \"sepolia\" # Register a new template gemforce register-template \\ --name \"CustomNFT\" \\ --version \"1.0.0\" \\ --config \"./templates/custom-nft.json\" \\ --network \"sepolia\" Related Documentation \u00b6 Diamond Standard Overview Diamond Cut Facet Diamond Loupe Facet Diamond Factory Library Deployment Guide Template Development Guide Standards Compliance \u00b6 EIP-2535 : Diamond Standard implementation EIP-1167 : Minimal Proxy Standard for cloning EIP-1014 : CREATE2 for deterministic addresses Factory Pattern : Standard factory design patterns","title":"Diamond Factory"},{"location":"smart-contracts/diamond-factory/#diamond-factory","text":"The Diamond Factory is a contract deployment system that creates new diamond contracts with predefined facet configurations. It provides a standardized way to deploy diamonds with consistent initialization and upgrade patterns.","title":"Diamond Factory"},{"location":"smart-contracts/diamond-factory/#overview","text":"The Diamond Factory provides: Standardized Deployment : Deploy diamonds with consistent configurations Template Management : Manage diamond templates and facet combinations Initialization Support : Handle complex initialization sequences Upgrade Patterns : Support for upgradeable diamond deployments Access Control : Manage who can deploy new diamonds","title":"Overview"},{"location":"smart-contracts/diamond-factory/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/diamond-factory/#diamond-deployment","text":"Template-Based : Deploy from predefined templates Custom Configuration : Support custom facet combinations Initialization : Handle complex initialization logic Event Tracking : Track all deployed diamonds","title":"Diamond Deployment"},{"location":"smart-contracts/diamond-factory/#template-management","text":"Template Registry : Store and manage diamond templates Facet Combinations : Define standard facet sets Version Control : Support multiple template versions Validation : Validate template configurations","title":"Template Management"},{"location":"smart-contracts/diamond-factory/#factory-patterns","text":"Clone Factory : Efficient diamond cloning Minimal Proxy : Gas-efficient deployment patterns Deterministic Addresses : Predictable diamond addresses Batch Deployment : Deploy multiple diamonds efficiently","title":"Factory Patterns"},{"location":"smart-contracts/diamond-factory/#core-interface","text":"interface IDiamondFactory { struct DiamondTemplate { string name ; string version ; FacetCut [] facetCuts ; address initContract ; bytes initData ; bool active ; } struct DeploymentConfig { string templateName ; bytes32 salt ; bytes initData ; address owner ; } event DiamondDeployed ( address indexed diamond , address indexed owner , string templateName , bytes32 salt ); event TemplateRegistered ( string indexed name , string version , address indexed creator ); function deployDiamond ( DeploymentConfig calldata config ) external returns ( address diamond ); function registerTemplate ( DiamondTemplate calldata template ) external ; function getTemplate ( string calldata name ) external view returns ( DiamondTemplate memory ); function predictDiamondAddress ( DeploymentConfig calldata config ) external view returns ( address ); }","title":"Core Interface"},{"location":"smart-contracts/diamond-factory/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/diamond-factory/#deploydiamond","text":"Deploys a new diamond contract using a registered template. Parameters: - config : Deployment configuration including template name, salt, and initialization data Returns: - address : Address of the deployed diamond Usage: IDiamondFactory . DeploymentConfig memory config = IDiamondFactory . DeploymentConfig ({ templateName : \"StandardNFT\" , salt : keccak256 ( \"unique-identifier\" ), initData : abi . encode ( name , symbol , baseURI ), owner : msg.sender }); address diamond = IDiamondFactory ( factory ). deployDiamond ( config );","title":"deployDiamond()"},{"location":"smart-contracts/diamond-factory/#registertemplate","text":"Registers a new diamond template for deployment. Parameters: - template : Template configuration including facets and initialization Access Control: - Restricted to authorized template creators Usage: IDiamondFactory . DiamondTemplate memory template = IDiamondFactory . DiamondTemplate ({ name : \"StandardNFT\" , version : \"1.0.0\" , facetCuts : facetCuts , initContract : initContract , initData : initData , active : true }); IDiamondFactory ( factory ). registerTemplate ( template );","title":"registerTemplate()"},{"location":"smart-contracts/diamond-factory/#predictdiamondaddress","text":"Predicts the address of a diamond before deployment. Parameters: - config : Deployment configuration Returns: - address : Predicted diamond address Usage: address predictedAddress = IDiamondFactory ( factory ). predictDiamondAddress ( config );","title":"predictDiamondAddress()"},{"location":"smart-contracts/diamond-factory/#implementation-example","text":"","title":"Implementation Example"},{"location":"smart-contracts/diamond-factory/#basic-diamond-factory","text":"contract DiamondFactory is IDiamondFactory { using LibDiamondFactory for DiamondTemplate ; mapping ( string => DiamondTemplate ) private templates ; mapping ( address => bool ) public templateCreators ; address [] public deployedDiamonds ; modifier onlyTemplateCreator () { require ( templateCreators [ msg.sender ] || msg.sender == owner (), \"Not authorized\" ); _ ; } function deployDiamond ( DeploymentConfig calldata config ) external override returns ( address diamond ) { DiamondTemplate memory template = templates [ config . templateName ]; require ( template . active , \"Template not active\" ); // Deploy diamond using CREATE2 for deterministic addresses bytes32 salt = keccak256 ( abi . encodePacked ( config . salt , msg.sender )); diamond = Clones . cloneDeterministic ( diamondImplementation , salt ); // Initialize diamond with template configuration IDiamondCut ( diamond ). diamondCut ( template . facetCuts , template . initContract , abi . encodePacked ( template . initData , config . initData ) ); // Transfer ownership to specified owner IOwnership ( diamond ). transferOwnership ( config . owner ); deployedDiamonds . push ( diamond ); emit DiamondDeployed ( diamond , config . owner , config . templateName , config . salt ); } function registerTemplate ( DiamondTemplate calldata template ) external override onlyTemplateCreator { require ( bytes ( template . name ). length > 0 , \"Invalid template name\" ); require ( template . facetCuts . length > 0 , \"No facets specified\" ); templates [ template . name ] = template ; emit TemplateRegistered ( template . name , template . version , msg.sender ); } }","title":"Basic Diamond Factory"},{"location":"smart-contracts/diamond-factory/#advanced-factory-with-versioning","text":"contract VersionedDiamondFactory { struct VersionedTemplate { mapping ( string => DiamondTemplate ) versions ; string [] versionList ; string latestVersion ; } mapping ( string => VersionedTemplate ) private templates ; function registerTemplateVersion ( string calldata name , string calldata version , DiamondTemplate calldata template ) external onlyTemplateCreator { VersionedTemplate storage versionedTemplate = templates [ name ]; // Check if version already exists require ( bytes ( versionedTemplate . versions [ version ]. name ). length == 0 , \"Version already exists\" ); versionedTemplate . versions [ version ] = template ; versionedTemplate . versionList . push ( version ); versionedTemplate . latestVersion = version ; emit TemplateVersionRegistered ( name , version , msg.sender ); } function deployDiamondVersion ( string calldata templateName , string calldata version , DeploymentConfig calldata config ) external returns ( address diamond ) { DiamondTemplate memory template = templates [ templateName ]. versions [ version ]; require ( template . active , \"Template version not active\" ); // Deploy with version-specific logic return _deployDiamondFromTemplate ( template , config ); } }","title":"Advanced Factory with Versioning"},{"location":"smart-contracts/diamond-factory/#template-patterns","text":"","title":"Template Patterns"},{"location":"smart-contracts/diamond-factory/#standard-nft-template","text":"function createNFTTemplate () internal pure returns ( DiamondTemplate memory ) { FacetCut [] memory facetCuts = new FacetCut []( 4 ); // ERC721 Facet facetCuts [ 0 ] = FacetCut ({ facetAddress : erc721FacetAddress , action : FacetCutAction . Add , functionSelectors : getERC721Selectors () }); // Marketplace Facet facetCuts [ 1 ] = FacetCut ({ facetAddress : marketplaceFacetAddress , action : FacetCutAction . Add , functionSelectors : getMarketplaceSelectors () }); // Metadata Facet facetCuts [ 2 ] = FacetCut ({ facetAddress : metadataFacetAddress , action : FacetCutAction . Add , functionSelectors : getMetadataSelectors () }); // Ownership Facet facetCuts [ 3 ] = FacetCut ({ facetAddress : ownershipFacetAddress , action : FacetCutAction . Add , functionSelectors : getOwnershipSelectors () }); return DiamondTemplate ({ name : \"StandardNFT\" , version : \"1.0.0\" , facetCuts : facetCuts , initContract : nftInitContract , initData : \"\" , active : true }); }","title":"Standard NFT Template"},{"location":"smart-contracts/diamond-factory/#defi-protocol-template","text":"function createDeFiTemplate () internal pure returns ( DiamondTemplate memory ) { FacetCut [] memory facetCuts = new FacetCut []( 5 ); // Token Facet facetCuts [ 0 ] = FacetCut ({ facetAddress : tokenFacetAddress , action : FacetCutAction . Add , functionSelectors : getTokenSelectors () }); // Staking Facet facetCuts [ 1 ] = FacetCut ({ facetAddress : stakingFacetAddress , action : FacetCutAction . Add , functionSelectors : getStakingSelectors () }); // Governance Facet facetCuts [ 2 ] = FacetCut ({ facetAddress : governanceFacetAddress , action : FacetCutAction . Add , functionSelectors : getGovernanceSelectors () }); // Fee Distribution Facet facetCuts [ 3 ] = FacetCut ({ facetAddress : feeDistributorFacetAddress , action : FacetCutAction . Add , functionSelectors : getFeeDistributorSelectors () }); // Treasury Facet facetCuts [ 4 ] = FacetCut ({ facetAddress : treasuryFacetAddress , action : FacetCutAction . Add , functionSelectors : getTreasurySelectors () }); return DiamondTemplate ({ name : \"DeFiProtocol\" , version : \"1.0.0\" , facetCuts : facetCuts , initContract : defiInitContract , initData : \"\" , active : true }); }","title":"DeFi Protocol Template"},{"location":"smart-contracts/diamond-factory/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/diamond-factory/#access-control","text":"Template Creation : Restrict who can register templates Deployment Permissions : Control diamond deployment access Owner Assignment : Validate diamond ownership assignment Template Validation : Validate template configurations","title":"Access Control"},{"location":"smart-contracts/diamond-factory/#template-security","text":"Facet Validation : Ensure facet contracts are secure Initialization Safety : Validate initialization logic Upgrade Restrictions : Consider upgrade limitations Version Control : Manage template versions securely","title":"Template Security"},{"location":"smart-contracts/diamond-factory/#deployment-safety","text":"Address Prediction : Secure address prediction mechanisms Salt Management : Prevent salt collision attacks Initialization Atomicity : Ensure atomic initialization Ownership Transfer : Secure ownership transfer process","title":"Deployment Safety"},{"location":"smart-contracts/diamond-factory/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/diamond-factory/#template-design","text":"Modular Facets : Design reusable, modular facets Standard Interfaces : Use standard interfaces for compatibility Initialization Patterns : Follow consistent initialization patterns Documentation : Document template capabilities and limitations","title":"Template Design"},{"location":"smart-contracts/diamond-factory/#factory-management","text":"Access Control : Implement proper access controls Template Validation : Validate all template configurations Event Logging : Log all deployments and template changes Upgrade Planning : Plan for factory upgrades","title":"Factory Management"},{"location":"smart-contracts/diamond-factory/#deployment-patterns","text":"Deterministic Addresses : Use CREATE2 for predictable addresses Batch Operations : Support batch deployments for efficiency Gas Optimization : Optimize deployment gas costs Error Handling : Implement comprehensive error handling","title":"Deployment Patterns"},{"location":"smart-contracts/diamond-factory/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/diamond-factory/#frontend-integration","text":"class DiamondFactory { private contract : Contract ; constructor ( address : string , provider : Provider ) { this . contract = new Contract ( address , DIAMOND_FACTORY_ABI , provider ); } async deployDiamond ( config : DeploymentConfig ) : Promise < string > { const tx = await this . contract . deployDiamond ( config ); const receipt = await tx . wait (); const event = receipt . events ? . find ( e => e . event === 'DiamondDeployed' ); return event ? . args ? . diamond ; } async predictAddress ( config : DeploymentConfig ) : Promise < string > { return await this . contract . predictDiamondAddress ( config ); } async getTemplate ( name : string ) : Promise < DiamondTemplate > { return await this . contract . getTemplate ( name ); } }","title":"Frontend Integration"},{"location":"smart-contracts/diamond-factory/#cli-integration","text":"# Deploy a diamond using CLI gemforce deploy-diamond \\ --template \"StandardNFT\" \\ --name \"My NFT Collection\" \\ --symbol \"MNC\" \\ --owner \"0x...\" \\ --network \"sepolia\" # Register a new template gemforce register-template \\ --name \"CustomNFT\" \\ --version \"1.0.0\" \\ --config \"./templates/custom-nft.json\" \\ --network \"sepolia\"","title":"CLI Integration"},{"location":"smart-contracts/diamond-factory/#related-documentation","text":"Diamond Standard Overview Diamond Cut Facet Diamond Loupe Facet Diamond Factory Library Deployment Guide Template Development Guide","title":"Related Documentation"},{"location":"smart-contracts/diamond-factory/#standards-compliance","text":"EIP-2535 : Diamond Standard implementation EIP-1167 : Minimal Proxy Standard for cloning EIP-1014 : CREATE2 for deterministic addresses Factory Pattern : Standard factory design patterns","title":"Standards Compliance"},{"location":"smart-contracts/diamond/","text":"Diamond Contract \u00b6 Overview \u00b6 The Diamond.sol contract is the core proxy contract implementing the EIP-2535 Diamond Standard. It serves as the main entry point for all diamond-based contracts in the Gemforce system, providing upgradeable functionality through modular facets. Contract Details \u00b6 Contract Name : Diamond Inheritance : Initializable , IERC173 License : MIT Solidity Version : ^0.8.0 Key Features \u00b6 \ud83d\udd39 EIP-2535 Diamond Standard Implementation \u00b6 Modular architecture through facets Upgradeable functionality without changing contract address Gas-efficient proxy pattern with delegatecall \ud83d\udd39 Multi-Interface Support \u00b6 ERC165 (Interface Detection) ERC173 (Contract Ownership) ERC721 (Non-Fungible Token) ERC721Metadata (Token Metadata) ERC721Enumerable (Token Enumeration) \ud83d\udd39 Upgrade Timelock Security \u00b6 Built-in upgrade timelock mechanism Prevents immediate malicious upgrades Configurable timelock duration Core Functions \u00b6 Initialization \u00b6 initialize() \u00b6 function initialize ( address _owner , DiamondSettings memory params , IDiamondCut . FacetCut [] memory _facets , address diamondInit , bytes calldata _calldata ) public initializer Purpose : Initializes the Diamond contract with owner, settings, and initial facets. Parameters : - _owner : The initial owner of the contract - params : Diamond settings including name and symbol - _facets : Array of initial facets to add during deployment - diamondInit : Address of the initialization contract - _calldata : Initialization calldata to execute Key Operations : 1. Sets up supported interfaces (ERC165, ERC173, ERC721, etc.) 2. Performs diamond cut to add initial facets 3. Sets contract owner 4. Configures diamond metadata (name, symbol) 5. Initializes upgrade timelock with default duration Ownership Management \u00b6 transferOwnership() \u00b6 function transferOwnership ( address _newOwner ) external override Purpose : Transfers contract ownership to a new address. Access Control : Only current owner Parameters : - _newOwner : Address of the new owner owner() \u00b6 function owner () external override view returns ( address owner_ ) Purpose : Returns the current contract owner. Returns : Current owner address Utility Functions \u00b6 diamondAddress() \u00b6 function diamondAddress () external view returns ( address ) Purpose : Returns this contract's address. Returns : The diamond contract address Proxy Functionality \u00b6 fallback() \u00b6 fallback () external payable Purpose : Core proxy functionality that routes function calls to appropriate facets. Process : 1. Retrieves diamond storage 2. Looks up facet address for the called function selector 3. Executes function using delegatecall 4. Returns result or reverts with error receive() \u00b6 receive () external payable Purpose : Allows the contract to receive ETH directly. Architecture Integration \u00b6 Diamond Storage Pattern \u00b6 The Diamond contract uses the diamond storage pattern to avoid storage collisions: LibDiamond . DiamondStorage storage ds ; bytes32 position = LibDiamond . DIAMOND_STORAGE_POSITION ; assembly { ds . slot := position } Facet Routing \u00b6 Function calls are routed through the fallback function: Function Selector Lookup : msg.sig is used to find the corresponding facet Delegatecall Execution : Function is executed in the context of the diamond Return Handling : Results are returned to the caller Security Considerations \u00b6 Access Control \u00b6 Owner-only functions protected by LibDiamond.enforceIsContractOwner() Upgrade timelock prevents immediate malicious upgrades Interface validation ensures proper ERC compliance Upgrade Safety \u00b6 Timelock mechanism for upgrades Facet validation during diamond cuts Storage collision prevention through diamond storage pattern Reentrancy Protection \u00b6 Inherits reentrancy protection from facets Delegatecall pattern maintains security context Gas Optimization \u00b6 Efficient Proxy Pattern \u00b6 Single storage slot lookup for facet routing Assembly-optimized delegatecall implementation Minimal overhead for function calls Storage Efficiency \u00b6 Diamond storage pattern prevents storage collisions Packed structs in diamond settings Efficient interface registration Integration Examples \u00b6 Basic Diamond Deployment \u00b6 // Deploy diamond with initial facets IDiamondCut . FacetCut [] memory cuts = new IDiamondCut . FacetCut []( 3 ); // Add DiamondCutFacet cuts [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : diamondCutFacet , action : IDiamondCut . FacetCutAction . Add , functionSelectors : diamondCutSelectors }); // Add DiamondLoupeFacet cuts [ 1 ] = IDiamondCut . FacetCut ({ facetAddress : diamondLoupeFacet , action : IDiamondCut . FacetCutAction . Add , functionSelectors : diamondLoupeSelectors }); // Add OwnershipFacet cuts [ 2 ] = IDiamondCut . FacetCut ({ facetAddress : ownershipFacet , action : IDiamondCut . FacetCutAction . Add , functionSelectors : ownershipSelectors }); // Initialize diamond diamond . initialize ( owner , DiamondSettings ({ name : \"MyDiamond\" , symbol : \"MD\" }), cuts , diamondInit , initCalldata ); Adding New Facets \u00b6 // Add marketplace functionality IDiamondCut . FacetCut [] memory cuts = new IDiamondCut . FacetCut []( 1 ); cuts [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : marketplaceFacet , action : IDiamondCut . FacetCutAction . Add , functionSelectors : marketplaceSelectors }); IDiamondCut ( diamond ). diamondCut ( cuts , address ( 0 ), \"\" ); Events \u00b6 The Diamond contract itself doesn't emit events directly, but inherits events from: - LibDiamond for diamond cuts and ownership changes - Individual facets for their specific functionality Error Handling \u00b6 Common Errors \u00b6 \"Diamond: Function does not exist\" : Called function selector not found in any facet \"LibDiamond: Must be contract owner\" : Unauthorized access to owner-only functions \"LibDiamond: Upgrade timelock not expired\" : Attempted upgrade before timelock expiration Testing Considerations \u00b6 Unit Tests \u00b6 Test initialization with various facet combinations Verify ownership transfer functionality Test fallback function routing Validate interface support Integration Tests \u00b6 Test with real facet implementations Verify upgrade procedures Test complex multi-facet interactions Related Documentation \u00b6 DiamondFactory - Factory for diamond deployment DiamondCutFacet - Diamond upgrade functionality DiamondLoupeFacet - Diamond introspection LibDiamond - Diamond utility library External References \u00b6 EIP-2535: Diamonds, Multi-Facet Proxy Diamond Standard Documentation OpenZeppelin Initializable This documentation covers the core Diamond contract. For specific functionality, refer to the individual facet documentation.","title":"Diamond Contract"},{"location":"smart-contracts/diamond/#diamond-contract","text":"","title":"Diamond Contract"},{"location":"smart-contracts/diamond/#overview","text":"The Diamond.sol contract is the core proxy contract implementing the EIP-2535 Diamond Standard. It serves as the main entry point for all diamond-based contracts in the Gemforce system, providing upgradeable functionality through modular facets.","title":"Overview"},{"location":"smart-contracts/diamond/#contract-details","text":"Contract Name : Diamond Inheritance : Initializable , IERC173 License : MIT Solidity Version : ^0.8.0","title":"Contract Details"},{"location":"smart-contracts/diamond/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/diamond/#eip-2535-diamond-standard-implementation","text":"Modular architecture through facets Upgradeable functionality without changing contract address Gas-efficient proxy pattern with delegatecall","title":"\ud83d\udd39 EIP-2535 Diamond Standard Implementation"},{"location":"smart-contracts/diamond/#multi-interface-support","text":"ERC165 (Interface Detection) ERC173 (Contract Ownership) ERC721 (Non-Fungible Token) ERC721Metadata (Token Metadata) ERC721Enumerable (Token Enumeration)","title":"\ud83d\udd39 Multi-Interface Support"},{"location":"smart-contracts/diamond/#upgrade-timelock-security","text":"Built-in upgrade timelock mechanism Prevents immediate malicious upgrades Configurable timelock duration","title":"\ud83d\udd39 Upgrade Timelock Security"},{"location":"smart-contracts/diamond/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/diamond/#initialization","text":"","title":"Initialization"},{"location":"smart-contracts/diamond/#initialize","text":"function initialize ( address _owner , DiamondSettings memory params , IDiamondCut . FacetCut [] memory _facets , address diamondInit , bytes calldata _calldata ) public initializer Purpose : Initializes the Diamond contract with owner, settings, and initial facets. Parameters : - _owner : The initial owner of the contract - params : Diamond settings including name and symbol - _facets : Array of initial facets to add during deployment - diamondInit : Address of the initialization contract - _calldata : Initialization calldata to execute Key Operations : 1. Sets up supported interfaces (ERC165, ERC173, ERC721, etc.) 2. Performs diamond cut to add initial facets 3. Sets contract owner 4. Configures diamond metadata (name, symbol) 5. Initializes upgrade timelock with default duration","title":"initialize()"},{"location":"smart-contracts/diamond/#ownership-management","text":"","title":"Ownership Management"},{"location":"smart-contracts/diamond/#transferownership","text":"function transferOwnership ( address _newOwner ) external override Purpose : Transfers contract ownership to a new address. Access Control : Only current owner Parameters : - _newOwner : Address of the new owner","title":"transferOwnership()"},{"location":"smart-contracts/diamond/#owner","text":"function owner () external override view returns ( address owner_ ) Purpose : Returns the current contract owner. Returns : Current owner address","title":"owner()"},{"location":"smart-contracts/diamond/#utility-functions","text":"","title":"Utility Functions"},{"location":"smart-contracts/diamond/#diamondaddress","text":"function diamondAddress () external view returns ( address ) Purpose : Returns this contract's address. Returns : The diamond contract address","title":"diamondAddress()"},{"location":"smart-contracts/diamond/#proxy-functionality","text":"","title":"Proxy Functionality"},{"location":"smart-contracts/diamond/#fallback","text":"fallback () external payable Purpose : Core proxy functionality that routes function calls to appropriate facets. Process : 1. Retrieves diamond storage 2. Looks up facet address for the called function selector 3. Executes function using delegatecall 4. Returns result or reverts with error","title":"fallback()"},{"location":"smart-contracts/diamond/#receive","text":"receive () external payable Purpose : Allows the contract to receive ETH directly.","title":"receive()"},{"location":"smart-contracts/diamond/#architecture-integration","text":"","title":"Architecture Integration"},{"location":"smart-contracts/diamond/#diamond-storage-pattern","text":"The Diamond contract uses the diamond storage pattern to avoid storage collisions: LibDiamond . DiamondStorage storage ds ; bytes32 position = LibDiamond . DIAMOND_STORAGE_POSITION ; assembly { ds . slot := position }","title":"Diamond Storage Pattern"},{"location":"smart-contracts/diamond/#facet-routing","text":"Function calls are routed through the fallback function: Function Selector Lookup : msg.sig is used to find the corresponding facet Delegatecall Execution : Function is executed in the context of the diamond Return Handling : Results are returned to the caller","title":"Facet Routing"},{"location":"smart-contracts/diamond/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/diamond/#access-control","text":"Owner-only functions protected by LibDiamond.enforceIsContractOwner() Upgrade timelock prevents immediate malicious upgrades Interface validation ensures proper ERC compliance","title":"Access Control"},{"location":"smart-contracts/diamond/#upgrade-safety","text":"Timelock mechanism for upgrades Facet validation during diamond cuts Storage collision prevention through diamond storage pattern","title":"Upgrade Safety"},{"location":"smart-contracts/diamond/#reentrancy-protection","text":"Inherits reentrancy protection from facets Delegatecall pattern maintains security context","title":"Reentrancy Protection"},{"location":"smart-contracts/diamond/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/diamond/#efficient-proxy-pattern","text":"Single storage slot lookup for facet routing Assembly-optimized delegatecall implementation Minimal overhead for function calls","title":"Efficient Proxy Pattern"},{"location":"smart-contracts/diamond/#storage-efficiency","text":"Diamond storage pattern prevents storage collisions Packed structs in diamond settings Efficient interface registration","title":"Storage Efficiency"},{"location":"smart-contracts/diamond/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/diamond/#basic-diamond-deployment","text":"// Deploy diamond with initial facets IDiamondCut . FacetCut [] memory cuts = new IDiamondCut . FacetCut []( 3 ); // Add DiamondCutFacet cuts [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : diamondCutFacet , action : IDiamondCut . FacetCutAction . Add , functionSelectors : diamondCutSelectors }); // Add DiamondLoupeFacet cuts [ 1 ] = IDiamondCut . FacetCut ({ facetAddress : diamondLoupeFacet , action : IDiamondCut . FacetCutAction . Add , functionSelectors : diamondLoupeSelectors }); // Add OwnershipFacet cuts [ 2 ] = IDiamondCut . FacetCut ({ facetAddress : ownershipFacet , action : IDiamondCut . FacetCutAction . Add , functionSelectors : ownershipSelectors }); // Initialize diamond diamond . initialize ( owner , DiamondSettings ({ name : \"MyDiamond\" , symbol : \"MD\" }), cuts , diamondInit , initCalldata );","title":"Basic Diamond Deployment"},{"location":"smart-contracts/diamond/#adding-new-facets","text":"// Add marketplace functionality IDiamondCut . FacetCut [] memory cuts = new IDiamondCut . FacetCut []( 1 ); cuts [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : marketplaceFacet , action : IDiamondCut . FacetCutAction . Add , functionSelectors : marketplaceSelectors }); IDiamondCut ( diamond ). diamondCut ( cuts , address ( 0 ), \"\" );","title":"Adding New Facets"},{"location":"smart-contracts/diamond/#events","text":"The Diamond contract itself doesn't emit events directly, but inherits events from: - LibDiamond for diamond cuts and ownership changes - Individual facets for their specific functionality","title":"Events"},{"location":"smart-contracts/diamond/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/diamond/#common-errors","text":"\"Diamond: Function does not exist\" : Called function selector not found in any facet \"LibDiamond: Must be contract owner\" : Unauthorized access to owner-only functions \"LibDiamond: Upgrade timelock not expired\" : Attempted upgrade before timelock expiration","title":"Common Errors"},{"location":"smart-contracts/diamond/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/diamond/#unit-tests","text":"Test initialization with various facet combinations Verify ownership transfer functionality Test fallback function routing Validate interface support","title":"Unit Tests"},{"location":"smart-contracts/diamond/#integration-tests","text":"Test with real facet implementations Verify upgrade procedures Test complex multi-facet interactions","title":"Integration Tests"},{"location":"smart-contracts/diamond/#related-documentation","text":"DiamondFactory - Factory for diamond deployment DiamondCutFacet - Diamond upgrade functionality DiamondLoupeFacet - Diamond introspection LibDiamond - Diamond utility library","title":"Related Documentation"},{"location":"smart-contracts/diamond/#external-references","text":"EIP-2535: Diamonds, Multi-Facet Proxy Diamond Standard Documentation OpenZeppelin Initializable This documentation covers the core Diamond contract. For specific functionality, refer to the individual facet documentation.","title":"External References"},{"location":"smart-contracts/identity-factory/","text":"Identity Factory \u00b6 The Identity Factory is a specialized contract deployment system for creating ERC-734/ERC-735 compliant identity contracts. It provides standardized deployment of identity contracts with key management and claim verification capabilities. Overview \u00b6 The Identity Factory provides: Identity Deployment : Deploy ERC-734/ERC-735 identity contracts Key Management Setup : Initialize identity contracts with management keys Claim Integration : Setup trusted issuer relationships Registry Integration : Automatic registration with identity registries Template Management : Manage different identity contract templates Key Features \u00b6 Identity Contract Deployment \u00b6 ERC-734 Compliance : Deploy key manager compliant contracts ERC-735 Compliance : Deploy claim holder compliant contracts Combined Implementation : Deploy contracts supporting both standards Custom Configuration : Support custom identity configurations Key Management Integration \u00b6 Management Keys : Setup initial management keys Action Keys : Configure action-specific keys Claim Keys : Setup claim signing keys Encryption Keys : Configure encryption capabilities Registry Integration \u00b6 Automatic Registration : Register identities with central registry Trusted Issuer Setup : Configure trusted issuer relationships Claim Verification : Setup claim verification mechanisms Identity Linking : Link identities to external systems Core Interface \u00b6 interface IIdentityFactory { struct IdentityConfig { address owner ; bytes32 [] managementKeys ; bytes32 [] actionKeys ; bytes32 [] claimKeys ; address [] trustedIssuers ; bool registerWithRegistry ; } struct IdentityTemplate { string name ; string version ; address implementation ; bytes initCode ; bool active ; } event IdentityDeployed ( address indexed identity , address indexed owner , string templateName ); event TemplateRegistered ( string indexed name , string version , address implementation ); function deployIdentity ( string calldata templateName , IdentityConfig calldata config ) external returns ( address identity ); function registerTemplate ( IdentityTemplate calldata template ) external ; function getTemplate ( string calldata name ) external view returns ( IdentityTemplate memory ); function predictIdentityAddress ( string calldata templateName , IdentityConfig calldata config ) external view returns ( address ); } Core Functions \u00b6 deployIdentity() \u00b6 Deploys a new identity contract using a registered template. Parameters: - templateName : Name of the template to use - config : Identity configuration including keys and settings Returns: - address : Address of the deployed identity contract Usage: IIdentityFactory . IdentityConfig memory config = IIdentityFactory . IdentityConfig ({ owner : msg.sender , managementKeys : [ keccak256 ( abi . encodePacked ( msg.sender ))], actionKeys : [ keccak256 ( abi . encodePacked ( actionKey ))], claimKeys : [ keccak256 ( abi . encodePacked ( claimKey ))], trustedIssuers : [ trustedIssuerAddress ], registerWithRegistry : true }); address identity = IIdentityFactory ( factory ). deployIdentity ( \"StandardIdentity\" , config ); registerTemplate() \u00b6 Registers a new identity template for deployment. Parameters: - template : Template configuration including implementation and initialization Access Control: - Restricted to authorized template creators predictIdentityAddress() \u00b6 Predicts the address of an identity contract before deployment. Parameters: - templateName : Name of the template - config : Identity configuration Returns: - address : Predicted identity address Implementation Example \u00b6 Basic Identity Factory \u00b6 contract IdentityFactory is IIdentityFactory { using Clones for address ; mapping ( string => IdentityTemplate ) private templates ; mapping ( address => bool ) public templateCreators ; address public identityRegistry ; modifier onlyTemplateCreator () { require ( templateCreators [ msg.sender ] || msg.sender == owner (), \"Not authorized\" ); _ ; } function deployIdentity ( string calldata templateName , IdentityConfig calldata config ) external override returns ( address identity ) { IdentityTemplate memory template = templates [ templateName ]; require ( template . active , \"Template not active\" ); require ( config . owner != address ( 0 ), \"Invalid owner\" ); // Deploy identity using minimal proxy pattern bytes32 salt = keccak256 ( abi . encodePacked ( config . owner , block.timestamp )); identity = template . implementation . cloneDeterministic ( salt ); // Initialize identity with configuration _initializeIdentity ( identity , config , template ); // Register with identity registry if requested if ( config . registerWithRegistry && identityRegistry != address ( 0 )) { IIdentityRegistry ( identityRegistry ). registerIdentity ( identity , config . owner ); } emit IdentityDeployed ( identity , config . owner , templateName ); } function _initializeIdentity ( address identity , IdentityConfig memory config , IdentityTemplate memory template ) internal { // Initialize with template-specific logic if ( template . initCode . length > 0 ) { ( bool success ,) = identity . call ( abi . encodePacked ( template . initCode , abi . encode ( config )) ); require ( success , \"Identity initialization failed\" ); } // Setup management keys for ( uint i = 0 ; i < config . managementKeys . length ; i ++ ) { IERC734 ( identity ). addKey ( config . managementKeys [ i ], 1 , // MANAGEMENT purpose 1 // ECDSA key type ); } // Setup action keys for ( uint i = 0 ; i < config . actionKeys . length ; i ++ ) { IERC734 ( identity ). addKey ( config . actionKeys [ i ], 2 , // ACTION purpose 1 // ECDSA key type ); } // Setup claim keys for ( uint i = 0 ; i < config . claimKeys . length ; i ++ ) { IERC734 ( identity ). addKey ( config . claimKeys [ i ], 3 , // CLAIM purpose 1 // ECDSA key type ); } // Setup trusted issuers for ( uint i = 0 ; i < config . trustedIssuers . length ; i ++ ) { IERC735 ( identity ). addTrustedIssuer ( config . trustedIssuers [ i ]); } } } Advanced Identity Factory with Governance \u00b6 contract GovernanceIdentityFactory { struct GovernanceConfig { uint256 requiredApprovals ; address [] governors ; uint256 votingPeriod ; } mapping ( address => GovernanceConfig ) public identityGovernance ; function deployGovernedIdentity ( string calldata templateName , IdentityConfig calldata config , GovernanceConfig calldata governance ) external returns ( address identity ) { identity = deployIdentity ( templateName , config ); // Setup governance structure identityGovernance [ identity ] = governance ; // Initialize governance contract address governanceContract = _deployGovernanceContract ( identity , governance ); // Transfer identity ownership to governance contract IOwnable ( identity ). transferOwnership ( governanceContract ); emit GovernedIdentityDeployed ( identity , governanceContract ); } function _deployGovernanceContract ( address identity , GovernanceConfig memory config ) internal returns ( address governance ) { // Deploy governance contract for the identity governance = Clones . clone ( governanceImplementation ); IGovernance ( governance ). initialize ( identity , config . governors , config . requiredApprovals , config . votingPeriod ); } } Template Patterns \u00b6 Standard Identity Template \u00b6 function createStandardIdentityTemplate () internal pure returns ( IdentityTemplate memory ) { return IdentityTemplate ({ name : \"StandardIdentity\" , version : \"1.0.0\" , implementation : standardIdentityImplementation , initCode : abi . encodeWithSignature ( \"initialize(address)\" , address ( 0 )), active : true }); } Corporate Identity Template \u00b6 function createCorporateIdentityTemplate () internal pure returns ( IdentityTemplate memory ) { return IdentityTemplate ({ name : \"CorporateIdentity\" , version : \"1.0.0\" , implementation : corporateIdentityImplementation , initCode : abi . encodeWithSignature ( \"initializeCorporate(address,string,string)\" , address ( 0 ), \"\" , \"\" ), active : true }); } Multi-Signature Identity Template \u00b6 function createMultiSigIdentityTemplate () internal pure returns ( IdentityTemplate memory ) { return IdentityTemplate ({ name : \"MultiSigIdentity\" , version : \"1.0.0\" , implementation : multiSigIdentityImplementation , initCode : abi . encodeWithSignature ( \"initializeMultiSig(address[],uint256)\" , new address []( 0 ), 0 ), active : true }); } Integration Patterns \u00b6 Registry Integration \u00b6 contract IdentityRegistryIntegration { address public identityRegistry ; address public trustedIssuersRegistry ; function deployWithRegistration ( string calldata templateName , IdentityConfig calldata config ) external returns ( address identity ) { // Deploy identity identity = deployIdentity ( templateName , config ); // Register with identity registry IIdentityRegistry ( identityRegistry ). registerIdentity ( identity , config . owner ); // Setup trusted issuer relationships for ( uint i = 0 ; i < config . trustedIssuers . length ; i ++ ) { ITrustedIssuersRegistry ( trustedIssuersRegistry ). addTrustedIssuer ( identity , config . trustedIssuers [ i ] ); } emit IdentityRegistered ( identity , config . owner ); } } KYC Integration \u00b6 contract KYCIdentityFactory { mapping ( address => bool ) public kycProviders ; function deployKYCIdentity ( string calldata templateName , IdentityConfig calldata config , bytes calldata kycProof ) external returns ( address identity ) { // Verify KYC proof require ( _verifyKYCProof ( config . owner , kycProof ), \"Invalid KYC proof\" ); // Deploy identity with KYC claim identity = deployIdentity ( templateName , config ); // Add KYC claim bytes32 claimId = keccak256 ( \"KYC_VERIFIED\" ); IERC735 ( identity ). addClaim ( claimId , 1 , // KYC claim type msg.sender , // issuer kycProof , \"\" , // claim data \"\" // URI ); emit KYCIdentityDeployed ( identity , config . owner ); } function _verifyKYCProof ( address user , bytes memory proof ) internal view returns ( bool ) { // Implement KYC proof verification logic return kycProviders [ msg.sender ]; } } Security Considerations \u00b6 Access Control \u00b6 Template Creation : Restrict template registration to authorized users Deployment Permissions : Control who can deploy identities Key Management : Secure initial key setup Registry Integration : Validate registry interactions Identity Security \u00b6 Key Validation : Validate all provided keys Trusted Issuer Verification : Verify trusted issuer addresses Initialization Safety : Ensure secure initialization process Ownership Transfer : Secure ownership assignment Factory Security \u00b6 Template Validation : Validate template implementations Implementation Security : Ensure implementation contract security Upgrade Safety : Consider factory upgrade mechanisms Event Logging : Log all deployments for auditing Best Practices \u00b6 Template Design \u00b6 Standard Compliance : Ensure ERC-734/735 compliance Modular Design : Create reusable template components Security Audits : Audit all template implementations Documentation : Document template capabilities Factory Management \u00b6 Access Controls : Implement proper access controls Template Validation : Validate all template configurations Event Logging : Log all deployments and changes Upgrade Planning : Plan for factory upgrades Identity Deployment \u00b6 Key Management : Secure key generation and storage Registry Integration : Integrate with identity registries Claim Setup : Setup initial claims and trusted issuers Governance : Consider governance mechanisms Related Documentation \u00b6 ERC-734 Interface ERC-735 Interface Identity Registry Facet Trusted Issuers Registry Facet Identity System Guide KYC Integration Guide Standards Compliance \u00b6 ERC-734 : Key Manager Standard ERC-735 : Claim Holder Standard EIP-1167 : Minimal Proxy Standard EIP-1014 : CREATE2 for deterministic addresses Factory Pattern : Standard factory design patterns","title":"Identity Factory"},{"location":"smart-contracts/identity-factory/#identity-factory","text":"The Identity Factory is a specialized contract deployment system for creating ERC-734/ERC-735 compliant identity contracts. It provides standardized deployment of identity contracts with key management and claim verification capabilities.","title":"Identity Factory"},{"location":"smart-contracts/identity-factory/#overview","text":"The Identity Factory provides: Identity Deployment : Deploy ERC-734/ERC-735 identity contracts Key Management Setup : Initialize identity contracts with management keys Claim Integration : Setup trusted issuer relationships Registry Integration : Automatic registration with identity registries Template Management : Manage different identity contract templates","title":"Overview"},{"location":"smart-contracts/identity-factory/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/identity-factory/#identity-contract-deployment","text":"ERC-734 Compliance : Deploy key manager compliant contracts ERC-735 Compliance : Deploy claim holder compliant contracts Combined Implementation : Deploy contracts supporting both standards Custom Configuration : Support custom identity configurations","title":"Identity Contract Deployment"},{"location":"smart-contracts/identity-factory/#key-management-integration","text":"Management Keys : Setup initial management keys Action Keys : Configure action-specific keys Claim Keys : Setup claim signing keys Encryption Keys : Configure encryption capabilities","title":"Key Management Integration"},{"location":"smart-contracts/identity-factory/#registry-integration","text":"Automatic Registration : Register identities with central registry Trusted Issuer Setup : Configure trusted issuer relationships Claim Verification : Setup claim verification mechanisms Identity Linking : Link identities to external systems","title":"Registry Integration"},{"location":"smart-contracts/identity-factory/#core-interface","text":"interface IIdentityFactory { struct IdentityConfig { address owner ; bytes32 [] managementKeys ; bytes32 [] actionKeys ; bytes32 [] claimKeys ; address [] trustedIssuers ; bool registerWithRegistry ; } struct IdentityTemplate { string name ; string version ; address implementation ; bytes initCode ; bool active ; } event IdentityDeployed ( address indexed identity , address indexed owner , string templateName ); event TemplateRegistered ( string indexed name , string version , address implementation ); function deployIdentity ( string calldata templateName , IdentityConfig calldata config ) external returns ( address identity ); function registerTemplate ( IdentityTemplate calldata template ) external ; function getTemplate ( string calldata name ) external view returns ( IdentityTemplate memory ); function predictIdentityAddress ( string calldata templateName , IdentityConfig calldata config ) external view returns ( address ); }","title":"Core Interface"},{"location":"smart-contracts/identity-factory/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/identity-factory/#deployidentity","text":"Deploys a new identity contract using a registered template. Parameters: - templateName : Name of the template to use - config : Identity configuration including keys and settings Returns: - address : Address of the deployed identity contract Usage: IIdentityFactory . IdentityConfig memory config = IIdentityFactory . IdentityConfig ({ owner : msg.sender , managementKeys : [ keccak256 ( abi . encodePacked ( msg.sender ))], actionKeys : [ keccak256 ( abi . encodePacked ( actionKey ))], claimKeys : [ keccak256 ( abi . encodePacked ( claimKey ))], trustedIssuers : [ trustedIssuerAddress ], registerWithRegistry : true }); address identity = IIdentityFactory ( factory ). deployIdentity ( \"StandardIdentity\" , config );","title":"deployIdentity()"},{"location":"smart-contracts/identity-factory/#registertemplate","text":"Registers a new identity template for deployment. Parameters: - template : Template configuration including implementation and initialization Access Control: - Restricted to authorized template creators","title":"registerTemplate()"},{"location":"smart-contracts/identity-factory/#predictidentityaddress","text":"Predicts the address of an identity contract before deployment. Parameters: - templateName : Name of the template - config : Identity configuration Returns: - address : Predicted identity address","title":"predictIdentityAddress()"},{"location":"smart-contracts/identity-factory/#implementation-example","text":"","title":"Implementation Example"},{"location":"smart-contracts/identity-factory/#basic-identity-factory","text":"contract IdentityFactory is IIdentityFactory { using Clones for address ; mapping ( string => IdentityTemplate ) private templates ; mapping ( address => bool ) public templateCreators ; address public identityRegistry ; modifier onlyTemplateCreator () { require ( templateCreators [ msg.sender ] || msg.sender == owner (), \"Not authorized\" ); _ ; } function deployIdentity ( string calldata templateName , IdentityConfig calldata config ) external override returns ( address identity ) { IdentityTemplate memory template = templates [ templateName ]; require ( template . active , \"Template not active\" ); require ( config . owner != address ( 0 ), \"Invalid owner\" ); // Deploy identity using minimal proxy pattern bytes32 salt = keccak256 ( abi . encodePacked ( config . owner , block.timestamp )); identity = template . implementation . cloneDeterministic ( salt ); // Initialize identity with configuration _initializeIdentity ( identity , config , template ); // Register with identity registry if requested if ( config . registerWithRegistry && identityRegistry != address ( 0 )) { IIdentityRegistry ( identityRegistry ). registerIdentity ( identity , config . owner ); } emit IdentityDeployed ( identity , config . owner , templateName ); } function _initializeIdentity ( address identity , IdentityConfig memory config , IdentityTemplate memory template ) internal { // Initialize with template-specific logic if ( template . initCode . length > 0 ) { ( bool success ,) = identity . call ( abi . encodePacked ( template . initCode , abi . encode ( config )) ); require ( success , \"Identity initialization failed\" ); } // Setup management keys for ( uint i = 0 ; i < config . managementKeys . length ; i ++ ) { IERC734 ( identity ). addKey ( config . managementKeys [ i ], 1 , // MANAGEMENT purpose 1 // ECDSA key type ); } // Setup action keys for ( uint i = 0 ; i < config . actionKeys . length ; i ++ ) { IERC734 ( identity ). addKey ( config . actionKeys [ i ], 2 , // ACTION purpose 1 // ECDSA key type ); } // Setup claim keys for ( uint i = 0 ; i < config . claimKeys . length ; i ++ ) { IERC734 ( identity ). addKey ( config . claimKeys [ i ], 3 , // CLAIM purpose 1 // ECDSA key type ); } // Setup trusted issuers for ( uint i = 0 ; i < config . trustedIssuers . length ; i ++ ) { IERC735 ( identity ). addTrustedIssuer ( config . trustedIssuers [ i ]); } } }","title":"Basic Identity Factory"},{"location":"smart-contracts/identity-factory/#advanced-identity-factory-with-governance","text":"contract GovernanceIdentityFactory { struct GovernanceConfig { uint256 requiredApprovals ; address [] governors ; uint256 votingPeriod ; } mapping ( address => GovernanceConfig ) public identityGovernance ; function deployGovernedIdentity ( string calldata templateName , IdentityConfig calldata config , GovernanceConfig calldata governance ) external returns ( address identity ) { identity = deployIdentity ( templateName , config ); // Setup governance structure identityGovernance [ identity ] = governance ; // Initialize governance contract address governanceContract = _deployGovernanceContract ( identity , governance ); // Transfer identity ownership to governance contract IOwnable ( identity ). transferOwnership ( governanceContract ); emit GovernedIdentityDeployed ( identity , governanceContract ); } function _deployGovernanceContract ( address identity , GovernanceConfig memory config ) internal returns ( address governance ) { // Deploy governance contract for the identity governance = Clones . clone ( governanceImplementation ); IGovernance ( governance ). initialize ( identity , config . governors , config . requiredApprovals , config . votingPeriod ); } }","title":"Advanced Identity Factory with Governance"},{"location":"smart-contracts/identity-factory/#template-patterns","text":"","title":"Template Patterns"},{"location":"smart-contracts/identity-factory/#standard-identity-template","text":"function createStandardIdentityTemplate () internal pure returns ( IdentityTemplate memory ) { return IdentityTemplate ({ name : \"StandardIdentity\" , version : \"1.0.0\" , implementation : standardIdentityImplementation , initCode : abi . encodeWithSignature ( \"initialize(address)\" , address ( 0 )), active : true }); }","title":"Standard Identity Template"},{"location":"smart-contracts/identity-factory/#corporate-identity-template","text":"function createCorporateIdentityTemplate () internal pure returns ( IdentityTemplate memory ) { return IdentityTemplate ({ name : \"CorporateIdentity\" , version : \"1.0.0\" , implementation : corporateIdentityImplementation , initCode : abi . encodeWithSignature ( \"initializeCorporate(address,string,string)\" , address ( 0 ), \"\" , \"\" ), active : true }); }","title":"Corporate Identity Template"},{"location":"smart-contracts/identity-factory/#multi-signature-identity-template","text":"function createMultiSigIdentityTemplate () internal pure returns ( IdentityTemplate memory ) { return IdentityTemplate ({ name : \"MultiSigIdentity\" , version : \"1.0.0\" , implementation : multiSigIdentityImplementation , initCode : abi . encodeWithSignature ( \"initializeMultiSig(address[],uint256)\" , new address []( 0 ), 0 ), active : true }); }","title":"Multi-Signature Identity Template"},{"location":"smart-contracts/identity-factory/#integration-patterns","text":"","title":"Integration Patterns"},{"location":"smart-contracts/identity-factory/#registry-integration_1","text":"contract IdentityRegistryIntegration { address public identityRegistry ; address public trustedIssuersRegistry ; function deployWithRegistration ( string calldata templateName , IdentityConfig calldata config ) external returns ( address identity ) { // Deploy identity identity = deployIdentity ( templateName , config ); // Register with identity registry IIdentityRegistry ( identityRegistry ). registerIdentity ( identity , config . owner ); // Setup trusted issuer relationships for ( uint i = 0 ; i < config . trustedIssuers . length ; i ++ ) { ITrustedIssuersRegistry ( trustedIssuersRegistry ). addTrustedIssuer ( identity , config . trustedIssuers [ i ] ); } emit IdentityRegistered ( identity , config . owner ); } }","title":"Registry Integration"},{"location":"smart-contracts/identity-factory/#kyc-integration","text":"contract KYCIdentityFactory { mapping ( address => bool ) public kycProviders ; function deployKYCIdentity ( string calldata templateName , IdentityConfig calldata config , bytes calldata kycProof ) external returns ( address identity ) { // Verify KYC proof require ( _verifyKYCProof ( config . owner , kycProof ), \"Invalid KYC proof\" ); // Deploy identity with KYC claim identity = deployIdentity ( templateName , config ); // Add KYC claim bytes32 claimId = keccak256 ( \"KYC_VERIFIED\" ); IERC735 ( identity ). addClaim ( claimId , 1 , // KYC claim type msg.sender , // issuer kycProof , \"\" , // claim data \"\" // URI ); emit KYCIdentityDeployed ( identity , config . owner ); } function _verifyKYCProof ( address user , bytes memory proof ) internal view returns ( bool ) { // Implement KYC proof verification logic return kycProviders [ msg.sender ]; } }","title":"KYC Integration"},{"location":"smart-contracts/identity-factory/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/identity-factory/#access-control","text":"Template Creation : Restrict template registration to authorized users Deployment Permissions : Control who can deploy identities Key Management : Secure initial key setup Registry Integration : Validate registry interactions","title":"Access Control"},{"location":"smart-contracts/identity-factory/#identity-security","text":"Key Validation : Validate all provided keys Trusted Issuer Verification : Verify trusted issuer addresses Initialization Safety : Ensure secure initialization process Ownership Transfer : Secure ownership assignment","title":"Identity Security"},{"location":"smart-contracts/identity-factory/#factory-security","text":"Template Validation : Validate template implementations Implementation Security : Ensure implementation contract security Upgrade Safety : Consider factory upgrade mechanisms Event Logging : Log all deployments for auditing","title":"Factory Security"},{"location":"smart-contracts/identity-factory/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/identity-factory/#template-design","text":"Standard Compliance : Ensure ERC-734/735 compliance Modular Design : Create reusable template components Security Audits : Audit all template implementations Documentation : Document template capabilities","title":"Template Design"},{"location":"smart-contracts/identity-factory/#factory-management","text":"Access Controls : Implement proper access controls Template Validation : Validate all template configurations Event Logging : Log all deployments and changes Upgrade Planning : Plan for factory upgrades","title":"Factory Management"},{"location":"smart-contracts/identity-factory/#identity-deployment","text":"Key Management : Secure key generation and storage Registry Integration : Integrate with identity registries Claim Setup : Setup initial claims and trusted issuers Governance : Consider governance mechanisms","title":"Identity Deployment"},{"location":"smart-contracts/identity-factory/#related-documentation","text":"ERC-734 Interface ERC-735 Interface Identity Registry Facet Trusted Issuers Registry Facet Identity System Guide KYC Integration Guide","title":"Related Documentation"},{"location":"smart-contracts/identity-factory/#standards-compliance","text":"ERC-734 : Key Manager Standard ERC-735 : Claim Holder Standard EIP-1167 : Minimal Proxy Standard EIP-1014 : CREATE2 for deterministic addresses Factory Pattern : Standard factory design patterns","title":"Standards Compliance"},{"location":"smart-contracts/facets/carbon-credit-facet/","text":"CarbonCreditFacet \u00b6 Overview \u00b6 The CarbonCreditFacet.sol provides comprehensive carbon credit management functionality for ERC721 tokens within the Gemforce diamond system. This facet enables the tokenization, tracking, and retirement of environmental assets, supporting carbon offset programs and environmental sustainability initiatives. Contract Details \u00b6 Contract Name : CarbonCreditFacet Inheritance : ICarbonCredit , Modifiers License : MIT Solidity Version : ^0.8.0 Key Features \u00b6 \ud83d\udd39 Carbon Credit Lifecycle Management \u00b6 Initialize carbon credit balances for NFTs Track available credits per token Permanent retirement of credits for offsetting Comprehensive status tracking \ud83d\udd39 ERC721 Integration \u00b6 Carbon credits attached to specific NFT tokens Owner-only retirement permissions Token existence validation Seamless integration with existing NFT infrastructure \ud83d\udd39 Batch Operations \u00b6 Efficient batch initialization for multiple tokens Bulk balance queries Gas-optimized operations for large-scale deployments \ud83d\udd39 Environmental Compliance \u00b6 Permanent retirement prevents double-counting Transparent tracking for audit purposes Status reporting for compliance verification Core Data Structures \u00b6 CarbonCreditStatus Enum \u00b6 enum CarbonCreditStatus { NONE , // Token has no carbon credits initialized ACTIVE , // Token has available carbon credits RETIRED // All carbon credits have been retired } Storage Pattern \u00b6 The facet uses the CarbonCreditLib library for storage management: - Diamond storage pattern prevents storage collisions - Efficient mapping of token IDs to credit balances - Persistent storage across contract upgrades Core Functions \u00b6 Initialization Functions \u00b6 initializeCarbonCredit() \u00b6 function initializeCarbonCredit ( uint256 tokenId , uint256 initialBalance ) external onlyOwner Purpose : Initializes carbon credit balance for a specific ERC721 token. Parameters : - tokenId (uint256): ID of the ERC721 token to initialize - initialBalance (uint256): Initial carbon credit balance (must be > 0) Access Control : Owner only Validation : - Token ID must be greater than zero - Initial balance must be greater than zero - Token must exist (have a valid owner) - Token must not already have carbon credits initialized Process : 1. Validates input parameters 2. Checks token existence via ERC721 interface 3. Ensures token hasn't been previously initialized 4. Sets initial carbon credit balance 5. Emits CarbonCreditsInitialized event Events : CarbonCreditsInitialized(tokenId, initialBalance) Example Usage : // Initialize carbon credits for a newly minted environmental NFT ICarbonCredit ( diamond ). initializeCarbonCredit ( tokenId , 1000 // 1000 carbon credits ); Error Conditions : - \"CARBON_CREDIT: INVALID_TOKEN_ID\" - Token ID is zero - \"CARBON_CREDIT: INVALID_BALANCE\" - Initial balance is zero - \"CARBON_CREDIT: NONEXISTENT_TOKEN\" - Token doesn't exist - \"CARBON_CREDIT: ALREADY_INITIALIZED\" - Token already has credits batchInitializeCarbonCredits() \u00b6 function batchInitializeCarbonCredits ( uint256 [] calldata tokenIds , uint256 [] calldata initialBalances ) external onlyOwner Purpose : Efficiently initializes carbon credits for multiple tokens in a single transaction. Parameters : - tokenIds (uint256[]): Array of token IDs to initialize - initialBalances (uint256[]): Array of initial balances corresponding to token IDs Access Control : Owner only Validation : - Arrays must have equal length - Each token must exist - Standard initialization validation for each token Gas Optimization : More efficient than multiple individual calls Example Usage : // Batch initialize multiple environmental NFTs uint256 [] memory tokenIds = [ 1 , 2 , 3 , 4 , 5 ]; uint256 [] memory balances = [ 1000 , 1500 , 800 , 1200 , 900 ]; ICarbonCredit ( diamond ). batchInitializeCarbonCredits ( tokenIds , balances ); Credit Management Functions \u00b6 retireCarbonCredits() \u00b6 function retireCarbonCredits ( uint256 tokenId , uint256 amount ) external onlyTokenOwner ( tokenId ) Purpose : Permanently retires carbon credits, representing their use for carbon offsetting. Parameters : - tokenId (uint256): ID of the ERC721 token - amount (uint256): Amount of carbon credits to retire Access Control : Token owner only Validation : - Token ID must be greater than zero - Amount must be greater than zero - Token must have sufficient credit balance Process : 1. Validates input parameters 2. Checks current credit balance 3. Ensures sufficient credits available 4. Permanently reduces credit balance 5. Emits retirement event with remaining balance Events : CarbonCreditsRetired(tokenId, amount, remainingBalance) Example Usage : // Retire 100 carbon credits for offsetting ICarbonCredit ( diamond ). retireCarbonCredits ( tokenId , 100 ); Important : Retired credits cannot be recovered or reused. Query Functions \u00b6 getCarbonCreditBalance() \u00b6 function getCarbonCreditBalance ( uint256 tokenId ) external view returns ( uint256 ) Purpose : Returns the current available carbon credit balance for a token. Parameters : - tokenId (uint256): ID of the ERC721 token Returns : Current carbon credit balance (0 if not initialized) Example Usage : uint256 balance = ICarbonCredit ( diamond ). getCarbonCreditBalance ( tokenId ); console . log ( \"Available credits:\" , balance ); getCarbonCreditStatus() \u00b6 function getCarbonCreditStatus ( uint256 tokenId ) external view returns ( CarbonCreditStatus ) Purpose : Returns the carbon credit status for a token. Parameters : - tokenId (uint256): ID of the ERC721 token Returns : CarbonCreditStatus enum value - NONE : No credits initialized - ACTIVE : Credits available for retirement - RETIRED : All credits have been retired Example Usage : CarbonCreditStatus status = ICarbonCredit ( diamond ). getCarbonCreditStatus ( tokenId ); if ( status == CarbonCreditStatus . ACTIVE ) { // Credits available for retirement } else if ( status == CarbonCreditStatus . RETIRED ) { // All credits have been used } getAllCarbonCreditBalances() \u00b6 function getAllCarbonCreditBalances ( uint256 [] calldata tokenIds ) external view returns ( uint256 [] memory ) Purpose : Efficiently retrieves carbon credit balances for multiple tokens. Parameters : - tokenIds (uint256[]): Array of token IDs to query Returns : Array of balances in the same order as input token IDs Gas Optimization : Single call instead of multiple individual queries Example Usage : uint256 [] memory tokenIds = [ 1 , 2 , 3 , 4 , 5 ]; uint256 [] memory balances = ICarbonCredit ( diamond ). getAllCarbonCreditBalances ( tokenIds ); for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { console . log ( \"Token\" , tokenIds [ i ], \"has\" , balances [ i ], \"credits\" ); } Events \u00b6 CarbonCreditsInitialized \u00b6 event CarbonCreditsInitialized ( uint256 indexed tokenId , uint256 initialBalance ); Emitted when carbon credits are initialized for a token. CarbonCreditsRetired \u00b6 event CarbonCreditsRetired ( uint256 indexed tokenId , uint256 amount , uint256 remainingBalance ); Emitted when carbon credits are retired, including the remaining balance. Integration Examples \u00b6 Environmental NFT Marketplace \u00b6 // 1. Mint environmental asset NFT uint256 tokenId = IEnvironmentalNFT ( diamond ). mint ( recipient , \"Forest Conservation Project #1\" , metadataURI ); // 2. Initialize with carbon credits ICarbonCredit ( diamond ). initializeCarbonCredit ( tokenId , 5000 ); // 3. List on marketplace IMarketplace ( diamond ). listItem ( address ( 0 ), payable ( seller ), tokenId , 1 ether , false , address ( 0 ) ); Carbon Offset Program \u00b6 // User purchases environmental NFT and retires credits for offsetting function offsetCarbonFootprint ( uint256 tokenId , uint256 offsetAmount ) external { // Verify user owns the token require ( IERC721 ( diamond ). ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); // Check available credits uint256 available = ICarbonCredit ( diamond ). getCarbonCreditBalance ( tokenId ); require ( available >= offsetAmount , \"Insufficient credits\" ); // Retire credits for offsetting ICarbonCredit ( diamond ). retireCarbonCredits ( tokenId , offsetAmount ); // Record offset in external system emit CarbonFootprintOffset ( msg.sender , tokenId , offsetAmount ); } Batch Environmental Asset Management \u00b6 // Deploy multiple environmental projects function deployEnvironmentalProjects ( string [] memory projectNames , uint256 [] memory creditAmounts ) external onlyOwner { uint256 [] memory tokenIds = new uint256 []( projectNames . length ); // Mint NFTs for each project for ( uint256 i = 0 ; i < projectNames . length ; i ++ ) { tokenIds [ i ] = IEnvironmentalNFT ( diamond ). mint ( address ( this ), projectNames [ i ], generateMetadataURI ( projectNames [ i ]) ); } // Batch initialize carbon credits ICarbonCredit ( diamond ). batchInitializeCarbonCredits ( tokenIds , creditAmounts ); } Portfolio Tracking \u00b6 // Track carbon credit portfolio function getPortfolioStatus ( address owner ) external view returns ( uint256 [] memory tokenIds , uint256 [] memory balances , CarbonCreditStatus [] memory statuses ) { // Get all tokens owned by user tokenIds = getTokensByOwner ( owner ); // Get balances for all tokens balances = ICarbonCredit ( diamond ). getAllCarbonCreditBalances ( tokenIds ); // Get status for each token statuses = new CarbonCreditStatus []( tokenIds . length ); for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { statuses [ i ] = ICarbonCredit ( diamond ). getCarbonCreditStatus ( tokenIds [ i ]); } } Environmental Standards Compliance \u00b6 International Standards \u00b6 The carbon credit system supports compliance with: - Verified Carbon Standard (VCS) - Clean Development Mechanism (CDM) - Gold Standard - Climate Action Reserve (CAR) Audit Trail \u00b6 All initialization events are permanently recorded Retirement events provide complete audit trail Status tracking enables compliance verification Immutable blockchain records prevent tampering Double-Counting Prevention \u00b6 Credits can only be retired once No transfer of retired credits Permanent reduction in available balance Clear status indication for auditors Security Considerations \u00b6 Access Control \u00b6 Only contract owner can initialize credits Only token owner can retire credits Token existence validation prevents invalid operations Data Integrity \u00b6 Diamond storage pattern prevents storage collisions Immutable retirement records Overflow protection in arithmetic operations Audit Compliance \u00b6 Complete event logging for all operations Transparent balance tracking Status verification for compliance reporting Gas Optimization \u00b6 Batch Operations \u00b6 batchInitializeCarbonCredits() for efficient initialization getAllCarbonCreditBalances() for bulk queries Reduced transaction costs for large-scale operations Storage Efficiency \u00b6 Efficient mapping structures in CarbonCreditLib Minimal storage footprint per token Optimized for frequent read operations Error Handling \u00b6 Validation Errors \u00b6 \"CARBON_CREDIT: INVALID_TOKEN_ID\" - Invalid token ID \"CARBON_CREDIT: INVALID_BALANCE\" - Invalid balance amount \"CARBON_CREDIT: INVALID_AMOUNT\" - Invalid retirement amount State Errors \u00b6 \"CARBON_CREDIT: NONEXISTENT_TOKEN\" - Token doesn't exist \"CARBON_CREDIT: ALREADY_INITIALIZED\" - Token already has credits \"CARBON_CREDIT: INSUFFICIENT_BALANCE\" - Not enough credits to retire Access Errors \u00b6 \"Only token owner can call this function\" - Unauthorized retirement attempt Testing Considerations \u00b6 Unit Tests \u00b6 Credit initialization with various amounts Retirement operations and balance updates Status transitions and validation Batch operation efficiency Integration Tests \u00b6 NFT marketplace integration Multi-token portfolio management Environmental compliance workflows Audit trail verification Related Documentation \u00b6 ICarbonCredit - Carbon credit interface CarbonCreditLib - Carbon credit utility library EIP-DRAFT-Carbon-Credit-Standard - EIP specification Environmental Asset Guide - Implementation guide This facet implements the Carbon Credit Standard as defined in the Gemforce EIP suite, enabling comprehensive environmental asset management on the blockchain.","title":"Carbon Credit Facet"},{"location":"smart-contracts/facets/carbon-credit-facet/#carboncreditfacet","text":"","title":"CarbonCreditFacet"},{"location":"smart-contracts/facets/carbon-credit-facet/#overview","text":"The CarbonCreditFacet.sol provides comprehensive carbon credit management functionality for ERC721 tokens within the Gemforce diamond system. This facet enables the tokenization, tracking, and retirement of environmental assets, supporting carbon offset programs and environmental sustainability initiatives.","title":"Overview"},{"location":"smart-contracts/facets/carbon-credit-facet/#contract-details","text":"Contract Name : CarbonCreditFacet Inheritance : ICarbonCredit , Modifiers License : MIT Solidity Version : ^0.8.0","title":"Contract Details"},{"location":"smart-contracts/facets/carbon-credit-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/carbon-credit-facet/#carbon-credit-lifecycle-management","text":"Initialize carbon credit balances for NFTs Track available credits per token Permanent retirement of credits for offsetting Comprehensive status tracking","title":"\ud83d\udd39 Carbon Credit Lifecycle Management"},{"location":"smart-contracts/facets/carbon-credit-facet/#erc721-integration","text":"Carbon credits attached to specific NFT tokens Owner-only retirement permissions Token existence validation Seamless integration with existing NFT infrastructure","title":"\ud83d\udd39 ERC721 Integration"},{"location":"smart-contracts/facets/carbon-credit-facet/#batch-operations","text":"Efficient batch initialization for multiple tokens Bulk balance queries Gas-optimized operations for large-scale deployments","title":"\ud83d\udd39 Batch Operations"},{"location":"smart-contracts/facets/carbon-credit-facet/#environmental-compliance","text":"Permanent retirement prevents double-counting Transparent tracking for audit purposes Status reporting for compliance verification","title":"\ud83d\udd39 Environmental Compliance"},{"location":"smart-contracts/facets/carbon-credit-facet/#core-data-structures","text":"","title":"Core Data Structures"},{"location":"smart-contracts/facets/carbon-credit-facet/#carboncreditstatus-enum","text":"enum CarbonCreditStatus { NONE , // Token has no carbon credits initialized ACTIVE , // Token has available carbon credits RETIRED // All carbon credits have been retired }","title":"CarbonCreditStatus Enum"},{"location":"smart-contracts/facets/carbon-credit-facet/#storage-pattern","text":"The facet uses the CarbonCreditLib library for storage management: - Diamond storage pattern prevents storage collisions - Efficient mapping of token IDs to credit balances - Persistent storage across contract upgrades","title":"Storage Pattern"},{"location":"smart-contracts/facets/carbon-credit-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/carbon-credit-facet/#initialization-functions","text":"","title":"Initialization Functions"},{"location":"smart-contracts/facets/carbon-credit-facet/#initializecarboncredit","text":"function initializeCarbonCredit ( uint256 tokenId , uint256 initialBalance ) external onlyOwner Purpose : Initializes carbon credit balance for a specific ERC721 token. Parameters : - tokenId (uint256): ID of the ERC721 token to initialize - initialBalance (uint256): Initial carbon credit balance (must be > 0) Access Control : Owner only Validation : - Token ID must be greater than zero - Initial balance must be greater than zero - Token must exist (have a valid owner) - Token must not already have carbon credits initialized Process : 1. Validates input parameters 2. Checks token existence via ERC721 interface 3. Ensures token hasn't been previously initialized 4. Sets initial carbon credit balance 5. Emits CarbonCreditsInitialized event Events : CarbonCreditsInitialized(tokenId, initialBalance) Example Usage : // Initialize carbon credits for a newly minted environmental NFT ICarbonCredit ( diamond ). initializeCarbonCredit ( tokenId , 1000 // 1000 carbon credits ); Error Conditions : - \"CARBON_CREDIT: INVALID_TOKEN_ID\" - Token ID is zero - \"CARBON_CREDIT: INVALID_BALANCE\" - Initial balance is zero - \"CARBON_CREDIT: NONEXISTENT_TOKEN\" - Token doesn't exist - \"CARBON_CREDIT: ALREADY_INITIALIZED\" - Token already has credits","title":"initializeCarbonCredit()"},{"location":"smart-contracts/facets/carbon-credit-facet/#batchinitializecarboncredits","text":"function batchInitializeCarbonCredits ( uint256 [] calldata tokenIds , uint256 [] calldata initialBalances ) external onlyOwner Purpose : Efficiently initializes carbon credits for multiple tokens in a single transaction. Parameters : - tokenIds (uint256[]): Array of token IDs to initialize - initialBalances (uint256[]): Array of initial balances corresponding to token IDs Access Control : Owner only Validation : - Arrays must have equal length - Each token must exist - Standard initialization validation for each token Gas Optimization : More efficient than multiple individual calls Example Usage : // Batch initialize multiple environmental NFTs uint256 [] memory tokenIds = [ 1 , 2 , 3 , 4 , 5 ]; uint256 [] memory balances = [ 1000 , 1500 , 800 , 1200 , 900 ]; ICarbonCredit ( diamond ). batchInitializeCarbonCredits ( tokenIds , balances );","title":"batchInitializeCarbonCredits()"},{"location":"smart-contracts/facets/carbon-credit-facet/#credit-management-functions","text":"","title":"Credit Management Functions"},{"location":"smart-contracts/facets/carbon-credit-facet/#retirecarboncredits","text":"function retireCarbonCredits ( uint256 tokenId , uint256 amount ) external onlyTokenOwner ( tokenId ) Purpose : Permanently retires carbon credits, representing their use for carbon offsetting. Parameters : - tokenId (uint256): ID of the ERC721 token - amount (uint256): Amount of carbon credits to retire Access Control : Token owner only Validation : - Token ID must be greater than zero - Amount must be greater than zero - Token must have sufficient credit balance Process : 1. Validates input parameters 2. Checks current credit balance 3. Ensures sufficient credits available 4. Permanently reduces credit balance 5. Emits retirement event with remaining balance Events : CarbonCreditsRetired(tokenId, amount, remainingBalance) Example Usage : // Retire 100 carbon credits for offsetting ICarbonCredit ( diamond ). retireCarbonCredits ( tokenId , 100 ); Important : Retired credits cannot be recovered or reused.","title":"retireCarbonCredits()"},{"location":"smart-contracts/facets/carbon-credit-facet/#query-functions","text":"","title":"Query Functions"},{"location":"smart-contracts/facets/carbon-credit-facet/#getcarboncreditbalance","text":"function getCarbonCreditBalance ( uint256 tokenId ) external view returns ( uint256 ) Purpose : Returns the current available carbon credit balance for a token. Parameters : - tokenId (uint256): ID of the ERC721 token Returns : Current carbon credit balance (0 if not initialized) Example Usage : uint256 balance = ICarbonCredit ( diamond ). getCarbonCreditBalance ( tokenId ); console . log ( \"Available credits:\" , balance );","title":"getCarbonCreditBalance()"},{"location":"smart-contracts/facets/carbon-credit-facet/#getcarboncreditstatus","text":"function getCarbonCreditStatus ( uint256 tokenId ) external view returns ( CarbonCreditStatus ) Purpose : Returns the carbon credit status for a token. Parameters : - tokenId (uint256): ID of the ERC721 token Returns : CarbonCreditStatus enum value - NONE : No credits initialized - ACTIVE : Credits available for retirement - RETIRED : All credits have been retired Example Usage : CarbonCreditStatus status = ICarbonCredit ( diamond ). getCarbonCreditStatus ( tokenId ); if ( status == CarbonCreditStatus . ACTIVE ) { // Credits available for retirement } else if ( status == CarbonCreditStatus . RETIRED ) { // All credits have been used }","title":"getCarbonCreditStatus()"},{"location":"smart-contracts/facets/carbon-credit-facet/#getallcarboncreditbalances","text":"function getAllCarbonCreditBalances ( uint256 [] calldata tokenIds ) external view returns ( uint256 [] memory ) Purpose : Efficiently retrieves carbon credit balances for multiple tokens. Parameters : - tokenIds (uint256[]): Array of token IDs to query Returns : Array of balances in the same order as input token IDs Gas Optimization : Single call instead of multiple individual queries Example Usage : uint256 [] memory tokenIds = [ 1 , 2 , 3 , 4 , 5 ]; uint256 [] memory balances = ICarbonCredit ( diamond ). getAllCarbonCreditBalances ( tokenIds ); for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { console . log ( \"Token\" , tokenIds [ i ], \"has\" , balances [ i ], \"credits\" ); }","title":"getAllCarbonCreditBalances()"},{"location":"smart-contracts/facets/carbon-credit-facet/#events","text":"","title":"Events"},{"location":"smart-contracts/facets/carbon-credit-facet/#carboncreditsinitialized","text":"event CarbonCreditsInitialized ( uint256 indexed tokenId , uint256 initialBalance ); Emitted when carbon credits are initialized for a token.","title":"CarbonCreditsInitialized"},{"location":"smart-contracts/facets/carbon-credit-facet/#carboncreditsretired","text":"event CarbonCreditsRetired ( uint256 indexed tokenId , uint256 amount , uint256 remainingBalance ); Emitted when carbon credits are retired, including the remaining balance.","title":"CarbonCreditsRetired"},{"location":"smart-contracts/facets/carbon-credit-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/facets/carbon-credit-facet/#environmental-nft-marketplace","text":"// 1. Mint environmental asset NFT uint256 tokenId = IEnvironmentalNFT ( diamond ). mint ( recipient , \"Forest Conservation Project #1\" , metadataURI ); // 2. Initialize with carbon credits ICarbonCredit ( diamond ). initializeCarbonCredit ( tokenId , 5000 ); // 3. List on marketplace IMarketplace ( diamond ). listItem ( address ( 0 ), payable ( seller ), tokenId , 1 ether , false , address ( 0 ) );","title":"Environmental NFT Marketplace"},{"location":"smart-contracts/facets/carbon-credit-facet/#carbon-offset-program","text":"// User purchases environmental NFT and retires credits for offsetting function offsetCarbonFootprint ( uint256 tokenId , uint256 offsetAmount ) external { // Verify user owns the token require ( IERC721 ( diamond ). ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); // Check available credits uint256 available = ICarbonCredit ( diamond ). getCarbonCreditBalance ( tokenId ); require ( available >= offsetAmount , \"Insufficient credits\" ); // Retire credits for offsetting ICarbonCredit ( diamond ). retireCarbonCredits ( tokenId , offsetAmount ); // Record offset in external system emit CarbonFootprintOffset ( msg.sender , tokenId , offsetAmount ); }","title":"Carbon Offset Program"},{"location":"smart-contracts/facets/carbon-credit-facet/#batch-environmental-asset-management","text":"// Deploy multiple environmental projects function deployEnvironmentalProjects ( string [] memory projectNames , uint256 [] memory creditAmounts ) external onlyOwner { uint256 [] memory tokenIds = new uint256 []( projectNames . length ); // Mint NFTs for each project for ( uint256 i = 0 ; i < projectNames . length ; i ++ ) { tokenIds [ i ] = IEnvironmentalNFT ( diamond ). mint ( address ( this ), projectNames [ i ], generateMetadataURI ( projectNames [ i ]) ); } // Batch initialize carbon credits ICarbonCredit ( diamond ). batchInitializeCarbonCredits ( tokenIds , creditAmounts ); }","title":"Batch Environmental Asset Management"},{"location":"smart-contracts/facets/carbon-credit-facet/#portfolio-tracking","text":"// Track carbon credit portfolio function getPortfolioStatus ( address owner ) external view returns ( uint256 [] memory tokenIds , uint256 [] memory balances , CarbonCreditStatus [] memory statuses ) { // Get all tokens owned by user tokenIds = getTokensByOwner ( owner ); // Get balances for all tokens balances = ICarbonCredit ( diamond ). getAllCarbonCreditBalances ( tokenIds ); // Get status for each token statuses = new CarbonCreditStatus []( tokenIds . length ); for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { statuses [ i ] = ICarbonCredit ( diamond ). getCarbonCreditStatus ( tokenIds [ i ]); } }","title":"Portfolio Tracking"},{"location":"smart-contracts/facets/carbon-credit-facet/#environmental-standards-compliance","text":"","title":"Environmental Standards Compliance"},{"location":"smart-contracts/facets/carbon-credit-facet/#international-standards","text":"The carbon credit system supports compliance with: - Verified Carbon Standard (VCS) - Clean Development Mechanism (CDM) - Gold Standard - Climate Action Reserve (CAR)","title":"International Standards"},{"location":"smart-contracts/facets/carbon-credit-facet/#audit-trail","text":"All initialization events are permanently recorded Retirement events provide complete audit trail Status tracking enables compliance verification Immutable blockchain records prevent tampering","title":"Audit Trail"},{"location":"smart-contracts/facets/carbon-credit-facet/#double-counting-prevention","text":"Credits can only be retired once No transfer of retired credits Permanent reduction in available balance Clear status indication for auditors","title":"Double-Counting Prevention"},{"location":"smart-contracts/facets/carbon-credit-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/carbon-credit-facet/#access-control","text":"Only contract owner can initialize credits Only token owner can retire credits Token existence validation prevents invalid operations","title":"Access Control"},{"location":"smart-contracts/facets/carbon-credit-facet/#data-integrity","text":"Diamond storage pattern prevents storage collisions Immutable retirement records Overflow protection in arithmetic operations","title":"Data Integrity"},{"location":"smart-contracts/facets/carbon-credit-facet/#audit-compliance","text":"Complete event logging for all operations Transparent balance tracking Status verification for compliance reporting","title":"Audit Compliance"},{"location":"smart-contracts/facets/carbon-credit-facet/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/facets/carbon-credit-facet/#batch-operations_1","text":"batchInitializeCarbonCredits() for efficient initialization getAllCarbonCreditBalances() for bulk queries Reduced transaction costs for large-scale operations","title":"Batch Operations"},{"location":"smart-contracts/facets/carbon-credit-facet/#storage-efficiency","text":"Efficient mapping structures in CarbonCreditLib Minimal storage footprint per token Optimized for frequent read operations","title":"Storage Efficiency"},{"location":"smart-contracts/facets/carbon-credit-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/carbon-credit-facet/#validation-errors","text":"\"CARBON_CREDIT: INVALID_TOKEN_ID\" - Invalid token ID \"CARBON_CREDIT: INVALID_BALANCE\" - Invalid balance amount \"CARBON_CREDIT: INVALID_AMOUNT\" - Invalid retirement amount","title":"Validation Errors"},{"location":"smart-contracts/facets/carbon-credit-facet/#state-errors","text":"\"CARBON_CREDIT: NONEXISTENT_TOKEN\" - Token doesn't exist \"CARBON_CREDIT: ALREADY_INITIALIZED\" - Token already has credits \"CARBON_CREDIT: INSUFFICIENT_BALANCE\" - Not enough credits to retire","title":"State Errors"},{"location":"smart-contracts/facets/carbon-credit-facet/#access-errors","text":"\"Only token owner can call this function\" - Unauthorized retirement attempt","title":"Access Errors"},{"location":"smart-contracts/facets/carbon-credit-facet/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/facets/carbon-credit-facet/#unit-tests","text":"Credit initialization with various amounts Retirement operations and balance updates Status transitions and validation Batch operation efficiency","title":"Unit Tests"},{"location":"smart-contracts/facets/carbon-credit-facet/#integration-tests","text":"NFT marketplace integration Multi-token portfolio management Environmental compliance workflows Audit trail verification","title":"Integration Tests"},{"location":"smart-contracts/facets/carbon-credit-facet/#related-documentation","text":"ICarbonCredit - Carbon credit interface CarbonCreditLib - Carbon credit utility library EIP-DRAFT-Carbon-Credit-Standard - EIP specification Environmental Asset Guide - Implementation guide This facet implements the Carbon Credit Standard as defined in the Gemforce EIP suite, enabling comprehensive environmental asset management on the blockchain.","title":"Related Documentation"},{"location":"smart-contracts/facets/collateral-token-factory-facet/","text":"CollateralTokenFactoryFacet \u00b6 Overview \u00b6 The CollateralTokenFactoryFacet.sol provides factory functionality for creating and managing restricted collateral tokens within the Gemforce diamond system. This facet enables the creation of ERC20 tokens that represent collateral positions in trade deals, with built-in transfer restrictions and participant validation. Contract Details \u00b6 Contract Name : CollateralTokenFactoryFacet Inheritance : Modifiers License : MIT Solidity Version : ^0.8.0 Key Features \u00b6 \ud83d\udd39 Factory Pattern Implementation \u00b6 Automated factory deployment and initialization Template-based token creation using proxy patterns Centralized token management and tracking Efficient deployment of multiple token instances \ud83d\udd39 Restricted Collateral Tokens \u00b6 ERC20 tokens with transfer restrictions Trade deal participant validation Configurable restriction enforcement Integration with identity verification systems \ud83d\udd39 Trade Deal Integration \u00b6 One-to-one mapping between trade deals and tokens Automatic token creation for trade deals Participant management integration Collateral position tracking \ud83d\udd39 Administrative Controls \u00b6 Owner-only token creation and configuration Restriction management for existing tokens Factory address management Comprehensive event logging Core Architecture \u00b6 Factory Pattern \u00b6 The facet implements a factory pattern where: - Factory Contract : CollateralTokenFactory manages token creation - Implementation Contract : RestrictedCollateralToken serves as the template - Proxy Pattern : New tokens are created as minimal proxies to save gas - Diamond Integration : Factory is managed through the diamond storage Storage Structure \u00b6 struct CollateralTokenFactoryStorage { address factoryAddress ; // Address of the factory contract mapping ( uint256 => address ) tradeDealToToken ; // Trade deal ID to token address mapping } Token Restrictions \u00b6 Collateral tokens can enforce restrictions on: - Transfer Limitations : Only verified participants can transfer tokens - Participant Validation : Integration with identity verification - Trade Deal Compliance : Tokens tied to specific trade deal rules - Administrative Controls : Owner can enable/disable restrictions Core Functions \u00b6 Initialization Functions \u00b6 CollateralTokenFactoryFacet_init() \u00b6 function CollateralTokenFactoryFacet_init () external Purpose : Initializes the collateral token factory when the facet is added to the diamond. Access Control : Public (with initialization check) Process : 1. Checks that factory hasn't been initialized already 2. Deploys a new RestrictedCollateralToken implementation 3. Creates a CollateralTokenFactory with the implementation 4. Stores the factory address in diamond storage 5. Emits CollateralTokenFactoryInitialized event Events : CollateralTokenFactoryInitialized(factoryAddress) Example Usage : // Called automatically when facet is added to diamond // Or can be called manually if needed ICollateralTokenFactory ( diamond ). CollateralTokenFactoryFacet_init (); console . log ( \"Collateral token factory initialized\" ); Requirements : - Factory must not be already initialized - Caller must have appropriate permissions - Sufficient gas for contract deployments getCollateralTokenFactory() \u00b6 function getCollateralTokenFactory () external view returns ( address ) Purpose : Returns the address of the deployed CollateralTokenFactory contract. Returns : - address : Address of the factory contract Example Usage : address factoryAddress = ICollateralTokenFactory ( diamond ). getCollateralTokenFactory (); console . log ( \"Factory deployed at:\" , factoryAddress ); // Use factory directly if needed CollateralTokenFactory factory = CollateralTokenFactory ( factoryAddress ); Token Creation Functions \u00b6 createCollateralToken() \u00b6 function createCollateralToken ( uint256 _tradeDealId , string memory _name , string memory _symbol , bool _restrictionsEnabled ) external onlyOwner returns ( address ) Purpose : Creates a new restricted collateral token for a specific trade deal. Parameters : - _tradeDealId (uint256): Unique identifier for the trade deal - _name (string): Human-readable name for the token - _symbol (string): Token symbol (typically 3-5 characters) - _restrictionsEnabled (bool): Whether to enforce transfer restrictions Returns : - address : Address of the newly created token contract Access Control : Owner only Process : 1. Validates factory is initialized 2. Checks no token exists for the trade deal ID 3. Calls factory to create new token with specified parameters 4. Stores token address in trade deal mapping 5. Emits CollateralTokenCreated event Events : CollateralTokenCreated(tradeDealId, tokenAddress, name, symbol) Example Usage : // Create collateral token for trade deal uint256 tradeDealId = 1 ; string memory tokenName = \"Trade Deal 1 Collateral\" ; string memory tokenSymbol = \"TD1C\" ; bool restrictionsEnabled = true ; address tokenAddress = ICollateralTokenFactory ( diamond ). createCollateralToken ( tradeDealId , tokenName , tokenSymbol , restrictionsEnabled ); console . log ( \"Created collateral token:\" , tokenAddress ); console . log ( \"For trade deal:\" , tradeDealId ); Token Configuration : - Name : Descriptive name for the collateral token - Symbol : Short identifier for the token - Diamond Address : Set as the token's diamond for integration - Trade Deal ID : Links token to specific trade deal - Restrictions : Controls transfer limitations Error Conditions : - \"factory not set\" - Factory not initialized - \"token already exists for this trade deal\" - Duplicate creation attempt - Access control failures for non-owners Query Functions \u00b6 getCollateralTokenAddress() \u00b6 function getCollateralTokenAddress ( uint256 _tradeDealId ) external view returns ( address ) Purpose : Retrieves the token address for a specific trade deal. Parameters : - _tradeDealId (uint256): ID of the trade deal Returns : - address : Address of the collateral token (zero address if not found) Process : 1. Checks local mapping for token address 2. Falls back to factory lookup if not found locally 3. Returns zero address if token doesn't exist Example Usage : uint256 tradeDealId = 1 ; address tokenAddress = ICollateralTokenFactory ( diamond ). getCollateralTokenAddress ( tradeDealId ); if ( tokenAddress != address ( 0 )) { console . log ( \"Token found:\" , tokenAddress ); // Interact with the token IERC20 collateralToken = IERC20 ( tokenAddress ); uint256 balance = collateralToken . balanceOf ( msg.sender ); console . log ( \"My collateral balance:\" , balance ); } else { console . log ( \"No token found for trade deal:\" , tradeDealId ); } isCollateralTokenParticipant() \u00b6 function isCollateralTokenParticipant ( uint256 _tradeDealId , address _address ) external view returns ( bool ) Purpose : Checks if an address is a verified participant for a trade deal's collateral token. Parameters : - _tradeDealId (uint256): ID of the trade deal - _address (address): Address to check for participation Returns : - bool : True if address is a verified participant Process : 1. Retrieves token address for the trade deal 2. Calls token's participant verification function 3. Returns false if token doesn't exist Example Usage : uint256 tradeDealId = 1 ; address userAddress = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; bool isParticipant = ICollateralTokenFactory ( diamond ). isCollateralTokenParticipant ( tradeDealId , userAddress ); if ( isParticipant ) { console . log ( \"User is verified participant\" ); // Allow token operations } else { console . log ( \"User is not a participant\" ); // Restrict token operations } Administrative Functions \u00b6 setCollateralTokenRestrictions() \u00b6 function setCollateralTokenRestrictions ( uint256 _tradeDealId , bool _restrictionsEnabled ) external onlyOwner Purpose : Enables or disables transfer restrictions for a collateral token. Parameters : - _tradeDealId (uint256): ID of the trade deal - _restrictionsEnabled (bool): Whether to enforce restrictions Access Control : Owner only Process : 1. Retrieves token address for the trade deal 2. Validates token exists 3. Calls token's restriction configuration function 4. Updates restriction status Example Usage : uint256 tradeDealId = 1 ; // Enable restrictions (only participants can transfer) ICollateralTokenFactory ( diamond ). setCollateralTokenRestrictions ( tradeDealId , true ); console . log ( \"Restrictions enabled for trade deal:\" , tradeDealId ); // Later, disable restrictions (open transfers) ICollateralTokenFactory ( diamond ). setCollateralTokenRestrictions ( tradeDealId , false ); console . log ( \"Restrictions disabled for trade deal:\" , tradeDealId ); Use Cases : - Enable Restrictions : During active trade deal phase - Disable Restrictions : After trade deal completion - Compliance Requirements : Based on regulatory needs - Emergency Controls : For security incidents Integration Examples \u00b6 Complete Trade Deal Token Lifecycle \u00b6 // Comprehensive trade deal collateral token management contract TradeDealTokenManager { struct TokenInfo { uint256 tradeDealId ; address tokenAddress ; string name ; string symbol ; bool restrictionsEnabled ; uint256 totalSupply ; uint256 participantCount ; } mapping ( uint256 => TokenInfo ) public tradeDealTokens ; mapping ( address => uint256 []) public userTradeDealIds ; function createTradeDealWithToken ( uint256 tradeDealId , string memory dealName , string memory tokenSymbol , bool initialRestrictions ) external onlyOwner returns ( address tokenAddress ) { // Create collateral token for trade deal string memory tokenName = string ( abi . encodePacked ( dealName , \" Collateral\" )); tokenAddress = ICollateralTokenFactory ( diamond ). createCollateralToken ( tradeDealId , tokenName , tokenSymbol , initialRestrictions ); // Store token information tradeDealTokens [ tradeDealId ] = TokenInfo ({ tradeDealId : tradeDealId , tokenAddress : tokenAddress , name : tokenName , symbol : tokenSymbol , restrictionsEnabled : initialRestrictions , totalSupply : 0 , participantCount : 0 }); emit TradeDealTokenCreated ( tradeDealId , tokenAddress , tokenName , tokenSymbol ); } function addParticipantToTradeDeal ( uint256 tradeDealId , address participant ) external onlyOwner { TokenInfo storage tokenInfo = tradeDealTokens [ tradeDealId ]; require ( tokenInfo . tokenAddress != address ( 0 ), \"Trade deal token not found\" ); // Add participant to trade deal (this would integrate with TradeDealAdminFacet) // ITradeDealAdmin(diamond).addTradeDealParticipant(tradeDealId, participant); // Track user's trade deal participation userTradeDealIds [ participant ]. push ( tradeDealId ); tokenInfo . participantCount ++ ; emit ParticipantAdded ( tradeDealId , participant ); } function updateTokenRestrictions ( uint256 tradeDealId , bool restrictionsEnabled ) external onlyOwner { TokenInfo storage tokenInfo = tradeDealTokens [ tradeDealId ]; require ( tokenInfo . tokenAddress != address ( 0 ), \"Trade deal token not found\" ); // Update restrictions through factory facet ICollateralTokenFactory ( diamond ). setCollateralTokenRestrictions ( tradeDealId , restrictionsEnabled ); // Update local tracking tokenInfo . restrictionsEnabled = restrictionsEnabled ; emit TokenRestrictionsUpdated ( tradeDealId , restrictionsEnabled ); } function getTokenInfo ( uint256 tradeDealId ) external view returns ( TokenInfo memory ) { return tradeDealTokens [ tradeDealId ]; } function getUserTradeDealTokens ( address user ) external view returns ( uint256 [] memory tradeDealIds , address [] memory tokenAddresses , uint256 [] memory balances ) { uint256 [] memory userDeals = userTradeDealIds [ user ]; tradeDealIds = new uint256 []( userDeals . length ); tokenAddresses = new address []( userDeals . length ); balances = new uint256 []( userDeals . length ); for ( uint256 i = 0 ; i < userDeals . length ; i ++ ) { uint256 tradeDealId = userDeals [ i ]; TokenInfo memory tokenInfo = tradeDealTokens [ tradeDealId ]; tradeDealIds [ i ] = tradeDealId ; tokenAddresses [ i ] = tokenInfo . tokenAddress ; if ( tokenInfo . tokenAddress != address ( 0 )) { balances [ i ] = IERC20 ( tokenInfo . tokenAddress ). balanceOf ( user ); } } } } Collateral Token Distribution System \u00b6 // System for distributing collateral tokens to participants contract CollateralTokenDistributor { struct DistributionRecord { uint256 tradeDealId ; address recipient ; uint256 amount ; uint256 timestamp ; string reason ; } mapping ( uint256 => DistributionRecord []) public distributionHistory ; mapping ( uint256 => mapping ( address => uint256 )) public totalDistributed ; function distributeCollateralTokens ( uint256 tradeDealId , address [] memory recipients , uint256 [] memory amounts , string memory reason ) external onlyOwner { require ( recipients . length == amounts . length , \"Array length mismatch\" ); // Get token address address tokenAddress = ICollateralTokenFactory ( diamond ). getCollateralTokenAddress ( tradeDealId ); require ( tokenAddress != address ( 0 ), \"Token not found for trade deal\" ); RestrictedCollateralToken token = RestrictedCollateralToken ( tokenAddress ); for ( uint256 i = 0 ; i < recipients . length ; i ++ ) { address recipient = recipients [ i ]; uint256 amount = amounts [ i ]; // Verify recipient is a participant bool isParticipant = ICollateralTokenFactory ( diamond ). isCollateralTokenParticipant ( tradeDealId , recipient ); require ( isParticipant , \"Recipient is not a trade deal participant\" ); // Mint tokens to recipient token . mint ( recipient , amount ); // Record distribution distributionHistory [ tradeDealId ]. push ( DistributionRecord ({ tradeDealId : tradeDealId , recipient : recipient , amount : amount , timestamp : block.timestamp , reason : reason })); totalDistributed [ tradeDealId ][ recipient ] += amount ; emit CollateralTokensDistributed ( tradeDealId , recipient , amount , reason ); } } function batchDistributeEqual ( uint256 tradeDealId , address [] memory recipients , uint256 totalAmount , string memory reason ) external onlyOwner { require ( recipients . length > 0 , \"No recipients provided\" ); uint256 amountPerRecipient = totalAmount / recipients . length ; uint256 [] memory amounts = new uint256 []( recipients . length ); for ( uint256 i = 0 ; i < recipients . length ; i ++ ) { amounts [ i ] = amountPerRecipient ; } distributeCollateralTokens ( tradeDealId , recipients , amounts , reason ); } function getDistributionHistory ( uint256 tradeDealId ) external view returns ( DistributionRecord [] memory ) { return distributionHistory [ tradeDealId ]; } function getTotalDistributed ( uint256 tradeDealId , address recipient ) external view returns ( uint256 ) { return totalDistributed [ tradeDealId ][ recipient ]; } } Token Restriction Manager \u00b6 // Advanced restriction management for collateral tokens contract TokenRestrictionManager { struct RestrictionPolicy { bool transfersEnabled ; bool onlyParticipants ; uint256 maxTransferAmount ; uint256 cooldownPeriod ; bool emergencyFreeze ; } mapping ( uint256 => RestrictionPolicy ) public restrictionPolicies ; mapping ( uint256 => mapping ( address => uint256 )) public lastTransferTime ; function setRestrictionPolicy ( uint256 tradeDealId , RestrictionPolicy memory policy ) external onlyOwner { restrictionPolicies [ tradeDealId ] = policy ; // Apply basic restrictions through factory facet ICollateralTokenFactory ( diamond ). setCollateralTokenRestrictions ( tradeDealId , policy . onlyParticipants || ! policy . transfersEnabled ); emit RestrictionPolicyUpdated ( tradeDealId , policy ); } function validateTransfer ( uint256 tradeDealId , address from , address to , uint256 amount ) external view returns ( bool allowed , string memory reason ) { RestrictionPolicy memory policy = restrictionPolicies [ tradeDealId ]; // Check emergency freeze if ( policy . emergencyFreeze ) { return ( false , \"Emergency freeze active\" ); } // Check if transfers are enabled if ( ! policy . transfersEnabled ) { return ( false , \"Transfers disabled\" ); } // Check participant requirement if ( policy . onlyParticipants ) { bool fromIsParticipant = ICollateralTokenFactory ( diamond ). isCollateralTokenParticipant ( tradeDealId , from ); bool toIsParticipant = ICollateralTokenFactory ( diamond ). isCollateralTokenParticipant ( tradeDealId , to ); if ( ! fromIsParticipant || ! toIsParticipant ) { return ( false , \"Both parties must be participants\" ); } } // Check transfer amount limit if ( policy . maxTransferAmount > 0 && amount > policy . maxTransferAmount ) { return ( false , \"Amount exceeds maximum transfer limit\" ); } // Check cooldown period if ( policy . cooldownPeriod > 0 ) { uint256 timeSinceLastTransfer = block.timestamp - lastTransferTime [ tradeDealId ][ from ]; if ( timeSinceLastTransfer < policy . cooldownPeriod ) { return ( false , \"Cooldown period not elapsed\" ); } } return ( true , \"Transfer allowed\" ); } function emergencyFreeze ( uint256 tradeDealId , bool freeze ) external onlyOwner { restrictionPolicies [ tradeDealId ]. emergencyFreeze = freeze ; // Apply emergency restrictions ICollateralTokenFactory ( diamond ). setCollateralTokenRestrictions ( tradeDealId , freeze ); emit EmergencyFreezeUpdated ( tradeDealId , freeze ); } function updateTransferTime ( uint256 tradeDealId , address user ) external onlyAuthorized { lastTransferTime [ tradeDealId ][ user ] = block.timestamp ; } } Factory Analytics and Monitoring \u00b6 // Analytics and monitoring for collateral token factory contract CollateralTokenAnalytics { struct TokenMetrics { uint256 tradeDealId ; address tokenAddress ; uint256 totalSupply ; uint256 holderCount ; uint256 transferCount ; uint256 creationTime ; bool restrictionsActive ; } mapping ( uint256 => TokenMetrics ) public tokenMetrics ; mapping ( address => uint256 ) public tokenToTradeDeal ; uint256 [] public allTradeDealIds ; function trackTokenCreation ( uint256 tradeDealId , address tokenAddress , string memory name , string memory symbol ) external onlyAuthorized { tokenMetrics [ tradeDealId ] = TokenMetrics ({ tradeDealId : tradeDealId , tokenAddress : tokenAddress , totalSupply : 0 , holderCount : 0 , transferCount : 0 , creationTime : block.timestamp , restrictionsActive : true }); tokenToTradeDeal [ tokenAddress ] = tradeDealId ; allTradeDealIds . push ( tradeDealId ); emit TokenCreationTracked ( tradeDealId , tokenAddress , name , symbol ); } function updateTokenMetrics ( uint256 tradeDealId ) external { TokenMetrics storage metrics = tokenMetrics [ tradeDealId ]; require ( metrics . tokenAddress != address ( 0 ), \"Token not found\" ); IERC20 token = IERC20 ( metrics . tokenAddress ); metrics . totalSupply = token . totalSupply (); // Update restriction status // This would require additional interface methods on RestrictedCollateralToken emit TokenMetricsUpdated ( tradeDealId , metrics . totalSupply , metrics . holderCount ); } function getFactoryOverview () external view returns ( uint256 totalTokens , uint256 totalSupplyAcrossTokens , uint256 averageHoldersPerToken , uint256 tokensWithRestrictions ) { totalTokens = allTradeDealIds . length ; uint256 totalHolders = 0 ; for ( uint256 i = 0 ; i < allTradeDealIds . length ; i ++ ) { TokenMetrics memory metrics = tokenMetrics [ allTradeDealIds [ i ]]; totalSupplyAcrossTokens += metrics . totalSupply ; totalHolders += metrics . holderCount ; if ( metrics . restrictionsActive ) { tokensWithRestrictions ++ ; } } if ( totalTokens > 0 ) { averageHoldersPerToken = totalHolders / totalTokens ; } } function getTokensByRestrictionStatus ( bool restrictionsActive ) external view returns ( uint256 [] memory ) { uint256 [] memory matchingTokens = new uint256 []( allTradeDealIds . length ); uint256 count = 0 ; for ( uint256 i = 0 ; i < allTradeDealIds . length ; i ++ ) { if ( tokenMetrics [ allTradeDealIds [ i ]]. restrictionsActive == restrictionsActive ) { matchingTokens [ count ] = allTradeDealIds [ i ]; count ++ ; } } // Resize array to actual count uint256 [] memory result = new uint256 []( count ); for ( uint256 i = 0 ; i < count ; i ++ ) { result [ i ] = matchingTokens [ i ]; } return result ; } } Events \u00b6 Factory Events \u00b6 event CollateralTokenFactoryInitialized ( address indexed factoryAddress ); Token Management Events \u00b6 event CollateralTokenCreated ( uint256 indexed tradeDealId , address indexed tokenAddress , string name , string symbol ); Security Considerations \u00b6 Factory Security \u00b6 Factory initialization protection against re-initialization Owner-only access for token creation and configuration Validation of trade deal uniqueness Proper factory address management Token Security \u00b6 Transfer restrictions based on participant verification Integration with identity verification systems Emergency controls for restriction management Proper access control for administrative functions Integration Security \u00b6 Validation of trade deal existence before token creation Proper participant verification before token operations Secure storage of factory and token addresses Event logging for audit trails Gas Optimization \u00b6 Factory Efficiency \u00b6 Minimal proxy pattern for token deployment Efficient storage layout for mappings Batch operations where possible Optimized factory initialization Token Operations \u00b6 Gas-efficient participant verification Optimized restriction checking Minimal storage operations Efficient event emission Error Handling \u00b6 Common Errors \u00b6 \"factory not set\" - Factory not initialized \"token already exists for this trade deal\" - Duplicate token creation \"token does not exist for this trade deal\" - Invalid token reference Access control failures for unauthorized operations Best Practices \u00b6 Always check factory initialization before operations Validate trade deal existence before token creation Verify participant status before token operations Handle zero address returns gracefully Testing Considerations \u00b6 Unit Tests \u00b6 Factory initialization and configuration Token creation and management Restriction setting and validation Participant verification Access control enforcement Integration Tests \u00b6 Trade deal integration workflows Participant management integration Token distribution scenarios Restriction policy enforcement Related Documentation \u00b6 RestrictedCollateralToken - Token implementation CollateralTokenFactory - Factory contract TradeDealAdminFacet - Trade deal administration TradeDealOperationsFacet - Trade deal operations IdentityRegistryFacet - Participant verification Token Factory Guide - Implementation guide This facet provides factory functionality for creating and managing restricted collateral tokens within the Gemforce platform, enabling secure and compliant token distribution for trade deal participants.","title":"Collateral Token Factory Facet"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#collateraltokenfactoryfacet","text":"","title":"CollateralTokenFactoryFacet"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#overview","text":"The CollateralTokenFactoryFacet.sol provides factory functionality for creating and managing restricted collateral tokens within the Gemforce diamond system. This facet enables the creation of ERC20 tokens that represent collateral positions in trade deals, with built-in transfer restrictions and participant validation.","title":"Overview"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#contract-details","text":"Contract Name : CollateralTokenFactoryFacet Inheritance : Modifiers License : MIT Solidity Version : ^0.8.0","title":"Contract Details"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#factory-pattern-implementation","text":"Automated factory deployment and initialization Template-based token creation using proxy patterns Centralized token management and tracking Efficient deployment of multiple token instances","title":"\ud83d\udd39 Factory Pattern Implementation"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#restricted-collateral-tokens","text":"ERC20 tokens with transfer restrictions Trade deal participant validation Configurable restriction enforcement Integration with identity verification systems","title":"\ud83d\udd39 Restricted Collateral Tokens"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#trade-deal-integration","text":"One-to-one mapping between trade deals and tokens Automatic token creation for trade deals Participant management integration Collateral position tracking","title":"\ud83d\udd39 Trade Deal Integration"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#administrative-controls","text":"Owner-only token creation and configuration Restriction management for existing tokens Factory address management Comprehensive event logging","title":"\ud83d\udd39 Administrative Controls"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#core-architecture","text":"","title":"Core Architecture"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#factory-pattern","text":"The facet implements a factory pattern where: - Factory Contract : CollateralTokenFactory manages token creation - Implementation Contract : RestrictedCollateralToken serves as the template - Proxy Pattern : New tokens are created as minimal proxies to save gas - Diamond Integration : Factory is managed through the diamond storage","title":"Factory Pattern"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#storage-structure","text":"struct CollateralTokenFactoryStorage { address factoryAddress ; // Address of the factory contract mapping ( uint256 => address ) tradeDealToToken ; // Trade deal ID to token address mapping }","title":"Storage Structure"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#token-restrictions","text":"Collateral tokens can enforce restrictions on: - Transfer Limitations : Only verified participants can transfer tokens - Participant Validation : Integration with identity verification - Trade Deal Compliance : Tokens tied to specific trade deal rules - Administrative Controls : Owner can enable/disable restrictions","title":"Token Restrictions"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#initialization-functions","text":"","title":"Initialization Functions"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#collateraltokenfactoryfacet_init","text":"function CollateralTokenFactoryFacet_init () external Purpose : Initializes the collateral token factory when the facet is added to the diamond. Access Control : Public (with initialization check) Process : 1. Checks that factory hasn't been initialized already 2. Deploys a new RestrictedCollateralToken implementation 3. Creates a CollateralTokenFactory with the implementation 4. Stores the factory address in diamond storage 5. Emits CollateralTokenFactoryInitialized event Events : CollateralTokenFactoryInitialized(factoryAddress) Example Usage : // Called automatically when facet is added to diamond // Or can be called manually if needed ICollateralTokenFactory ( diamond ). CollateralTokenFactoryFacet_init (); console . log ( \"Collateral token factory initialized\" ); Requirements : - Factory must not be already initialized - Caller must have appropriate permissions - Sufficient gas for contract deployments","title":"CollateralTokenFactoryFacet_init()"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#getcollateraltokenfactory","text":"function getCollateralTokenFactory () external view returns ( address ) Purpose : Returns the address of the deployed CollateralTokenFactory contract. Returns : - address : Address of the factory contract Example Usage : address factoryAddress = ICollateralTokenFactory ( diamond ). getCollateralTokenFactory (); console . log ( \"Factory deployed at:\" , factoryAddress ); // Use factory directly if needed CollateralTokenFactory factory = CollateralTokenFactory ( factoryAddress );","title":"getCollateralTokenFactory()"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#token-creation-functions","text":"","title":"Token Creation Functions"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#createcollateraltoken","text":"function createCollateralToken ( uint256 _tradeDealId , string memory _name , string memory _symbol , bool _restrictionsEnabled ) external onlyOwner returns ( address ) Purpose : Creates a new restricted collateral token for a specific trade deal. Parameters : - _tradeDealId (uint256): Unique identifier for the trade deal - _name (string): Human-readable name for the token - _symbol (string): Token symbol (typically 3-5 characters) - _restrictionsEnabled (bool): Whether to enforce transfer restrictions Returns : - address : Address of the newly created token contract Access Control : Owner only Process : 1. Validates factory is initialized 2. Checks no token exists for the trade deal ID 3. Calls factory to create new token with specified parameters 4. Stores token address in trade deal mapping 5. Emits CollateralTokenCreated event Events : CollateralTokenCreated(tradeDealId, tokenAddress, name, symbol) Example Usage : // Create collateral token for trade deal uint256 tradeDealId = 1 ; string memory tokenName = \"Trade Deal 1 Collateral\" ; string memory tokenSymbol = \"TD1C\" ; bool restrictionsEnabled = true ; address tokenAddress = ICollateralTokenFactory ( diamond ). createCollateralToken ( tradeDealId , tokenName , tokenSymbol , restrictionsEnabled ); console . log ( \"Created collateral token:\" , tokenAddress ); console . log ( \"For trade deal:\" , tradeDealId ); Token Configuration : - Name : Descriptive name for the collateral token - Symbol : Short identifier for the token - Diamond Address : Set as the token's diamond for integration - Trade Deal ID : Links token to specific trade deal - Restrictions : Controls transfer limitations Error Conditions : - \"factory not set\" - Factory not initialized - \"token already exists for this trade deal\" - Duplicate creation attempt - Access control failures for non-owners","title":"createCollateralToken()"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#query-functions","text":"","title":"Query Functions"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#getcollateraltokenaddress","text":"function getCollateralTokenAddress ( uint256 _tradeDealId ) external view returns ( address ) Purpose : Retrieves the token address for a specific trade deal. Parameters : - _tradeDealId (uint256): ID of the trade deal Returns : - address : Address of the collateral token (zero address if not found) Process : 1. Checks local mapping for token address 2. Falls back to factory lookup if not found locally 3. Returns zero address if token doesn't exist Example Usage : uint256 tradeDealId = 1 ; address tokenAddress = ICollateralTokenFactory ( diamond ). getCollateralTokenAddress ( tradeDealId ); if ( tokenAddress != address ( 0 )) { console . log ( \"Token found:\" , tokenAddress ); // Interact with the token IERC20 collateralToken = IERC20 ( tokenAddress ); uint256 balance = collateralToken . balanceOf ( msg.sender ); console . log ( \"My collateral balance:\" , balance ); } else { console . log ( \"No token found for trade deal:\" , tradeDealId ); }","title":"getCollateralTokenAddress()"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#iscollateraltokenparticipant","text":"function isCollateralTokenParticipant ( uint256 _tradeDealId , address _address ) external view returns ( bool ) Purpose : Checks if an address is a verified participant for a trade deal's collateral token. Parameters : - _tradeDealId (uint256): ID of the trade deal - _address (address): Address to check for participation Returns : - bool : True if address is a verified participant Process : 1. Retrieves token address for the trade deal 2. Calls token's participant verification function 3. Returns false if token doesn't exist Example Usage : uint256 tradeDealId = 1 ; address userAddress = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; bool isParticipant = ICollateralTokenFactory ( diamond ). isCollateralTokenParticipant ( tradeDealId , userAddress ); if ( isParticipant ) { console . log ( \"User is verified participant\" ); // Allow token operations } else { console . log ( \"User is not a participant\" ); // Restrict token operations }","title":"isCollateralTokenParticipant()"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#administrative-functions","text":"","title":"Administrative Functions"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#setcollateraltokenrestrictions","text":"function setCollateralTokenRestrictions ( uint256 _tradeDealId , bool _restrictionsEnabled ) external onlyOwner Purpose : Enables or disables transfer restrictions for a collateral token. Parameters : - _tradeDealId (uint256): ID of the trade deal - _restrictionsEnabled (bool): Whether to enforce restrictions Access Control : Owner only Process : 1. Retrieves token address for the trade deal 2. Validates token exists 3. Calls token's restriction configuration function 4. Updates restriction status Example Usage : uint256 tradeDealId = 1 ; // Enable restrictions (only participants can transfer) ICollateralTokenFactory ( diamond ). setCollateralTokenRestrictions ( tradeDealId , true ); console . log ( \"Restrictions enabled for trade deal:\" , tradeDealId ); // Later, disable restrictions (open transfers) ICollateralTokenFactory ( diamond ). setCollateralTokenRestrictions ( tradeDealId , false ); console . log ( \"Restrictions disabled for trade deal:\" , tradeDealId ); Use Cases : - Enable Restrictions : During active trade deal phase - Disable Restrictions : After trade deal completion - Compliance Requirements : Based on regulatory needs - Emergency Controls : For security incidents","title":"setCollateralTokenRestrictions()"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#complete-trade-deal-token-lifecycle","text":"// Comprehensive trade deal collateral token management contract TradeDealTokenManager { struct TokenInfo { uint256 tradeDealId ; address tokenAddress ; string name ; string symbol ; bool restrictionsEnabled ; uint256 totalSupply ; uint256 participantCount ; } mapping ( uint256 => TokenInfo ) public tradeDealTokens ; mapping ( address => uint256 []) public userTradeDealIds ; function createTradeDealWithToken ( uint256 tradeDealId , string memory dealName , string memory tokenSymbol , bool initialRestrictions ) external onlyOwner returns ( address tokenAddress ) { // Create collateral token for trade deal string memory tokenName = string ( abi . encodePacked ( dealName , \" Collateral\" )); tokenAddress = ICollateralTokenFactory ( diamond ). createCollateralToken ( tradeDealId , tokenName , tokenSymbol , initialRestrictions ); // Store token information tradeDealTokens [ tradeDealId ] = TokenInfo ({ tradeDealId : tradeDealId , tokenAddress : tokenAddress , name : tokenName , symbol : tokenSymbol , restrictionsEnabled : initialRestrictions , totalSupply : 0 , participantCount : 0 }); emit TradeDealTokenCreated ( tradeDealId , tokenAddress , tokenName , tokenSymbol ); } function addParticipantToTradeDeal ( uint256 tradeDealId , address participant ) external onlyOwner { TokenInfo storage tokenInfo = tradeDealTokens [ tradeDealId ]; require ( tokenInfo . tokenAddress != address ( 0 ), \"Trade deal token not found\" ); // Add participant to trade deal (this would integrate with TradeDealAdminFacet) // ITradeDealAdmin(diamond).addTradeDealParticipant(tradeDealId, participant); // Track user's trade deal participation userTradeDealIds [ participant ]. push ( tradeDealId ); tokenInfo . participantCount ++ ; emit ParticipantAdded ( tradeDealId , participant ); } function updateTokenRestrictions ( uint256 tradeDealId , bool restrictionsEnabled ) external onlyOwner { TokenInfo storage tokenInfo = tradeDealTokens [ tradeDealId ]; require ( tokenInfo . tokenAddress != address ( 0 ), \"Trade deal token not found\" ); // Update restrictions through factory facet ICollateralTokenFactory ( diamond ). setCollateralTokenRestrictions ( tradeDealId , restrictionsEnabled ); // Update local tracking tokenInfo . restrictionsEnabled = restrictionsEnabled ; emit TokenRestrictionsUpdated ( tradeDealId , restrictionsEnabled ); } function getTokenInfo ( uint256 tradeDealId ) external view returns ( TokenInfo memory ) { return tradeDealTokens [ tradeDealId ]; } function getUserTradeDealTokens ( address user ) external view returns ( uint256 [] memory tradeDealIds , address [] memory tokenAddresses , uint256 [] memory balances ) { uint256 [] memory userDeals = userTradeDealIds [ user ]; tradeDealIds = new uint256 []( userDeals . length ); tokenAddresses = new address []( userDeals . length ); balances = new uint256 []( userDeals . length ); for ( uint256 i = 0 ; i < userDeals . length ; i ++ ) { uint256 tradeDealId = userDeals [ i ]; TokenInfo memory tokenInfo = tradeDealTokens [ tradeDealId ]; tradeDealIds [ i ] = tradeDealId ; tokenAddresses [ i ] = tokenInfo . tokenAddress ; if ( tokenInfo . tokenAddress != address ( 0 )) { balances [ i ] = IERC20 ( tokenInfo . tokenAddress ). balanceOf ( user ); } } } }","title":"Complete Trade Deal Token Lifecycle"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#collateral-token-distribution-system","text":"// System for distributing collateral tokens to participants contract CollateralTokenDistributor { struct DistributionRecord { uint256 tradeDealId ; address recipient ; uint256 amount ; uint256 timestamp ; string reason ; } mapping ( uint256 => DistributionRecord []) public distributionHistory ; mapping ( uint256 => mapping ( address => uint256 )) public totalDistributed ; function distributeCollateralTokens ( uint256 tradeDealId , address [] memory recipients , uint256 [] memory amounts , string memory reason ) external onlyOwner { require ( recipients . length == amounts . length , \"Array length mismatch\" ); // Get token address address tokenAddress = ICollateralTokenFactory ( diamond ). getCollateralTokenAddress ( tradeDealId ); require ( tokenAddress != address ( 0 ), \"Token not found for trade deal\" ); RestrictedCollateralToken token = RestrictedCollateralToken ( tokenAddress ); for ( uint256 i = 0 ; i < recipients . length ; i ++ ) { address recipient = recipients [ i ]; uint256 amount = amounts [ i ]; // Verify recipient is a participant bool isParticipant = ICollateralTokenFactory ( diamond ). isCollateralTokenParticipant ( tradeDealId , recipient ); require ( isParticipant , \"Recipient is not a trade deal participant\" ); // Mint tokens to recipient token . mint ( recipient , amount ); // Record distribution distributionHistory [ tradeDealId ]. push ( DistributionRecord ({ tradeDealId : tradeDealId , recipient : recipient , amount : amount , timestamp : block.timestamp , reason : reason })); totalDistributed [ tradeDealId ][ recipient ] += amount ; emit CollateralTokensDistributed ( tradeDealId , recipient , amount , reason ); } } function batchDistributeEqual ( uint256 tradeDealId , address [] memory recipients , uint256 totalAmount , string memory reason ) external onlyOwner { require ( recipients . length > 0 , \"No recipients provided\" ); uint256 amountPerRecipient = totalAmount / recipients . length ; uint256 [] memory amounts = new uint256 []( recipients . length ); for ( uint256 i = 0 ; i < recipients . length ; i ++ ) { amounts [ i ] = amountPerRecipient ; } distributeCollateralTokens ( tradeDealId , recipients , amounts , reason ); } function getDistributionHistory ( uint256 tradeDealId ) external view returns ( DistributionRecord [] memory ) { return distributionHistory [ tradeDealId ]; } function getTotalDistributed ( uint256 tradeDealId , address recipient ) external view returns ( uint256 ) { return totalDistributed [ tradeDealId ][ recipient ]; } }","title":"Collateral Token Distribution System"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#token-restriction-manager","text":"// Advanced restriction management for collateral tokens contract TokenRestrictionManager { struct RestrictionPolicy { bool transfersEnabled ; bool onlyParticipants ; uint256 maxTransferAmount ; uint256 cooldownPeriod ; bool emergencyFreeze ; } mapping ( uint256 => RestrictionPolicy ) public restrictionPolicies ; mapping ( uint256 => mapping ( address => uint256 )) public lastTransferTime ; function setRestrictionPolicy ( uint256 tradeDealId , RestrictionPolicy memory policy ) external onlyOwner { restrictionPolicies [ tradeDealId ] = policy ; // Apply basic restrictions through factory facet ICollateralTokenFactory ( diamond ). setCollateralTokenRestrictions ( tradeDealId , policy . onlyParticipants || ! policy . transfersEnabled ); emit RestrictionPolicyUpdated ( tradeDealId , policy ); } function validateTransfer ( uint256 tradeDealId , address from , address to , uint256 amount ) external view returns ( bool allowed , string memory reason ) { RestrictionPolicy memory policy = restrictionPolicies [ tradeDealId ]; // Check emergency freeze if ( policy . emergencyFreeze ) { return ( false , \"Emergency freeze active\" ); } // Check if transfers are enabled if ( ! policy . transfersEnabled ) { return ( false , \"Transfers disabled\" ); } // Check participant requirement if ( policy . onlyParticipants ) { bool fromIsParticipant = ICollateralTokenFactory ( diamond ). isCollateralTokenParticipant ( tradeDealId , from ); bool toIsParticipant = ICollateralTokenFactory ( diamond ). isCollateralTokenParticipant ( tradeDealId , to ); if ( ! fromIsParticipant || ! toIsParticipant ) { return ( false , \"Both parties must be participants\" ); } } // Check transfer amount limit if ( policy . maxTransferAmount > 0 && amount > policy . maxTransferAmount ) { return ( false , \"Amount exceeds maximum transfer limit\" ); } // Check cooldown period if ( policy . cooldownPeriod > 0 ) { uint256 timeSinceLastTransfer = block.timestamp - lastTransferTime [ tradeDealId ][ from ]; if ( timeSinceLastTransfer < policy . cooldownPeriod ) { return ( false , \"Cooldown period not elapsed\" ); } } return ( true , \"Transfer allowed\" ); } function emergencyFreeze ( uint256 tradeDealId , bool freeze ) external onlyOwner { restrictionPolicies [ tradeDealId ]. emergencyFreeze = freeze ; // Apply emergency restrictions ICollateralTokenFactory ( diamond ). setCollateralTokenRestrictions ( tradeDealId , freeze ); emit EmergencyFreezeUpdated ( tradeDealId , freeze ); } function updateTransferTime ( uint256 tradeDealId , address user ) external onlyAuthorized { lastTransferTime [ tradeDealId ][ user ] = block.timestamp ; } }","title":"Token Restriction Manager"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#factory-analytics-and-monitoring","text":"// Analytics and monitoring for collateral token factory contract CollateralTokenAnalytics { struct TokenMetrics { uint256 tradeDealId ; address tokenAddress ; uint256 totalSupply ; uint256 holderCount ; uint256 transferCount ; uint256 creationTime ; bool restrictionsActive ; } mapping ( uint256 => TokenMetrics ) public tokenMetrics ; mapping ( address => uint256 ) public tokenToTradeDeal ; uint256 [] public allTradeDealIds ; function trackTokenCreation ( uint256 tradeDealId , address tokenAddress , string memory name , string memory symbol ) external onlyAuthorized { tokenMetrics [ tradeDealId ] = TokenMetrics ({ tradeDealId : tradeDealId , tokenAddress : tokenAddress , totalSupply : 0 , holderCount : 0 , transferCount : 0 , creationTime : block.timestamp , restrictionsActive : true }); tokenToTradeDeal [ tokenAddress ] = tradeDealId ; allTradeDealIds . push ( tradeDealId ); emit TokenCreationTracked ( tradeDealId , tokenAddress , name , symbol ); } function updateTokenMetrics ( uint256 tradeDealId ) external { TokenMetrics storage metrics = tokenMetrics [ tradeDealId ]; require ( metrics . tokenAddress != address ( 0 ), \"Token not found\" ); IERC20 token = IERC20 ( metrics . tokenAddress ); metrics . totalSupply = token . totalSupply (); // Update restriction status // This would require additional interface methods on RestrictedCollateralToken emit TokenMetricsUpdated ( tradeDealId , metrics . totalSupply , metrics . holderCount ); } function getFactoryOverview () external view returns ( uint256 totalTokens , uint256 totalSupplyAcrossTokens , uint256 averageHoldersPerToken , uint256 tokensWithRestrictions ) { totalTokens = allTradeDealIds . length ; uint256 totalHolders = 0 ; for ( uint256 i = 0 ; i < allTradeDealIds . length ; i ++ ) { TokenMetrics memory metrics = tokenMetrics [ allTradeDealIds [ i ]]; totalSupplyAcrossTokens += metrics . totalSupply ; totalHolders += metrics . holderCount ; if ( metrics . restrictionsActive ) { tokensWithRestrictions ++ ; } } if ( totalTokens > 0 ) { averageHoldersPerToken = totalHolders / totalTokens ; } } function getTokensByRestrictionStatus ( bool restrictionsActive ) external view returns ( uint256 [] memory ) { uint256 [] memory matchingTokens = new uint256 []( allTradeDealIds . length ); uint256 count = 0 ; for ( uint256 i = 0 ; i < allTradeDealIds . length ; i ++ ) { if ( tokenMetrics [ allTradeDealIds [ i ]]. restrictionsActive == restrictionsActive ) { matchingTokens [ count ] = allTradeDealIds [ i ]; count ++ ; } } // Resize array to actual count uint256 [] memory result = new uint256 []( count ); for ( uint256 i = 0 ; i < count ; i ++ ) { result [ i ] = matchingTokens [ i ]; } return result ; } }","title":"Factory Analytics and Monitoring"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#events","text":"","title":"Events"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#factory-events","text":"event CollateralTokenFactoryInitialized ( address indexed factoryAddress );","title":"Factory Events"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#token-management-events","text":"event CollateralTokenCreated ( uint256 indexed tradeDealId , address indexed tokenAddress , string name , string symbol );","title":"Token Management Events"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#factory-security","text":"Factory initialization protection against re-initialization Owner-only access for token creation and configuration Validation of trade deal uniqueness Proper factory address management","title":"Factory Security"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#token-security","text":"Transfer restrictions based on participant verification Integration with identity verification systems Emergency controls for restriction management Proper access control for administrative functions","title":"Token Security"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#integration-security","text":"Validation of trade deal existence before token creation Proper participant verification before token operations Secure storage of factory and token addresses Event logging for audit trails","title":"Integration Security"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#factory-efficiency","text":"Minimal proxy pattern for token deployment Efficient storage layout for mappings Batch operations where possible Optimized factory initialization","title":"Factory Efficiency"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#token-operations","text":"Gas-efficient participant verification Optimized restriction checking Minimal storage operations Efficient event emission","title":"Token Operations"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#common-errors","text":"\"factory not set\" - Factory not initialized \"token already exists for this trade deal\" - Duplicate token creation \"token does not exist for this trade deal\" - Invalid token reference Access control failures for unauthorized operations","title":"Common Errors"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#best-practices","text":"Always check factory initialization before operations Validate trade deal existence before token creation Verify participant status before token operations Handle zero address returns gracefully","title":"Best Practices"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#unit-tests","text":"Factory initialization and configuration Token creation and management Restriction setting and validation Participant verification Access control enforcement","title":"Unit Tests"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#integration-tests","text":"Trade deal integration workflows Participant management integration Token distribution scenarios Restriction policy enforcement","title":"Integration Tests"},{"location":"smart-contracts/facets/collateral-token-factory-facet/#related-documentation","text":"RestrictedCollateralToken - Token implementation CollateralTokenFactory - Factory contract TradeDealAdminFacet - Trade deal administration TradeDealOperationsFacet - Trade deal operations IdentityRegistryFacet - Participant verification Token Factory Guide - Implementation guide This facet provides factory functionality for creating and managing restricted collateral tokens within the Gemforce platform, enabling secure and compliant token distribution for trade deal participants.","title":"Related Documentation"},{"location":"smart-contracts/facets/diamond-cut-facet/","text":"Diamond Cut Facet \u00b6 The Diamond Cut Facet implements the core diamond upgrade functionality as defined in EIP-2535. This facet enables adding, replacing, and removing functions from a diamond contract, making it upgradeable while maintaining state. Overview \u00b6 The Diamond Cut Facet is a fundamental component of the Diamond Standard that provides: Function Management : Add, replace, or remove functions from the diamond Facet Management : Manage which facets are part of the diamond Upgrade Safety : Ensures upgrades maintain contract integrity Access Control : Restricts upgrade operations to authorized users Key Features \u00b6 Function Operations \u00b6 Add Functions : Add new functions from facets to the diamond Replace Functions : Update existing function implementations Remove Functions : Remove functions that are no longer needed Safety Mechanisms \u00b6 Selector Validation : Ensures function selectors don't conflict Facet Address Validation : Validates facet contract addresses Initialization Support : Supports initialization calls during upgrades Interface \u00b6 interface IDiamondCut { enum FacetCutAction { Add , Replace , Remove } struct FacetCut { address facetAddress ; FacetCutAction action ; bytes4 [] functionSelectors ; } function diamondCut ( FacetCut [] calldata _diamondCut , address _init , bytes calldata _calldata ) external ; } Core Functions \u00b6 diamondCut() \u00b6 Performs diamond upgrade operations by adding, replacing, or removing functions. Parameters: - _diamondCut : Array of FacetCut structs defining the changes - _init : Address of contract to call for initialization (optional) - _calldata : Data to pass to initialization contract (optional) Access Control: - Only contract owner can perform diamond cuts - Validates all operations before execution Events: - Emits DiamondCut event for each successful upgrade Usage Examples \u00b6 Adding a New Facet \u00b6 // Define the facet cut IDiamondCut . FacetCut [] memory cut = new IDiamondCut . FacetCut []( 1 ); cut [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : newFacetAddress , action : IDiamondCut . FacetCutAction . Add , functionSelectors : selectors }); // Perform the diamond cut IDiamondCut ( diamond ). diamondCut ( cut , address ( 0 ), \"\" ); Replacing Function Implementation \u00b6 // Replace existing functions with new implementation IDiamondCut . FacetCut [] memory cut = new IDiamondCut . FacetCut []( 1 ); cut [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : updatedFacetAddress , action : IDiamondCut . FacetCutAction . Replace , functionSelectors : selectorsToReplace }); IDiamondCut ( diamond ). diamondCut ( cut , address ( 0 ), \"\" ); Removing Functions \u00b6 // Remove functions from diamond IDiamondCut . FacetCut [] memory cut = new IDiamondCut . FacetCut []( 1 ); cut [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : address ( 0 ), // Address 0 for removal action : IDiamondCut . FacetCutAction . Remove , functionSelectors : selectorsToRemove }); IDiamondCut ( diamond ). diamondCut ( cut , address ( 0 ), \"\" ); Security Considerations \u00b6 Access Control \u00b6 Owner Only : Only the diamond owner can perform cuts Multi-sig Recommended : Use multi-signature wallets for production Timelock Integration : Consider timelock contracts for upgrade delays Validation Checks \u00b6 Selector Conflicts : Prevents duplicate function selectors Address Validation : Ensures facet addresses are valid contracts Function Existence : Validates functions exist before replacement/removal Upgrade Safety \u00b6 State Preservation : Upgrades preserve existing contract state Initialization Calls : Supports safe state migration during upgrades Rollback Planning : Plan for potential rollback scenarios Integration with Other Facets \u00b6 Diamond Loupe Facet \u00b6 Works with Diamond Loupe Facet to provide introspection capabilities: - Query current facets and functions - Validate upgrade operations - Monitor diamond composition Ownership Facet \u00b6 Integrates with ownership controls: - Restricts cuts to authorized users - Supports ownership transfer - Enables governance integration Best Practices \u00b6 Upgrade Planning \u00b6 Test Thoroughly : Test all upgrades on testnets first Incremental Changes : Make small, incremental upgrades Documentation : Document all changes and their impacts Monitoring : Monitor contract behavior after upgrades Development Workflow \u00b6 Facet Development : Develop and test new facets independently Integration Testing : Test facet integration with existing diamond Upgrade Execution : Execute upgrades during low-activity periods Post-Upgrade Validation : Validate functionality after upgrades Error Handling \u00b6 Common Errors \u00b6 DiamondCut: No selectors in facet to cut : Empty selector array DiamondCut: Add facet can't be address(0) : Invalid facet address for add DiamondCut: Can't replace function that doesn't exist : Function not found DiamondCut: Can't remove function that doesn't exist : Function not found Troubleshooting \u00b6 Validate Selectors : Ensure function selectors are correct Check Addresses : Verify facet contract addresses Review Permissions : Confirm caller has upgrade permissions Test Operations : Test upgrade operations on development networks Related Documentation \u00b6 Diamond Standard Overview Diamond Loupe Facet Ownership Facet Diamond Architecture Guide Upgrade Patterns Guide Standards Compliance \u00b6 EIP-2535 : Diamond Standard implementation EIP-165 : Interface detection support Access Control : OpenZeppelin-compatible ownership patterns","title":"Diamond Cut Facet"},{"location":"smart-contracts/facets/diamond-cut-facet/#diamond-cut-facet","text":"The Diamond Cut Facet implements the core diamond upgrade functionality as defined in EIP-2535. This facet enables adding, replacing, and removing functions from a diamond contract, making it upgradeable while maintaining state.","title":"Diamond Cut Facet"},{"location":"smart-contracts/facets/diamond-cut-facet/#overview","text":"The Diamond Cut Facet is a fundamental component of the Diamond Standard that provides: Function Management : Add, replace, or remove functions from the diamond Facet Management : Manage which facets are part of the diamond Upgrade Safety : Ensures upgrades maintain contract integrity Access Control : Restricts upgrade operations to authorized users","title":"Overview"},{"location":"smart-contracts/facets/diamond-cut-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/diamond-cut-facet/#function-operations","text":"Add Functions : Add new functions from facets to the diamond Replace Functions : Update existing function implementations Remove Functions : Remove functions that are no longer needed","title":"Function Operations"},{"location":"smart-contracts/facets/diamond-cut-facet/#safety-mechanisms","text":"Selector Validation : Ensures function selectors don't conflict Facet Address Validation : Validates facet contract addresses Initialization Support : Supports initialization calls during upgrades","title":"Safety Mechanisms"},{"location":"smart-contracts/facets/diamond-cut-facet/#interface","text":"interface IDiamondCut { enum FacetCutAction { Add , Replace , Remove } struct FacetCut { address facetAddress ; FacetCutAction action ; bytes4 [] functionSelectors ; } function diamondCut ( FacetCut [] calldata _diamondCut , address _init , bytes calldata _calldata ) external ; }","title":"Interface"},{"location":"smart-contracts/facets/diamond-cut-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/diamond-cut-facet/#diamondcut","text":"Performs diamond upgrade operations by adding, replacing, or removing functions. Parameters: - _diamondCut : Array of FacetCut structs defining the changes - _init : Address of contract to call for initialization (optional) - _calldata : Data to pass to initialization contract (optional) Access Control: - Only contract owner can perform diamond cuts - Validates all operations before execution Events: - Emits DiamondCut event for each successful upgrade","title":"diamondCut()"},{"location":"smart-contracts/facets/diamond-cut-facet/#usage-examples","text":"","title":"Usage Examples"},{"location":"smart-contracts/facets/diamond-cut-facet/#adding-a-new-facet","text":"// Define the facet cut IDiamondCut . FacetCut [] memory cut = new IDiamondCut . FacetCut []( 1 ); cut [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : newFacetAddress , action : IDiamondCut . FacetCutAction . Add , functionSelectors : selectors }); // Perform the diamond cut IDiamondCut ( diamond ). diamondCut ( cut , address ( 0 ), \"\" );","title":"Adding a New Facet"},{"location":"smart-contracts/facets/diamond-cut-facet/#replacing-function-implementation","text":"// Replace existing functions with new implementation IDiamondCut . FacetCut [] memory cut = new IDiamondCut . FacetCut []( 1 ); cut [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : updatedFacetAddress , action : IDiamondCut . FacetCutAction . Replace , functionSelectors : selectorsToReplace }); IDiamondCut ( diamond ). diamondCut ( cut , address ( 0 ), \"\" );","title":"Replacing Function Implementation"},{"location":"smart-contracts/facets/diamond-cut-facet/#removing-functions","text":"// Remove functions from diamond IDiamondCut . FacetCut [] memory cut = new IDiamondCut . FacetCut []( 1 ); cut [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : address ( 0 ), // Address 0 for removal action : IDiamondCut . FacetCutAction . Remove , functionSelectors : selectorsToRemove }); IDiamondCut ( diamond ). diamondCut ( cut , address ( 0 ), \"\" );","title":"Removing Functions"},{"location":"smart-contracts/facets/diamond-cut-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/diamond-cut-facet/#access-control","text":"Owner Only : Only the diamond owner can perform cuts Multi-sig Recommended : Use multi-signature wallets for production Timelock Integration : Consider timelock contracts for upgrade delays","title":"Access Control"},{"location":"smart-contracts/facets/diamond-cut-facet/#validation-checks","text":"Selector Conflicts : Prevents duplicate function selectors Address Validation : Ensures facet addresses are valid contracts Function Existence : Validates functions exist before replacement/removal","title":"Validation Checks"},{"location":"smart-contracts/facets/diamond-cut-facet/#upgrade-safety","text":"State Preservation : Upgrades preserve existing contract state Initialization Calls : Supports safe state migration during upgrades Rollback Planning : Plan for potential rollback scenarios","title":"Upgrade Safety"},{"location":"smart-contracts/facets/diamond-cut-facet/#integration-with-other-facets","text":"","title":"Integration with Other Facets"},{"location":"smart-contracts/facets/diamond-cut-facet/#diamond-loupe-facet","text":"Works with Diamond Loupe Facet to provide introspection capabilities: - Query current facets and functions - Validate upgrade operations - Monitor diamond composition","title":"Diamond Loupe Facet"},{"location":"smart-contracts/facets/diamond-cut-facet/#ownership-facet","text":"Integrates with ownership controls: - Restricts cuts to authorized users - Supports ownership transfer - Enables governance integration","title":"Ownership Facet"},{"location":"smart-contracts/facets/diamond-cut-facet/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/facets/diamond-cut-facet/#upgrade-planning","text":"Test Thoroughly : Test all upgrades on testnets first Incremental Changes : Make small, incremental upgrades Documentation : Document all changes and their impacts Monitoring : Monitor contract behavior after upgrades","title":"Upgrade Planning"},{"location":"smart-contracts/facets/diamond-cut-facet/#development-workflow","text":"Facet Development : Develop and test new facets independently Integration Testing : Test facet integration with existing diamond Upgrade Execution : Execute upgrades during low-activity periods Post-Upgrade Validation : Validate functionality after upgrades","title":"Development Workflow"},{"location":"smart-contracts/facets/diamond-cut-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/diamond-cut-facet/#common-errors","text":"DiamondCut: No selectors in facet to cut : Empty selector array DiamondCut: Add facet can't be address(0) : Invalid facet address for add DiamondCut: Can't replace function that doesn't exist : Function not found DiamondCut: Can't remove function that doesn't exist : Function not found","title":"Common Errors"},{"location":"smart-contracts/facets/diamond-cut-facet/#troubleshooting","text":"Validate Selectors : Ensure function selectors are correct Check Addresses : Verify facet contract addresses Review Permissions : Confirm caller has upgrade permissions Test Operations : Test upgrade operations on development networks","title":"Troubleshooting"},{"location":"smart-contracts/facets/diamond-cut-facet/#related-documentation","text":"Diamond Standard Overview Diamond Loupe Facet Ownership Facet Diamond Architecture Guide Upgrade Patterns Guide","title":"Related Documentation"},{"location":"smart-contracts/facets/diamond-cut-facet/#standards-compliance","text":"EIP-2535 : Diamond Standard implementation EIP-165 : Interface detection support Access Control : OpenZeppelin-compatible ownership patterns","title":"Standards Compliance"},{"location":"smart-contracts/facets/diamond-loupe-facet/","text":"Diamond Loupe Facet \u00b6 The Diamond Loupe Facet provides introspection capabilities for diamond contracts as defined in EIP-2535. It allows querying the current state of a diamond, including which facets are installed and what functions they provide. Overview \u00b6 The Diamond Loupe Facet is an essential component of the Diamond Standard that provides: Facet Discovery : Query all facets currently part of the diamond Function Mapping : Discover which facet implements each function Interface Detection : Support for EIP-165 interface detection Diamond Inspection : Complete visibility into diamond composition Key Features \u00b6 Introspection Capabilities \u00b6 List All Facets : Get addresses of all facets in the diamond Function Selectors : Query function selectors for each facet Facet Mapping : Find which facet implements a specific function Interface Support : Check if diamond supports specific interfaces Standards Compliance \u00b6 EIP-2535 : Full Diamond Standard compliance EIP-165 : Interface detection support Read-Only Operations : All functions are view/pure (no state changes) Interface \u00b6 interface IDiamondLoupe { struct Facet { address facetAddress ; bytes4 [] functionSelectors ; } function facets () external view returns ( Facet [] memory facets_ ); function facetFunctionSelectors ( address _facet ) external view returns ( bytes4 [] memory facetFunctionSelectors_ ); function facetAddresses () external view returns ( address [] memory facetAddresses_ ); function facetAddress ( bytes4 _functionSelector ) external view returns ( address facetAddress_ ); function supportsInterface ( bytes4 _interfaceId ) external view returns ( bool ); } Core Functions \u00b6 facets() \u00b6 Returns all facets and their function selectors. Returns: - Facet[] : Array of Facet structs containing address and selectors Usage: IDiamondLoupe . Facet [] memory allFacets = IDiamondLoupe ( diamond ). facets (); for ( uint i = 0 ; i < allFacets . length ; i ++ ) { console . log ( \"Facet:\" , allFacets [ i ]. facetAddress ); console . log ( \"Functions:\" , allFacets [ i ]. functionSelectors . length ); } facetFunctionSelectors() \u00b6 Returns function selectors for a specific facet. Parameters: - _facet : Address of the facet to query Returns: - bytes4[] : Array of function selectors implemented by the facet facetAddresses() \u00b6 Returns addresses of all facets in the diamond. Returns: - address[] : Array of facet addresses facetAddress() \u00b6 Returns the facet address that implements a specific function. Parameters: - _functionSelector : Function selector to query Returns: - address : Address of facet implementing the function supportsInterface() \u00b6 Checks if the diamond supports a specific interface (EIP-165). Parameters: - _interfaceId : Interface identifier to check Returns: - bool : True if interface is supported Usage Examples \u00b6 Complete Diamond Inspection \u00b6 contract DiamondInspector { function inspectDiamond ( address diamond ) external view returns ( uint256 facetCount , uint256 totalFunctions , address [] memory facetAddresses ) { IDiamondLoupe loupe = IDiamondLoupe ( diamond ); // Get all facets IDiamondLoupe . Facet [] memory facets = loupe . facets (); facetCount = facets . length ; facetAddresses = new address []( facetCount ); // Count total functions and collect addresses for ( uint i = 0 ; i < facets . length ; i ++ ) { totalFunctions += facets [ i ]. functionSelectors . length ; facetAddresses [ i ] = facets [ i ]. facetAddress ; } } } Function Discovery \u00b6 contract FunctionDiscovery { function findFunctionImplementation ( address diamond , string memory functionSignature ) external view returns ( address facetAddress , bool exists ) { bytes4 selector = bytes4 ( keccak256 ( bytes ( functionSignature ))); facetAddress = IDiamondLoupe ( diamond ). facetAddress ( selector ); exists = facetAddress != address ( 0 ); } } Security Considerations \u00b6 Read-Only Nature \u00b6 No State Changes : All functions are view/pure Gas Efficient : Minimal gas cost for queries Safe to Call : No risk of state modification Information Disclosure \u00b6 Public Information : All diamond structure is publicly visible Design Consideration : Consider privacy implications Transparency : Enables full transparency of contract capabilities Best Practices \u00b6 Integration Guidelines \u00b6 Cache Results : Cache facet information when possible Batch Queries : Use facets() for complete information Interface Checks : Always verify interface support Error Handling : Handle cases where functions don't exist Development Workflow \u00b6 Testing : Use loupe for testing diamond composition Debugging : Inspect diamond state during development Documentation : Generate documentation from loupe data Monitoring : Monitor diamond changes in production Related Documentation \u00b6 Diamond Standard Overview Diamond Cut Facet IDiamond Interface Diamond Architecture Guide Standards Compliance \u00b6 EIP-2535 : Diamond Standard implementation EIP-165 : Interface detection support Gas Optimization : Efficient storage and retrieval patterns","title":"Diamond Loupe Facet"},{"location":"smart-contracts/facets/diamond-loupe-facet/#diamond-loupe-facet","text":"The Diamond Loupe Facet provides introspection capabilities for diamond contracts as defined in EIP-2535. It allows querying the current state of a diamond, including which facets are installed and what functions they provide.","title":"Diamond Loupe Facet"},{"location":"smart-contracts/facets/diamond-loupe-facet/#overview","text":"The Diamond Loupe Facet is an essential component of the Diamond Standard that provides: Facet Discovery : Query all facets currently part of the diamond Function Mapping : Discover which facet implements each function Interface Detection : Support for EIP-165 interface detection Diamond Inspection : Complete visibility into diamond composition","title":"Overview"},{"location":"smart-contracts/facets/diamond-loupe-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/diamond-loupe-facet/#introspection-capabilities","text":"List All Facets : Get addresses of all facets in the diamond Function Selectors : Query function selectors for each facet Facet Mapping : Find which facet implements a specific function Interface Support : Check if diamond supports specific interfaces","title":"Introspection Capabilities"},{"location":"smart-contracts/facets/diamond-loupe-facet/#standards-compliance","text":"EIP-2535 : Full Diamond Standard compliance EIP-165 : Interface detection support Read-Only Operations : All functions are view/pure (no state changes)","title":"Standards Compliance"},{"location":"smart-contracts/facets/diamond-loupe-facet/#interface","text":"interface IDiamondLoupe { struct Facet { address facetAddress ; bytes4 [] functionSelectors ; } function facets () external view returns ( Facet [] memory facets_ ); function facetFunctionSelectors ( address _facet ) external view returns ( bytes4 [] memory facetFunctionSelectors_ ); function facetAddresses () external view returns ( address [] memory facetAddresses_ ); function facetAddress ( bytes4 _functionSelector ) external view returns ( address facetAddress_ ); function supportsInterface ( bytes4 _interfaceId ) external view returns ( bool ); }","title":"Interface"},{"location":"smart-contracts/facets/diamond-loupe-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/diamond-loupe-facet/#facets","text":"Returns all facets and their function selectors. Returns: - Facet[] : Array of Facet structs containing address and selectors Usage: IDiamondLoupe . Facet [] memory allFacets = IDiamondLoupe ( diamond ). facets (); for ( uint i = 0 ; i < allFacets . length ; i ++ ) { console . log ( \"Facet:\" , allFacets [ i ]. facetAddress ); console . log ( \"Functions:\" , allFacets [ i ]. functionSelectors . length ); }","title":"facets()"},{"location":"smart-contracts/facets/diamond-loupe-facet/#facetfunctionselectors","text":"Returns function selectors for a specific facet. Parameters: - _facet : Address of the facet to query Returns: - bytes4[] : Array of function selectors implemented by the facet","title":"facetFunctionSelectors()"},{"location":"smart-contracts/facets/diamond-loupe-facet/#facetaddresses","text":"Returns addresses of all facets in the diamond. Returns: - address[] : Array of facet addresses","title":"facetAddresses()"},{"location":"smart-contracts/facets/diamond-loupe-facet/#facetaddress","text":"Returns the facet address that implements a specific function. Parameters: - _functionSelector : Function selector to query Returns: - address : Address of facet implementing the function","title":"facetAddress()"},{"location":"smart-contracts/facets/diamond-loupe-facet/#supportsinterface","text":"Checks if the diamond supports a specific interface (EIP-165). Parameters: - _interfaceId : Interface identifier to check Returns: - bool : True if interface is supported","title":"supportsInterface()"},{"location":"smart-contracts/facets/diamond-loupe-facet/#usage-examples","text":"","title":"Usage Examples"},{"location":"smart-contracts/facets/diamond-loupe-facet/#complete-diamond-inspection","text":"contract DiamondInspector { function inspectDiamond ( address diamond ) external view returns ( uint256 facetCount , uint256 totalFunctions , address [] memory facetAddresses ) { IDiamondLoupe loupe = IDiamondLoupe ( diamond ); // Get all facets IDiamondLoupe . Facet [] memory facets = loupe . facets (); facetCount = facets . length ; facetAddresses = new address []( facetCount ); // Count total functions and collect addresses for ( uint i = 0 ; i < facets . length ; i ++ ) { totalFunctions += facets [ i ]. functionSelectors . length ; facetAddresses [ i ] = facets [ i ]. facetAddress ; } } }","title":"Complete Diamond Inspection"},{"location":"smart-contracts/facets/diamond-loupe-facet/#function-discovery","text":"contract FunctionDiscovery { function findFunctionImplementation ( address diamond , string memory functionSignature ) external view returns ( address facetAddress , bool exists ) { bytes4 selector = bytes4 ( keccak256 ( bytes ( functionSignature ))); facetAddress = IDiamondLoupe ( diamond ). facetAddress ( selector ); exists = facetAddress != address ( 0 ); } }","title":"Function Discovery"},{"location":"smart-contracts/facets/diamond-loupe-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/diamond-loupe-facet/#read-only-nature","text":"No State Changes : All functions are view/pure Gas Efficient : Minimal gas cost for queries Safe to Call : No risk of state modification","title":"Read-Only Nature"},{"location":"smart-contracts/facets/diamond-loupe-facet/#information-disclosure","text":"Public Information : All diamond structure is publicly visible Design Consideration : Consider privacy implications Transparency : Enables full transparency of contract capabilities","title":"Information Disclosure"},{"location":"smart-contracts/facets/diamond-loupe-facet/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/facets/diamond-loupe-facet/#integration-guidelines","text":"Cache Results : Cache facet information when possible Batch Queries : Use facets() for complete information Interface Checks : Always verify interface support Error Handling : Handle cases where functions don't exist","title":"Integration Guidelines"},{"location":"smart-contracts/facets/diamond-loupe-facet/#development-workflow","text":"Testing : Use loupe for testing diamond composition Debugging : Inspect diamond state during development Documentation : Generate documentation from loupe data Monitoring : Monitor diamond changes in production","title":"Development Workflow"},{"location":"smart-contracts/facets/diamond-loupe-facet/#related-documentation","text":"Diamond Standard Overview Diamond Cut Facet IDiamond Interface Diamond Architecture Guide","title":"Related Documentation"},{"location":"smart-contracts/facets/diamond-loupe-facet/#standards-compliance_1","text":"EIP-2535 : Diamond Standard implementation EIP-165 : Interface detection support Gas Optimization : Efficient storage and retrieval patterns","title":"Standards Compliance"},{"location":"smart-contracts/facets/fee-distributor-facet/","text":"FeeDistributorFacet \u00b6 Overview \u00b6 The FeeDistributorFacet.sol provides comprehensive fee distribution functionality within the Gemforce diamond system. This facet enables automated distribution of fees and revenues to multiple recipients based on configurable weights, supporting complex revenue sharing models for marketplace operations, trade deals, and other platform activities. Contract Details \u00b6 Contract Name : FeeDistributorFacet Inheritance : IFeeDistributor , Modifiers License : MIT Solidity Version : ^0.8.0 Key Features \u00b6 \ud83d\udd39 Flexible Fee Distribution \u00b6 Configure multiple fee recipients with custom weights Proportional distribution based on weight ratios Support for any ERC20 token distribution Automated calculation and distribution \ud83d\udd39 Revenue Sharing Models \u00b6 Marketplace commission distribution Trade deal fee sharing Platform revenue allocation Partner revenue sharing \ud83d\udd39 Transparent Calculations \u00b6 View-only calculation functions Precise fee amount calculations Adjustable weight basis for flexibility Real-time distribution previews \ud83d\udd39 Secure Operations \u00b6 Owner-only configuration functions Validation of all parameters Event logging for transparency Integration with diamond access control Core Data Structures \u00b6 Fee Distribution Configuration \u00b6 Distribution Token : ERC20 token used for fee payments (e.g., USDC) Total Weight Basis : Denominator for weight calculations (e.g., 10000 for basis points) Fee Receivers : Array of addresses that receive fee distributions Fee Weights : Corresponding weights for each receiver Storage Pattern \u00b6 Uses diamond storage pattern via FeeDistributorLib : - Prevents storage collisions in diamond architecture - Efficient storage of fee configuration - Persistent settings across contract upgrades Core Functions \u00b6 Initialization Functions \u00b6 initializeFeeDistributor() \u00b6 function initializeFeeDistributor ( address _distributionToken , uint256 _totalWeightBasis ) external onlyOwner Purpose : Initializes the fee distributor with token and weight basis configuration. Parameters : - _distributionToken (address): ERC20 token address for fee distributions - _totalWeightBasis (uint256): Total weight basis for calculations (e.g., 10000) Access Control : Owner only Validation : - Distribution token cannot be zero address - Total weight basis must be greater than zero - Can only be called once during deployment Process : 1. Validates input parameters 2. Initializes fee distributor storage 3. Sets distribution token and weight basis 4. Emits FeeDistributorInitialized event Events : FeeDistributorInitialized(distributionToken, totalWeightBasis) Example Usage : // Initialize with USDC and basis points (10000) IFeeDistributor ( diamond ). initializeFeeDistributor ( usdcAddress , 10000 // 10000 basis points = 100% ); Error Conditions : - \"FeeDistributor: Distribution token cannot be zero address\" - Invalid token address - Already initialized error from library Configuration Functions \u00b6 setFeeReceivers() \u00b6 function setFeeReceivers ( address [] calldata _feeReceivers , uint256 [] calldata _feeWeights ) external override onlyOwner Purpose : Configures the addresses and weights for fee distribution. Parameters : - _feeReceivers (address[]): Array of addresses to receive fees - _feeWeights (uint256[]): Array of weights corresponding to each receiver Access Control : Owner only Validation : - Arrays must have equal length - No zero addresses in receivers - Weights must be greater than zero - Total weights should not exceed weight basis Process : 1. Validates input arrays 2. Updates fee receiver configuration 3. Stores receivers and weights 4. Emits FeeReceiversSet event Events : FeeReceiversSet(receivers, weights) Example Usage : // Set up fee distribution: 70% to treasury, 20% to team, 10% to marketing address [] memory receivers = new address []( 3 ); receivers [ 0 ] = treasuryAddress ; receivers [ 1 ] = teamAddress ; receivers [ 2 ] = marketingAddress ; uint256 [] memory weights = new uint256 []( 3 ); weights [ 0 ] = 7000 ; // 70% weights [ 1 ] = 2000 ; // 20% weights [ 2 ] = 1000 ; // 10% IFeeDistributor ( diamond ). setFeeReceivers ( receivers , weights ); Weight Calculation Example : // With totalWeightBasis = 10000 // Treasury: 7000/10000 = 70% // Team: 2000/10000 = 20% // Marketing: 1000/10000 = 10% Query Functions \u00b6 getFeeReceivers() \u00b6 function getFeeReceivers () external view override returns ( address [] memory feeReceivers , uint256 [] memory feeWeights ) Purpose : Returns the current fee receiver configuration. Returns : - feeReceivers (address[]): Array of fee recipient addresses - feeWeights (uint256[]): Array of corresponding weights Example Usage : ( address [] memory receivers , uint256 [] memory weights ) = IFeeDistributor ( diamond ). getFeeReceivers (); for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { console . log ( \"Receiver:\" , receivers [ i ]); console . log ( \"Weight:\" , weights [ i ]); } calculateAmounts() \u00b6 function calculateAmounts ( uint256 principalAmount ) external view override returns ( uint256 adjustedAmount , uint256 [] memory feeAmounts ) Purpose : Calculates fee distribution amounts without executing transfers. Parameters : - principalAmount (uint256): Total amount before fee deduction Returns : - adjustedAmount (uint256): Principal amount after deducting fees - feeAmounts (uint256[]): Individual fee amounts for each receiver Example Usage : // Calculate fees for a $1000 transaction uint256 totalAmount = 1000 * 10 ** 6 ; // 1000 USDC (6 decimals) ( uint256 adjustedAmount , uint256 [] memory feeAmounts ) = IFeeDistributor ( diamond ). calculateAmounts ( totalAmount ); console . log ( \"Amount after fees:\" , adjustedAmount ); console . log ( \"Treasury fee:\" , feeAmounts [ 0 ]); console . log ( \"Team fee:\" , feeAmounts [ 1 ]); console . log ( \"Marketing fee:\" , feeAmounts [ 2 ]); Calculation Logic : // Example with 1000 USDC and weights [7000, 2000, 1000] // Total fee weight: 10000 (100%) // Treasury fee: 1000 * 7000 / 10000 = 700 USDC // Team fee: 1000 * 2000 / 10000 = 200 USDC // Marketing fee: 1000 * 1000 / 10000 = 100 USDC // Adjusted amount: 1000 - (700 + 200 + 100) = 0 USDC Distribution Functions \u00b6 distributeAmounts() \u00b6 function distributeAmounts ( address principalAmountReceiver , uint256 _principalAmount ) external override returns ( address adjustedAmountReceiver , uint256 adjustedAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) Purpose : Executes fee distribution by transferring calculated amounts to recipients. Parameters : - principalAmountReceiver (address): Address to receive the adjusted principal amount - _principalAmount (uint256): Total amount to distribute Returns : - adjustedAmountReceiver (address): Address that received the adjusted amount - adjustedAmount (uint256): Adjusted principal amount transferred - feeReceivers (address[]): Addresses that received fee amounts - feeAmounts (uint256[]): Individual fee amounts transferred Access Control : Can be called by authorized contracts (marketplace, trade deals) Requirements : - Contract must have sufficient token balance or allowance - All recipient addresses must be valid - Distribution token must be properly configured Process : 1. Calculates fee amounts using internal logic 2. Transfers fees to each configured receiver 3. Transfers adjusted amount to principal receiver 4. Emits AmountsDistributed event 5. Returns distribution details Events : AmountsDistributed(principalReceiver, originalAmount, adjustedReceiver, adjustedAmount, feeReceivers, feeAmounts) Example Usage : // Distribute marketplace sale proceeds ( address adjustedReceiver , uint256 adjustedAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = IFeeDistributor ( diamond ). distributeAmounts ( sellerAddress , saleAmount ); console . log ( \"Seller received:\" , adjustedAmount ); console . log ( \"Fees distributed to\" , feeReceivers . length , \"recipients\" ); Integration Examples \u00b6 Marketplace Integration \u00b6 // Integrate fee distribution with marketplace sales contract MarketplaceIntegration { function completeSale ( uint256 tokenId , uint256 salePrice , address seller , address buyer ) external { // Transfer payment from buyer to contract IERC20 ( paymentToken ). transferFrom ( buyer , address ( this ), salePrice ); // Distribute fees and pay seller ( address adjustedReceiver , uint256 sellerAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = IFeeDistributor ( diamond ). distributeAmounts ( seller , salePrice ); // Transfer NFT to buyer IERC721 ( nftContract ). transferFrom ( seller , buyer , tokenId ); // Log the transaction emit SaleCompleted ( tokenId , salePrice , seller , buyer , sellerAmount , feeReceivers , feeAmounts ); } } Trade Deal Fee Distribution \u00b6 // Distribute trade deal fees and interest contract TradeDealFeeDistribution { function distributeInterestPayment ( uint256 tradeDealId , uint256 interestAmount , address borrower ) external { // Calculate and distribute fees from interest payment ( address adjustedReceiver , uint256 netInterest , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = IFeeDistributor ( diamond ). distributeAmounts ( getTradeDealLender ( tradeDealId ), interestAmount ); // Record interest distribution emit InterestDistributed ( tradeDealId , interestAmount , netInterest , feeReceivers , feeAmounts ); } } Dynamic Fee Configuration \u00b6 // Dynamically adjust fee structure based on conditions contract DynamicFeeManager { function updateFeeStructure ( uint256 marketCondition , uint256 volumeTier ) external onlyOwner { address [] memory receivers = new address []( 4 ); receivers [ 0 ] = treasuryAddress ; receivers [ 1 ] = teamAddress ; receivers [ 2 ] = marketingAddress ; receivers [ 3 ] = developmentAddress ; uint256 [] memory weights = new uint256 []( 4 ); if ( marketCondition == HIGH_VOLUME ) { // Reduce fees during high volume periods weights [ 0 ] = 5000 ; // 50% treasury weights [ 1 ] = 1500 ; // 15% team weights [ 2 ] = 1000 ; // 10% marketing weights [ 3 ] = 2500 ; // 25% development } else { // Standard fee structure weights [ 0 ] = 6000 ; // 60% treasury weights [ 1 ] = 2000 ; // 20% team weights [ 2 ] = 1000 ; // 10% marketing weights [ 3 ] = 1000 ; // 10% development } IFeeDistributor ( diamond ). setFeeReceivers ( receivers , weights ); } } Multi-Token Fee Distribution \u00b6 // Handle fee distribution for multiple tokens contract MultiTokenFeeDistribution { mapping ( address => bool ) public supportedTokens ; function distributeFees ( address token , uint256 amount , address principalReceiver ) external { require ( supportedTokens [ token ], \"Token not supported\" ); // Temporarily set distribution token if different address currentToken = getCurrentDistributionToken (); if ( currentToken != token ) { // Would need additional function to change distribution token // or handle multiple tokens in the fee distributor } IFeeDistributor ( diamond ). distributeAmounts ( principalReceiver , amount ); } } Fee Analytics and Reporting \u00b6 // Track and report fee distribution analytics contract FeeAnalytics { struct FeeReport { uint256 totalDistributed ; uint256 totalFees ; address [] recipients ; uint256 [] amounts ; uint256 timestamp ; } FeeReport [] public feeReports ; function recordFeeDistribution ( uint256 originalAmount , address principalReceiver ) external returns ( uint256 reportId ) { ( address adjustedReceiver , uint256 adjustedAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = IFeeDistributor ( diamond ). distributeAmounts ( principalReceiver , originalAmount ); uint256 totalFees = originalAmount - adjustedAmount ; feeReports . push ( FeeReport ({ totalDistributed : originalAmount , totalFees : totalFees , recipients : feeReceivers , amounts : feeAmounts , timestamp : block.timestamp })); return feeReports . length - 1 ; } function getFeeReport ( uint256 reportId ) external view returns ( FeeReport memory ) { require ( reportId < feeReports . length , \"Invalid report ID\" ); return feeReports [ reportId ]; } } Events \u00b6 Configuration Events \u00b6 event FeeDistributorInitialized ( address indexed distributionToken , uint256 totalWeightBasis ); event FeeReceiversSet ( address [] receivers , uint256 [] weights ); Distribution Events \u00b6 event AmountsDistributed ( address indexed principalReceiver , uint256 originalAmount , address indexed adjustedReceiver , uint256 adjustedAmount , address [] feeReceivers , uint256 [] feeAmounts ); Security Considerations \u00b6 Access Control \u00b6 Only contract owner can initialize and configure fee distribution Distribution function can be called by authorized contracts Validation of all addresses and amounts Financial Security \u00b6 Requires sufficient token balance or allowance for distributions Atomic transfers ensure all-or-nothing distribution Precise calculations prevent rounding errors Configuration Validation \u00b6 Prevents zero addresses in fee receivers Validates weight arrays match receiver arrays Ensures total weights don't exceed basis Gas Optimization \u00b6 Efficient Calculations \u00b6 Single-pass calculation of all fee amounts Minimal storage reads and writes Optimized array operations Batch Operations \u00b6 Single transaction for all fee distributions Reduced gas costs compared to individual transfers Efficient event emission Error Handling \u00b6 Configuration Errors \u00b6 \"FeeDistributor: Distribution token cannot be zero address\" - Invalid token Array length mismatch errors Invalid weight configuration errors Distribution Errors \u00b6 Insufficient balance or allowance errors Transfer failure errors Invalid recipient address errors Testing Considerations \u00b6 Unit Tests \u00b6 Fee calculation accuracy Distribution execution Configuration validation Access control enforcement Integration Tests \u00b6 Marketplace integration Trade deal integration Multi-contract workflows Event emission verification Related Documentation \u00b6 IFeeDistributor - Fee distributor interface FeeDistributorLib - Fee distribution utilities MarketplaceFacet - Marketplace integration TradeDealManagementFacet - Trade deal integration Revenue Sharing Guide - Implementation guide This facet provides the foundation for flexible and transparent fee distribution within the Gemforce platform, enabling complex revenue sharing models and automated fee management across all platform operations.","title":"Fee Distributor Facet"},{"location":"smart-contracts/facets/fee-distributor-facet/#feedistributorfacet","text":"","title":"FeeDistributorFacet"},{"location":"smart-contracts/facets/fee-distributor-facet/#overview","text":"The FeeDistributorFacet.sol provides comprehensive fee distribution functionality within the Gemforce diamond system. This facet enables automated distribution of fees and revenues to multiple recipients based on configurable weights, supporting complex revenue sharing models for marketplace operations, trade deals, and other platform activities.","title":"Overview"},{"location":"smart-contracts/facets/fee-distributor-facet/#contract-details","text":"Contract Name : FeeDistributorFacet Inheritance : IFeeDistributor , Modifiers License : MIT Solidity Version : ^0.8.0","title":"Contract Details"},{"location":"smart-contracts/facets/fee-distributor-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/fee-distributor-facet/#flexible-fee-distribution","text":"Configure multiple fee recipients with custom weights Proportional distribution based on weight ratios Support for any ERC20 token distribution Automated calculation and distribution","title":"\ud83d\udd39 Flexible Fee Distribution"},{"location":"smart-contracts/facets/fee-distributor-facet/#revenue-sharing-models","text":"Marketplace commission distribution Trade deal fee sharing Platform revenue allocation Partner revenue sharing","title":"\ud83d\udd39 Revenue Sharing Models"},{"location":"smart-contracts/facets/fee-distributor-facet/#transparent-calculations","text":"View-only calculation functions Precise fee amount calculations Adjustable weight basis for flexibility Real-time distribution previews","title":"\ud83d\udd39 Transparent Calculations"},{"location":"smart-contracts/facets/fee-distributor-facet/#secure-operations","text":"Owner-only configuration functions Validation of all parameters Event logging for transparency Integration with diamond access control","title":"\ud83d\udd39 Secure Operations"},{"location":"smart-contracts/facets/fee-distributor-facet/#core-data-structures","text":"","title":"Core Data Structures"},{"location":"smart-contracts/facets/fee-distributor-facet/#fee-distribution-configuration","text":"Distribution Token : ERC20 token used for fee payments (e.g., USDC) Total Weight Basis : Denominator for weight calculations (e.g., 10000 for basis points) Fee Receivers : Array of addresses that receive fee distributions Fee Weights : Corresponding weights for each receiver","title":"Fee Distribution Configuration"},{"location":"smart-contracts/facets/fee-distributor-facet/#storage-pattern","text":"Uses diamond storage pattern via FeeDistributorLib : - Prevents storage collisions in diamond architecture - Efficient storage of fee configuration - Persistent settings across contract upgrades","title":"Storage Pattern"},{"location":"smart-contracts/facets/fee-distributor-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/fee-distributor-facet/#initialization-functions","text":"","title":"Initialization Functions"},{"location":"smart-contracts/facets/fee-distributor-facet/#initializefeedistributor","text":"function initializeFeeDistributor ( address _distributionToken , uint256 _totalWeightBasis ) external onlyOwner Purpose : Initializes the fee distributor with token and weight basis configuration. Parameters : - _distributionToken (address): ERC20 token address for fee distributions - _totalWeightBasis (uint256): Total weight basis for calculations (e.g., 10000) Access Control : Owner only Validation : - Distribution token cannot be zero address - Total weight basis must be greater than zero - Can only be called once during deployment Process : 1. Validates input parameters 2. Initializes fee distributor storage 3. Sets distribution token and weight basis 4. Emits FeeDistributorInitialized event Events : FeeDistributorInitialized(distributionToken, totalWeightBasis) Example Usage : // Initialize with USDC and basis points (10000) IFeeDistributor ( diamond ). initializeFeeDistributor ( usdcAddress , 10000 // 10000 basis points = 100% ); Error Conditions : - \"FeeDistributor: Distribution token cannot be zero address\" - Invalid token address - Already initialized error from library","title":"initializeFeeDistributor()"},{"location":"smart-contracts/facets/fee-distributor-facet/#configuration-functions","text":"","title":"Configuration Functions"},{"location":"smart-contracts/facets/fee-distributor-facet/#setfeereceivers","text":"function setFeeReceivers ( address [] calldata _feeReceivers , uint256 [] calldata _feeWeights ) external override onlyOwner Purpose : Configures the addresses and weights for fee distribution. Parameters : - _feeReceivers (address[]): Array of addresses to receive fees - _feeWeights (uint256[]): Array of weights corresponding to each receiver Access Control : Owner only Validation : - Arrays must have equal length - No zero addresses in receivers - Weights must be greater than zero - Total weights should not exceed weight basis Process : 1. Validates input arrays 2. Updates fee receiver configuration 3. Stores receivers and weights 4. Emits FeeReceiversSet event Events : FeeReceiversSet(receivers, weights) Example Usage : // Set up fee distribution: 70% to treasury, 20% to team, 10% to marketing address [] memory receivers = new address []( 3 ); receivers [ 0 ] = treasuryAddress ; receivers [ 1 ] = teamAddress ; receivers [ 2 ] = marketingAddress ; uint256 [] memory weights = new uint256 []( 3 ); weights [ 0 ] = 7000 ; // 70% weights [ 1 ] = 2000 ; // 20% weights [ 2 ] = 1000 ; // 10% IFeeDistributor ( diamond ). setFeeReceivers ( receivers , weights ); Weight Calculation Example : // With totalWeightBasis = 10000 // Treasury: 7000/10000 = 70% // Team: 2000/10000 = 20% // Marketing: 1000/10000 = 10%","title":"setFeeReceivers()"},{"location":"smart-contracts/facets/fee-distributor-facet/#query-functions","text":"","title":"Query Functions"},{"location":"smart-contracts/facets/fee-distributor-facet/#getfeereceivers","text":"function getFeeReceivers () external view override returns ( address [] memory feeReceivers , uint256 [] memory feeWeights ) Purpose : Returns the current fee receiver configuration. Returns : - feeReceivers (address[]): Array of fee recipient addresses - feeWeights (uint256[]): Array of corresponding weights Example Usage : ( address [] memory receivers , uint256 [] memory weights ) = IFeeDistributor ( diamond ). getFeeReceivers (); for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { console . log ( \"Receiver:\" , receivers [ i ]); console . log ( \"Weight:\" , weights [ i ]); }","title":"getFeeReceivers()"},{"location":"smart-contracts/facets/fee-distributor-facet/#calculateamounts","text":"function calculateAmounts ( uint256 principalAmount ) external view override returns ( uint256 adjustedAmount , uint256 [] memory feeAmounts ) Purpose : Calculates fee distribution amounts without executing transfers. Parameters : - principalAmount (uint256): Total amount before fee deduction Returns : - adjustedAmount (uint256): Principal amount after deducting fees - feeAmounts (uint256[]): Individual fee amounts for each receiver Example Usage : // Calculate fees for a $1000 transaction uint256 totalAmount = 1000 * 10 ** 6 ; // 1000 USDC (6 decimals) ( uint256 adjustedAmount , uint256 [] memory feeAmounts ) = IFeeDistributor ( diamond ). calculateAmounts ( totalAmount ); console . log ( \"Amount after fees:\" , adjustedAmount ); console . log ( \"Treasury fee:\" , feeAmounts [ 0 ]); console . log ( \"Team fee:\" , feeAmounts [ 1 ]); console . log ( \"Marketing fee:\" , feeAmounts [ 2 ]); Calculation Logic : // Example with 1000 USDC and weights [7000, 2000, 1000] // Total fee weight: 10000 (100%) // Treasury fee: 1000 * 7000 / 10000 = 700 USDC // Team fee: 1000 * 2000 / 10000 = 200 USDC // Marketing fee: 1000 * 1000 / 10000 = 100 USDC // Adjusted amount: 1000 - (700 + 200 + 100) = 0 USDC","title":"calculateAmounts()"},{"location":"smart-contracts/facets/fee-distributor-facet/#distribution-functions","text":"","title":"Distribution Functions"},{"location":"smart-contracts/facets/fee-distributor-facet/#distributeamounts","text":"function distributeAmounts ( address principalAmountReceiver , uint256 _principalAmount ) external override returns ( address adjustedAmountReceiver , uint256 adjustedAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) Purpose : Executes fee distribution by transferring calculated amounts to recipients. Parameters : - principalAmountReceiver (address): Address to receive the adjusted principal amount - _principalAmount (uint256): Total amount to distribute Returns : - adjustedAmountReceiver (address): Address that received the adjusted amount - adjustedAmount (uint256): Adjusted principal amount transferred - feeReceivers (address[]): Addresses that received fee amounts - feeAmounts (uint256[]): Individual fee amounts transferred Access Control : Can be called by authorized contracts (marketplace, trade deals) Requirements : - Contract must have sufficient token balance or allowance - All recipient addresses must be valid - Distribution token must be properly configured Process : 1. Calculates fee amounts using internal logic 2. Transfers fees to each configured receiver 3. Transfers adjusted amount to principal receiver 4. Emits AmountsDistributed event 5. Returns distribution details Events : AmountsDistributed(principalReceiver, originalAmount, adjustedReceiver, adjustedAmount, feeReceivers, feeAmounts) Example Usage : // Distribute marketplace sale proceeds ( address adjustedReceiver , uint256 adjustedAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = IFeeDistributor ( diamond ). distributeAmounts ( sellerAddress , saleAmount ); console . log ( \"Seller received:\" , adjustedAmount ); console . log ( \"Fees distributed to\" , feeReceivers . length , \"recipients\" );","title":"distributeAmounts()"},{"location":"smart-contracts/facets/fee-distributor-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/facets/fee-distributor-facet/#marketplace-integration","text":"// Integrate fee distribution with marketplace sales contract MarketplaceIntegration { function completeSale ( uint256 tokenId , uint256 salePrice , address seller , address buyer ) external { // Transfer payment from buyer to contract IERC20 ( paymentToken ). transferFrom ( buyer , address ( this ), salePrice ); // Distribute fees and pay seller ( address adjustedReceiver , uint256 sellerAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = IFeeDistributor ( diamond ). distributeAmounts ( seller , salePrice ); // Transfer NFT to buyer IERC721 ( nftContract ). transferFrom ( seller , buyer , tokenId ); // Log the transaction emit SaleCompleted ( tokenId , salePrice , seller , buyer , sellerAmount , feeReceivers , feeAmounts ); } }","title":"Marketplace Integration"},{"location":"smart-contracts/facets/fee-distributor-facet/#trade-deal-fee-distribution","text":"// Distribute trade deal fees and interest contract TradeDealFeeDistribution { function distributeInterestPayment ( uint256 tradeDealId , uint256 interestAmount , address borrower ) external { // Calculate and distribute fees from interest payment ( address adjustedReceiver , uint256 netInterest , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = IFeeDistributor ( diamond ). distributeAmounts ( getTradeDealLender ( tradeDealId ), interestAmount ); // Record interest distribution emit InterestDistributed ( tradeDealId , interestAmount , netInterest , feeReceivers , feeAmounts ); } }","title":"Trade Deal Fee Distribution"},{"location":"smart-contracts/facets/fee-distributor-facet/#dynamic-fee-configuration","text":"// Dynamically adjust fee structure based on conditions contract DynamicFeeManager { function updateFeeStructure ( uint256 marketCondition , uint256 volumeTier ) external onlyOwner { address [] memory receivers = new address []( 4 ); receivers [ 0 ] = treasuryAddress ; receivers [ 1 ] = teamAddress ; receivers [ 2 ] = marketingAddress ; receivers [ 3 ] = developmentAddress ; uint256 [] memory weights = new uint256 []( 4 ); if ( marketCondition == HIGH_VOLUME ) { // Reduce fees during high volume periods weights [ 0 ] = 5000 ; // 50% treasury weights [ 1 ] = 1500 ; // 15% team weights [ 2 ] = 1000 ; // 10% marketing weights [ 3 ] = 2500 ; // 25% development } else { // Standard fee structure weights [ 0 ] = 6000 ; // 60% treasury weights [ 1 ] = 2000 ; // 20% team weights [ 2 ] = 1000 ; // 10% marketing weights [ 3 ] = 1000 ; // 10% development } IFeeDistributor ( diamond ). setFeeReceivers ( receivers , weights ); } }","title":"Dynamic Fee Configuration"},{"location":"smart-contracts/facets/fee-distributor-facet/#multi-token-fee-distribution","text":"// Handle fee distribution for multiple tokens contract MultiTokenFeeDistribution { mapping ( address => bool ) public supportedTokens ; function distributeFees ( address token , uint256 amount , address principalReceiver ) external { require ( supportedTokens [ token ], \"Token not supported\" ); // Temporarily set distribution token if different address currentToken = getCurrentDistributionToken (); if ( currentToken != token ) { // Would need additional function to change distribution token // or handle multiple tokens in the fee distributor } IFeeDistributor ( diamond ). distributeAmounts ( principalReceiver , amount ); } }","title":"Multi-Token Fee Distribution"},{"location":"smart-contracts/facets/fee-distributor-facet/#fee-analytics-and-reporting","text":"// Track and report fee distribution analytics contract FeeAnalytics { struct FeeReport { uint256 totalDistributed ; uint256 totalFees ; address [] recipients ; uint256 [] amounts ; uint256 timestamp ; } FeeReport [] public feeReports ; function recordFeeDistribution ( uint256 originalAmount , address principalReceiver ) external returns ( uint256 reportId ) { ( address adjustedReceiver , uint256 adjustedAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = IFeeDistributor ( diamond ). distributeAmounts ( principalReceiver , originalAmount ); uint256 totalFees = originalAmount - adjustedAmount ; feeReports . push ( FeeReport ({ totalDistributed : originalAmount , totalFees : totalFees , recipients : feeReceivers , amounts : feeAmounts , timestamp : block.timestamp })); return feeReports . length - 1 ; } function getFeeReport ( uint256 reportId ) external view returns ( FeeReport memory ) { require ( reportId < feeReports . length , \"Invalid report ID\" ); return feeReports [ reportId ]; } }","title":"Fee Analytics and Reporting"},{"location":"smart-contracts/facets/fee-distributor-facet/#events","text":"","title":"Events"},{"location":"smart-contracts/facets/fee-distributor-facet/#configuration-events","text":"event FeeDistributorInitialized ( address indexed distributionToken , uint256 totalWeightBasis ); event FeeReceiversSet ( address [] receivers , uint256 [] weights );","title":"Configuration Events"},{"location":"smart-contracts/facets/fee-distributor-facet/#distribution-events","text":"event AmountsDistributed ( address indexed principalReceiver , uint256 originalAmount , address indexed adjustedReceiver , uint256 adjustedAmount , address [] feeReceivers , uint256 [] feeAmounts );","title":"Distribution Events"},{"location":"smart-contracts/facets/fee-distributor-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/fee-distributor-facet/#access-control","text":"Only contract owner can initialize and configure fee distribution Distribution function can be called by authorized contracts Validation of all addresses and amounts","title":"Access Control"},{"location":"smart-contracts/facets/fee-distributor-facet/#financial-security","text":"Requires sufficient token balance or allowance for distributions Atomic transfers ensure all-or-nothing distribution Precise calculations prevent rounding errors","title":"Financial Security"},{"location":"smart-contracts/facets/fee-distributor-facet/#configuration-validation","text":"Prevents zero addresses in fee receivers Validates weight arrays match receiver arrays Ensures total weights don't exceed basis","title":"Configuration Validation"},{"location":"smart-contracts/facets/fee-distributor-facet/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/facets/fee-distributor-facet/#efficient-calculations","text":"Single-pass calculation of all fee amounts Minimal storage reads and writes Optimized array operations","title":"Efficient Calculations"},{"location":"smart-contracts/facets/fee-distributor-facet/#batch-operations","text":"Single transaction for all fee distributions Reduced gas costs compared to individual transfers Efficient event emission","title":"Batch Operations"},{"location":"smart-contracts/facets/fee-distributor-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/fee-distributor-facet/#configuration-errors","text":"\"FeeDistributor: Distribution token cannot be zero address\" - Invalid token Array length mismatch errors Invalid weight configuration errors","title":"Configuration Errors"},{"location":"smart-contracts/facets/fee-distributor-facet/#distribution-errors","text":"Insufficient balance or allowance errors Transfer failure errors Invalid recipient address errors","title":"Distribution Errors"},{"location":"smart-contracts/facets/fee-distributor-facet/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/facets/fee-distributor-facet/#unit-tests","text":"Fee calculation accuracy Distribution execution Configuration validation Access control enforcement","title":"Unit Tests"},{"location":"smart-contracts/facets/fee-distributor-facet/#integration-tests","text":"Marketplace integration Trade deal integration Multi-contract workflows Event emission verification","title":"Integration Tests"},{"location":"smart-contracts/facets/fee-distributor-facet/#related-documentation","text":"IFeeDistributor - Fee distributor interface FeeDistributorLib - Fee distribution utilities MarketplaceFacet - Marketplace integration TradeDealManagementFacet - Trade deal integration Revenue Sharing Guide - Implementation guide This facet provides the foundation for flexible and transparent fee distribution within the Gemforce platform, enabling complex revenue sharing models and automated fee management across all platform operations.","title":"Related Documentation"},{"location":"smart-contracts/facets/gemforce-minter-facet/","text":"GemforceMinterFacet \u00b6 Overview \u00b6 The GemforceMinterFacet.sol provides specialized token minting functionality within the Gemforce diamond system. This facet enables the creation of NFTs with customizable attributes in a single transaction, supporting rich metadata and flexible token properties for various use cases including environmental assets, trade deals, and marketplace items. Contract Details \u00b6 Contract Name : GemforceMinterFacet Inheritance : Modifiers , IGemforceMinterFacet License : MIT Solidity Version : ^0.8.6 Key Features \u00b6 \ud83d\udd39 Attribute-Rich Token Minting \u00b6 Mint tokens with custom attributes in single transaction Flexible metadata system using trait types and values Support for complex token properties and characteristics Efficient batch attribute assignment \ud83d\udd39 Diamond Integration \u00b6 Seamless integration with diamond storage pattern Access to identity system for token management Consistent token ID generation and tracking Event-driven architecture for transparency \ud83d\udd39 Owner-Controlled Minting \u00b6 Secure owner-only minting functionality Controlled token supply management Administrative oversight of token creation Integration with access control systems \ud83d\udd39 Metadata Management \u00b6 Rich attribute system for token metadata Support for various data types and formats Extensible attribute framework On-chain metadata storage Core Data Structures \u00b6 Attribute Structure \u00b6 struct Attribute { string traitType ; // The type/category of the attribute string value ; // The value of the attribute } Storage Integration \u00b6 Identity System Storage : Token state and ownership management Attribute Storage : Token metadata and attribute management Diamond Storage : Persistent storage across contract upgrades Core Functions \u00b6 Token Minting Functions \u00b6 gemforceMint() \u00b6 function gemforceMint ( Attribute [] memory metadata ) external override onlyOwner returns ( uint256 ) Purpose : Mints a new token with customizable attributes in a single transaction. Parameters : - metadata (Attribute[]): Array of attribute structs to assign to the token Returns : - tokenId (uint256): ID of the newly minted token Access Control : Owner only Process : 1. Gets next available token ID from identity system 2. Emits GemforceMinted event before state changes 3. Mints token to the caller (owner) 4. Assigns all specified attributes to the token 5. Returns the new token ID Events : GemforceMinted(tokenId, recipient, metadata) Example Usage : // Mint environmental asset NFT with attributes Attribute [] memory attributes = new Attribute []( 5 ); attributes [ 0 ] = Attribute ( \"Asset Type\" , \"Carbon Credit\" ); attributes [ 1 ] = Attribute ( \"Project\" , \"Amazon Rainforest Conservation\" ); attributes [ 2 ] = Attribute ( \"Credits\" , \"1000\" ); attributes [ 3 ] = Attribute ( \"Vintage\" , \"2024\" ); attributes [ 4 ] = Attribute ( \"Standard\" , \"VCS\" ); uint256 tokenId = IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); console . log ( \"Minted environmental asset with ID:\" , tokenId ); Gas Optimization : Single transaction for minting and attribute assignment reduces gas costs compared to separate operations. Security Features : - Owner-only access prevents unauthorized minting - Event emission before state changes ensures transparency - Atomic operation ensures all-or-nothing minting Integration Examples \u00b6 Environmental Asset Minting \u00b6 // Mint carbon credit NFTs with environmental attributes contract EnvironmentalAssetMinter { function mintCarbonCreditAsset ( string memory projectName , uint256 creditAmount , string memory vintage , string memory standard , string memory location ) external onlyAuthorized returns ( uint256 ) { Attribute [] memory attributes = new Attribute []( 6 ); attributes [ 0 ] = Attribute ( \"Asset Type\" , \"Carbon Credit\" ); attributes [ 1 ] = Attribute ( \"Project\" , projectName ); attributes [ 2 ] = Attribute ( \"Credits\" , creditAmount . toString ()); attributes [ 3 ] = Attribute ( \"Vintage\" , vintage ); attributes [ 4 ] = Attribute ( \"Standard\" , standard ); attributes [ 5 ] = Attribute ( \"Location\" , location ); uint256 tokenId = IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); // Initialize carbon credits for the token ICarbonCredit ( diamond ). initializeCarbonCredit ( tokenId , creditAmount ); return tokenId ; } } Trade Deal Collateral Minting \u00b6 // Mint collateral tokens for trade deals contract TradeDealCollateralMinter { function mintCollateralToken ( uint256 tradeDealId , string memory collateralType , uint256 value , string memory description ) external onlyTradeDealManager returns ( uint256 ) { Attribute [] memory attributes = new Attribute []( 5 ); attributes [ 0 ] = Attribute ( \"Asset Type\" , \"Trade Deal Collateral\" ); attributes [ 1 ] = Attribute ( \"Trade Deal ID\" , tradeDealId . toString ()); attributes [ 2 ] = Attribute ( \"Collateral Type\" , collateralType ); attributes [ 3 ] = Attribute ( \"Value\" , value . toString ()); attributes [ 4 ] = Attribute ( \"Description\" , description ); uint256 tokenId = IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); // Link token to trade deal ITradeDeal ( diamond ). addCollateralToken ( tradeDealId , tokenId ); return tokenId ; } } Marketplace Item Minting \u00b6 // Mint marketplace items with rich metadata contract MarketplaceItemMinter { function mintMarketplaceItem ( string memory itemName , string memory category , string memory description , string memory imageURI , uint256 price ) external onlyMerchant returns ( uint256 ) { Attribute [] memory attributes = new Attribute []( 6 ); attributes [ 0 ] = Attribute ( \"Item Type\" , \"Marketplace Item\" ); attributes [ 1 ] = Attribute ( \"Name\" , itemName ); attributes [ 2 ] = Attribute ( \"Category\" , category ); attributes [ 3 ] = Attribute ( \"Description\" , description ); attributes [ 4 ] = Attribute ( \"Image\" , imageURI ); attributes [ 5 ] = Attribute ( \"Price\" , price . toString ()); uint256 tokenId = IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); // List item on marketplace IMarketplace ( diamond ). listItem ( address ( 0 ), payable ( msg.sender ), tokenId , price , false , address ( 0 ) ); return tokenId ; } } Batch Minting System \u00b6 // Efficient batch minting for multiple tokens contract BatchMintingSystem { function batchMintTokens ( Attribute [][] memory tokenAttributes ) external onlyOwner returns ( uint256 [] memory ) { uint256 [] memory tokenIds = new uint256 []( tokenAttributes . length ); for ( uint256 i = 0 ; i < tokenAttributes . length ; i ++ ) { tokenIds [ i ] = IGemforceMinterFacet ( diamond ). gemforceMint ( tokenAttributes [ i ] ); } return tokenIds ; } function mintTokenCollection ( string memory collectionName , string memory baseImageURI , uint256 quantity ) external onlyOwner returns ( uint256 [] memory ) { uint256 [] memory tokenIds = new uint256 []( quantity ); for ( uint256 i = 0 ; i < quantity ; i ++ ) { Attribute [] memory attributes = new Attribute []( 4 ); attributes [ 0 ] = Attribute ( \"Collection\" , collectionName ); attributes [ 1 ] = Attribute ( \"Edition\" , ( i + 1 ). toString ()); attributes [ 2 ] = Attribute ( \"Total Supply\" , quantity . toString ()); attributes [ 3 ] = Attribute ( \"Image\" , string ( abi . encodePacked ( baseImageURI , ( i + 1 ). toString ()))); tokenIds [ i ] = IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); } return tokenIds ; } } Dynamic Attribute Minting \u00b6 // Mint tokens with dynamic attributes based on conditions contract DynamicAttributeMinter { function mintDynamicToken ( string memory tokenType , uint256 rarity , bool isSpecial ) external onlyOwner returns ( uint256 ) { // Base attributes Attribute [] memory attributes = new Attribute []( isSpecial ? 6 : 4 ); attributes [ 0 ] = Attribute ( \"Type\" , tokenType ); attributes [ 1 ] = Attribute ( \"Rarity\" , getRarityString ( rarity )); attributes [ 2 ] = Attribute ( \"Minted At\" , block.timestamp . toString ()); attributes [ 3 ] = Attribute ( \"Minted By\" , \"Gemforce System\" ); // Add special attributes if applicable if ( isSpecial ) { attributes [ 4 ] = Attribute ( \"Special\" , \"true\" ); attributes [ 5 ] = Attribute ( \"Special Type\" , getSpecialType ( rarity )); } uint256 tokenId = IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); // Apply special properties if needed if ( isSpecial ) { applySpecialProperties ( tokenId , rarity ); } return tokenId ; } function getRarityString ( uint256 rarity ) internal pure returns ( string memory ) { if ( rarity >= 90 ) return \"Legendary\" ; if ( rarity >= 70 ) return \"Epic\" ; if ( rarity >= 50 ) return \"Rare\" ; if ( rarity >= 30 ) return \"Uncommon\" ; return \"Common\" ; } function getSpecialType ( uint256 rarity ) internal pure returns ( string memory ) { if ( rarity >= 95 ) return \"Mythic\" ; if ( rarity >= 90 ) return \"Legendary\" ; return \"Special Edition\" ; } } Metadata Validation System \u00b6 // Validate and standardize metadata before minting contract MetadataValidationMinter { mapping ( string => bool ) public validTraitTypes ; mapping ( string => string []) public validTraitValues ; function setValidTraitTypes ( string [] memory traitTypes ) external onlyOwner { for ( uint256 i = 0 ; i < traitTypes . length ; i ++ ) { validTraitTypes [ traitTypes [ i ]] = true ; } } function setValidTraitValues ( string memory traitType , string [] memory values ) external onlyOwner { validTraitValues [ traitType ] = values ; } function mintValidatedToken ( Attribute [] memory attributes ) external onlyOwner returns ( uint256 ) { // Validate all attributes for ( uint256 i = 0 ; i < attributes . length ; i ++ ) { require ( validTraitTypes [ attributes [ i ]. traitType ], \"Invalid trait type\" ); // Validate trait values if specified string [] memory validValues = validTraitValues [ attributes [ i ]. traitType ]; if ( validValues . length > 0 ) { bool isValid = false ; for ( uint256 j = 0 ; j < validValues . length ; j ++ ) { if ( keccak256 ( bytes ( validValues [ j ])) == keccak256 ( bytes ( attributes [ i ]. value ))) { isValid = true ; break ; } } require ( isValid , \"Invalid trait value\" ); } } return IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); } } Events \u00b6 Minting Events \u00b6 event GemforceMinted ( uint256 indexed tokenId , address indexed recipient , Attribute [] metadata ); Event Details : - tokenId : ID of the newly minted token - recipient : Address that received the token (always the owner) - metadata : Array of attributes assigned to the token Security Considerations \u00b6 Access Control \u00b6 Only contract owner can mint tokens Prevents unauthorized token creation Integration with diamond access control system Data Integrity \u00b6 Atomic minting and attribute assignment Event emission before state changes Consistent token ID generation Attribute Validation \u00b6 Flexible attribute system supports various data types On-chain storage ensures data persistence Integration with attribute library for consistency Gas Optimization \u00b6 Single Transaction Minting \u00b6 Combines token minting and attribute assignment Reduces gas costs compared to separate operations Efficient batch attribute processing Storage Efficiency \u00b6 Uses diamond storage pattern for optimal storage Minimal storage footprint per token Efficient attribute storage through library Error Handling \u00b6 Access Control Errors \u00b6 Owner-only function restrictions Unauthorized access prevention Minting Errors \u00b6 Token creation failures Attribute assignment failures Storage operation errors Testing Considerations \u00b6 Unit Tests \u00b6 Token minting functionality Attribute assignment accuracy Access control validation Event emission verification Integration Tests \u00b6 Diamond storage integration Attribute library integration Multi-facet workflows Gas optimization validation Related Documentation \u00b6 IGemforceMinterFacet - Minter interface AttributeLib - Attribute management library IdentitySystemStorage - Storage library CarbonCreditFacet - Environmental asset integration MarketplaceFacet - Marketplace integration Token Minting Guide - Implementation guide This facet provides the foundation for creating rich, attribute-enabled NFTs within the Gemforce platform, supporting diverse use cases from environmental assets to marketplace items with comprehensive metadata management.","title":"Gemforce Minter Facet"},{"location":"smart-contracts/facets/gemforce-minter-facet/#gemforceminterfacet","text":"","title":"GemforceMinterFacet"},{"location":"smart-contracts/facets/gemforce-minter-facet/#overview","text":"The GemforceMinterFacet.sol provides specialized token minting functionality within the Gemforce diamond system. This facet enables the creation of NFTs with customizable attributes in a single transaction, supporting rich metadata and flexible token properties for various use cases including environmental assets, trade deals, and marketplace items.","title":"Overview"},{"location":"smart-contracts/facets/gemforce-minter-facet/#contract-details","text":"Contract Name : GemforceMinterFacet Inheritance : Modifiers , IGemforceMinterFacet License : MIT Solidity Version : ^0.8.6","title":"Contract Details"},{"location":"smart-contracts/facets/gemforce-minter-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/gemforce-minter-facet/#attribute-rich-token-minting","text":"Mint tokens with custom attributes in single transaction Flexible metadata system using trait types and values Support for complex token properties and characteristics Efficient batch attribute assignment","title":"\ud83d\udd39 Attribute-Rich Token Minting"},{"location":"smart-contracts/facets/gemforce-minter-facet/#diamond-integration","text":"Seamless integration with diamond storage pattern Access to identity system for token management Consistent token ID generation and tracking Event-driven architecture for transparency","title":"\ud83d\udd39 Diamond Integration"},{"location":"smart-contracts/facets/gemforce-minter-facet/#owner-controlled-minting","text":"Secure owner-only minting functionality Controlled token supply management Administrative oversight of token creation Integration with access control systems","title":"\ud83d\udd39 Owner-Controlled Minting"},{"location":"smart-contracts/facets/gemforce-minter-facet/#metadata-management","text":"Rich attribute system for token metadata Support for various data types and formats Extensible attribute framework On-chain metadata storage","title":"\ud83d\udd39 Metadata Management"},{"location":"smart-contracts/facets/gemforce-minter-facet/#core-data-structures","text":"","title":"Core Data Structures"},{"location":"smart-contracts/facets/gemforce-minter-facet/#attribute-structure","text":"struct Attribute { string traitType ; // The type/category of the attribute string value ; // The value of the attribute }","title":"Attribute Structure"},{"location":"smart-contracts/facets/gemforce-minter-facet/#storage-integration","text":"Identity System Storage : Token state and ownership management Attribute Storage : Token metadata and attribute management Diamond Storage : Persistent storage across contract upgrades","title":"Storage Integration"},{"location":"smart-contracts/facets/gemforce-minter-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/gemforce-minter-facet/#token-minting-functions","text":"","title":"Token Minting Functions"},{"location":"smart-contracts/facets/gemforce-minter-facet/#gemforcemint","text":"function gemforceMint ( Attribute [] memory metadata ) external override onlyOwner returns ( uint256 ) Purpose : Mints a new token with customizable attributes in a single transaction. Parameters : - metadata (Attribute[]): Array of attribute structs to assign to the token Returns : - tokenId (uint256): ID of the newly minted token Access Control : Owner only Process : 1. Gets next available token ID from identity system 2. Emits GemforceMinted event before state changes 3. Mints token to the caller (owner) 4. Assigns all specified attributes to the token 5. Returns the new token ID Events : GemforceMinted(tokenId, recipient, metadata) Example Usage : // Mint environmental asset NFT with attributes Attribute [] memory attributes = new Attribute []( 5 ); attributes [ 0 ] = Attribute ( \"Asset Type\" , \"Carbon Credit\" ); attributes [ 1 ] = Attribute ( \"Project\" , \"Amazon Rainforest Conservation\" ); attributes [ 2 ] = Attribute ( \"Credits\" , \"1000\" ); attributes [ 3 ] = Attribute ( \"Vintage\" , \"2024\" ); attributes [ 4 ] = Attribute ( \"Standard\" , \"VCS\" ); uint256 tokenId = IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); console . log ( \"Minted environmental asset with ID:\" , tokenId ); Gas Optimization : Single transaction for minting and attribute assignment reduces gas costs compared to separate operations. Security Features : - Owner-only access prevents unauthorized minting - Event emission before state changes ensures transparency - Atomic operation ensures all-or-nothing minting","title":"gemforceMint()"},{"location":"smart-contracts/facets/gemforce-minter-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/facets/gemforce-minter-facet/#environmental-asset-minting","text":"// Mint carbon credit NFTs with environmental attributes contract EnvironmentalAssetMinter { function mintCarbonCreditAsset ( string memory projectName , uint256 creditAmount , string memory vintage , string memory standard , string memory location ) external onlyAuthorized returns ( uint256 ) { Attribute [] memory attributes = new Attribute []( 6 ); attributes [ 0 ] = Attribute ( \"Asset Type\" , \"Carbon Credit\" ); attributes [ 1 ] = Attribute ( \"Project\" , projectName ); attributes [ 2 ] = Attribute ( \"Credits\" , creditAmount . toString ()); attributes [ 3 ] = Attribute ( \"Vintage\" , vintage ); attributes [ 4 ] = Attribute ( \"Standard\" , standard ); attributes [ 5 ] = Attribute ( \"Location\" , location ); uint256 tokenId = IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); // Initialize carbon credits for the token ICarbonCredit ( diamond ). initializeCarbonCredit ( tokenId , creditAmount ); return tokenId ; } }","title":"Environmental Asset Minting"},{"location":"smart-contracts/facets/gemforce-minter-facet/#trade-deal-collateral-minting","text":"// Mint collateral tokens for trade deals contract TradeDealCollateralMinter { function mintCollateralToken ( uint256 tradeDealId , string memory collateralType , uint256 value , string memory description ) external onlyTradeDealManager returns ( uint256 ) { Attribute [] memory attributes = new Attribute []( 5 ); attributes [ 0 ] = Attribute ( \"Asset Type\" , \"Trade Deal Collateral\" ); attributes [ 1 ] = Attribute ( \"Trade Deal ID\" , tradeDealId . toString ()); attributes [ 2 ] = Attribute ( \"Collateral Type\" , collateralType ); attributes [ 3 ] = Attribute ( \"Value\" , value . toString ()); attributes [ 4 ] = Attribute ( \"Description\" , description ); uint256 tokenId = IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); // Link token to trade deal ITradeDeal ( diamond ). addCollateralToken ( tradeDealId , tokenId ); return tokenId ; } }","title":"Trade Deal Collateral Minting"},{"location":"smart-contracts/facets/gemforce-minter-facet/#marketplace-item-minting","text":"// Mint marketplace items with rich metadata contract MarketplaceItemMinter { function mintMarketplaceItem ( string memory itemName , string memory category , string memory description , string memory imageURI , uint256 price ) external onlyMerchant returns ( uint256 ) { Attribute [] memory attributes = new Attribute []( 6 ); attributes [ 0 ] = Attribute ( \"Item Type\" , \"Marketplace Item\" ); attributes [ 1 ] = Attribute ( \"Name\" , itemName ); attributes [ 2 ] = Attribute ( \"Category\" , category ); attributes [ 3 ] = Attribute ( \"Description\" , description ); attributes [ 4 ] = Attribute ( \"Image\" , imageURI ); attributes [ 5 ] = Attribute ( \"Price\" , price . toString ()); uint256 tokenId = IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); // List item on marketplace IMarketplace ( diamond ). listItem ( address ( 0 ), payable ( msg.sender ), tokenId , price , false , address ( 0 ) ); return tokenId ; } }","title":"Marketplace Item Minting"},{"location":"smart-contracts/facets/gemforce-minter-facet/#batch-minting-system","text":"// Efficient batch minting for multiple tokens contract BatchMintingSystem { function batchMintTokens ( Attribute [][] memory tokenAttributes ) external onlyOwner returns ( uint256 [] memory ) { uint256 [] memory tokenIds = new uint256 []( tokenAttributes . length ); for ( uint256 i = 0 ; i < tokenAttributes . length ; i ++ ) { tokenIds [ i ] = IGemforceMinterFacet ( diamond ). gemforceMint ( tokenAttributes [ i ] ); } return tokenIds ; } function mintTokenCollection ( string memory collectionName , string memory baseImageURI , uint256 quantity ) external onlyOwner returns ( uint256 [] memory ) { uint256 [] memory tokenIds = new uint256 []( quantity ); for ( uint256 i = 0 ; i < quantity ; i ++ ) { Attribute [] memory attributes = new Attribute []( 4 ); attributes [ 0 ] = Attribute ( \"Collection\" , collectionName ); attributes [ 1 ] = Attribute ( \"Edition\" , ( i + 1 ). toString ()); attributes [ 2 ] = Attribute ( \"Total Supply\" , quantity . toString ()); attributes [ 3 ] = Attribute ( \"Image\" , string ( abi . encodePacked ( baseImageURI , ( i + 1 ). toString ()))); tokenIds [ i ] = IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); } return tokenIds ; } }","title":"Batch Minting System"},{"location":"smart-contracts/facets/gemforce-minter-facet/#dynamic-attribute-minting","text":"// Mint tokens with dynamic attributes based on conditions contract DynamicAttributeMinter { function mintDynamicToken ( string memory tokenType , uint256 rarity , bool isSpecial ) external onlyOwner returns ( uint256 ) { // Base attributes Attribute [] memory attributes = new Attribute []( isSpecial ? 6 : 4 ); attributes [ 0 ] = Attribute ( \"Type\" , tokenType ); attributes [ 1 ] = Attribute ( \"Rarity\" , getRarityString ( rarity )); attributes [ 2 ] = Attribute ( \"Minted At\" , block.timestamp . toString ()); attributes [ 3 ] = Attribute ( \"Minted By\" , \"Gemforce System\" ); // Add special attributes if applicable if ( isSpecial ) { attributes [ 4 ] = Attribute ( \"Special\" , \"true\" ); attributes [ 5 ] = Attribute ( \"Special Type\" , getSpecialType ( rarity )); } uint256 tokenId = IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); // Apply special properties if needed if ( isSpecial ) { applySpecialProperties ( tokenId , rarity ); } return tokenId ; } function getRarityString ( uint256 rarity ) internal pure returns ( string memory ) { if ( rarity >= 90 ) return \"Legendary\" ; if ( rarity >= 70 ) return \"Epic\" ; if ( rarity >= 50 ) return \"Rare\" ; if ( rarity >= 30 ) return \"Uncommon\" ; return \"Common\" ; } function getSpecialType ( uint256 rarity ) internal pure returns ( string memory ) { if ( rarity >= 95 ) return \"Mythic\" ; if ( rarity >= 90 ) return \"Legendary\" ; return \"Special Edition\" ; } }","title":"Dynamic Attribute Minting"},{"location":"smart-contracts/facets/gemforce-minter-facet/#metadata-validation-system","text":"// Validate and standardize metadata before minting contract MetadataValidationMinter { mapping ( string => bool ) public validTraitTypes ; mapping ( string => string []) public validTraitValues ; function setValidTraitTypes ( string [] memory traitTypes ) external onlyOwner { for ( uint256 i = 0 ; i < traitTypes . length ; i ++ ) { validTraitTypes [ traitTypes [ i ]] = true ; } } function setValidTraitValues ( string memory traitType , string [] memory values ) external onlyOwner { validTraitValues [ traitType ] = values ; } function mintValidatedToken ( Attribute [] memory attributes ) external onlyOwner returns ( uint256 ) { // Validate all attributes for ( uint256 i = 0 ; i < attributes . length ; i ++ ) { require ( validTraitTypes [ attributes [ i ]. traitType ], \"Invalid trait type\" ); // Validate trait values if specified string [] memory validValues = validTraitValues [ attributes [ i ]. traitType ]; if ( validValues . length > 0 ) { bool isValid = false ; for ( uint256 j = 0 ; j < validValues . length ; j ++ ) { if ( keccak256 ( bytes ( validValues [ j ])) == keccak256 ( bytes ( attributes [ i ]. value ))) { isValid = true ; break ; } } require ( isValid , \"Invalid trait value\" ); } } return IGemforceMinterFacet ( diamond ). gemforceMint ( attributes ); } }","title":"Metadata Validation System"},{"location":"smart-contracts/facets/gemforce-minter-facet/#events","text":"","title":"Events"},{"location":"smart-contracts/facets/gemforce-minter-facet/#minting-events","text":"event GemforceMinted ( uint256 indexed tokenId , address indexed recipient , Attribute [] metadata ); Event Details : - tokenId : ID of the newly minted token - recipient : Address that received the token (always the owner) - metadata : Array of attributes assigned to the token","title":"Minting Events"},{"location":"smart-contracts/facets/gemforce-minter-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/gemforce-minter-facet/#access-control","text":"Only contract owner can mint tokens Prevents unauthorized token creation Integration with diamond access control system","title":"Access Control"},{"location":"smart-contracts/facets/gemforce-minter-facet/#data-integrity","text":"Atomic minting and attribute assignment Event emission before state changes Consistent token ID generation","title":"Data Integrity"},{"location":"smart-contracts/facets/gemforce-minter-facet/#attribute-validation","text":"Flexible attribute system supports various data types On-chain storage ensures data persistence Integration with attribute library for consistency","title":"Attribute Validation"},{"location":"smart-contracts/facets/gemforce-minter-facet/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/facets/gemforce-minter-facet/#single-transaction-minting","text":"Combines token minting and attribute assignment Reduces gas costs compared to separate operations Efficient batch attribute processing","title":"Single Transaction Minting"},{"location":"smart-contracts/facets/gemforce-minter-facet/#storage-efficiency","text":"Uses diamond storage pattern for optimal storage Minimal storage footprint per token Efficient attribute storage through library","title":"Storage Efficiency"},{"location":"smart-contracts/facets/gemforce-minter-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/gemforce-minter-facet/#access-control-errors","text":"Owner-only function restrictions Unauthorized access prevention","title":"Access Control Errors"},{"location":"smart-contracts/facets/gemforce-minter-facet/#minting-errors","text":"Token creation failures Attribute assignment failures Storage operation errors","title":"Minting Errors"},{"location":"smart-contracts/facets/gemforce-minter-facet/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/facets/gemforce-minter-facet/#unit-tests","text":"Token minting functionality Attribute assignment accuracy Access control validation Event emission verification","title":"Unit Tests"},{"location":"smart-contracts/facets/gemforce-minter-facet/#integration-tests","text":"Diamond storage integration Attribute library integration Multi-facet workflows Gas optimization validation","title":"Integration Tests"},{"location":"smart-contracts/facets/gemforce-minter-facet/#related-documentation","text":"IGemforceMinterFacet - Minter interface AttributeLib - Attribute management library IdentitySystemStorage - Storage library CarbonCreditFacet - Environmental asset integration MarketplaceFacet - Marketplace integration Token Minting Guide - Implementation guide This facet provides the foundation for creating rich, attribute-enabled NFTs within the Gemforce platform, supporting diverse use cases from environmental assets to marketplace items with comprehensive metadata management.","title":"Related Documentation"},{"location":"smart-contracts/facets/identity-registry-facet/","text":"IdentityRegistryFacet \u00b6 Overview \u00b6 The IdentityRegistryFacet.sol provides comprehensive decentralized identity management functionality within the Gemforce diamond system. This facet implements a claims-based identity system where trusted issuers can create, verify, and manage digital identities with associated attestations. Contract Details \u00b6 Contract Name : IdentityRegistryFacet Inheritance : IIdentityRegistry , Modifiers License : MIT Solidity Version : ^0.8.0 Key Features \u00b6 \ud83d\udd39 Decentralized Identity Management \u00b6 Register and manage digital identities on-chain Associate user addresses with identity contracts Batch operations for efficient identity management Complete identity lifecycle management \ud83d\udd39 Claims-Based Verification System \u00b6 Add, remove, and manage identity claims (attestations) Topic-based claim organization Trusted issuer authorization for specific claim types Comprehensive claim verification and querying \ud83d\udd39 Access Control & Security \u00b6 Multi-level trusted issuer system Topic-specific issuer permissions Identity ownership validation Secure claim management with proper authorization \ud83d\udd39 Registry Operations \u00b6 Complete user registry with enumeration Identity existence and verification checks Efficient batch processing capabilities Gas-optimized storage patterns Core Data Structures \u00b6 Identity System Components \u00b6 Identity Contracts : ERC734/ERC735-compliant identity contracts Claims : Verifiable attestations about identities Trusted Issuers : Authorized entities that can manage identities and claims Claim Topics : Categorized types of claims (KYC, accreditation, etc.) Storage Pattern \u00b6 Uses diamond storage pattern via IdentitySystemStorage : - Prevents storage collisions in diamond architecture - Efficient mappings for identity and claim data - Persistent storage across contract upgrades Access Control Modifiers \u00b6 isTrustedIssuer() \u00b6 modifier isTrustedIssuer () Purpose : Restricts function access to approved trusted issuers only. Validation : Checks if msg.sender is registered as a trusted issuer in the system. Usage : Applied to identity management functions that require issuer authorization. isTrustedIssuerForClaimTopic(uint256 _claimTopic) \u00b6 modifier isTrustedIssuerForClaimTopic ( uint256 _claimTopic ) Purpose : Restricts access to issuers authorized for specific claim topics. Parameters : - _claimTopic (uint256): The claim topic requiring authorization Validation : - Verifies caller is a trusted issuer - Confirms issuer is authorized for the specific claim topic Usage : Applied to claim management functions for topic-specific authorization. isTrustedIssuerForClaimTopics(uint256[] memory _claimTopics) \u00b6 modifier isTrustedIssuerForClaimTopics ( uint256 [] memory _claimTopics ) Purpose : Restricts access to issuers authorized for multiple claim topics. Parameters : - _claimTopics (uint256[]): Array of claim topics requiring authorization Validation : Ensures caller is authorized for ALL specified claim topics. Usage : Applied to batch claim operations requiring multiple topic permissions. Core Functions \u00b6 Identity Management Functions \u00b6 addIdentity() \u00b6 function addIdentity ( address _address , IIdentity identityData ) external override isTrustedIssuer Purpose : Registers a new identity in the system. Parameters : - _address (address): User address that will own the identity - identityData (IIdentity): Identity contract instance Access Control : Trusted issuers only Validation : - Address cannot be zero - Identity must not already exist for the address - Identity contract must be valid Process : 1. Validates input parameters 2. Checks for existing identity 3. Updates identity mappings 4. Adds to identity owners list 5. Emits IdentityAdded event Events : IdentityAdded(issuer, address, identityData) Example Usage : // Deploy new identity contract IIdentity newIdentity = new Identity ( userAddress , managementKey ); // Register identity in the system IIdentityRegistry ( diamond ). addIdentity ( userAddress , newIdentity ); batchAddIdentity() \u00b6 function batchAddIdentity ( address [] calldata _addresses , IIdentity [] calldata identityDatas ) external override isTrustedIssuer Purpose : Efficiently registers multiple identities in a single transaction. Parameters : - _addresses (address[]): Array of user addresses - identityDatas (IIdentity[]): Array of corresponding identity contracts Access Control : Trusted issuers only Validation : Arrays must have equal length Gas Optimization : More efficient than multiple individual calls Example Usage : // Batch register multiple users address [] memory users = [ user1 , user2 , user3 ]; IIdentity [] memory identities = [ identity1 , identity2 , identity3 ]; IIdentityRegistry ( diamond ). batchAddIdentity ( users , identities ); removeIdentity() \u00b6 function removeIdentity ( address _ownerAddress ) external override isTrustedIssuer Purpose : Removes an identity from the registry and cleans up all associated data. Parameters : - _ownerAddress (address): Address of the identity owner to remove Access Control : Trusted issuers only Validation : Identity must exist for the specified owner Cleanup Process : 1. Removes from identities mapping (owner \u2192 identity) 2. Removes from reverse mapping (identity \u2192 owner) 3. Removes from identity owners array using swap-and-pop 4. Emits IdentityRemoved event Events : IdentityRemoved(issuer, ownerAddress, identityData) Example Usage : // Remove user's identity from registry IIdentityRegistry ( diamond ). removeIdentity ( userAddress ); Claim Management Functions \u00b6 addClaim() \u00b6 function addClaim ( address _address , uint256 _claimTopic , bytes calldata _claim ) external override isTrustedIssuerForClaimTopic ( _claimTopic ) Purpose : Adds a new claim (attestation) to an identity. Parameters : - _address (address): User or identity address - _claimTopic (uint256): Topic/type of the claim - _claim (bytes): Claim data Access Control : Trusted issuer for specific claim topic Validation : - Identity must exist - Claim must not already exist for this topic - Issuer must be authorized for the claim topic Process : 1. Resolves address to identity 2. Validates claim doesn't exist 3. Adds claim to storage mappings 4. Updates claim list for the identity 5. Emits ClaimAdded event Events : ClaimAdded(issuer, identity, claimTopic, claimData) Example Usage : // Add KYC claim to user's identity bytes memory kycData = abi . encode ( \"KYC_VERIFIED\" , block.timestamp ); IIdentityRegistry ( diamond ). addClaim ( userAddress , KYC_TOPIC , kycData ); setClaims() \u00b6 function setClaims ( address _address , uint256 [] memory _claims ) external override isTrustedIssuerForClaimTopics ( _claims ) Purpose : Sets multiple claims for an identity in a single transaction. Parameters : - _address (address): User or identity address - _claims (uint256[]): Array of claim topics to set Access Control : Trusted issuer for all specified claim topics Validation : - Identity must exist - Claims must not already exist - Claim topics must be valid (exist in topic list) - Issuer must be authorized for all claim topics Process : 1. Validates identity existence 2. Iterates through claim topics 3. Validates each claim topic against topic list 4. Adds valid claims to storage 5. Emits individual ClaimAdded events and batch ClaimsSet event Events : ClaimAdded(...) for each claim, ClaimsSet(issuer, identity, claims) Example Usage : // Set multiple claims for accredited investor uint256 [] memory claims = [ KYC_TOPIC , ACCREDITED_INVESTOR_TOPIC , JURISDICTION_TOPIC ]; IIdentityRegistry ( diamond ). setClaims ( userAddress , claims ); removeClaim() \u00b6 function removeClaim ( address _address , uint256 _claimTopic ) external override isTrustedIssuerForClaimTopic ( _claimTopic ) Purpose : Removes a specific claim from an identity. Parameters : - _address (address): User or identity address - _claimTopic (uint256): Topic of the claim to remove Access Control : Trusted issuer for specific claim topic Validation : - Identity must exist - Cannot remove claims from self - Claim must exist Process : 1. Resolves address to identity 2. Finds claim in claim list 3. Removes using swap-and-pop method 4. Deletes from claims mapping 5. Emits ClaimRemoved event Events : ClaimRemoved(issuer, identity, claimTopic) Example Usage : // Remove expired KYC claim IIdentityRegistry ( diamond ). removeClaim ( userAddress , KYC_TOPIC ); unsetClaims() \u00b6 function unsetClaims ( address _address , uint256 [] memory _claims ) external override isTrustedIssuerForClaimTopics ( _claims ) Purpose : Removes multiple claims from an identity in a single transaction. Parameters : - _address (address): User or identity address - _claims (uint256[]): Array of claim topics to remove Access Control : Trusted issuer for all specified claim topics Process : 1. Validates identity existence 2. Iterates through claims to remove 3. Uses efficient removal algorithm with array resizing 4. Emits ClaimsRemoved event with actually removed claims Events : ClaimsRemoved(issuer, identity, removedClaims) Gas Optimization : Batch removal more efficient than individual calls Query Functions \u00b6 identity() \u00b6 function identity ( address _userAddress ) external view override returns ( address ) Purpose : Returns the identity contract address for a user address. Parameters : - _userAddress (address): User address to query Returns : Identity contract address (or zero if not found) Example Usage : address identityContract = IIdentityRegistry ( diamond ). identity ( userAddress ); if ( identityContract != address ( 0 )) { // User has registered identity } contains() \u00b6 function contains ( address _userAddress ) external view override returns ( bool ) Purpose : Checks if an identity exists for the given address. Parameters : - _userAddress (address): User address to check Returns : True if identity exists, false otherwise Example Usage : bool hasIdentity = IIdentityRegistry ( diamond ). contains ( userAddress ); require ( hasIdentity , \"User must have registered identity\" ); isVerified() \u00b6 function isVerified ( address _address ) external view override returns ( bool ) Purpose : Checks if an address is associated with a verified identity. Parameters : - _address (address): Address to verify (user or identity address) Returns : True if verified, false otherwise Example Usage : bool verified = IIdentityRegistry ( diamond ). isVerified ( userAddress ); if ( verified ) { // Allow access to verified-only features } getClaims() \u00b6 function getClaims ( address _address ) external view override returns ( uint256 [] memory ) Purpose : Returns all claim topics for an identity. Parameters : - _address (address): User or identity address Returns : Array of claim topics Example Usage : uint256 [] memory claims = IIdentityRegistry ( diamond ). getClaims ( userAddress ); for ( uint256 i = 0 ; i < claims . length ; i ++ ) { console . log ( \"User has claim topic:\" , claims [ i ]); } getClaim() \u00b6 function getClaim ( address _address , uint256 _claimTopic ) external view override returns ( uint256 ) Purpose : Returns a specific claim value for an identity. Parameters : - _address (address): User or identity address - _claimTopic (uint256): Claim topic to query Returns : Claim value (or 0 if not found) Example Usage : uint256 kycClaim = IIdentityRegistry ( diamond ). getClaim ( userAddress , KYC_TOPIC ); if ( kycClaim != 0 ) { // User has KYC claim } hasClaim() \u00b6 function hasClaim ( address _address , uint256 _claimTopic ) external view override returns ( bool ) Purpose : Checks if an identity has a specific claim. Parameters : - _address (address): User or identity address - _claimTopic (uint256): Claim topic to check Returns : True if claim exists, false otherwise Example Usage : bool hasKYC = IIdentityRegistry ( diamond ). hasClaim ( userAddress , KYC_TOPIC ); require ( hasKYC , \"KYC verification required\" ); getRegistryUsers() \u00b6 function getRegistryUsers () external view override returns ( address [] memory ) Purpose : Returns all registered user addresses in the system. Returns : Array of user addresses with registered identities Example Usage : address [] memory users = IIdentityRegistry ( diamond ). getRegistryUsers (); console . log ( \"Total registered users:\" , users . length ); isRegistryUser() \u00b6 function isRegistryUser ( address _registryUser ) external view override returns ( bool ) Purpose : Checks if an address is a registered user in the system. Parameters : - _registryUser (address): Address to check Returns : True if registered, false otherwise Example Usage : bool isRegistered = IIdentityRegistry ( diamond ). isRegistryUser ( userAddress ); if ( ! isRegistered ) { // Prompt user to register identity } Integration Examples \u00b6 KYC Verification System \u00b6 // Complete KYC verification workflow contract KYCVerification { uint256 constant KYC_TOPIC = 1 ; uint256 constant ACCREDITED_TOPIC = 2 ; function verifyAndRegisterUser ( address user , bytes calldata kycData , bool isAccredited ) external onlyKYCProvider { // 1. Deploy identity contract IIdentity identity = new Identity ( user , getManagementKey ( user )); // 2. Register identity IIdentityRegistry ( diamond ). addIdentity ( user , identity ); // 3. Add KYC claim IIdentityRegistry ( diamond ). addClaim ( user , KYC_TOPIC , kycData ); // 4. Add accredited investor claim if applicable if ( isAccredited ) { bytes memory accreditedData = abi . encode ( \"ACCREDITED\" , block.timestamp ); IIdentityRegistry ( diamond ). addClaim ( user , ACCREDITED_TOPIC , accreditedData ); } } } Access Control Integration \u00b6 // Use identity system for access control modifier requiresKYC ( address user ) { require ( IIdentityRegistry ( diamond ). hasClaim ( user , KYC_TOPIC ), \"KYC verification required\" ); _ ; } modifier requiresAccreditation ( address user ) { require ( IIdentityRegistry ( diamond ). hasClaim ( user , ACCREDITED_TOPIC ), \"Accredited investor status required\" ); _ ; } function restrictedFunction () external requiresKYC ( msg.sender ) { // Function only accessible to KYC-verified users } Batch User Management \u00b6 // Efficient batch user onboarding function batchOnboardUsers ( address [] calldata users , IIdentity [] calldata identities , uint256 [][] calldata userClaims ) external onlyTrustedIssuer { // 1. Batch register identities IIdentityRegistry ( diamond ). batchAddIdentity ( users , identities ); // 2. Set claims for each user for ( uint256 i = 0 ; i < users . length ; i ++ ) { if ( userClaims [ i ]. length > 0 ) { IIdentityRegistry ( diamond ). setClaims ( users [ i ], userClaims [ i ]); } } } Identity Portfolio Dashboard \u00b6 // Get complete user identity information function getUserIdentityInfo ( address user ) external view returns ( bool hasIdentity , address identityContract , uint256 [] memory claims , bool isKYCVerified , bool isAccredited ) { hasIdentity = IIdentityRegistry ( diamond ). contains ( user ); if ( hasIdentity ) { identityContract = IIdentityRegistry ( diamond ). identity ( user ); claims = IIdentityRegistry ( diamond ). getClaims ( user ); isKYCVerified = IIdentityRegistry ( diamond ). hasClaim ( user , KYC_TOPIC ); isAccredited = IIdentityRegistry ( diamond ). hasClaim ( user , ACCREDITED_TOPIC ); } } Events \u00b6 Identity Events \u00b6 event IdentityAdded ( address indexed issuer , address indexed user , IIdentity indexed identity ); event IdentityRemoved ( address indexed issuer , address indexed user , IIdentity indexed identity ); Claim Events \u00b6 event ClaimAdded ( address indexed issuer , address indexed identity , uint256 indexed claimTopic , bytes claimData ); event ClaimRemoved ( address indexed issuer , address indexed identity , uint256 indexed claimTopic ); event ClaimsSet ( address indexed issuer , address indexed identity , uint256 [] claimTopics ); event ClaimsRemoved ( address indexed issuer , address indexed identity , uint256 [] claimTopics ); Security Considerations \u00b6 Access Control \u00b6 Multi-level trusted issuer system prevents unauthorized identity management Topic-specific permissions ensure issuers can only manage authorized claim types Identity ownership validation prevents unauthorized claim modifications Data Integrity \u00b6 Diamond storage pattern prevents storage collisions Comprehensive validation ensures data consistency Event logging provides complete audit trail Privacy & Compliance \u00b6 Claims-based system supports privacy-preserving verification Flexible claim topics support various compliance requirements Immutable blockchain records provide audit trail Gas Optimization \u00b6 Batch Operations \u00b6 batchAddIdentity() for efficient bulk registration setClaims() and unsetClaims() for bulk claim management Optimized array operations using swap-and-pop Storage Efficiency \u00b6 Efficient mapping structures in IdentitySystemStorage Minimal storage footprint per identity Optimized for frequent read operations Error Handling \u00b6 Identity Errors \u00b6 \"Invalid identity address\" - Zero address provided \"Identity already exists\" - Duplicate registration attempt \"Identity does not exist\" - Operation on non-existent identity Claim Errors \u00b6 \"Claim already exists\" - Duplicate claim addition \"Claim does not exist\" - Operation on non-existent claim \"Cannot set claims for self\" - Self-claim prevention Authorization Errors \u00b6 \"Not trusted issuer\" - Unauthorized issuer access \"Issuer not authorized for claim topic\" - Topic-specific authorization failure \"Arrays length mismatch\" - Batch operation parameter mismatch Testing Considerations \u00b6 Unit Tests \u00b6 Identity registration and removal Claim addition, removal, and querying Access control validation Batch operation efficiency Integration Tests \u00b6 Multi-facet identity workflows KYC/compliance integration Access control integration Event emission verification Related Documentation \u00b6 IIdentityRegistry - Identity registry interface IdentitySystemStorage - Storage library TrustedIssuersRegistryFacet - Trusted issuer management EIP-DRAFT-Enhanced-Identity-System - EIP specification Identity Integration Guide - Implementation guide This facet implements the Enhanced Identity System as defined in the Gemforce EIP suite, providing comprehensive decentralized identity management with claims-based verification.","title":"Identity Registry Facet"},{"location":"smart-contracts/facets/identity-registry-facet/#identityregistryfacet","text":"","title":"IdentityRegistryFacet"},{"location":"smart-contracts/facets/identity-registry-facet/#overview","text":"The IdentityRegistryFacet.sol provides comprehensive decentralized identity management functionality within the Gemforce diamond system. This facet implements a claims-based identity system where trusted issuers can create, verify, and manage digital identities with associated attestations.","title":"Overview"},{"location":"smart-contracts/facets/identity-registry-facet/#contract-details","text":"Contract Name : IdentityRegistryFacet Inheritance : IIdentityRegistry , Modifiers License : MIT Solidity Version : ^0.8.0","title":"Contract Details"},{"location":"smart-contracts/facets/identity-registry-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/identity-registry-facet/#decentralized-identity-management","text":"Register and manage digital identities on-chain Associate user addresses with identity contracts Batch operations for efficient identity management Complete identity lifecycle management","title":"\ud83d\udd39 Decentralized Identity Management"},{"location":"smart-contracts/facets/identity-registry-facet/#claims-based-verification-system","text":"Add, remove, and manage identity claims (attestations) Topic-based claim organization Trusted issuer authorization for specific claim types Comprehensive claim verification and querying","title":"\ud83d\udd39 Claims-Based Verification System"},{"location":"smart-contracts/facets/identity-registry-facet/#access-control-security","text":"Multi-level trusted issuer system Topic-specific issuer permissions Identity ownership validation Secure claim management with proper authorization","title":"\ud83d\udd39 Access Control &amp; Security"},{"location":"smart-contracts/facets/identity-registry-facet/#registry-operations","text":"Complete user registry with enumeration Identity existence and verification checks Efficient batch processing capabilities Gas-optimized storage patterns","title":"\ud83d\udd39 Registry Operations"},{"location":"smart-contracts/facets/identity-registry-facet/#core-data-structures","text":"","title":"Core Data Structures"},{"location":"smart-contracts/facets/identity-registry-facet/#identity-system-components","text":"Identity Contracts : ERC734/ERC735-compliant identity contracts Claims : Verifiable attestations about identities Trusted Issuers : Authorized entities that can manage identities and claims Claim Topics : Categorized types of claims (KYC, accreditation, etc.)","title":"Identity System Components"},{"location":"smart-contracts/facets/identity-registry-facet/#storage-pattern","text":"Uses diamond storage pattern via IdentitySystemStorage : - Prevents storage collisions in diamond architecture - Efficient mappings for identity and claim data - Persistent storage across contract upgrades","title":"Storage Pattern"},{"location":"smart-contracts/facets/identity-registry-facet/#access-control-modifiers","text":"","title":"Access Control Modifiers"},{"location":"smart-contracts/facets/identity-registry-facet/#istrustedissuer","text":"modifier isTrustedIssuer () Purpose : Restricts function access to approved trusted issuers only. Validation : Checks if msg.sender is registered as a trusted issuer in the system. Usage : Applied to identity management functions that require issuer authorization.","title":"isTrustedIssuer()"},{"location":"smart-contracts/facets/identity-registry-facet/#istrustedissuerforclaimtopicuint256-_claimtopic","text":"modifier isTrustedIssuerForClaimTopic ( uint256 _claimTopic ) Purpose : Restricts access to issuers authorized for specific claim topics. Parameters : - _claimTopic (uint256): The claim topic requiring authorization Validation : - Verifies caller is a trusted issuer - Confirms issuer is authorized for the specific claim topic Usage : Applied to claim management functions for topic-specific authorization.","title":"isTrustedIssuerForClaimTopic(uint256 _claimTopic)"},{"location":"smart-contracts/facets/identity-registry-facet/#istrustedissuerforclaimtopicsuint256-memory-_claimtopics","text":"modifier isTrustedIssuerForClaimTopics ( uint256 [] memory _claimTopics ) Purpose : Restricts access to issuers authorized for multiple claim topics. Parameters : - _claimTopics (uint256[]): Array of claim topics requiring authorization Validation : Ensures caller is authorized for ALL specified claim topics. Usage : Applied to batch claim operations requiring multiple topic permissions.","title":"isTrustedIssuerForClaimTopics(uint256[] memory _claimTopics)"},{"location":"smart-contracts/facets/identity-registry-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/identity-registry-facet/#identity-management-functions","text":"","title":"Identity Management Functions"},{"location":"smart-contracts/facets/identity-registry-facet/#addidentity","text":"function addIdentity ( address _address , IIdentity identityData ) external override isTrustedIssuer Purpose : Registers a new identity in the system. Parameters : - _address (address): User address that will own the identity - identityData (IIdentity): Identity contract instance Access Control : Trusted issuers only Validation : - Address cannot be zero - Identity must not already exist for the address - Identity contract must be valid Process : 1. Validates input parameters 2. Checks for existing identity 3. Updates identity mappings 4. Adds to identity owners list 5. Emits IdentityAdded event Events : IdentityAdded(issuer, address, identityData) Example Usage : // Deploy new identity contract IIdentity newIdentity = new Identity ( userAddress , managementKey ); // Register identity in the system IIdentityRegistry ( diamond ). addIdentity ( userAddress , newIdentity );","title":"addIdentity()"},{"location":"smart-contracts/facets/identity-registry-facet/#batchaddidentity","text":"function batchAddIdentity ( address [] calldata _addresses , IIdentity [] calldata identityDatas ) external override isTrustedIssuer Purpose : Efficiently registers multiple identities in a single transaction. Parameters : - _addresses (address[]): Array of user addresses - identityDatas (IIdentity[]): Array of corresponding identity contracts Access Control : Trusted issuers only Validation : Arrays must have equal length Gas Optimization : More efficient than multiple individual calls Example Usage : // Batch register multiple users address [] memory users = [ user1 , user2 , user3 ]; IIdentity [] memory identities = [ identity1 , identity2 , identity3 ]; IIdentityRegistry ( diamond ). batchAddIdentity ( users , identities );","title":"batchAddIdentity()"},{"location":"smart-contracts/facets/identity-registry-facet/#removeidentity","text":"function removeIdentity ( address _ownerAddress ) external override isTrustedIssuer Purpose : Removes an identity from the registry and cleans up all associated data. Parameters : - _ownerAddress (address): Address of the identity owner to remove Access Control : Trusted issuers only Validation : Identity must exist for the specified owner Cleanup Process : 1. Removes from identities mapping (owner \u2192 identity) 2. Removes from reverse mapping (identity \u2192 owner) 3. Removes from identity owners array using swap-and-pop 4. Emits IdentityRemoved event Events : IdentityRemoved(issuer, ownerAddress, identityData) Example Usage : // Remove user's identity from registry IIdentityRegistry ( diamond ). removeIdentity ( userAddress );","title":"removeIdentity()"},{"location":"smart-contracts/facets/identity-registry-facet/#claim-management-functions","text":"","title":"Claim Management Functions"},{"location":"smart-contracts/facets/identity-registry-facet/#addclaim","text":"function addClaim ( address _address , uint256 _claimTopic , bytes calldata _claim ) external override isTrustedIssuerForClaimTopic ( _claimTopic ) Purpose : Adds a new claim (attestation) to an identity. Parameters : - _address (address): User or identity address - _claimTopic (uint256): Topic/type of the claim - _claim (bytes): Claim data Access Control : Trusted issuer for specific claim topic Validation : - Identity must exist - Claim must not already exist for this topic - Issuer must be authorized for the claim topic Process : 1. Resolves address to identity 2. Validates claim doesn't exist 3. Adds claim to storage mappings 4. Updates claim list for the identity 5. Emits ClaimAdded event Events : ClaimAdded(issuer, identity, claimTopic, claimData) Example Usage : // Add KYC claim to user's identity bytes memory kycData = abi . encode ( \"KYC_VERIFIED\" , block.timestamp ); IIdentityRegistry ( diamond ). addClaim ( userAddress , KYC_TOPIC , kycData );","title":"addClaim()"},{"location":"smart-contracts/facets/identity-registry-facet/#setclaims","text":"function setClaims ( address _address , uint256 [] memory _claims ) external override isTrustedIssuerForClaimTopics ( _claims ) Purpose : Sets multiple claims for an identity in a single transaction. Parameters : - _address (address): User or identity address - _claims (uint256[]): Array of claim topics to set Access Control : Trusted issuer for all specified claim topics Validation : - Identity must exist - Claims must not already exist - Claim topics must be valid (exist in topic list) - Issuer must be authorized for all claim topics Process : 1. Validates identity existence 2. Iterates through claim topics 3. Validates each claim topic against topic list 4. Adds valid claims to storage 5. Emits individual ClaimAdded events and batch ClaimsSet event Events : ClaimAdded(...) for each claim, ClaimsSet(issuer, identity, claims) Example Usage : // Set multiple claims for accredited investor uint256 [] memory claims = [ KYC_TOPIC , ACCREDITED_INVESTOR_TOPIC , JURISDICTION_TOPIC ]; IIdentityRegistry ( diamond ). setClaims ( userAddress , claims );","title":"setClaims()"},{"location":"smart-contracts/facets/identity-registry-facet/#removeclaim","text":"function removeClaim ( address _address , uint256 _claimTopic ) external override isTrustedIssuerForClaimTopic ( _claimTopic ) Purpose : Removes a specific claim from an identity. Parameters : - _address (address): User or identity address - _claimTopic (uint256): Topic of the claim to remove Access Control : Trusted issuer for specific claim topic Validation : - Identity must exist - Cannot remove claims from self - Claim must exist Process : 1. Resolves address to identity 2. Finds claim in claim list 3. Removes using swap-and-pop method 4. Deletes from claims mapping 5. Emits ClaimRemoved event Events : ClaimRemoved(issuer, identity, claimTopic) Example Usage : // Remove expired KYC claim IIdentityRegistry ( diamond ). removeClaim ( userAddress , KYC_TOPIC );","title":"removeClaim()"},{"location":"smart-contracts/facets/identity-registry-facet/#unsetclaims","text":"function unsetClaims ( address _address , uint256 [] memory _claims ) external override isTrustedIssuerForClaimTopics ( _claims ) Purpose : Removes multiple claims from an identity in a single transaction. Parameters : - _address (address): User or identity address - _claims (uint256[]): Array of claim topics to remove Access Control : Trusted issuer for all specified claim topics Process : 1. Validates identity existence 2. Iterates through claims to remove 3. Uses efficient removal algorithm with array resizing 4. Emits ClaimsRemoved event with actually removed claims Events : ClaimsRemoved(issuer, identity, removedClaims) Gas Optimization : Batch removal more efficient than individual calls","title":"unsetClaims()"},{"location":"smart-contracts/facets/identity-registry-facet/#query-functions","text":"","title":"Query Functions"},{"location":"smart-contracts/facets/identity-registry-facet/#identity","text":"function identity ( address _userAddress ) external view override returns ( address ) Purpose : Returns the identity contract address for a user address. Parameters : - _userAddress (address): User address to query Returns : Identity contract address (or zero if not found) Example Usage : address identityContract = IIdentityRegistry ( diamond ). identity ( userAddress ); if ( identityContract != address ( 0 )) { // User has registered identity }","title":"identity()"},{"location":"smart-contracts/facets/identity-registry-facet/#contains","text":"function contains ( address _userAddress ) external view override returns ( bool ) Purpose : Checks if an identity exists for the given address. Parameters : - _userAddress (address): User address to check Returns : True if identity exists, false otherwise Example Usage : bool hasIdentity = IIdentityRegistry ( diamond ). contains ( userAddress ); require ( hasIdentity , \"User must have registered identity\" );","title":"contains()"},{"location":"smart-contracts/facets/identity-registry-facet/#isverified","text":"function isVerified ( address _address ) external view override returns ( bool ) Purpose : Checks if an address is associated with a verified identity. Parameters : - _address (address): Address to verify (user or identity address) Returns : True if verified, false otherwise Example Usage : bool verified = IIdentityRegistry ( diamond ). isVerified ( userAddress ); if ( verified ) { // Allow access to verified-only features }","title":"isVerified()"},{"location":"smart-contracts/facets/identity-registry-facet/#getclaims","text":"function getClaims ( address _address ) external view override returns ( uint256 [] memory ) Purpose : Returns all claim topics for an identity. Parameters : - _address (address): User or identity address Returns : Array of claim topics Example Usage : uint256 [] memory claims = IIdentityRegistry ( diamond ). getClaims ( userAddress ); for ( uint256 i = 0 ; i < claims . length ; i ++ ) { console . log ( \"User has claim topic:\" , claims [ i ]); }","title":"getClaims()"},{"location":"smart-contracts/facets/identity-registry-facet/#getclaim","text":"function getClaim ( address _address , uint256 _claimTopic ) external view override returns ( uint256 ) Purpose : Returns a specific claim value for an identity. Parameters : - _address (address): User or identity address - _claimTopic (uint256): Claim topic to query Returns : Claim value (or 0 if not found) Example Usage : uint256 kycClaim = IIdentityRegistry ( diamond ). getClaim ( userAddress , KYC_TOPIC ); if ( kycClaim != 0 ) { // User has KYC claim }","title":"getClaim()"},{"location":"smart-contracts/facets/identity-registry-facet/#hasclaim","text":"function hasClaim ( address _address , uint256 _claimTopic ) external view override returns ( bool ) Purpose : Checks if an identity has a specific claim. Parameters : - _address (address): User or identity address - _claimTopic (uint256): Claim topic to check Returns : True if claim exists, false otherwise Example Usage : bool hasKYC = IIdentityRegistry ( diamond ). hasClaim ( userAddress , KYC_TOPIC ); require ( hasKYC , \"KYC verification required\" );","title":"hasClaim()"},{"location":"smart-contracts/facets/identity-registry-facet/#getregistryusers","text":"function getRegistryUsers () external view override returns ( address [] memory ) Purpose : Returns all registered user addresses in the system. Returns : Array of user addresses with registered identities Example Usage : address [] memory users = IIdentityRegistry ( diamond ). getRegistryUsers (); console . log ( \"Total registered users:\" , users . length );","title":"getRegistryUsers()"},{"location":"smart-contracts/facets/identity-registry-facet/#isregistryuser","text":"function isRegistryUser ( address _registryUser ) external view override returns ( bool ) Purpose : Checks if an address is a registered user in the system. Parameters : - _registryUser (address): Address to check Returns : True if registered, false otherwise Example Usage : bool isRegistered = IIdentityRegistry ( diamond ). isRegistryUser ( userAddress ); if ( ! isRegistered ) { // Prompt user to register identity }","title":"isRegistryUser()"},{"location":"smart-contracts/facets/identity-registry-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/facets/identity-registry-facet/#kyc-verification-system","text":"// Complete KYC verification workflow contract KYCVerification { uint256 constant KYC_TOPIC = 1 ; uint256 constant ACCREDITED_TOPIC = 2 ; function verifyAndRegisterUser ( address user , bytes calldata kycData , bool isAccredited ) external onlyKYCProvider { // 1. Deploy identity contract IIdentity identity = new Identity ( user , getManagementKey ( user )); // 2. Register identity IIdentityRegistry ( diamond ). addIdentity ( user , identity ); // 3. Add KYC claim IIdentityRegistry ( diamond ). addClaim ( user , KYC_TOPIC , kycData ); // 4. Add accredited investor claim if applicable if ( isAccredited ) { bytes memory accreditedData = abi . encode ( \"ACCREDITED\" , block.timestamp ); IIdentityRegistry ( diamond ). addClaim ( user , ACCREDITED_TOPIC , accreditedData ); } } }","title":"KYC Verification System"},{"location":"smart-contracts/facets/identity-registry-facet/#access-control-integration","text":"// Use identity system for access control modifier requiresKYC ( address user ) { require ( IIdentityRegistry ( diamond ). hasClaim ( user , KYC_TOPIC ), \"KYC verification required\" ); _ ; } modifier requiresAccreditation ( address user ) { require ( IIdentityRegistry ( diamond ). hasClaim ( user , ACCREDITED_TOPIC ), \"Accredited investor status required\" ); _ ; } function restrictedFunction () external requiresKYC ( msg.sender ) { // Function only accessible to KYC-verified users }","title":"Access Control Integration"},{"location":"smart-contracts/facets/identity-registry-facet/#batch-user-management","text":"// Efficient batch user onboarding function batchOnboardUsers ( address [] calldata users , IIdentity [] calldata identities , uint256 [][] calldata userClaims ) external onlyTrustedIssuer { // 1. Batch register identities IIdentityRegistry ( diamond ). batchAddIdentity ( users , identities ); // 2. Set claims for each user for ( uint256 i = 0 ; i < users . length ; i ++ ) { if ( userClaims [ i ]. length > 0 ) { IIdentityRegistry ( diamond ). setClaims ( users [ i ], userClaims [ i ]); } } }","title":"Batch User Management"},{"location":"smart-contracts/facets/identity-registry-facet/#identity-portfolio-dashboard","text":"// Get complete user identity information function getUserIdentityInfo ( address user ) external view returns ( bool hasIdentity , address identityContract , uint256 [] memory claims , bool isKYCVerified , bool isAccredited ) { hasIdentity = IIdentityRegistry ( diamond ). contains ( user ); if ( hasIdentity ) { identityContract = IIdentityRegistry ( diamond ). identity ( user ); claims = IIdentityRegistry ( diamond ). getClaims ( user ); isKYCVerified = IIdentityRegistry ( diamond ). hasClaim ( user , KYC_TOPIC ); isAccredited = IIdentityRegistry ( diamond ). hasClaim ( user , ACCREDITED_TOPIC ); } }","title":"Identity Portfolio Dashboard"},{"location":"smart-contracts/facets/identity-registry-facet/#events","text":"","title":"Events"},{"location":"smart-contracts/facets/identity-registry-facet/#identity-events","text":"event IdentityAdded ( address indexed issuer , address indexed user , IIdentity indexed identity ); event IdentityRemoved ( address indexed issuer , address indexed user , IIdentity indexed identity );","title":"Identity Events"},{"location":"smart-contracts/facets/identity-registry-facet/#claim-events","text":"event ClaimAdded ( address indexed issuer , address indexed identity , uint256 indexed claimTopic , bytes claimData ); event ClaimRemoved ( address indexed issuer , address indexed identity , uint256 indexed claimTopic ); event ClaimsSet ( address indexed issuer , address indexed identity , uint256 [] claimTopics ); event ClaimsRemoved ( address indexed issuer , address indexed identity , uint256 [] claimTopics );","title":"Claim Events"},{"location":"smart-contracts/facets/identity-registry-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/identity-registry-facet/#access-control","text":"Multi-level trusted issuer system prevents unauthorized identity management Topic-specific permissions ensure issuers can only manage authorized claim types Identity ownership validation prevents unauthorized claim modifications","title":"Access Control"},{"location":"smart-contracts/facets/identity-registry-facet/#data-integrity","text":"Diamond storage pattern prevents storage collisions Comprehensive validation ensures data consistency Event logging provides complete audit trail","title":"Data Integrity"},{"location":"smart-contracts/facets/identity-registry-facet/#privacy-compliance","text":"Claims-based system supports privacy-preserving verification Flexible claim topics support various compliance requirements Immutable blockchain records provide audit trail","title":"Privacy &amp; Compliance"},{"location":"smart-contracts/facets/identity-registry-facet/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/facets/identity-registry-facet/#batch-operations","text":"batchAddIdentity() for efficient bulk registration setClaims() and unsetClaims() for bulk claim management Optimized array operations using swap-and-pop","title":"Batch Operations"},{"location":"smart-contracts/facets/identity-registry-facet/#storage-efficiency","text":"Efficient mapping structures in IdentitySystemStorage Minimal storage footprint per identity Optimized for frequent read operations","title":"Storage Efficiency"},{"location":"smart-contracts/facets/identity-registry-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/identity-registry-facet/#identity-errors","text":"\"Invalid identity address\" - Zero address provided \"Identity already exists\" - Duplicate registration attempt \"Identity does not exist\" - Operation on non-existent identity","title":"Identity Errors"},{"location":"smart-contracts/facets/identity-registry-facet/#claim-errors","text":"\"Claim already exists\" - Duplicate claim addition \"Claim does not exist\" - Operation on non-existent claim \"Cannot set claims for self\" - Self-claim prevention","title":"Claim Errors"},{"location":"smart-contracts/facets/identity-registry-facet/#authorization-errors","text":"\"Not trusted issuer\" - Unauthorized issuer access \"Issuer not authorized for claim topic\" - Topic-specific authorization failure \"Arrays length mismatch\" - Batch operation parameter mismatch","title":"Authorization Errors"},{"location":"smart-contracts/facets/identity-registry-facet/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/facets/identity-registry-facet/#unit-tests","text":"Identity registration and removal Claim addition, removal, and querying Access control validation Batch operation efficiency","title":"Unit Tests"},{"location":"smart-contracts/facets/identity-registry-facet/#integration-tests","text":"Multi-facet identity workflows KYC/compliance integration Access control integration Event emission verification","title":"Integration Tests"},{"location":"smart-contracts/facets/identity-registry-facet/#related-documentation","text":"IIdentityRegistry - Identity registry interface IdentitySystemStorage - Storage library TrustedIssuersRegistryFacet - Trusted issuer management EIP-DRAFT-Enhanced-Identity-System - EIP specification Identity Integration Guide - Implementation guide This facet implements the Enhanced Identity System as defined in the Gemforce EIP suite, providing comprehensive decentralized identity management with claims-based verification.","title":"Related Documentation"},{"location":"smart-contracts/facets/marketplace-facet/","text":"MarketplaceFacet \u00b6 Overview \u00b6 The MarketplaceFacet.sol provides comprehensive NFT marketplace functionality for the Gemforce diamond system. This facet enables users to list, purchase, and manage NFT sales with support for both ETH and ERC20 token payments, featuring a sophisticated fee distribution system. Contract Details \u00b6 Contract Name : MarketplaceFacet Inheritance : IMarketplace , Modifiers , ReentrancyGuard License : MIT Solidity Version : ^0.8.4 Key Features \u00b6 \ud83d\udd39 Multi-Payment Support \u00b6 ETH payments for traditional transactions ERC20 token payments for flexible payment options Automatic payment validation and processing \ud83d\udd39 Configurable Fee Distribution \u00b6 Parts-per-million precision fee system (1,000,000 = 100%) Multiple fee receivers per transaction Transparent fee distribution with events \ud83d\udd39 Identity-Based Access Control \u00b6 Integration with Gemforce identity system Buyer registration requirements Permissioned NFT transfers \ud83d\udd39 Security Features \u00b6 Reentrancy protection via ReentrancyGuard Checks-effects-interactions pattern Price protection mechanisms Core Data Structures \u00b6 FeeReceiver \u00b6 struct FeeReceiver { address receiver ; // Address receiving the fee uint256 sharePerMillion ; // Fee share in parts per million } Usage : Defines fee distribution recipients and their percentage shares. MarketItem \u00b6 struct MarketItem { address nftContract ; // Contract address of the NFT uint256 tokenId ; // Token ID of the NFT address seller ; // Original seller address address owner ; // Current owner address uint256 price ; // Listing price bool sold ; // Sale status address receiver ; // Payment receiver address address paymentToken ; // Payment token (address(0) for ETH) } Usage : Stores complete listing information for marketplace items. Core Functions \u00b6 Initialization \u00b6 initializeMarketplace() \u00b6 function initializeMarketplace ( FeeReceiver [] memory _feeReceivers ) external onlyOwner Purpose : One-time initialization of the marketplace fee distribution system. Parameters : - _feeReceivers : Array of fee receivers with their respective shares Access Control : Owner only Validation : - Can only be called once - Fee receiver addresses must be valid (non-zero) - Share amounts must be greater than zero - Total shares cannot exceed 100% (1,000,000 parts per million) Events : Emits MarketplaceInitialized(feeReceivers) Listing Management \u00b6 listItem() \u00b6 function listItem ( address , // Unused parameter for interface compatibility address payable receiver , uint256 tokenId , uint256 price , bool transferNFT , address paymentToken ) external payable nonReentrant Purpose : Lists an NFT for sale in the marketplace. Parameters : - receiver : Address that will receive payment when item is sold - tokenId : ID of the NFT being listed - price : Listing price in wei (ETH) or token units - transferNFT : Whether to transfer NFT to contract (true) or keep with seller (false) - paymentToken : ERC20 token address for payment, or address(0) for ETH Access Control : NFT owner only Validation : - Caller must own the NFT - Price must be greater than zero - Item must not already be listed - No ETH should be sent with listing Process : 1. Validates ownership and listing status 2. Optionally transfers NFT to contract 3. Creates market item entry 4. Updates listing status 5. Adds to items array Events : Emits Listings event with listing details purchaseItem() \u00b6 function purchaseItem ( address , // Unused parameter for interface compatibility uint256 tokenId , uint256 maxPrice ) external payable nonReentrant Purpose : Purchases a listed NFT from the marketplace. Parameters : - tokenId : ID of the NFT to purchase - maxPrice : Maximum price buyer is willing to pay (price protection) Access Control : Registered users only Validation : - Item must be listed and not sold - Buyer must be registered in identity system - Sufficient payment must be provided - Price must not exceed maxPrice Process : 1. Validates listing status and buyer registration 2. Checks payment sufficiency 3. Marks item as sold 4. Transfers NFT to buyer 5. Distributes payment to fee receivers 6. Sends remaining payment to receiver Events : Emits Sales event upon successful purchase Utility Functions \u00b6 delistItem() \u00b6 function delistItem ( uint256 tokenId ) external nonReentrant Purpose : Removes an NFT listing from the marketplace. Parameters : - tokenId : ID of the NFT to delist Access Control : NFT owner only Process : 1. Validates ownership 2. Transfers NFT back to owner (if held by contract) 3. Updates listing status 4. Clears market item data Events : Emits Delisted event Payment Distribution System \u00b6 Fee Calculation \u00b6 uint256 private constant SHARE_PRECISION = 1 _000_000 ; // 100% = 1,000,000 Example Fee Structure : - Platform fee: 25,000 parts per million (2.5%) - Community treasury: 10,000 parts per million (1.0%) - Creator royalty: 50,000 parts per million (5.0%) - Total fees : 85,000 parts per million (8.5%) - Seller receives : 915,000 parts per million (91.5%) Distribution Process \u00b6 Calculate total fees : Sum all fee receiver shares Distribute to fee receivers : Transfer calculated amounts Transfer remainder : Send remaining payment to listing receiver Emit events : Log all payment distributions Security Considerations \u00b6 Reentrancy Protection \u00b6 All state-changing functions use nonReentrant modifier Follows checks-effects-interactions pattern State updates before external calls Access Control \u00b6 Owner-only initialization NFT owner validation for listings Identity system integration for purchases Payment Security \u00b6 Price validation and protection Overflow protection in fee calculations Safe token transfers using OpenZeppelin's SafeERC20 Input Validation \u00b6 Non-zero price requirements Valid address checks Listing status validation Gas Optimization \u00b6 Storage Efficiency \u00b6 Packed structs for market items Efficient mapping usage Minimal storage operations Function Optimization \u00b6 Early validation returns Batch operations where possible Optimized fee distribution loops Integration Examples \u00b6 Initialize Marketplace \u00b6 // Set up fee distribution IMarketplace . FeeReceiver [] memory feeReceivers = new IMarketplace . FeeReceiver []( 2 ); feeReceivers [ 0 ] = IMarketplace . FeeReceiver ({ receiver : platformTreasury , sharePerMillion : 25000 // 2.5% }); feeReceivers [ 1 ] = IMarketplace . FeeReceiver ({ receiver : communityTreasury , sharePerMillion : 10000 // 1.0% }); IMarketplace ( diamond ). initializeMarketplace ( feeReceivers ); List NFT for Sale \u00b6 // List NFT for 1 ETH, keeping NFT with seller IMarketplace ( diamond ). listItem ( address ( 0 ), // Unused parameter payable ( seller ), // Payment receiver tokenId , // NFT token ID 1 ether , // Price in wei false , // Don't transfer NFT to contract address ( 0 ) // ETH payment ); Purchase NFT \u00b6 // Purchase NFT with ETH IMarketplace ( diamond ). purchaseItem { value : 1 ether }( address ( 0 ), // Unused parameter tokenId , // NFT token ID 1 . 1 ether // Maximum price willing to pay ); Purchase with ERC20 Token \u00b6 // Approve token spending first IERC20 ( paymentToken ). approve ( diamond , price ); // Purchase with ERC20 token IMarketplace ( diamond ). purchaseItem ( address ( 0 ), // Unused parameter tokenId , // NFT token ID price // Maximum price ); Events \u00b6 MarketplaceInitialized \u00b6 event MarketplaceInitialized ( FeeReceiver [] feeReceivers ); Emitted when marketplace is initialized with fee receivers. PaymentDistributed \u00b6 event PaymentDistributed ( address token , address receiver , uint256 amount ); Emitted for each payment distribution during a sale. Listings \u00b6 event Listings ( address indexed nftContract , uint256 indexed tokenId , address indexed seller , address receiver , address buyer , uint256 price , bool sold , address paymentToken ); Emitted when an NFT is listed for sale. Sales \u00b6 event Sales ( address indexed nftContract , uint256 indexed tokenId , address indexed buyer ); Emitted when an NFT is successfully purchased. Delisted \u00b6 event Delisted ( uint256 indexed tokenId ); Emitted when an NFT listing is removed. Error Handling \u00b6 Common Errors \u00b6 \"Marketplace already initialized\" : Attempting to initialize twice \"MARKETPLACE: NOT_OWNER\" : Non-owner trying to list NFT \"MARKETPLACE: SALE_COMPLETED\" : Attempting to purchase already sold item \"MARKETPLACE: INVALID_LISTING\" : Trying to purchase non-existent listing \"Price must be greater than 0\" : Invalid pricing \"Total shares exceed 100%\" : Invalid fee configuration Testing Considerations \u00b6 Unit Tests \u00b6 Fee calculation accuracy Payment distribution logic Access control validation State transition correctness Integration Tests \u00b6 End-to-end marketplace flows Multi-token payment scenarios Identity system integration Error condition handling Related Documentation \u00b6 IMarketplace - Marketplace interface IdentityStorage - Identity system integration Diamond - Core diamond contract EIP-DRAFT-Diamond-Enhanced-Marketplace - EIP specification This facet implements the Diamond-Enhanced NFT Marketplace standard as defined in the Gemforce EIP suite.","title":"Marketplace Facet"},{"location":"smart-contracts/facets/marketplace-facet/#marketplacefacet","text":"","title":"MarketplaceFacet"},{"location":"smart-contracts/facets/marketplace-facet/#overview","text":"The MarketplaceFacet.sol provides comprehensive NFT marketplace functionality for the Gemforce diamond system. This facet enables users to list, purchase, and manage NFT sales with support for both ETH and ERC20 token payments, featuring a sophisticated fee distribution system.","title":"Overview"},{"location":"smart-contracts/facets/marketplace-facet/#contract-details","text":"Contract Name : MarketplaceFacet Inheritance : IMarketplace , Modifiers , ReentrancyGuard License : MIT Solidity Version : ^0.8.4","title":"Contract Details"},{"location":"smart-contracts/facets/marketplace-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/marketplace-facet/#multi-payment-support","text":"ETH payments for traditional transactions ERC20 token payments for flexible payment options Automatic payment validation and processing","title":"\ud83d\udd39 Multi-Payment Support"},{"location":"smart-contracts/facets/marketplace-facet/#configurable-fee-distribution","text":"Parts-per-million precision fee system (1,000,000 = 100%) Multiple fee receivers per transaction Transparent fee distribution with events","title":"\ud83d\udd39 Configurable Fee Distribution"},{"location":"smart-contracts/facets/marketplace-facet/#identity-based-access-control","text":"Integration with Gemforce identity system Buyer registration requirements Permissioned NFT transfers","title":"\ud83d\udd39 Identity-Based Access Control"},{"location":"smart-contracts/facets/marketplace-facet/#security-features","text":"Reentrancy protection via ReentrancyGuard Checks-effects-interactions pattern Price protection mechanisms","title":"\ud83d\udd39 Security Features"},{"location":"smart-contracts/facets/marketplace-facet/#core-data-structures","text":"","title":"Core Data Structures"},{"location":"smart-contracts/facets/marketplace-facet/#feereceiver","text":"struct FeeReceiver { address receiver ; // Address receiving the fee uint256 sharePerMillion ; // Fee share in parts per million } Usage : Defines fee distribution recipients and their percentage shares.","title":"FeeReceiver"},{"location":"smart-contracts/facets/marketplace-facet/#marketitem","text":"struct MarketItem { address nftContract ; // Contract address of the NFT uint256 tokenId ; // Token ID of the NFT address seller ; // Original seller address address owner ; // Current owner address uint256 price ; // Listing price bool sold ; // Sale status address receiver ; // Payment receiver address address paymentToken ; // Payment token (address(0) for ETH) } Usage : Stores complete listing information for marketplace items.","title":"MarketItem"},{"location":"smart-contracts/facets/marketplace-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/marketplace-facet/#initialization","text":"","title":"Initialization"},{"location":"smart-contracts/facets/marketplace-facet/#initializemarketplace","text":"function initializeMarketplace ( FeeReceiver [] memory _feeReceivers ) external onlyOwner Purpose : One-time initialization of the marketplace fee distribution system. Parameters : - _feeReceivers : Array of fee receivers with their respective shares Access Control : Owner only Validation : - Can only be called once - Fee receiver addresses must be valid (non-zero) - Share amounts must be greater than zero - Total shares cannot exceed 100% (1,000,000 parts per million) Events : Emits MarketplaceInitialized(feeReceivers)","title":"initializeMarketplace()"},{"location":"smart-contracts/facets/marketplace-facet/#listing-management","text":"","title":"Listing Management"},{"location":"smart-contracts/facets/marketplace-facet/#listitem","text":"function listItem ( address , // Unused parameter for interface compatibility address payable receiver , uint256 tokenId , uint256 price , bool transferNFT , address paymentToken ) external payable nonReentrant Purpose : Lists an NFT for sale in the marketplace. Parameters : - receiver : Address that will receive payment when item is sold - tokenId : ID of the NFT being listed - price : Listing price in wei (ETH) or token units - transferNFT : Whether to transfer NFT to contract (true) or keep with seller (false) - paymentToken : ERC20 token address for payment, or address(0) for ETH Access Control : NFT owner only Validation : - Caller must own the NFT - Price must be greater than zero - Item must not already be listed - No ETH should be sent with listing Process : 1. Validates ownership and listing status 2. Optionally transfers NFT to contract 3. Creates market item entry 4. Updates listing status 5. Adds to items array Events : Emits Listings event with listing details","title":"listItem()"},{"location":"smart-contracts/facets/marketplace-facet/#purchaseitem","text":"function purchaseItem ( address , // Unused parameter for interface compatibility uint256 tokenId , uint256 maxPrice ) external payable nonReentrant Purpose : Purchases a listed NFT from the marketplace. Parameters : - tokenId : ID of the NFT to purchase - maxPrice : Maximum price buyer is willing to pay (price protection) Access Control : Registered users only Validation : - Item must be listed and not sold - Buyer must be registered in identity system - Sufficient payment must be provided - Price must not exceed maxPrice Process : 1. Validates listing status and buyer registration 2. Checks payment sufficiency 3. Marks item as sold 4. Transfers NFT to buyer 5. Distributes payment to fee receivers 6. Sends remaining payment to receiver Events : Emits Sales event upon successful purchase","title":"purchaseItem()"},{"location":"smart-contracts/facets/marketplace-facet/#utility-functions","text":"","title":"Utility Functions"},{"location":"smart-contracts/facets/marketplace-facet/#delistitem","text":"function delistItem ( uint256 tokenId ) external nonReentrant Purpose : Removes an NFT listing from the marketplace. Parameters : - tokenId : ID of the NFT to delist Access Control : NFT owner only Process : 1. Validates ownership 2. Transfers NFT back to owner (if held by contract) 3. Updates listing status 4. Clears market item data Events : Emits Delisted event","title":"delistItem()"},{"location":"smart-contracts/facets/marketplace-facet/#payment-distribution-system","text":"","title":"Payment Distribution System"},{"location":"smart-contracts/facets/marketplace-facet/#fee-calculation","text":"uint256 private constant SHARE_PRECISION = 1 _000_000 ; // 100% = 1,000,000 Example Fee Structure : - Platform fee: 25,000 parts per million (2.5%) - Community treasury: 10,000 parts per million (1.0%) - Creator royalty: 50,000 parts per million (5.0%) - Total fees : 85,000 parts per million (8.5%) - Seller receives : 915,000 parts per million (91.5%)","title":"Fee Calculation"},{"location":"smart-contracts/facets/marketplace-facet/#distribution-process","text":"Calculate total fees : Sum all fee receiver shares Distribute to fee receivers : Transfer calculated amounts Transfer remainder : Send remaining payment to listing receiver Emit events : Log all payment distributions","title":"Distribution Process"},{"location":"smart-contracts/facets/marketplace-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/marketplace-facet/#reentrancy-protection","text":"All state-changing functions use nonReentrant modifier Follows checks-effects-interactions pattern State updates before external calls","title":"Reentrancy Protection"},{"location":"smart-contracts/facets/marketplace-facet/#access-control","text":"Owner-only initialization NFT owner validation for listings Identity system integration for purchases","title":"Access Control"},{"location":"smart-contracts/facets/marketplace-facet/#payment-security","text":"Price validation and protection Overflow protection in fee calculations Safe token transfers using OpenZeppelin's SafeERC20","title":"Payment Security"},{"location":"smart-contracts/facets/marketplace-facet/#input-validation","text":"Non-zero price requirements Valid address checks Listing status validation","title":"Input Validation"},{"location":"smart-contracts/facets/marketplace-facet/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/facets/marketplace-facet/#storage-efficiency","text":"Packed structs for market items Efficient mapping usage Minimal storage operations","title":"Storage Efficiency"},{"location":"smart-contracts/facets/marketplace-facet/#function-optimization","text":"Early validation returns Batch operations where possible Optimized fee distribution loops","title":"Function Optimization"},{"location":"smart-contracts/facets/marketplace-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/facets/marketplace-facet/#initialize-marketplace","text":"// Set up fee distribution IMarketplace . FeeReceiver [] memory feeReceivers = new IMarketplace . FeeReceiver []( 2 ); feeReceivers [ 0 ] = IMarketplace . FeeReceiver ({ receiver : platformTreasury , sharePerMillion : 25000 // 2.5% }); feeReceivers [ 1 ] = IMarketplace . FeeReceiver ({ receiver : communityTreasury , sharePerMillion : 10000 // 1.0% }); IMarketplace ( diamond ). initializeMarketplace ( feeReceivers );","title":"Initialize Marketplace"},{"location":"smart-contracts/facets/marketplace-facet/#list-nft-for-sale","text":"// List NFT for 1 ETH, keeping NFT with seller IMarketplace ( diamond ). listItem ( address ( 0 ), // Unused parameter payable ( seller ), // Payment receiver tokenId , // NFT token ID 1 ether , // Price in wei false , // Don't transfer NFT to contract address ( 0 ) // ETH payment );","title":"List NFT for Sale"},{"location":"smart-contracts/facets/marketplace-facet/#purchase-nft","text":"// Purchase NFT with ETH IMarketplace ( diamond ). purchaseItem { value : 1 ether }( address ( 0 ), // Unused parameter tokenId , // NFT token ID 1 . 1 ether // Maximum price willing to pay );","title":"Purchase NFT"},{"location":"smart-contracts/facets/marketplace-facet/#purchase-with-erc20-token","text":"// Approve token spending first IERC20 ( paymentToken ). approve ( diamond , price ); // Purchase with ERC20 token IMarketplace ( diamond ). purchaseItem ( address ( 0 ), // Unused parameter tokenId , // NFT token ID price // Maximum price );","title":"Purchase with ERC20 Token"},{"location":"smart-contracts/facets/marketplace-facet/#events","text":"","title":"Events"},{"location":"smart-contracts/facets/marketplace-facet/#marketplaceinitialized","text":"event MarketplaceInitialized ( FeeReceiver [] feeReceivers ); Emitted when marketplace is initialized with fee receivers.","title":"MarketplaceInitialized"},{"location":"smart-contracts/facets/marketplace-facet/#paymentdistributed","text":"event PaymentDistributed ( address token , address receiver , uint256 amount ); Emitted for each payment distribution during a sale.","title":"PaymentDistributed"},{"location":"smart-contracts/facets/marketplace-facet/#listings","text":"event Listings ( address indexed nftContract , uint256 indexed tokenId , address indexed seller , address receiver , address buyer , uint256 price , bool sold , address paymentToken ); Emitted when an NFT is listed for sale.","title":"Listings"},{"location":"smart-contracts/facets/marketplace-facet/#sales","text":"event Sales ( address indexed nftContract , uint256 indexed tokenId , address indexed buyer ); Emitted when an NFT is successfully purchased.","title":"Sales"},{"location":"smart-contracts/facets/marketplace-facet/#delisted","text":"event Delisted ( uint256 indexed tokenId ); Emitted when an NFT listing is removed.","title":"Delisted"},{"location":"smart-contracts/facets/marketplace-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/marketplace-facet/#common-errors","text":"\"Marketplace already initialized\" : Attempting to initialize twice \"MARKETPLACE: NOT_OWNER\" : Non-owner trying to list NFT \"MARKETPLACE: SALE_COMPLETED\" : Attempting to purchase already sold item \"MARKETPLACE: INVALID_LISTING\" : Trying to purchase non-existent listing \"Price must be greater than 0\" : Invalid pricing \"Total shares exceed 100%\" : Invalid fee configuration","title":"Common Errors"},{"location":"smart-contracts/facets/marketplace-facet/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/facets/marketplace-facet/#unit-tests","text":"Fee calculation accuracy Payment distribution logic Access control validation State transition correctness","title":"Unit Tests"},{"location":"smart-contracts/facets/marketplace-facet/#integration-tests","text":"End-to-end marketplace flows Multi-token payment scenarios Identity system integration Error condition handling","title":"Integration Tests"},{"location":"smart-contracts/facets/marketplace-facet/#related-documentation","text":"IMarketplace - Marketplace interface IdentityStorage - Identity system integration Diamond - Core diamond contract EIP-DRAFT-Diamond-Enhanced-Marketplace - EIP specification This facet implements the Diamond-Enhanced NFT Marketplace standard as defined in the Gemforce EIP suite.","title":"Related Documentation"},{"location":"smart-contracts/facets/multi-sale-facet/","text":"MultiSaleFacet \u00b6 Overview \u00b6 The MultiSaleFacet.sol provides comprehensive multi-token sale functionality within the Gemforce diamond system. This facet enables the creation and management of token sales supporting multiple token standards (ERC20, ERC721, ERC1155) with flexible payment methods, allowlist support, and advanced purchase controls. Contract Details \u00b6 Contract Name : MultiSaleFacet Inheritance : IMultiSale , Modifiers , ReentrancyGuard License : MIT Solidity Version : >=0.8.0 Key Features \u00b6 \ud83d\udd39 Multi-Token Standard Support \u00b6 ERC20 fungible token sales ERC721 NFT individual sales ERC1155 semi-fungible token sales Automatic token type detection and minting \ud83d\udd39 Flexible Payment Methods \u00b6 ETH payments with automatic refund of excess ERC20 token payments Configurable payment tokens per sale Secure payment processing with reentrancy protection \ud83d\udd39 Advanced Sale Controls \u00b6 Per-account purchase limits Allowlist support with cryptographic proofs Variable pricing mechanisms Owner and admin access controls \ud83d\udd39 Comprehensive Sale Management \u00b6 Create, update, and query token sales Track purchase history and quantities Batch operations for efficiency Event-driven architecture for transparency Core Data Structures \u00b6 MultiSaleSettings \u00b6 struct MultiSaleSettings { address token ; // Token contract address TokenType tokenType ; // ERC20, ERC721, or ERC1155 address owner ; // Sale owner (receives payments) VariablePriceContract price ; // Price configuration PaymentMethod paymentMethod ; // ETH or ERC20 address paymentToken ; // ERC20 token for payments (if applicable) uint256 maxQuantityPerAccount ; // Purchase limit per account (0 = unlimited) // Additional configuration fields... } MultiSalePurchase \u00b6 struct MultiSalePurchase { uint256 multiSaleId ; // ID of the token sale address purchaser ; // Address making the purchase address receiver ; // Address receiving the tokens uint256 quantity ; // Number of tokens to purchase } MultiSaleProof \u00b6 struct MultiSaleProof { bytes proof ; // Cryptographic proof (e.g., Merkle proof) bytes data ; // Additional proof or purchase data } Core Functions \u00b6 Sale Management Functions \u00b6 createTokenSale() \u00b6 function createTokenSale ( MultiSaleSettings memory tokenSaleInit ) external virtual onlyOwner returns ( uint256 tokenSaleId ) Purpose : Creates a new token sale with specified configuration. Parameters : - tokenSaleInit (MultiSaleSettings): Complete sale configuration Returns : - tokenSaleId (uint256): Unique identifier for the new sale Access Control : Owner only Process : 1. Generates unique token sale ID 2. Stores complete sale configuration 3. Adds sale ID to tracking array 4. Emits MultiSaleCreated event Events : MultiSaleCreated(tokenSaleId, settings) Example Usage : // Create NFT sale with ETH payment MultiSaleSettings memory nftSale = MultiSaleSettings ({ token : nftContractAddress , tokenType : TokenType . ERC721 , owner : saleOwner , price : VariablePriceContract ({ price : 0 . 1 ether , // Additional price configuration... }), paymentMethod : PaymentMethod . ETH , paymentToken : address ( 0 ), maxQuantityPerAccount : 5 // Additional settings... }); uint256 saleId = IMultiSale ( diamond ). createTokenSale ( nftSale ); console . log ( \"Created NFT sale with ID:\" , saleId ); updateTokenSaleSettings() \u00b6 function updateTokenSaleSettings ( uint256 tokenSaleId , MultiSaleSettings memory settings ) external Purpose : Updates configuration for an existing token sale. Parameters : - tokenSaleId (uint256): ID of the sale to update - settings (MultiSaleSettings): New configuration settings Access Control : Sale owner or contract owner Process : 1. Validates caller permissions 2. Replaces existing settings with new configuration 3. Emits MultiSaleUpdated event Events : MultiSaleUpdated(tokenSaleId, settings) Example Usage : // Update sale price and purchase limit MultiSaleSettings memory updatedSettings = existingSettings ; updatedSettings . price . price = 0 . 15 ether ; updatedSettings . maxQuantityPerAccount = 3 ; IMultiSale ( diamond ). updateTokenSaleSettings ( saleId , updatedSettings ); Purchase Functions \u00b6 purchase() \u00b6 function purchase ( uint256 multiSaleId , address purchaser , address receiver , uint256 quantity , bytes memory data ) external payable nonReentrant returns ( uint256 [] memory ids ) Purpose : Purchases tokens from a sale without requiring cryptographic proof. Parameters : - multiSaleId (uint256): ID of the token sale - purchaser (address): Address making the purchase (defaults to msg.sender if zero) - receiver (address): Address receiving tokens (defaults to msg.sender if zero) - quantity (uint256): Number of tokens to purchase - data (bytes): Additional data for minting process Returns : - ids (uint256[]): Array of minted token IDs Security : Uses nonReentrant modifier for payment protection Process : 1. Retrieves sale configuration and calculates total price 2. Validates and processes payment (ETH or ERC20) 3. Sets default addresses if not provided 4. Checks purchase limits and constraints 5. Processes purchase through MultiSaleLib 6. Mints tokens to receiver 7. Updates sale state and tracking 8. Emits purchase event Payment Handling : - ETH : Validates sufficient payment, refunds excess automatically - ERC20 : Validates no ETH sent, transfers payment tokens Example Usage : // Purchase 3 NFTs with ETH uint256 [] memory tokenIds = IMultiSale ( diamond ). purchase { value : 0 . 3 ether }( saleId , address ( 0 ), // Use msg.sender as purchaser address ( 0 ), // Use msg.sender as receiver 3 , // Purchase 3 tokens \"\" // No additional data ); console . log ( \"Purchased\" , tokenIds . length , \"NFTs\" ); Error Conditions : - \"Insufficient ETH sent\" - Not enough ETH for purchase - \"Do not send ETH for ERC20 payments\" - ETH sent for ERC20 sale - \"maxperaccount\" - Exceeds per-account purchase limit - \"ETH transfer failed\" - Refund transfer failure purchaseProof() \u00b6 function purchaseProof ( MultiSalePurchase memory purchaseInfo , MultiSaleProof memory purchaseProofParam ) external payable nonReentrant returns ( uint256 [] memory ids ) Purpose : Purchases tokens using cryptographic proof for allowlist or presale access. Parameters : - purchaseInfo (MultiSalePurchase): Purchase details - purchaseProofParam (MultiSaleProof): Cryptographic proof and data Returns : - ids (uint256[]): Array of minted token IDs Security : Uses nonReentrant modifier and proof validation Process : 1. Retrieves sale configuration 2. Validates purchase limits against receiver address 3. Sets default addresses if not provided 4. Validates and processes payment 5. Validates cryptographic proof through MultiSaleLib 6. Mints tokens to receiver 7. Updates sale state and tracking 8. Emits purchase event Proof Types : - Merkle Proofs : For allowlist verification - Signature Proofs : For presale authorization - Custom Proofs : Application-specific verification Example Usage : // Purchase with Merkle proof for allowlist MultiSalePurchase memory purchase = MultiSalePurchase ({ multiSaleId : saleId , purchaser : msg.sender , receiver : msg.sender , quantity : 2 }); MultiSaleProof memory proof = MultiSaleProof ({ proof : merkleProof , data : abi . encode ( maxAllowedQuantity ) }); uint256 [] memory tokenIds = IMultiSale ( diamond ). purchaseProof { value : 0 . 2 ether }( purchase , proof ); Query Functions \u00b6 getTokenSaleSettings() \u00b6 function getTokenSaleSettings ( uint256 tokenSaleId ) external view virtual returns ( MultiSaleSettings memory settings ) Purpose : Retrieves complete configuration for a specific token sale. Parameters : - tokenSaleId (uint256): ID of the token sale Returns : - settings (MultiSaleSettings): Complete sale configuration Example Usage : MultiSaleSettings memory saleConfig = IMultiSale ( diamond ). getTokenSaleSettings ( saleId ); console . log ( \"Sale price:\" , saleConfig . price . price ); console . log ( \"Max per account:\" , saleConfig . maxQuantityPerAccount ); getTokenSaleIds() \u00b6 function getTokenSaleIds () external view returns ( uint256 [] memory ) Purpose : Returns all token sale IDs in the system. Returns : Array of token sale IDs Example Usage : uint256 [] memory allSaleIds = IMultiSale ( diamond ). getTokenSaleIds (); console . log ( \"Total sales:\" , allSaleIds . length ); listTokenSales() \u00b6 function listTokenSales () external view returns ( MultiSaleSettings [] memory ) Purpose : Returns complete settings for all token sales. Returns : Array of MultiSaleSettings for all sales Example Usage : MultiSaleSettings [] memory allSales = IMultiSale ( diamond ). listTokenSales (); for ( uint256 i = 0 ; i < allSales . length ; i ++ ) { console . log ( \"Sale\" , i , \"price:\" , allSales [ i ]. price . price ); } Integration Examples \u00b6 NFT Collection Sale \u00b6 // Create and manage NFT collection sale contract NFTCollectionSale { function createNFTSale ( address nftContract , uint256 pricePerNFT , uint256 maxPerWallet ) external onlyOwner returns ( uint256 ) { MultiSaleSettings memory settings = MultiSaleSettings ({ token : nftContract , tokenType : TokenType . ERC721 , owner : msg.sender , price : VariablePriceContract ({ price : pricePerNFT , priceType : PriceType . FIXED }), paymentMethod : PaymentMethod . ETH , paymentToken : address ( 0 ), maxQuantityPerAccount : maxPerWallet }); return IMultiSale ( diamond ). createTokenSale ( settings ); } function purchaseNFTs ( uint256 saleId , uint256 quantity ) external payable { uint256 [] memory tokenIds = IMultiSale ( diamond ). purchase { value : msg.value }( saleId , msg.sender , msg.sender , quantity , \"\" ); emit NFTsPurchased ( msg.sender , tokenIds ); } } Allowlist Presale \u00b6 // Implement allowlist-based presale contract AllowlistPresale { bytes32 public merkleRoot ; function setAllowlist ( bytes32 _merkleRoot ) external onlyOwner { merkleRoot = _merkleRoot ; } function purchaseWithAllowlist ( uint256 saleId , uint256 quantity , uint256 maxAllowed , bytes32 [] calldata merkleProof ) external payable { // Verify Merkle proof bytes32 leaf = keccak256 ( abi . encodePacked ( msg.sender , maxAllowed )); require ( MerkleProof . verify ( merkleProof , merkleRoot , leaf ), \"Invalid proof\" ); MultiSalePurchase memory purchase = MultiSalePurchase ({ multiSaleId : saleId , purchaser : msg.sender , receiver : msg.sender , quantity : quantity }); MultiSaleProof memory proof = MultiSaleProof ({ proof : abi . encode ( merkleProof ), data : abi . encode ( maxAllowed ) }); uint256 [] memory tokenIds = IMultiSale ( diamond ). purchaseProof { value : msg.value }( purchase , proof ); emit AllowlistPurchase ( msg.sender , tokenIds , quantity ); } } Multi-Token Marketplace \u00b6 // Support multiple token types in one marketplace contract MultiTokenMarketplace { function createERC20Sale ( address tokenContract , uint256 tokensPerETH , address paymentToken ) external returns ( uint256 ) { MultiSaleSettings memory settings = MultiSaleSettings ({ token : tokenContract , tokenType : TokenType . ERC20 , owner : msg.sender , price : VariablePriceContract ({ price : 1 ether / tokensPerETH , priceType : PriceType . FIXED }), paymentMethod : PaymentMethod . ERC20 , paymentToken : paymentToken , maxQuantityPerAccount : 0 // Unlimited }); return IMultiSale ( diamond ). createTokenSale ( settings ); } function createERC1155Sale ( address tokenContract , uint256 pricePerToken , uint256 maxPerAccount ) external returns ( uint256 ) { MultiSaleSettings memory settings = MultiSaleSettings ({ token : tokenContract , tokenType : TokenType . ERC1155 , owner : msg.sender , price : VariablePriceContract ({ price : pricePerToken , priceType : PriceType . FIXED }), paymentMethod : PaymentMethod . ETH , paymentToken : address ( 0 ), maxQuantityPerAccount : maxPerAccount }); return IMultiSale ( diamond ). createTokenSale ( settings ); } } Dynamic Pricing Sale \u00b6 // Implement dynamic pricing mechanisms contract DynamicPricingSale { function createTimedSale ( address tokenContract , uint256 startPrice , uint256 endPrice , uint256 duration ) external returns ( uint256 ) { MultiSaleSettings memory settings = MultiSaleSettings ({ token : tokenContract , tokenType : TokenType . ERC721 , owner : msg.sender , price : VariablePriceContract ({ price : startPrice , priceType : PriceType . LINEAR_DECREASE , startTime : block.timestamp , endTime : block.timestamp + duration , endPrice : endPrice }), paymentMethod : PaymentMethod . ETH , paymentToken : address ( 0 ), maxQuantityPerAccount : 10 }); return IMultiSale ( diamond ). createTokenSale ( settings ); } function getCurrentPrice ( uint256 saleId ) external view returns ( uint256 ) { MultiSaleSettings memory settings = IMultiSale ( diamond ). getTokenSaleSettings ( saleId ); return VariablePriceLib . calculateCurrentPrice ( settings . price ); } } Batch Purchase System \u00b6 // Enable batch purchases across multiple sales contract BatchPurchaseSystem { struct BatchPurchase { uint256 saleId ; uint256 quantity ; bytes data ; } function batchPurchase ( BatchPurchase [] calldata purchases ) external payable { uint256 totalValue = 0 ; for ( uint256 i = 0 ; i < purchases . length ; i ++ ) { MultiSaleSettings memory settings = IMultiSale ( diamond ). getTokenSaleSettings ( purchases [ i ]. saleId ); uint256 purchaseValue = settings . price . price * purchases [ i ]. quantity ; uint256 [] memory tokenIds = IMultiSale ( diamond ). purchase { value : purchaseValue }( purchases [ i ]. saleId , msg.sender , msg.sender , purchases [ i ]. quantity , purchases [ i ]. data ); totalValue += purchaseValue ; emit BatchPurchaseItem ( purchases [ i ]. saleId , tokenIds ); } // Refund any excess ETH if ( msg.value > totalValue ) { ( bool success , ) = payable ( msg.sender ). call { value : msg.value - totalValue }( \"\" ); require ( success , \"Refund failed\" ); } } } Events \u00b6 Sale Management Events \u00b6 event MultiSaleCreated ( uint256 indexed tokenSaleId , MultiSaleSettings settings ); event MultiSaleUpdated ( uint256 indexed tokenSaleId , MultiSaleSettings settings ); Purchase Events \u00b6 event MultiSaleSold ( uint256 indexed multiSaleId , address indexed purchaser , uint256 [] tokenIds , bytes data ); Security Considerations \u00b6 Reentrancy Protection \u00b6 All payment functions use nonReentrant modifier Secure ETH and ERC20 token handling Automatic excess ETH refunds Access Control \u00b6 Owner-only sale creation and updates Sale owner permissions for configuration changes Purchaser validation and limits Payment Security \u00b6 Precise payment amount validation Automatic excess payment refunds Secure token transfer mechanisms Proof Validation \u00b6 Cryptographic proof verification for allowlists Merkle proof support for presales Custom proof mechanisms for advanced use cases Gas Optimization \u00b6 Efficient Minting \u00b6 Batch minting for multiple tokens Optimized token ID generation Minimal storage operations Payment Processing \u00b6 Single transaction for purchase and minting Efficient excess ETH handling Optimized storage updates Error Handling \u00b6 Purchase Errors \u00b6 \"Insufficient ETH sent\" - Payment amount validation \"maxperaccount\" - Purchase limit enforcement \"Token not supported\" - Invalid token type Access Errors \u00b6 \"notowner\" - Unauthorized sale updates Proof validation failures Payment method mismatches Testing Considerations \u00b6 Unit Tests \u00b6 Sale creation and configuration Purchase flows for all token types Payment processing and refunds Access control validation Integration Tests \u00b6 Multi-token sale scenarios Allowlist and proof verification Dynamic pricing mechanisms Batch operation efficiency Related Documentation \u00b6 IMultiSale - Multi-sale interface MultiSaleLib - Multi-sale utilities VariablePriceLib - Pricing mechanisms MarketplaceFacet - Marketplace integration Token Sale Guide - Implementation guide This facet provides comprehensive multi-token sale functionality within the Gemforce platform, supporting diverse token standards and advanced sale mechanisms for flexible marketplace operations.","title":"Multi Sale Facet"},{"location":"smart-contracts/facets/multi-sale-facet/#multisalefacet","text":"","title":"MultiSaleFacet"},{"location":"smart-contracts/facets/multi-sale-facet/#overview","text":"The MultiSaleFacet.sol provides comprehensive multi-token sale functionality within the Gemforce diamond system. This facet enables the creation and management of token sales supporting multiple token standards (ERC20, ERC721, ERC1155) with flexible payment methods, allowlist support, and advanced purchase controls.","title":"Overview"},{"location":"smart-contracts/facets/multi-sale-facet/#contract-details","text":"Contract Name : MultiSaleFacet Inheritance : IMultiSale , Modifiers , ReentrancyGuard License : MIT Solidity Version : >=0.8.0","title":"Contract Details"},{"location":"smart-contracts/facets/multi-sale-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/multi-sale-facet/#multi-token-standard-support","text":"ERC20 fungible token sales ERC721 NFT individual sales ERC1155 semi-fungible token sales Automatic token type detection and minting","title":"\ud83d\udd39 Multi-Token Standard Support"},{"location":"smart-contracts/facets/multi-sale-facet/#flexible-payment-methods","text":"ETH payments with automatic refund of excess ERC20 token payments Configurable payment tokens per sale Secure payment processing with reentrancy protection","title":"\ud83d\udd39 Flexible Payment Methods"},{"location":"smart-contracts/facets/multi-sale-facet/#advanced-sale-controls","text":"Per-account purchase limits Allowlist support with cryptographic proofs Variable pricing mechanisms Owner and admin access controls","title":"\ud83d\udd39 Advanced Sale Controls"},{"location":"smart-contracts/facets/multi-sale-facet/#comprehensive-sale-management","text":"Create, update, and query token sales Track purchase history and quantities Batch operations for efficiency Event-driven architecture for transparency","title":"\ud83d\udd39 Comprehensive Sale Management"},{"location":"smart-contracts/facets/multi-sale-facet/#core-data-structures","text":"","title":"Core Data Structures"},{"location":"smart-contracts/facets/multi-sale-facet/#multisalesettings","text":"struct MultiSaleSettings { address token ; // Token contract address TokenType tokenType ; // ERC20, ERC721, or ERC1155 address owner ; // Sale owner (receives payments) VariablePriceContract price ; // Price configuration PaymentMethod paymentMethod ; // ETH or ERC20 address paymentToken ; // ERC20 token for payments (if applicable) uint256 maxQuantityPerAccount ; // Purchase limit per account (0 = unlimited) // Additional configuration fields... }","title":"MultiSaleSettings"},{"location":"smart-contracts/facets/multi-sale-facet/#multisalepurchase","text":"struct MultiSalePurchase { uint256 multiSaleId ; // ID of the token sale address purchaser ; // Address making the purchase address receiver ; // Address receiving the tokens uint256 quantity ; // Number of tokens to purchase }","title":"MultiSalePurchase"},{"location":"smart-contracts/facets/multi-sale-facet/#multisaleproof","text":"struct MultiSaleProof { bytes proof ; // Cryptographic proof (e.g., Merkle proof) bytes data ; // Additional proof or purchase data }","title":"MultiSaleProof"},{"location":"smart-contracts/facets/multi-sale-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/multi-sale-facet/#sale-management-functions","text":"","title":"Sale Management Functions"},{"location":"smart-contracts/facets/multi-sale-facet/#createtokensale","text":"function createTokenSale ( MultiSaleSettings memory tokenSaleInit ) external virtual onlyOwner returns ( uint256 tokenSaleId ) Purpose : Creates a new token sale with specified configuration. Parameters : - tokenSaleInit (MultiSaleSettings): Complete sale configuration Returns : - tokenSaleId (uint256): Unique identifier for the new sale Access Control : Owner only Process : 1. Generates unique token sale ID 2. Stores complete sale configuration 3. Adds sale ID to tracking array 4. Emits MultiSaleCreated event Events : MultiSaleCreated(tokenSaleId, settings) Example Usage : // Create NFT sale with ETH payment MultiSaleSettings memory nftSale = MultiSaleSettings ({ token : nftContractAddress , tokenType : TokenType . ERC721 , owner : saleOwner , price : VariablePriceContract ({ price : 0 . 1 ether , // Additional price configuration... }), paymentMethod : PaymentMethod . ETH , paymentToken : address ( 0 ), maxQuantityPerAccount : 5 // Additional settings... }); uint256 saleId = IMultiSale ( diamond ). createTokenSale ( nftSale ); console . log ( \"Created NFT sale with ID:\" , saleId );","title":"createTokenSale()"},{"location":"smart-contracts/facets/multi-sale-facet/#updatetokensalesettings","text":"function updateTokenSaleSettings ( uint256 tokenSaleId , MultiSaleSettings memory settings ) external Purpose : Updates configuration for an existing token sale. Parameters : - tokenSaleId (uint256): ID of the sale to update - settings (MultiSaleSettings): New configuration settings Access Control : Sale owner or contract owner Process : 1. Validates caller permissions 2. Replaces existing settings with new configuration 3. Emits MultiSaleUpdated event Events : MultiSaleUpdated(tokenSaleId, settings) Example Usage : // Update sale price and purchase limit MultiSaleSettings memory updatedSettings = existingSettings ; updatedSettings . price . price = 0 . 15 ether ; updatedSettings . maxQuantityPerAccount = 3 ; IMultiSale ( diamond ). updateTokenSaleSettings ( saleId , updatedSettings );","title":"updateTokenSaleSettings()"},{"location":"smart-contracts/facets/multi-sale-facet/#purchase-functions","text":"","title":"Purchase Functions"},{"location":"smart-contracts/facets/multi-sale-facet/#purchase","text":"function purchase ( uint256 multiSaleId , address purchaser , address receiver , uint256 quantity , bytes memory data ) external payable nonReentrant returns ( uint256 [] memory ids ) Purpose : Purchases tokens from a sale without requiring cryptographic proof. Parameters : - multiSaleId (uint256): ID of the token sale - purchaser (address): Address making the purchase (defaults to msg.sender if zero) - receiver (address): Address receiving tokens (defaults to msg.sender if zero) - quantity (uint256): Number of tokens to purchase - data (bytes): Additional data for minting process Returns : - ids (uint256[]): Array of minted token IDs Security : Uses nonReentrant modifier for payment protection Process : 1. Retrieves sale configuration and calculates total price 2. Validates and processes payment (ETH or ERC20) 3. Sets default addresses if not provided 4. Checks purchase limits and constraints 5. Processes purchase through MultiSaleLib 6. Mints tokens to receiver 7. Updates sale state and tracking 8. Emits purchase event Payment Handling : - ETH : Validates sufficient payment, refunds excess automatically - ERC20 : Validates no ETH sent, transfers payment tokens Example Usage : // Purchase 3 NFTs with ETH uint256 [] memory tokenIds = IMultiSale ( diamond ). purchase { value : 0 . 3 ether }( saleId , address ( 0 ), // Use msg.sender as purchaser address ( 0 ), // Use msg.sender as receiver 3 , // Purchase 3 tokens \"\" // No additional data ); console . log ( \"Purchased\" , tokenIds . length , \"NFTs\" ); Error Conditions : - \"Insufficient ETH sent\" - Not enough ETH for purchase - \"Do not send ETH for ERC20 payments\" - ETH sent for ERC20 sale - \"maxperaccount\" - Exceeds per-account purchase limit - \"ETH transfer failed\" - Refund transfer failure","title":"purchase()"},{"location":"smart-contracts/facets/multi-sale-facet/#purchaseproof","text":"function purchaseProof ( MultiSalePurchase memory purchaseInfo , MultiSaleProof memory purchaseProofParam ) external payable nonReentrant returns ( uint256 [] memory ids ) Purpose : Purchases tokens using cryptographic proof for allowlist or presale access. Parameters : - purchaseInfo (MultiSalePurchase): Purchase details - purchaseProofParam (MultiSaleProof): Cryptographic proof and data Returns : - ids (uint256[]): Array of minted token IDs Security : Uses nonReentrant modifier and proof validation Process : 1. Retrieves sale configuration 2. Validates purchase limits against receiver address 3. Sets default addresses if not provided 4. Validates and processes payment 5. Validates cryptographic proof through MultiSaleLib 6. Mints tokens to receiver 7. Updates sale state and tracking 8. Emits purchase event Proof Types : - Merkle Proofs : For allowlist verification - Signature Proofs : For presale authorization - Custom Proofs : Application-specific verification Example Usage : // Purchase with Merkle proof for allowlist MultiSalePurchase memory purchase = MultiSalePurchase ({ multiSaleId : saleId , purchaser : msg.sender , receiver : msg.sender , quantity : 2 }); MultiSaleProof memory proof = MultiSaleProof ({ proof : merkleProof , data : abi . encode ( maxAllowedQuantity ) }); uint256 [] memory tokenIds = IMultiSale ( diamond ). purchaseProof { value : 0 . 2 ether }( purchase , proof );","title":"purchaseProof()"},{"location":"smart-contracts/facets/multi-sale-facet/#query-functions","text":"","title":"Query Functions"},{"location":"smart-contracts/facets/multi-sale-facet/#gettokensalesettings","text":"function getTokenSaleSettings ( uint256 tokenSaleId ) external view virtual returns ( MultiSaleSettings memory settings ) Purpose : Retrieves complete configuration for a specific token sale. Parameters : - tokenSaleId (uint256): ID of the token sale Returns : - settings (MultiSaleSettings): Complete sale configuration Example Usage : MultiSaleSettings memory saleConfig = IMultiSale ( diamond ). getTokenSaleSettings ( saleId ); console . log ( \"Sale price:\" , saleConfig . price . price ); console . log ( \"Max per account:\" , saleConfig . maxQuantityPerAccount );","title":"getTokenSaleSettings()"},{"location":"smart-contracts/facets/multi-sale-facet/#gettokensaleids","text":"function getTokenSaleIds () external view returns ( uint256 [] memory ) Purpose : Returns all token sale IDs in the system. Returns : Array of token sale IDs Example Usage : uint256 [] memory allSaleIds = IMultiSale ( diamond ). getTokenSaleIds (); console . log ( \"Total sales:\" , allSaleIds . length );","title":"getTokenSaleIds()"},{"location":"smart-contracts/facets/multi-sale-facet/#listtokensales","text":"function listTokenSales () external view returns ( MultiSaleSettings [] memory ) Purpose : Returns complete settings for all token sales. Returns : Array of MultiSaleSettings for all sales Example Usage : MultiSaleSettings [] memory allSales = IMultiSale ( diamond ). listTokenSales (); for ( uint256 i = 0 ; i < allSales . length ; i ++ ) { console . log ( \"Sale\" , i , \"price:\" , allSales [ i ]. price . price ); }","title":"listTokenSales()"},{"location":"smart-contracts/facets/multi-sale-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/facets/multi-sale-facet/#nft-collection-sale","text":"// Create and manage NFT collection sale contract NFTCollectionSale { function createNFTSale ( address nftContract , uint256 pricePerNFT , uint256 maxPerWallet ) external onlyOwner returns ( uint256 ) { MultiSaleSettings memory settings = MultiSaleSettings ({ token : nftContract , tokenType : TokenType . ERC721 , owner : msg.sender , price : VariablePriceContract ({ price : pricePerNFT , priceType : PriceType . FIXED }), paymentMethod : PaymentMethod . ETH , paymentToken : address ( 0 ), maxQuantityPerAccount : maxPerWallet }); return IMultiSale ( diamond ). createTokenSale ( settings ); } function purchaseNFTs ( uint256 saleId , uint256 quantity ) external payable { uint256 [] memory tokenIds = IMultiSale ( diamond ). purchase { value : msg.value }( saleId , msg.sender , msg.sender , quantity , \"\" ); emit NFTsPurchased ( msg.sender , tokenIds ); } }","title":"NFT Collection Sale"},{"location":"smart-contracts/facets/multi-sale-facet/#allowlist-presale","text":"// Implement allowlist-based presale contract AllowlistPresale { bytes32 public merkleRoot ; function setAllowlist ( bytes32 _merkleRoot ) external onlyOwner { merkleRoot = _merkleRoot ; } function purchaseWithAllowlist ( uint256 saleId , uint256 quantity , uint256 maxAllowed , bytes32 [] calldata merkleProof ) external payable { // Verify Merkle proof bytes32 leaf = keccak256 ( abi . encodePacked ( msg.sender , maxAllowed )); require ( MerkleProof . verify ( merkleProof , merkleRoot , leaf ), \"Invalid proof\" ); MultiSalePurchase memory purchase = MultiSalePurchase ({ multiSaleId : saleId , purchaser : msg.sender , receiver : msg.sender , quantity : quantity }); MultiSaleProof memory proof = MultiSaleProof ({ proof : abi . encode ( merkleProof ), data : abi . encode ( maxAllowed ) }); uint256 [] memory tokenIds = IMultiSale ( diamond ). purchaseProof { value : msg.value }( purchase , proof ); emit AllowlistPurchase ( msg.sender , tokenIds , quantity ); } }","title":"Allowlist Presale"},{"location":"smart-contracts/facets/multi-sale-facet/#multi-token-marketplace","text":"// Support multiple token types in one marketplace contract MultiTokenMarketplace { function createERC20Sale ( address tokenContract , uint256 tokensPerETH , address paymentToken ) external returns ( uint256 ) { MultiSaleSettings memory settings = MultiSaleSettings ({ token : tokenContract , tokenType : TokenType . ERC20 , owner : msg.sender , price : VariablePriceContract ({ price : 1 ether / tokensPerETH , priceType : PriceType . FIXED }), paymentMethod : PaymentMethod . ERC20 , paymentToken : paymentToken , maxQuantityPerAccount : 0 // Unlimited }); return IMultiSale ( diamond ). createTokenSale ( settings ); } function createERC1155Sale ( address tokenContract , uint256 pricePerToken , uint256 maxPerAccount ) external returns ( uint256 ) { MultiSaleSettings memory settings = MultiSaleSettings ({ token : tokenContract , tokenType : TokenType . ERC1155 , owner : msg.sender , price : VariablePriceContract ({ price : pricePerToken , priceType : PriceType . FIXED }), paymentMethod : PaymentMethod . ETH , paymentToken : address ( 0 ), maxQuantityPerAccount : maxPerAccount }); return IMultiSale ( diamond ). createTokenSale ( settings ); } }","title":"Multi-Token Marketplace"},{"location":"smart-contracts/facets/multi-sale-facet/#dynamic-pricing-sale","text":"// Implement dynamic pricing mechanisms contract DynamicPricingSale { function createTimedSale ( address tokenContract , uint256 startPrice , uint256 endPrice , uint256 duration ) external returns ( uint256 ) { MultiSaleSettings memory settings = MultiSaleSettings ({ token : tokenContract , tokenType : TokenType . ERC721 , owner : msg.sender , price : VariablePriceContract ({ price : startPrice , priceType : PriceType . LINEAR_DECREASE , startTime : block.timestamp , endTime : block.timestamp + duration , endPrice : endPrice }), paymentMethod : PaymentMethod . ETH , paymentToken : address ( 0 ), maxQuantityPerAccount : 10 }); return IMultiSale ( diamond ). createTokenSale ( settings ); } function getCurrentPrice ( uint256 saleId ) external view returns ( uint256 ) { MultiSaleSettings memory settings = IMultiSale ( diamond ). getTokenSaleSettings ( saleId ); return VariablePriceLib . calculateCurrentPrice ( settings . price ); } }","title":"Dynamic Pricing Sale"},{"location":"smart-contracts/facets/multi-sale-facet/#batch-purchase-system","text":"// Enable batch purchases across multiple sales contract BatchPurchaseSystem { struct BatchPurchase { uint256 saleId ; uint256 quantity ; bytes data ; } function batchPurchase ( BatchPurchase [] calldata purchases ) external payable { uint256 totalValue = 0 ; for ( uint256 i = 0 ; i < purchases . length ; i ++ ) { MultiSaleSettings memory settings = IMultiSale ( diamond ). getTokenSaleSettings ( purchases [ i ]. saleId ); uint256 purchaseValue = settings . price . price * purchases [ i ]. quantity ; uint256 [] memory tokenIds = IMultiSale ( diamond ). purchase { value : purchaseValue }( purchases [ i ]. saleId , msg.sender , msg.sender , purchases [ i ]. quantity , purchases [ i ]. data ); totalValue += purchaseValue ; emit BatchPurchaseItem ( purchases [ i ]. saleId , tokenIds ); } // Refund any excess ETH if ( msg.value > totalValue ) { ( bool success , ) = payable ( msg.sender ). call { value : msg.value - totalValue }( \"\" ); require ( success , \"Refund failed\" ); } } }","title":"Batch Purchase System"},{"location":"smart-contracts/facets/multi-sale-facet/#events","text":"","title":"Events"},{"location":"smart-contracts/facets/multi-sale-facet/#sale-management-events","text":"event MultiSaleCreated ( uint256 indexed tokenSaleId , MultiSaleSettings settings ); event MultiSaleUpdated ( uint256 indexed tokenSaleId , MultiSaleSettings settings );","title":"Sale Management Events"},{"location":"smart-contracts/facets/multi-sale-facet/#purchase-events","text":"event MultiSaleSold ( uint256 indexed multiSaleId , address indexed purchaser , uint256 [] tokenIds , bytes data );","title":"Purchase Events"},{"location":"smart-contracts/facets/multi-sale-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/multi-sale-facet/#reentrancy-protection","text":"All payment functions use nonReentrant modifier Secure ETH and ERC20 token handling Automatic excess ETH refunds","title":"Reentrancy Protection"},{"location":"smart-contracts/facets/multi-sale-facet/#access-control","text":"Owner-only sale creation and updates Sale owner permissions for configuration changes Purchaser validation and limits","title":"Access Control"},{"location":"smart-contracts/facets/multi-sale-facet/#payment-security","text":"Precise payment amount validation Automatic excess payment refunds Secure token transfer mechanisms","title":"Payment Security"},{"location":"smart-contracts/facets/multi-sale-facet/#proof-validation","text":"Cryptographic proof verification for allowlists Merkle proof support for presales Custom proof mechanisms for advanced use cases","title":"Proof Validation"},{"location":"smart-contracts/facets/multi-sale-facet/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/facets/multi-sale-facet/#efficient-minting","text":"Batch minting for multiple tokens Optimized token ID generation Minimal storage operations","title":"Efficient Minting"},{"location":"smart-contracts/facets/multi-sale-facet/#payment-processing","text":"Single transaction for purchase and minting Efficient excess ETH handling Optimized storage updates","title":"Payment Processing"},{"location":"smart-contracts/facets/multi-sale-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/multi-sale-facet/#purchase-errors","text":"\"Insufficient ETH sent\" - Payment amount validation \"maxperaccount\" - Purchase limit enforcement \"Token not supported\" - Invalid token type","title":"Purchase Errors"},{"location":"smart-contracts/facets/multi-sale-facet/#access-errors","text":"\"notowner\" - Unauthorized sale updates Proof validation failures Payment method mismatches","title":"Access Errors"},{"location":"smart-contracts/facets/multi-sale-facet/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/facets/multi-sale-facet/#unit-tests","text":"Sale creation and configuration Purchase flows for all token types Payment processing and refunds Access control validation","title":"Unit Tests"},{"location":"smart-contracts/facets/multi-sale-facet/#integration-tests","text":"Multi-token sale scenarios Allowlist and proof verification Dynamic pricing mechanisms Batch operation efficiency","title":"Integration Tests"},{"location":"smart-contracts/facets/multi-sale-facet/#related-documentation","text":"IMultiSale - Multi-sale interface MultiSaleLib - Multi-sale utilities VariablePriceLib - Pricing mechanisms MarketplaceFacet - Marketplace integration Token Sale Guide - Implementation guide This facet provides comprehensive multi-token sale functionality within the Gemforce platform, supporting diverse token standards and advanced sale mechanisms for flexible marketplace operations.","title":"Related Documentation"},{"location":"smart-contracts/facets/ownership-facet/","text":"Ownership Facet \u00b6 The Ownership Facet provides ownership management functionality for diamond contracts, implementing access control patterns that restrict administrative operations to authorized users. Overview \u00b6 The Ownership Facet is a critical security component that provides: Access Control : Restrict sensitive operations to contract owner Ownership Transfer : Safe transfer of contract ownership Administrative Functions : Foundation for other facet access controls Security Patterns : Standard ownership verification mechanisms Key Features \u00b6 Ownership Management \u00b6 Owner Verification : Check if address is contract owner Ownership Transfer : Transfer ownership to new address Renounce Ownership : Remove ownership (irreversible) Pending Ownership : Two-step ownership transfer for safety Access Control Integration \u00b6 Modifier Support : Provides onlyOwner functionality Facet Integration : Other facets can use ownership checks Administrative Gates : Controls access to upgrade functions Emergency Controls : Owner-only emergency functions Interface \u00b6 interface IOwnership { event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ); function owner () external view returns ( address owner_ ); function transferOwnership ( address _newOwner ) external ; function renounceOwnership () external ; } Core Functions \u00b6 owner() \u00b6 Returns the current owner of the contract. Returns: - address : Current owner address Usage: address currentOwner = IOwnership ( diamond ). owner (); transferOwnership() \u00b6 Transfers ownership to a new address. Parameters: - _newOwner : Address of the new owner Access Control: - Only current owner can call this function Events: - Emits OwnershipTransferred event Usage: IOwnership ( diamond ). transferOwnership ( newOwnerAddress ); renounceOwnership() \u00b6 Renounces ownership, leaving the contract without an owner. Warning: This is irreversible and will disable all owner-only functions. Access Control: - Only current owner can call this function Events: - Emits OwnershipTransferred with new owner as address(0) Implementation Patterns \u00b6 Basic Ownership Check \u00b6 contract ExampleFacet { modifier onlyOwner () { require ( LibDiamond . contractOwner () == msg.sender , \"Not owner\" ); _ ; } function adminFunction () external onlyOwner { // Admin-only logic here } } Safe Ownership Transfer \u00b6 contract SafeOwnershipFacet { address private pendingOwner ; function transferOwnership ( address newOwner ) external onlyOwner { require ( newOwner != address ( 0 ), \"Invalid owner\" ); pendingOwner = newOwner ; } function acceptOwnership () external { require ( msg.sender == pendingOwner , \"Not pending owner\" ); address oldOwner = LibDiamond . contractOwner (); LibDiamond . setContractOwner ( pendingOwner ); pendingOwner = address ( 0 ); emit OwnershipTransferred ( oldOwner , msg.sender ); } } Multi-Signature Integration \u00b6 contract MultiSigOwnership { mapping ( address => bool ) public isOwner ; uint256 public requiredSignatures ; struct Transaction { address to ; bytes data ; uint256 confirmations ; mapping ( address => bool ) confirmed ; bool executed ; } mapping ( uint256 => Transaction ) public transactions ; uint256 public transactionCount ; modifier onlyMultiSigOwner () { require ( isOwner [ msg.sender ], \"Not authorized\" ); _ ; } function submitTransaction ( address to , bytes memory data ) external onlyMultiSigOwner returns ( uint256 transactionId ) { transactionId = transactionCount ++ ; Transaction storage txn = transactions [ transactionId ]; txn . to = to ; txn . data = data ; confirmTransaction ( transactionId ); } function confirmTransaction ( uint256 transactionId ) public onlyMultiSigOwner { Transaction storage txn = transactions [ transactionId ]; require ( ! txn . confirmed [ msg.sender ], \"Already confirmed\" ); txn . confirmed [ msg.sender ] = true ; txn . confirmations ++ ; if ( txn . confirmations >= requiredSignatures ) { executeTransaction ( transactionId ); } } } Security Considerations \u00b6 Access Control \u00b6 Owner Verification : Always verify caller is owner Zero Address Check : Prevent ownership transfer to zero address Reentrancy Protection : Consider reentrancy in ownership functions Event Emission : Always emit events for ownership changes Ownership Transfer Safety \u00b6 Two-Step Transfer : Use pending ownership pattern for safety Address Validation : Validate new owner addresses Confirmation Required : Require new owner to accept ownership Timelock Integration : Consider timelock for ownership changes Emergency Considerations \u00b6 Recovery Mechanisms : Plan for owner key loss scenarios Multi-Signature : Use multi-sig for high-value contracts Governance Integration : Consider DAO governance for ownership Upgrade Restrictions : Limit upgrade capabilities appropriately Integration with Diamond Standard \u00b6 LibDiamond Integration \u00b6 library LibDiamond { bytes32 constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.standard.diamond.storage\" ); struct DiamondStorage { mapping ( bytes4 => bytes32 ) facets ; mapping ( uint256 => bytes32 ) selectorSlots ; uint256 selectorCount ; mapping ( bytes4 => bool ) supportedInterfaces ; address contractOwner ; } function diamondStorage () internal pure returns ( DiamondStorage storage ds ) { bytes32 position = DIAMOND_STORAGE_POSITION ; assembly { ds . slot := position } } function setContractOwner ( address _newOwner ) internal { DiamondStorage storage ds = diamondStorage (); address previousOwner = ds . contractOwner ; ds . contractOwner = _newOwner ; emit OwnershipTransferred ( previousOwner , _newOwner ); } function contractOwner () internal view returns ( address contractOwner_ ) { contractOwner_ = diamondStorage (). contractOwner ; } function enforceIsContractOwner () internal view { require ( msg.sender == diamondStorage (). contractOwner , \"LibDiamond: Must be contract owner\" ); } } Diamond Cut Integration \u00b6 contract DiamondCutFacet is IDiamondCut { function diamondCut ( FacetCut [] calldata _diamondCut , address _init , bytes calldata _calldata ) external override { LibDiamond . enforceIsContractOwner (); LibDiamond . diamondCut ( _diamondCut , _init , _calldata ); } } Best Practices \u00b6 Development Guidelines \u00b6 Always Use Modifiers : Use onlyOwner modifier consistently Event Emission : Emit events for all ownership changes Address Validation : Validate addresses before ownership transfer Documentation : Document all owner-only functions clearly Production Deployment \u00b6 Multi-Signature : Use multi-sig wallets for production ownership Timelock Contracts : Consider timelock for sensitive operations Governance Integration : Plan for decentralized governance Emergency Procedures : Establish emergency response procedures Security Auditing \u00b6 Access Control Review : Audit all access control mechanisms Ownership Transfer Testing : Test ownership transfer scenarios Emergency Function Testing : Test emergency and recovery functions Multi-Signature Validation : Validate multi-sig implementations Common Patterns \u00b6 Role-Based Access Control \u00b6 contract RoleBasedOwnership { bytes32 public constant ADMIN_ROLE = keccak256 ( \"ADMIN_ROLE\" ); bytes32 public constant OPERATOR_ROLE = keccak256 ( \"OPERATOR_ROLE\" ); mapping ( bytes32 => mapping ( address => bool )) private roles ; modifier onlyRole ( bytes32 role ) { require ( hasRole ( role , msg.sender ), \"AccessControl: account missing role\" ); _ ; } function hasRole ( bytes32 role , address account ) public view returns ( bool ) { return roles [ role ][ account ] || ( role == ADMIN_ROLE && account == LibDiamond . contractOwner ()); } function grantRole ( bytes32 role , address account ) external onlyOwner { roles [ role ][ account ] = true ; } function revokeRole ( bytes32 role , address account ) external onlyOwner { roles [ role ][ account ] = false ; } } Pausable Contract \u00b6 contract PausableOwnership { bool private paused ; event Paused ( address account ); event Unpaused ( address account ); modifier whenNotPaused () { require ( ! paused , \"Contract is paused\" ); _ ; } modifier whenPaused () { require ( paused , \"Contract is not paused\" ); _ ; } function pause () external onlyOwner whenNotPaused { paused = true ; emit Paused ( msg.sender ); } function unpause () external onlyOwner whenPaused { paused = false ; emit Unpaused ( msg.sender ); } } Error Handling \u00b6 Common Errors \u00b6 \"Not owner\" : Caller is not the contract owner \"Invalid owner\" : Attempting to set invalid owner address \"Already owner\" : Attempting to transfer to current owner \"Zero address\" : Attempting to use zero address as owner Troubleshooting \u00b6 Verify Caller : Ensure calling address is current owner Check Address : Validate target addresses are not zero Transaction Status : Verify transactions are properly executed Event Logs : Check event logs for ownership changes Related Documentation \u00b6 Diamond Standard Overview Diamond Cut Facet Access Control Patterns Security Best Practices Multi-Signature Integration Standards Compliance \u00b6 OpenZeppelin Ownable : Compatible with OpenZeppelin patterns EIP-173 : Contract Ownership Standard Diamond Standard : Integrated with EIP-2535 Access Control : Industry-standard access control patterns","title":"Ownership Facet"},{"location":"smart-contracts/facets/ownership-facet/#ownership-facet","text":"The Ownership Facet provides ownership management functionality for diamond contracts, implementing access control patterns that restrict administrative operations to authorized users.","title":"Ownership Facet"},{"location":"smart-contracts/facets/ownership-facet/#overview","text":"The Ownership Facet is a critical security component that provides: Access Control : Restrict sensitive operations to contract owner Ownership Transfer : Safe transfer of contract ownership Administrative Functions : Foundation for other facet access controls Security Patterns : Standard ownership verification mechanisms","title":"Overview"},{"location":"smart-contracts/facets/ownership-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/ownership-facet/#ownership-management","text":"Owner Verification : Check if address is contract owner Ownership Transfer : Transfer ownership to new address Renounce Ownership : Remove ownership (irreversible) Pending Ownership : Two-step ownership transfer for safety","title":"Ownership Management"},{"location":"smart-contracts/facets/ownership-facet/#access-control-integration","text":"Modifier Support : Provides onlyOwner functionality Facet Integration : Other facets can use ownership checks Administrative Gates : Controls access to upgrade functions Emergency Controls : Owner-only emergency functions","title":"Access Control Integration"},{"location":"smart-contracts/facets/ownership-facet/#interface","text":"interface IOwnership { event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ); function owner () external view returns ( address owner_ ); function transferOwnership ( address _newOwner ) external ; function renounceOwnership () external ; }","title":"Interface"},{"location":"smart-contracts/facets/ownership-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/ownership-facet/#owner","text":"Returns the current owner of the contract. Returns: - address : Current owner address Usage: address currentOwner = IOwnership ( diamond ). owner ();","title":"owner()"},{"location":"smart-contracts/facets/ownership-facet/#transferownership","text":"Transfers ownership to a new address. Parameters: - _newOwner : Address of the new owner Access Control: - Only current owner can call this function Events: - Emits OwnershipTransferred event Usage: IOwnership ( diamond ). transferOwnership ( newOwnerAddress );","title":"transferOwnership()"},{"location":"smart-contracts/facets/ownership-facet/#renounceownership","text":"Renounces ownership, leaving the contract without an owner. Warning: This is irreversible and will disable all owner-only functions. Access Control: - Only current owner can call this function Events: - Emits OwnershipTransferred with new owner as address(0)","title":"renounceOwnership()"},{"location":"smart-contracts/facets/ownership-facet/#implementation-patterns","text":"","title":"Implementation Patterns"},{"location":"smart-contracts/facets/ownership-facet/#basic-ownership-check","text":"contract ExampleFacet { modifier onlyOwner () { require ( LibDiamond . contractOwner () == msg.sender , \"Not owner\" ); _ ; } function adminFunction () external onlyOwner { // Admin-only logic here } }","title":"Basic Ownership Check"},{"location":"smart-contracts/facets/ownership-facet/#safe-ownership-transfer","text":"contract SafeOwnershipFacet { address private pendingOwner ; function transferOwnership ( address newOwner ) external onlyOwner { require ( newOwner != address ( 0 ), \"Invalid owner\" ); pendingOwner = newOwner ; } function acceptOwnership () external { require ( msg.sender == pendingOwner , \"Not pending owner\" ); address oldOwner = LibDiamond . contractOwner (); LibDiamond . setContractOwner ( pendingOwner ); pendingOwner = address ( 0 ); emit OwnershipTransferred ( oldOwner , msg.sender ); } }","title":"Safe Ownership Transfer"},{"location":"smart-contracts/facets/ownership-facet/#multi-signature-integration","text":"contract MultiSigOwnership { mapping ( address => bool ) public isOwner ; uint256 public requiredSignatures ; struct Transaction { address to ; bytes data ; uint256 confirmations ; mapping ( address => bool ) confirmed ; bool executed ; } mapping ( uint256 => Transaction ) public transactions ; uint256 public transactionCount ; modifier onlyMultiSigOwner () { require ( isOwner [ msg.sender ], \"Not authorized\" ); _ ; } function submitTransaction ( address to , bytes memory data ) external onlyMultiSigOwner returns ( uint256 transactionId ) { transactionId = transactionCount ++ ; Transaction storage txn = transactions [ transactionId ]; txn . to = to ; txn . data = data ; confirmTransaction ( transactionId ); } function confirmTransaction ( uint256 transactionId ) public onlyMultiSigOwner { Transaction storage txn = transactions [ transactionId ]; require ( ! txn . confirmed [ msg.sender ], \"Already confirmed\" ); txn . confirmed [ msg.sender ] = true ; txn . confirmations ++ ; if ( txn . confirmations >= requiredSignatures ) { executeTransaction ( transactionId ); } } }","title":"Multi-Signature Integration"},{"location":"smart-contracts/facets/ownership-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/ownership-facet/#access-control","text":"Owner Verification : Always verify caller is owner Zero Address Check : Prevent ownership transfer to zero address Reentrancy Protection : Consider reentrancy in ownership functions Event Emission : Always emit events for ownership changes","title":"Access Control"},{"location":"smart-contracts/facets/ownership-facet/#ownership-transfer-safety","text":"Two-Step Transfer : Use pending ownership pattern for safety Address Validation : Validate new owner addresses Confirmation Required : Require new owner to accept ownership Timelock Integration : Consider timelock for ownership changes","title":"Ownership Transfer Safety"},{"location":"smart-contracts/facets/ownership-facet/#emergency-considerations","text":"Recovery Mechanisms : Plan for owner key loss scenarios Multi-Signature : Use multi-sig for high-value contracts Governance Integration : Consider DAO governance for ownership Upgrade Restrictions : Limit upgrade capabilities appropriately","title":"Emergency Considerations"},{"location":"smart-contracts/facets/ownership-facet/#integration-with-diamond-standard","text":"","title":"Integration with Diamond Standard"},{"location":"smart-contracts/facets/ownership-facet/#libdiamond-integration","text":"library LibDiamond { bytes32 constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.standard.diamond.storage\" ); struct DiamondStorage { mapping ( bytes4 => bytes32 ) facets ; mapping ( uint256 => bytes32 ) selectorSlots ; uint256 selectorCount ; mapping ( bytes4 => bool ) supportedInterfaces ; address contractOwner ; } function diamondStorage () internal pure returns ( DiamondStorage storage ds ) { bytes32 position = DIAMOND_STORAGE_POSITION ; assembly { ds . slot := position } } function setContractOwner ( address _newOwner ) internal { DiamondStorage storage ds = diamondStorage (); address previousOwner = ds . contractOwner ; ds . contractOwner = _newOwner ; emit OwnershipTransferred ( previousOwner , _newOwner ); } function contractOwner () internal view returns ( address contractOwner_ ) { contractOwner_ = diamondStorage (). contractOwner ; } function enforceIsContractOwner () internal view { require ( msg.sender == diamondStorage (). contractOwner , \"LibDiamond: Must be contract owner\" ); } }","title":"LibDiamond Integration"},{"location":"smart-contracts/facets/ownership-facet/#diamond-cut-integration","text":"contract DiamondCutFacet is IDiamondCut { function diamondCut ( FacetCut [] calldata _diamondCut , address _init , bytes calldata _calldata ) external override { LibDiamond . enforceIsContractOwner (); LibDiamond . diamondCut ( _diamondCut , _init , _calldata ); } }","title":"Diamond Cut Integration"},{"location":"smart-contracts/facets/ownership-facet/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/facets/ownership-facet/#development-guidelines","text":"Always Use Modifiers : Use onlyOwner modifier consistently Event Emission : Emit events for all ownership changes Address Validation : Validate addresses before ownership transfer Documentation : Document all owner-only functions clearly","title":"Development Guidelines"},{"location":"smart-contracts/facets/ownership-facet/#production-deployment","text":"Multi-Signature : Use multi-sig wallets for production ownership Timelock Contracts : Consider timelock for sensitive operations Governance Integration : Plan for decentralized governance Emergency Procedures : Establish emergency response procedures","title":"Production Deployment"},{"location":"smart-contracts/facets/ownership-facet/#security-auditing","text":"Access Control Review : Audit all access control mechanisms Ownership Transfer Testing : Test ownership transfer scenarios Emergency Function Testing : Test emergency and recovery functions Multi-Signature Validation : Validate multi-sig implementations","title":"Security Auditing"},{"location":"smart-contracts/facets/ownership-facet/#common-patterns","text":"","title":"Common Patterns"},{"location":"smart-contracts/facets/ownership-facet/#role-based-access-control","text":"contract RoleBasedOwnership { bytes32 public constant ADMIN_ROLE = keccak256 ( \"ADMIN_ROLE\" ); bytes32 public constant OPERATOR_ROLE = keccak256 ( \"OPERATOR_ROLE\" ); mapping ( bytes32 => mapping ( address => bool )) private roles ; modifier onlyRole ( bytes32 role ) { require ( hasRole ( role , msg.sender ), \"AccessControl: account missing role\" ); _ ; } function hasRole ( bytes32 role , address account ) public view returns ( bool ) { return roles [ role ][ account ] || ( role == ADMIN_ROLE && account == LibDiamond . contractOwner ()); } function grantRole ( bytes32 role , address account ) external onlyOwner { roles [ role ][ account ] = true ; } function revokeRole ( bytes32 role , address account ) external onlyOwner { roles [ role ][ account ] = false ; } }","title":"Role-Based Access Control"},{"location":"smart-contracts/facets/ownership-facet/#pausable-contract","text":"contract PausableOwnership { bool private paused ; event Paused ( address account ); event Unpaused ( address account ); modifier whenNotPaused () { require ( ! paused , \"Contract is paused\" ); _ ; } modifier whenPaused () { require ( paused , \"Contract is not paused\" ); _ ; } function pause () external onlyOwner whenNotPaused { paused = true ; emit Paused ( msg.sender ); } function unpause () external onlyOwner whenPaused { paused = false ; emit Unpaused ( msg.sender ); } }","title":"Pausable Contract"},{"location":"smart-contracts/facets/ownership-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/ownership-facet/#common-errors","text":"\"Not owner\" : Caller is not the contract owner \"Invalid owner\" : Attempting to set invalid owner address \"Already owner\" : Attempting to transfer to current owner \"Zero address\" : Attempting to use zero address as owner","title":"Common Errors"},{"location":"smart-contracts/facets/ownership-facet/#troubleshooting","text":"Verify Caller : Ensure calling address is current owner Check Address : Validate target addresses are not zero Transaction Status : Verify transactions are properly executed Event Logs : Check event logs for ownership changes","title":"Troubleshooting"},{"location":"smart-contracts/facets/ownership-facet/#related-documentation","text":"Diamond Standard Overview Diamond Cut Facet Access Control Patterns Security Best Practices Multi-Signature Integration","title":"Related Documentation"},{"location":"smart-contracts/facets/ownership-facet/#standards-compliance","text":"OpenZeppelin Ownable : Compatible with OpenZeppelin patterns EIP-173 : Contract Ownership Standard Diamond Standard : Integrated with EIP-2535 Access Control : Industry-standard access control patterns","title":"Standards Compliance"},{"location":"smart-contracts/facets/svg-templates-facet/","text":"SVGTemplatesFacet \u00b6 Overview \u00b6 The SVGTemplatesFacet.sol provides SVG template management functionality within the Gemforce diamond system. This facet enables the creation, storage, and retrieval of SVG templates that can be used for dynamic NFT metadata generation, visual representations, and on-chain graphics rendering. Contract Details \u00b6 Contract Name : SVGTemplatesFacet Inheritance : Modifiers License : MIT Solidity Version : ^0.8.0 Key Features \u00b6 \ud83d\udd39 SVG Template Management \u00b6 Create and store SVG templates on-chain Retrieve SVG data as strings Template address resolution Centralized SVG manager integration \ud83d\udd39 Dynamic Graphics Generation \u00b6 On-chain SVG rendering capabilities Template-based NFT metadata Scalable vector graphics support Customizable visual elements \ud83d\udd39 Manager-Based Architecture \u00b6 Delegated SVG management system Upgradeable template storage Centralized template registry Access control for template creation Core Architecture \u00b6 SVG Manager Integration \u00b6 The facet operates through a manager-based architecture where an external SVG manager contract handles the actual template storage and rendering logic. This design provides: Separation of Concerns : Template logic separated from diamond storage Upgradeability : SVG manager can be updated without affecting the diamond Scalability : Dedicated contract for complex SVG operations Modularity : Clean interface between diamond and SVG functionality Template Storage Pattern \u00b6 // SVG templates are managed through external manager address svgManager = SVGTemplatesLib . svgStorage (). svgManager ; // Templates accessed via manager interface ISVGTemplate ( svgManager ). svgString ( templateName ); Core Functions \u00b6 Management Functions \u00b6 setSVGManager() \u00b6 function setSVGManager ( address _manager ) external onlyOwner Purpose : Sets the address of the SVG manager contract that handles template operations. Parameters : - _manager (address): Address of the SVG manager contract Access Control : Owner only Process : 1. Updates the SVG manager address in diamond storage 2. All subsequent SVG operations will use the new manager 3. Enables upgrading SVG functionality without diamond changes Example Usage : // Deploy new SVG manager with enhanced features address newSVGManager = address ( new EnhancedSVGManager ()); // Update the diamond to use new manager ISVGTemplates ( diamond ). setSVGManager ( newSVGManager ); console . log ( \"SVG manager updated to:\" , newSVGManager ); Security Considerations : - Only contract owner can change the manager - Ensure new manager implements ISVGTemplate interface - Verify manager contract before setting createSVG() \u00b6 function createSVG ( string memory _name ) external onlyOwner returns ( address _tplAddress ) Purpose : Creates a new SVG template with the specified name. Parameters : - _name (string): Unique name for the SVG template Returns : - _tplAddress (address): Address of the created template contract Access Control : Owner only Process : 1. Delegates template creation to the SVG manager 2. Manager creates and deploys template contract 3. Returns template address for future reference 4. Emits SVGTemplateCreated event Events : SVGTemplateCreated(name, template) Example Usage : // Create template for NFT badges address badgeTemplate = ISVGTemplates ( diamond ). createSVG ( \"achievement-badge\" ); console . log ( \"Badge template created at:\" , badgeTemplate ); // Create template for dynamic backgrounds address bgTemplate = ISVGTemplates ( diamond ). createSVG ( \"gradient-background\" ); console . log ( \"Background template created at:\" , bgTemplate ); Error Conditions : - Template name already exists - SVG manager not set - Template creation failure Query Functions \u00b6 svgs() \u00b6 function svgs () external view returns ( string [] memory ) Purpose : Returns all SVG template names stored in the system. Returns : Array of template names Example Usage : string [] memory templateNames = ISVGTemplates ( diamond ). svgs (); console . log ( \"Available templates:\" ); for ( uint256 i = 0 ; i < templateNames . length ; i ++ ) { console . log ( \"-\" , templateNames [ i ]); } Use Cases : - UI template selection - Template enumeration - System inventory - Integration discovery svgAddress() \u00b6 function svgAddress ( string memory _name ) external view returns ( address _svgAddress ) Purpose : Returns the contract address for a specific SVG template. Parameters : - _name (string): Name of the SVG template Returns : - _svgAddress (address): Contract address of the template Example Usage : address templateAddress = ISVGTemplates ( diamond ). svgAddress ( \"achievement-badge\" ); if ( templateAddress != address ( 0 )) { console . log ( \"Template found at:\" , templateAddress ); // Use template for rendering } else { console . log ( \"Template not found\" ); } Important Notes : - Returns address even if template doesn't exist (may be zero address) - Check address validity before using - Address doesn't guarantee template functionality svgString() \u00b6 function svgString ( string memory _name ) external view returns ( string memory data_ ) Purpose : Returns the SVG data as a string for the specified template. Parameters : - _name (string): Name of the SVG template Returns : - data_ (string): Complete SVG markup as string Example Usage : string memory svgData = ISVGTemplates ( diamond ). svgString ( \"achievement-badge\" ); // Use in NFT metadata string memory metadata = string ( abi . encodePacked ( '{\"name\":\"Achievement Badge\",\"image\":\"data:image/svg+xml;base64,' , Base64 . encode ( bytes ( svgData )), '\"}' )); Use Cases : - NFT metadata generation - On-chain image rendering - Dynamic visual content - Template preview Integration Examples \u00b6 NFT Metadata Generation \u00b6 // Generate dynamic NFT metadata with SVG templates contract DynamicNFT { function tokenURI ( uint256 tokenId ) public view override returns ( string memory ) { // Get achievement level for this token uint256 level = getAchievementLevel ( tokenId ); string memory templateName = string ( abi . encodePacked ( \"badge-level-\" , level . toString ())); // Get SVG data from template string memory svgData = ISVGTemplates ( diamond ). svgString ( templateName ); // Encode as base64 for data URI string memory imageURI = string ( abi . encodePacked ( \"data:image/svg+xml;base64,\" , Base64 . encode ( bytes ( svgData )) )); // Build complete metadata return string ( abi . encodePacked ( '{\"name\":\"Achievement Badge #' , tokenId . toString (), '\",\"description\":\"Dynamic achievement badge\",' , '\"image\":\"' , imageURI , '\",' , '\"attributes\":[{\"trait_type\":\"Level\",\"value\":' , level . toString (), '}]}' )); } } Template-Based Rendering System \u00b6 // System for rendering different visual elements contract VisualRenderer { mapping ( string => string ) public templateCategories ; function setTemplateCategory ( string memory templateName , string memory category ) external onlyOwner { templateCategories [ templateName ] = category ; } function renderByCategory ( string memory category , bytes memory params ) external view returns ( string memory ) { string [] memory allTemplates = ISVGTemplates ( diamond ). svgs (); for ( uint256 i = 0 ; i < allTemplates . length ; i ++ ) { if ( keccak256 ( bytes ( templateCategories [ allTemplates [ i ]])) == keccak256 ( bytes ( category ))) { return ISVGTemplates ( diamond ). svgString ( allTemplates [ i ]); } } revert ( \"No template found for category\" ); } function getTemplatesByCategory ( string memory category ) external view returns ( string [] memory ) { string [] memory allTemplates = ISVGTemplates ( diamond ). svgs (); string [] memory categoryTemplates = new string []( allTemplates . length ); uint256 count = 0 ; for ( uint256 i = 0 ; i < allTemplates . length ; i ++ ) { if ( keccak256 ( bytes ( templateCategories [ allTemplates [ i ]])) == keccak256 ( bytes ( category ))) { categoryTemplates [ count ] = allTemplates [ i ]; count ++ ; } } // Resize array to actual count string [] memory result = new string []( count ); for ( uint256 i = 0 ; i < count ; i ++ ) { result [ i ] = categoryTemplates [ i ]; } return result ; } } Dynamic Badge System \u00b6 // Create achievement badges with different templates contract AchievementSystem { struct Achievement { string name ; string description ; string svgTemplate ; uint256 requiredPoints ; } mapping ( uint256 => Achievement ) public achievements ; mapping ( address => mapping ( uint256 => bool )) public userAchievements ; uint256 public achievementCount ; function createAchievement ( string memory name , string memory description , string memory svgTemplate , uint256 requiredPoints ) external onlyOwner { // Verify template exists address templateAddr = ISVGTemplates ( diamond ). svgAddress ( svgTemplate ); require ( templateAddr != address ( 0 ), \"Template not found\" ); achievements [ achievementCount ] = Achievement ({ name : name , description : description , svgTemplate : svgTemplate , requiredPoints : requiredPoints }); achievementCount ++ ; emit AchievementCreated ( achievementCount - 1 , name , svgTemplate ); } function awardAchievement ( address user , uint256 achievementId ) external onlyOwner { require ( achievementId < achievementCount , \"Invalid achievement\" ); require ( ! userAchievements [ user ][ achievementId ], \"Already awarded\" ); userAchievements [ user ][ achievementId ] = true ; // Generate badge SVG string memory badgeSVG = ISVGTemplates ( diamond ). svgString ( achievements [ achievementId ]. svgTemplate ); emit AchievementAwarded ( user , achievementId , badgeSVG ); } function getUserBadge ( address user , uint256 achievementId ) external view returns ( string memory ) { require ( userAchievements [ user ][ achievementId ], \"Achievement not earned\" ); return ISVGTemplates ( diamond ). svgString ( achievements [ achievementId ]. svgTemplate ); } } Template Management System \u00b6 // Advanced template management with versioning contract TemplateManager { struct TemplateVersion { address templateAddress ; string version ; uint256 timestamp ; bool active ; } mapping ( string => TemplateVersion []) public templateVersions ; mapping ( string => uint256 ) public activeVersionIndex ; function createTemplateVersion ( string memory templateName , string memory version ) external onlyOwner { // Create new template address templateAddr = ISVGTemplates ( diamond ). createSVG ( string ( abi . encodePacked ( templateName , \"-\" , version )) ); // Store version info templateVersions [ templateName ]. push ( TemplateVersion ({ templateAddress : templateAddr , version : version , timestamp : block.timestamp , active : false })); emit TemplateVersionCreated ( templateName , version , templateAddr ); } function activateTemplateVersion ( string memory templateName , uint256 versionIndex ) external onlyOwner { require ( versionIndex < templateVersions [ templateName ]. length , \"Invalid version\" ); // Deactivate current version if ( templateVersions [ templateName ]. length > 0 ) { templateVersions [ templateName ][ activeVersionIndex [ templateName ]]. active = false ; } // Activate new version templateVersions [ templateName ][ versionIndex ]. active = true ; activeVersionIndex [ templateName ] = versionIndex ; emit TemplateVersionActivated ( templateName , versionIndex ); } function getActiveTemplate ( string memory templateName ) external view returns ( string memory ) { require ( templateVersions [ templateName ]. length > 0 , \"Template not found\" ); uint256 activeIndex = activeVersionIndex [ templateName ]; TemplateVersion memory activeVersion = templateVersions [ templateName ][ activeIndex ]; require ( activeVersion . active , \"No active version\" ); return ISVGTemplates ( diamond ). svgString ( string ( abi . encodePacked ( templateName , \"-\" , activeVersion . version )) ); } } On-Chain Art Gallery \u00b6 // Gallery system using SVG templates contract ArtGallery { struct Artwork { string title ; string artist ; string svgTemplate ; uint256 price ; bool forSale ; } mapping ( uint256 => Artwork ) public artworks ; uint256 public artworkCount ; function addArtwork ( string memory title , string memory artist , string memory svgTemplate , uint256 price ) external onlyOwner { // Verify template exists string memory svgData = ISVGTemplates ( diamond ). svgString ( svgTemplate ); require ( bytes ( svgData ). length > 0 , \"Template not found\" ); artworks [ artworkCount ] = Artwork ({ title : title , artist : artist , svgTemplate : svgTemplate , price : price , forSale : true }); artworkCount ++ ; emit ArtworkAdded ( artworkCount - 1 , title , artist ); } function previewArtwork ( uint256 artworkId ) external view returns ( string memory ) { require ( artworkId < artworkCount , \"Artwork not found\" ); return ISVGTemplates ( diamond ). svgString ( artworks [ artworkId ]. svgTemplate ); } function purchaseArtwork ( uint256 artworkId ) external payable { require ( artworkId < artworkCount , \"Artwork not found\" ); require ( artworks [ artworkId ]. forSale , \"Not for sale\" ); require ( msg.value >= artworks [ artworkId ]. price , \"Insufficient payment\" ); artworks [ artworkId ]. forSale = false ; // Generate NFT with SVG template string memory svgData = ISVGTemplates ( diamond ). svgString ( artworks [ artworkId ]. svgTemplate ); emit ArtworkPurchased ( artworkId , msg.sender , svgData ); } } Events \u00b6 Template Management Events \u00b6 event SVGTemplateCreated ( string name , address template ); Security Considerations \u00b6 Access Control \u00b6 Only contract owner can set SVG manager Only contract owner can create templates Manager contract should implement proper access controls Template Validation \u00b6 Verify SVG manager implements required interface Check template existence before operations Validate template data integrity Manager Security \u00b6 SVG manager contract should be audited Ensure manager cannot be set to malicious contract Consider timelock for manager changes Gas Optimization \u00b6 Efficient Queries \u00b6 Batch template operations when possible Cache frequently accessed templates Use view functions for read operations Storage Optimization \u00b6 Delegate storage to manager contract Minimize on-chain SVG data when possible Use IPFS for large templates if needed Error Handling \u00b6 Common Errors \u00b6 SVG manager not set Template not found Invalid template name Manager interface mismatch Best Practices \u00b6 Always check template existence Validate manager address before setting Handle empty template responses Testing Considerations \u00b6 Unit Tests \u00b6 Template creation and retrieval Manager setting and validation Access control enforcement Error condition handling Integration Tests \u00b6 NFT metadata generation Template rendering systems Manager upgrade scenarios Cross-facet interactions Related Documentation \u00b6 ISVG - SVG interface definitions SVGTemplatesLib - SVG utilities StringsLib - String manipulation GemforceMinterFacet - NFT minting integration NFT Metadata Guide - Implementation guide This facet provides SVG template management capabilities within the Gemforce platform, enabling dynamic on-chain graphics generation and template-based visual systems.","title":"SVG Templates Facet"},{"location":"smart-contracts/facets/svg-templates-facet/#svgtemplatesfacet","text":"","title":"SVGTemplatesFacet"},{"location":"smart-contracts/facets/svg-templates-facet/#overview","text":"The SVGTemplatesFacet.sol provides SVG template management functionality within the Gemforce diamond system. This facet enables the creation, storage, and retrieval of SVG templates that can be used for dynamic NFT metadata generation, visual representations, and on-chain graphics rendering.","title":"Overview"},{"location":"smart-contracts/facets/svg-templates-facet/#contract-details","text":"Contract Name : SVGTemplatesFacet Inheritance : Modifiers License : MIT Solidity Version : ^0.8.0","title":"Contract Details"},{"location":"smart-contracts/facets/svg-templates-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/svg-templates-facet/#svg-template-management","text":"Create and store SVG templates on-chain Retrieve SVG data as strings Template address resolution Centralized SVG manager integration","title":"\ud83d\udd39 SVG Template Management"},{"location":"smart-contracts/facets/svg-templates-facet/#dynamic-graphics-generation","text":"On-chain SVG rendering capabilities Template-based NFT metadata Scalable vector graphics support Customizable visual elements","title":"\ud83d\udd39 Dynamic Graphics Generation"},{"location":"smart-contracts/facets/svg-templates-facet/#manager-based-architecture","text":"Delegated SVG management system Upgradeable template storage Centralized template registry Access control for template creation","title":"\ud83d\udd39 Manager-Based Architecture"},{"location":"smart-contracts/facets/svg-templates-facet/#core-architecture","text":"","title":"Core Architecture"},{"location":"smart-contracts/facets/svg-templates-facet/#svg-manager-integration","text":"The facet operates through a manager-based architecture where an external SVG manager contract handles the actual template storage and rendering logic. This design provides: Separation of Concerns : Template logic separated from diamond storage Upgradeability : SVG manager can be updated without affecting the diamond Scalability : Dedicated contract for complex SVG operations Modularity : Clean interface between diamond and SVG functionality","title":"SVG Manager Integration"},{"location":"smart-contracts/facets/svg-templates-facet/#template-storage-pattern","text":"// SVG templates are managed through external manager address svgManager = SVGTemplatesLib . svgStorage (). svgManager ; // Templates accessed via manager interface ISVGTemplate ( svgManager ). svgString ( templateName );","title":"Template Storage Pattern"},{"location":"smart-contracts/facets/svg-templates-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/svg-templates-facet/#management-functions","text":"","title":"Management Functions"},{"location":"smart-contracts/facets/svg-templates-facet/#setsvgmanager","text":"function setSVGManager ( address _manager ) external onlyOwner Purpose : Sets the address of the SVG manager contract that handles template operations. Parameters : - _manager (address): Address of the SVG manager contract Access Control : Owner only Process : 1. Updates the SVG manager address in diamond storage 2. All subsequent SVG operations will use the new manager 3. Enables upgrading SVG functionality without diamond changes Example Usage : // Deploy new SVG manager with enhanced features address newSVGManager = address ( new EnhancedSVGManager ()); // Update the diamond to use new manager ISVGTemplates ( diamond ). setSVGManager ( newSVGManager ); console . log ( \"SVG manager updated to:\" , newSVGManager ); Security Considerations : - Only contract owner can change the manager - Ensure new manager implements ISVGTemplate interface - Verify manager contract before setting","title":"setSVGManager()"},{"location":"smart-contracts/facets/svg-templates-facet/#createsvg","text":"function createSVG ( string memory _name ) external onlyOwner returns ( address _tplAddress ) Purpose : Creates a new SVG template with the specified name. Parameters : - _name (string): Unique name for the SVG template Returns : - _tplAddress (address): Address of the created template contract Access Control : Owner only Process : 1. Delegates template creation to the SVG manager 2. Manager creates and deploys template contract 3. Returns template address for future reference 4. Emits SVGTemplateCreated event Events : SVGTemplateCreated(name, template) Example Usage : // Create template for NFT badges address badgeTemplate = ISVGTemplates ( diamond ). createSVG ( \"achievement-badge\" ); console . log ( \"Badge template created at:\" , badgeTemplate ); // Create template for dynamic backgrounds address bgTemplate = ISVGTemplates ( diamond ). createSVG ( \"gradient-background\" ); console . log ( \"Background template created at:\" , bgTemplate ); Error Conditions : - Template name already exists - SVG manager not set - Template creation failure","title":"createSVG()"},{"location":"smart-contracts/facets/svg-templates-facet/#query-functions","text":"","title":"Query Functions"},{"location":"smart-contracts/facets/svg-templates-facet/#svgs","text":"function svgs () external view returns ( string [] memory ) Purpose : Returns all SVG template names stored in the system. Returns : Array of template names Example Usage : string [] memory templateNames = ISVGTemplates ( diamond ). svgs (); console . log ( \"Available templates:\" ); for ( uint256 i = 0 ; i < templateNames . length ; i ++ ) { console . log ( \"-\" , templateNames [ i ]); } Use Cases : - UI template selection - Template enumeration - System inventory - Integration discovery","title":"svgs()"},{"location":"smart-contracts/facets/svg-templates-facet/#svgaddress","text":"function svgAddress ( string memory _name ) external view returns ( address _svgAddress ) Purpose : Returns the contract address for a specific SVG template. Parameters : - _name (string): Name of the SVG template Returns : - _svgAddress (address): Contract address of the template Example Usage : address templateAddress = ISVGTemplates ( diamond ). svgAddress ( \"achievement-badge\" ); if ( templateAddress != address ( 0 )) { console . log ( \"Template found at:\" , templateAddress ); // Use template for rendering } else { console . log ( \"Template not found\" ); } Important Notes : - Returns address even if template doesn't exist (may be zero address) - Check address validity before using - Address doesn't guarantee template functionality","title":"svgAddress()"},{"location":"smart-contracts/facets/svg-templates-facet/#svgstring","text":"function svgString ( string memory _name ) external view returns ( string memory data_ ) Purpose : Returns the SVG data as a string for the specified template. Parameters : - _name (string): Name of the SVG template Returns : - data_ (string): Complete SVG markup as string Example Usage : string memory svgData = ISVGTemplates ( diamond ). svgString ( \"achievement-badge\" ); // Use in NFT metadata string memory metadata = string ( abi . encodePacked ( '{\"name\":\"Achievement Badge\",\"image\":\"data:image/svg+xml;base64,' , Base64 . encode ( bytes ( svgData )), '\"}' )); Use Cases : - NFT metadata generation - On-chain image rendering - Dynamic visual content - Template preview","title":"svgString()"},{"location":"smart-contracts/facets/svg-templates-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/facets/svg-templates-facet/#nft-metadata-generation","text":"// Generate dynamic NFT metadata with SVG templates contract DynamicNFT { function tokenURI ( uint256 tokenId ) public view override returns ( string memory ) { // Get achievement level for this token uint256 level = getAchievementLevel ( tokenId ); string memory templateName = string ( abi . encodePacked ( \"badge-level-\" , level . toString ())); // Get SVG data from template string memory svgData = ISVGTemplates ( diamond ). svgString ( templateName ); // Encode as base64 for data URI string memory imageURI = string ( abi . encodePacked ( \"data:image/svg+xml;base64,\" , Base64 . encode ( bytes ( svgData )) )); // Build complete metadata return string ( abi . encodePacked ( '{\"name\":\"Achievement Badge #' , tokenId . toString (), '\",\"description\":\"Dynamic achievement badge\",' , '\"image\":\"' , imageURI , '\",' , '\"attributes\":[{\"trait_type\":\"Level\",\"value\":' , level . toString (), '}]}' )); } }","title":"NFT Metadata Generation"},{"location":"smart-contracts/facets/svg-templates-facet/#template-based-rendering-system","text":"// System for rendering different visual elements contract VisualRenderer { mapping ( string => string ) public templateCategories ; function setTemplateCategory ( string memory templateName , string memory category ) external onlyOwner { templateCategories [ templateName ] = category ; } function renderByCategory ( string memory category , bytes memory params ) external view returns ( string memory ) { string [] memory allTemplates = ISVGTemplates ( diamond ). svgs (); for ( uint256 i = 0 ; i < allTemplates . length ; i ++ ) { if ( keccak256 ( bytes ( templateCategories [ allTemplates [ i ]])) == keccak256 ( bytes ( category ))) { return ISVGTemplates ( diamond ). svgString ( allTemplates [ i ]); } } revert ( \"No template found for category\" ); } function getTemplatesByCategory ( string memory category ) external view returns ( string [] memory ) { string [] memory allTemplates = ISVGTemplates ( diamond ). svgs (); string [] memory categoryTemplates = new string []( allTemplates . length ); uint256 count = 0 ; for ( uint256 i = 0 ; i < allTemplates . length ; i ++ ) { if ( keccak256 ( bytes ( templateCategories [ allTemplates [ i ]])) == keccak256 ( bytes ( category ))) { categoryTemplates [ count ] = allTemplates [ i ]; count ++ ; } } // Resize array to actual count string [] memory result = new string []( count ); for ( uint256 i = 0 ; i < count ; i ++ ) { result [ i ] = categoryTemplates [ i ]; } return result ; } }","title":"Template-Based Rendering System"},{"location":"smart-contracts/facets/svg-templates-facet/#dynamic-badge-system","text":"// Create achievement badges with different templates contract AchievementSystem { struct Achievement { string name ; string description ; string svgTemplate ; uint256 requiredPoints ; } mapping ( uint256 => Achievement ) public achievements ; mapping ( address => mapping ( uint256 => bool )) public userAchievements ; uint256 public achievementCount ; function createAchievement ( string memory name , string memory description , string memory svgTemplate , uint256 requiredPoints ) external onlyOwner { // Verify template exists address templateAddr = ISVGTemplates ( diamond ). svgAddress ( svgTemplate ); require ( templateAddr != address ( 0 ), \"Template not found\" ); achievements [ achievementCount ] = Achievement ({ name : name , description : description , svgTemplate : svgTemplate , requiredPoints : requiredPoints }); achievementCount ++ ; emit AchievementCreated ( achievementCount - 1 , name , svgTemplate ); } function awardAchievement ( address user , uint256 achievementId ) external onlyOwner { require ( achievementId < achievementCount , \"Invalid achievement\" ); require ( ! userAchievements [ user ][ achievementId ], \"Already awarded\" ); userAchievements [ user ][ achievementId ] = true ; // Generate badge SVG string memory badgeSVG = ISVGTemplates ( diamond ). svgString ( achievements [ achievementId ]. svgTemplate ); emit AchievementAwarded ( user , achievementId , badgeSVG ); } function getUserBadge ( address user , uint256 achievementId ) external view returns ( string memory ) { require ( userAchievements [ user ][ achievementId ], \"Achievement not earned\" ); return ISVGTemplates ( diamond ). svgString ( achievements [ achievementId ]. svgTemplate ); } }","title":"Dynamic Badge System"},{"location":"smart-contracts/facets/svg-templates-facet/#template-management-system","text":"// Advanced template management with versioning contract TemplateManager { struct TemplateVersion { address templateAddress ; string version ; uint256 timestamp ; bool active ; } mapping ( string => TemplateVersion []) public templateVersions ; mapping ( string => uint256 ) public activeVersionIndex ; function createTemplateVersion ( string memory templateName , string memory version ) external onlyOwner { // Create new template address templateAddr = ISVGTemplates ( diamond ). createSVG ( string ( abi . encodePacked ( templateName , \"-\" , version )) ); // Store version info templateVersions [ templateName ]. push ( TemplateVersion ({ templateAddress : templateAddr , version : version , timestamp : block.timestamp , active : false })); emit TemplateVersionCreated ( templateName , version , templateAddr ); } function activateTemplateVersion ( string memory templateName , uint256 versionIndex ) external onlyOwner { require ( versionIndex < templateVersions [ templateName ]. length , \"Invalid version\" ); // Deactivate current version if ( templateVersions [ templateName ]. length > 0 ) { templateVersions [ templateName ][ activeVersionIndex [ templateName ]]. active = false ; } // Activate new version templateVersions [ templateName ][ versionIndex ]. active = true ; activeVersionIndex [ templateName ] = versionIndex ; emit TemplateVersionActivated ( templateName , versionIndex ); } function getActiveTemplate ( string memory templateName ) external view returns ( string memory ) { require ( templateVersions [ templateName ]. length > 0 , \"Template not found\" ); uint256 activeIndex = activeVersionIndex [ templateName ]; TemplateVersion memory activeVersion = templateVersions [ templateName ][ activeIndex ]; require ( activeVersion . active , \"No active version\" ); return ISVGTemplates ( diamond ). svgString ( string ( abi . encodePacked ( templateName , \"-\" , activeVersion . version )) ); } }","title":"Template Management System"},{"location":"smart-contracts/facets/svg-templates-facet/#on-chain-art-gallery","text":"// Gallery system using SVG templates contract ArtGallery { struct Artwork { string title ; string artist ; string svgTemplate ; uint256 price ; bool forSale ; } mapping ( uint256 => Artwork ) public artworks ; uint256 public artworkCount ; function addArtwork ( string memory title , string memory artist , string memory svgTemplate , uint256 price ) external onlyOwner { // Verify template exists string memory svgData = ISVGTemplates ( diamond ). svgString ( svgTemplate ); require ( bytes ( svgData ). length > 0 , \"Template not found\" ); artworks [ artworkCount ] = Artwork ({ title : title , artist : artist , svgTemplate : svgTemplate , price : price , forSale : true }); artworkCount ++ ; emit ArtworkAdded ( artworkCount - 1 , title , artist ); } function previewArtwork ( uint256 artworkId ) external view returns ( string memory ) { require ( artworkId < artworkCount , \"Artwork not found\" ); return ISVGTemplates ( diamond ). svgString ( artworks [ artworkId ]. svgTemplate ); } function purchaseArtwork ( uint256 artworkId ) external payable { require ( artworkId < artworkCount , \"Artwork not found\" ); require ( artworks [ artworkId ]. forSale , \"Not for sale\" ); require ( msg.value >= artworks [ artworkId ]. price , \"Insufficient payment\" ); artworks [ artworkId ]. forSale = false ; // Generate NFT with SVG template string memory svgData = ISVGTemplates ( diamond ). svgString ( artworks [ artworkId ]. svgTemplate ); emit ArtworkPurchased ( artworkId , msg.sender , svgData ); } }","title":"On-Chain Art Gallery"},{"location":"smart-contracts/facets/svg-templates-facet/#events","text":"","title":"Events"},{"location":"smart-contracts/facets/svg-templates-facet/#template-management-events","text":"event SVGTemplateCreated ( string name , address template );","title":"Template Management Events"},{"location":"smart-contracts/facets/svg-templates-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/svg-templates-facet/#access-control","text":"Only contract owner can set SVG manager Only contract owner can create templates Manager contract should implement proper access controls","title":"Access Control"},{"location":"smart-contracts/facets/svg-templates-facet/#template-validation","text":"Verify SVG manager implements required interface Check template existence before operations Validate template data integrity","title":"Template Validation"},{"location":"smart-contracts/facets/svg-templates-facet/#manager-security","text":"SVG manager contract should be audited Ensure manager cannot be set to malicious contract Consider timelock for manager changes","title":"Manager Security"},{"location":"smart-contracts/facets/svg-templates-facet/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/facets/svg-templates-facet/#efficient-queries","text":"Batch template operations when possible Cache frequently accessed templates Use view functions for read operations","title":"Efficient Queries"},{"location":"smart-contracts/facets/svg-templates-facet/#storage-optimization","text":"Delegate storage to manager contract Minimize on-chain SVG data when possible Use IPFS for large templates if needed","title":"Storage Optimization"},{"location":"smart-contracts/facets/svg-templates-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/svg-templates-facet/#common-errors","text":"SVG manager not set Template not found Invalid template name Manager interface mismatch","title":"Common Errors"},{"location":"smart-contracts/facets/svg-templates-facet/#best-practices","text":"Always check template existence Validate manager address before setting Handle empty template responses","title":"Best Practices"},{"location":"smart-contracts/facets/svg-templates-facet/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/facets/svg-templates-facet/#unit-tests","text":"Template creation and retrieval Manager setting and validation Access control enforcement Error condition handling","title":"Unit Tests"},{"location":"smart-contracts/facets/svg-templates-facet/#integration-tests","text":"NFT metadata generation Template rendering systems Manager upgrade scenarios Cross-facet interactions","title":"Integration Tests"},{"location":"smart-contracts/facets/svg-templates-facet/#related-documentation","text":"ISVG - SVG interface definitions SVGTemplatesLib - SVG utilities StringsLib - String manipulation GemforceMinterFacet - NFT minting integration NFT Metadata Guide - Implementation guide This facet provides SVG template management capabilities within the Gemforce platform, enabling dynamic on-chain graphics generation and template-based visual systems.","title":"Related Documentation"},{"location":"smart-contracts/facets/trade-deal-admin-facet/","text":"TradeDealAdminFacet \u00b6 Overview \u00b6 The TradeDealAdminFacet.sol provides administrative functionality for managing trade deals within the Gemforce diamond system. This facet handles participant management, interest distribution, claim topic configuration, and token address management for trade deal operations. Contract Details \u00b6 Contract Name : TradeDealAdminFacet Inheritance : Modifiers License : MIT Solidity Version : ^0.8.0 Key Features \u00b6 \ud83d\udd39 Participant Management \u00b6 Add and remove trade deal participants Access control for participant operations Event-driven participant tracking Integration with identity verification \ud83d\udd39 Interest Distribution \u00b6 Automated interest calculation and distribution Multi-pool interest allocation Token minting for interest payments Transparent distribution tracking \ud83d\udd39 Configuration Management \u00b6 Set required claim topics for verification Configure token addresses for trade deals Update trade deal parameters Backward compatibility support \ud83d\udd39 Administrative Controls \u00b6 Owner-only access for sensitive operations Comprehensive event logging Integration with TradeDealLib utilities Secure parameter validation Core Functions \u00b6 Participant Management Functions \u00b6 addTradeDealParticipant() \u00b6 function addTradeDealParticipant ( uint256 tradeDealId , address participant ) external onlyOwner Purpose : Adds a new participant to an existing trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal - participant (address): Address of the participant to add Access Control : Owner only Process : 1. Validates trade deal exists and is active 2. Checks participant eligibility and identity verification 3. Adds participant to trade deal participant list 4. Updates participant tracking and permissions 5. Emits TradeDealParticipantAdded event Events : TradeDealParticipantAdded(tradeDealId, participant) Example Usage : // Add verified participant to trade deal address newParticipant = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; uint256 tradeDealId = 1 ; ITradeDealAdmin ( diamond ). addTradeDealParticipant ( tradeDealId , newParticipant ); console . log ( \"Participant added to trade deal:\" , tradeDealId ); Requirements : - Trade deal must exist and be active - Participant must not already be in the trade deal - Participant must meet identity verification requirements - Caller must be contract owner removeTradeDealParticipant() \u00b6 function removeTradeDealParticipant ( uint256 tradeDealId , address participant ) external onlyOwner Purpose : Removes a participant from an existing trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal - participant (address): Address of the participant to remove Access Control : Owner only Process : 1. Validates trade deal exists 2. Confirms participant is currently in the trade deal 3. Checks for outstanding obligations or positions 4. Removes participant from trade deal 5. Updates tracking and revokes permissions 6. Emits TradeDealParticipantRemoved event Events : TradeDealParticipantRemoved(tradeDealId, participant) Example Usage : // Remove participant from trade deal address participantToRemove = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; uint256 tradeDealId = 1 ; ITradeDealAdmin ( diamond ). removeTradeDealParticipant ( tradeDealId , participantToRemove ); console . log ( \"Participant removed from trade deal:\" , tradeDealId ); Requirements : - Trade deal must exist - Participant must be currently in the trade deal - Participant must not have outstanding obligations - Caller must be contract owner Interest Distribution Functions \u00b6 tdDistributeInterest() \u00b6 function tdDistributeInterest ( uint256 tradeDealId ) external onlyOwner Purpose : Distributes accumulated interest for a specific trade deal across multiple pools and participants. Parameters : - tradeDealId (uint256): ID of the trade deal for interest distribution Access Control : Owner only Process : 1. Calculates total accumulated interest for the trade deal 2. Distributes interest across different pools: - Invoice pool interest - Interest pool allocation - Participant distributions 3. Mints interest tokens as needed 4. Updates interest tracking and balances 5. Emits InterestDistributedForTradeDeal event Events : InterestDistributedForTradeDeal(tradeDealId, totalInterest, invoicePoolInterest, interestInterest, interestTokensMinted) Example Usage : // Distribute interest for trade deal uint256 tradeDealId = 1 ; ITradeDealAdmin ( diamond ). tdDistributeInterest ( tradeDealId ); console . log ( \"Interest distributed for trade deal:\" , tradeDealId ); Interest Distribution Breakdown : - Total Interest : Complete interest amount calculated - Invoice Pool Interest : Portion allocated to invoice backing - Interest Interest : Compound interest on existing interest - Interest Tokens Minted : New tokens created for distribution Requirements : - Trade deal must exist and be active - Interest must have accumulated since last distribution - Trade deal must have active participants - Caller must be contract owner Configuration Management Functions \u00b6 setTradeDealRequiredClaimTopics() \u00b6 function setTradeDealRequiredClaimTopics ( uint256 tradeDealId , uint256 [] memory claimTopics ) external onlyOwner Purpose : Sets the required identity claim topics for trade deal participation. Parameters : - tradeDealId (uint256): ID of the trade deal - claimTopics (uint256[]): Array of claim topic IDs required for participation Access Control : Owner only Process : 1. Validates trade deal exists 2. Updates required claim topics for the trade deal 3. Applies new requirements to future participants 4. Existing participants may need re-verification 5. Emits TradeDealRequiredClaimTopicsSet event Events : TradeDealRequiredClaimTopicsSet(tradeDealId, claimTopics) Example Usage : // Set KYC and accreditation requirements uint256 [] memory requiredClaims = new uint256 []( 3 ); requiredClaims [ 0 ] = 1 ; // KYC verification requiredClaims [ 1 ] = 2 ; // Accredited investor status requiredClaims [ 2 ] = 3 ; // Geographic eligibility ITradeDealAdmin ( diamond ). setTradeDealRequiredClaimTopics ( tradeDealId , requiredClaims ); console . log ( \"Claim topics set for trade deal:\" , tradeDealId ); Common Claim Topics : - 1 : KYC (Know Your Customer) verification - 2 : Accredited investor status - 3 : Geographic eligibility - 4 : Professional investor qualification - 5 : Institutional investor status setTradeDealTokenAddresses() \u00b6 function setTradeDealTokenAddresses ( uint256 tradeDealId , address nftAddress , address collateralAddress , address interestAddress , address usdcAddress ) external onlyOwner Purpose : Configures the token contract addresses used by a trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal - nftAddress (address): Address of the NFT contract (currently unused) - collateralAddress (address): Address of the collateral token contract - interestAddress (address): Address of the interest token contract - usdcAddress (address): Address of the USDC token contract Access Control : Owner only Process : 1. Validates trade deal exists 2. Updates token contract addresses in trade deal configuration 3. Validates token contracts implement required interfaces 4. Updates trade deal settings and parameters 5. Emits TradeDealUpdated event with complete configuration Events : TradeDealUpdated(tradeDealId, name, symbol, interestRate, collateralToInterestRatio, active, collateralAddress, interestAddress, usdcAddress) Example Usage : // Configure token addresses for trade deal address collateralToken = 0x1234567890123456789012345678901234567890 ; address interestToken = 0x2345678901234567890123456789012345678901 ; address usdcToken = 0x3456789012345678901234567890123456789012 ; ITradeDealAdmin ( diamond ). setTradeDealTokenAddresses ( tradeDealId , address ( 0 ), // NFT address not used collateralToken , interestToken , usdcToken ); Token Address Roles : - Collateral Address : Token used as collateral backing - Interest Address : Token used for interest payments - USDC Address : Stablecoin for value reference and payments setTradeDealNFTAddress() \u00b6 function setTradeDealNFTAddress ( uint256 tradeDealId , address nftAddress ) external onlyOwner Purpose : Legacy function maintained for backward compatibility. Currently performs no operation. Parameters : - tradeDealId (uint256): ID of the trade deal - nftAddress (address): NFT contract address (ignored) Access Control : Owner only Note : This function is a no-op maintained for backward compatibility with older integrations. Integration Examples \u00b6 Trade Deal Participant Management \u00b6 // Comprehensive participant management system contract TradeDealParticipantManager { struct ParticipantInfo { address participant ; uint256 joinedAt ; uint256 [] claimTopics ; bool active ; } mapping ( uint256 => mapping ( address => ParticipantInfo )) public tradeDealParticipants ; mapping ( uint256 => address []) public participantLists ; function addVerifiedParticipant ( uint256 tradeDealId , address participant , uint256 [] memory verifiedClaims ) external onlyOwner { // Verify participant has required claims uint256 [] memory requiredClaims = getTradeDealRequiredClaims ( tradeDealId ); require ( hasRequiredClaims ( verifiedClaims , requiredClaims ), \"Missing required claims\" ); // Add to trade deal ITradeDealAdmin ( diamond ). addTradeDealParticipant ( tradeDealId , participant ); // Track participant info tradeDealParticipants [ tradeDealId ][ participant ] = ParticipantInfo ({ participant : participant , joinedAt : block.timestamp , claimTopics : verifiedClaims , active : true }); participantLists [ tradeDealId ]. push ( participant ); emit ParticipantAdded ( tradeDealId , participant , verifiedClaims ); } function removeParticipant ( uint256 tradeDealId , address participant ) external onlyOwner { require ( tradeDealParticipants [ tradeDealId ][ participant ]. active , \"Participant not active\" ); // Remove from trade deal ITradeDealAdmin ( diamond ). removeTradeDealParticipant ( tradeDealId , participant ); // Update tracking tradeDealParticipants [ tradeDealId ][ participant ]. active = false ; // Remove from list _removeFromParticipantList ( tradeDealId , participant ); emit ParticipantRemoved ( tradeDealId , participant ); } function hasRequiredClaims ( uint256 [] memory userClaims , uint256 [] memory requiredClaims ) internal pure returns ( bool ) { for ( uint256 i = 0 ; i < requiredClaims . length ; i ++ ) { bool hasRequiredClaim = false ; for ( uint256 j = 0 ; j < userClaims . length ; j ++ ) { if ( userClaims [ j ] == requiredClaims [ i ]) { hasRequiredClaim = true ; break ; } } if ( ! hasRequiredClaim ) { return false ; } } return true ; } } Automated Interest Distribution System \u00b6 // Automated interest distribution with scheduling contract InterestDistributionScheduler { struct DistributionSchedule { uint256 tradeDealId ; uint256 frequency ; // in seconds uint256 lastDistribution ; bool active ; } mapping ( uint256 => DistributionSchedule ) public distributionSchedules ; uint256 [] public scheduledTradeDealIds ; function setDistributionSchedule ( uint256 tradeDealId , uint256 frequency ) external onlyOwner { distributionSchedules [ tradeDealId ] = DistributionSchedule ({ tradeDealId : tradeDealId , frequency : frequency , lastDistribution : block.timestamp , active : true }); scheduledTradeDealIds . push ( tradeDealId ); emit DistributionScheduleSet ( tradeDealId , frequency ); } function executeScheduledDistributions () external { for ( uint256 i = 0 ; i < scheduledTradeDealIds . length ; i ++ ) { uint256 tradeDealId = scheduledTradeDealIds [ i ]; DistributionSchedule storage schedule = distributionSchedules [ tradeDealId ]; if ( schedule . active && block.timestamp >= schedule . lastDistribution + schedule . frequency ) { // Execute distribution ITradeDealAdmin ( diamond ). tdDistributeInterest ( tradeDealId ); // Update schedule schedule . lastDistribution = block.timestamp ; emit ScheduledDistributionExecuted ( tradeDealId , block.timestamp ); } } } function getDistributionStatus ( uint256 tradeDealId ) external view returns ( bool isDue , uint256 nextDistribution , uint256 timeSinceLastDistribution ) { DistributionSchedule memory schedule = distributionSchedules [ tradeDealId ]; if ( ! schedule . active ) { return ( false , 0 , 0 ); } timeSinceLastDistribution = block.timestamp - schedule . lastDistribution ; nextDistribution = schedule . lastDistribution + schedule . frequency ; isDue = block.timestamp >= nextDistribution ; } } Trade Deal Configuration Manager \u00b6 // Comprehensive trade deal configuration management contract TradeDealConfigManager { struct TradeDealConfig { string name ; string symbol ; uint256 interestRate ; uint256 collateralToInterestRatio ; address collateralAddress ; address interestAddress ; address usdcAddress ; uint256 [] requiredClaimTopics ; bool active ; } mapping ( uint256 => TradeDealConfig ) public tradeDealConfigs ; function configureTradeDeal ( uint256 tradeDealId , TradeDealConfig memory config ) external onlyOwner { // Set token addresses ITradeDealAdmin ( diamond ). setTradeDealTokenAddresses ( tradeDealId , address ( 0 ), // NFT address not used config . collateralAddress , config . interestAddress , config . usdcAddress ); // Set required claim topics ITradeDealAdmin ( diamond ). setTradeDealRequiredClaimTopics ( tradeDealId , config . requiredClaimTopics ); // Store configuration tradeDealConfigs [ tradeDealId ] = config ; emit TradeDealConfigured ( tradeDealId , config ); } function updateTradeDealTokens ( uint256 tradeDealId , address newCollateralAddress , address newInterestAddress , address newUsdcAddress ) external onlyOwner { TradeDealConfig storage config = tradeDealConfigs [ tradeDealId ]; // Update addresses ITradeDealAdmin ( diamond ). setTradeDealTokenAddresses ( tradeDealId , address ( 0 ), newCollateralAddress , newInterestAddress , newUsdcAddress ); // Update stored config config . collateralAddress = newCollateralAddress ; config . interestAddress = newInterestAddress ; config . usdcAddress = newUsdcAddress ; emit TradeDealTokensUpdated ( tradeDealId , newCollateralAddress , newInterestAddress , newUsdcAddress ); } function updateRequiredClaims ( uint256 tradeDealId , uint256 [] memory newClaimTopics ) external onlyOwner { // Update claim topics ITradeDealAdmin ( diamond ). setTradeDealRequiredClaimTopics ( tradeDealId , newClaimTopics ); // Update stored config tradeDealConfigs [ tradeDealId ]. requiredClaimTopics = newClaimTopics ; emit RequiredClaimsUpdated ( tradeDealId , newClaimTopics ); } } Interest Distribution Analytics \u00b6 // Analytics and reporting for interest distributions contract InterestDistributionAnalytics { struct DistributionRecord { uint256 timestamp ; uint256 totalInterest ; uint256 invoicePoolInterest ; uint256 interestInterest ; uint256 interestTokensMinted ; uint256 participantCount ; } mapping ( uint256 => DistributionRecord []) public distributionHistory ; mapping ( uint256 => uint256 ) public totalDistributedInterest ; mapping ( uint256 => uint256 ) public totalTokensMinted ; function recordDistribution ( uint256 tradeDealId , uint256 totalInterest , uint256 invoicePoolInterest , uint256 interestInterest , uint256 interestTokensMinted , uint256 participantCount ) external onlyAuthorized { DistributionRecord memory record = DistributionRecord ({ timestamp : block.timestamp , totalInterest : totalInterest , invoicePoolInterest : invoicePoolInterest , interestInterest : interestInterest , interestTokensMinted : interestTokensMinted , participantCount : participantCount }); distributionHistory [ tradeDealId ]. push ( record ); totalDistributedInterest [ tradeDealId ] += totalInterest ; totalTokensMinted [ tradeDealId ] += interestTokensMinted ; emit DistributionRecorded ( tradeDealId , record ); } function getDistributionStats ( uint256 tradeDealId ) external view returns ( uint256 totalDistributions , uint256 totalInterestDistributed , uint256 totalTokensMintedForInterest , uint256 averageDistributionAmount , uint256 lastDistributionTime ) { DistributionRecord [] memory history = distributionHistory [ tradeDealId ]; totalDistributions = history . length ; totalInterestDistributed = totalDistributedInterest [ tradeDealId ]; totalTokensMintedForInterest = totalTokensMinted [ tradeDealId ]; if ( totalDistributions > 0 ) { averageDistributionAmount = totalInterestDistributed / totalDistributions ; lastDistributionTime = history [ totalDistributions - 1 ]. timestamp ; } } function getRecentDistributions ( uint256 tradeDealId , uint256 count ) external view returns ( DistributionRecord [] memory ) { DistributionRecord [] memory history = distributionHistory [ tradeDealId ]; if ( history . length == 0 ) { return new DistributionRecord []( 0 ); } uint256 startIndex = history . length > count ? history . length - count : 0 ; uint256 resultLength = history . length - startIndex ; DistributionRecord [] memory recent = new DistributionRecord []( resultLength ); for ( uint256 i = 0 ; i < resultLength ; i ++ ) { recent [ i ] = history [ startIndex + i ]; } return recent ; } } Events \u00b6 Participant Management Events \u00b6 event TradeDealParticipantAdded ( uint256 indexed tradeDealId , address indexed participant ); event TradeDealParticipantRemoved ( uint256 indexed tradeDealId , address indexed participant ); Interest Distribution Events \u00b6 event InterestDistributedForTradeDeal ( uint256 indexed tradeDealId , uint256 totalInterest , uint256 invoicePoolInterest , uint256 interestInterest , uint256 interestTokensMinted ); Configuration Events \u00b6 event TradeDealRequiredClaimTopicsSet ( uint256 indexed tradeDealId , uint256 [] claimTopics ); event TradeDealUpdated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address collateralAddress , address interestAddress , address usdcAddress ); Security Considerations \u00b6 Access Control \u00b6 All functions restricted to contract owner Participant validation before addition/removal Token address validation before configuration Claim topic verification for participants Interest Distribution Security \u00b6 Precise interest calculation validation Overflow protection for large distributions Token minting authorization checks Distribution frequency limits Configuration Security \u00b6 Token contract interface validation Address zero checks for critical addresses Claim topic existence verification Configuration change event logging Gas Optimization \u00b6 Batch Operations \u00b6 Consider batching participant operations Optimize interest distribution calculations Minimize storage operations Use events for off-chain tracking Efficient Storage \u00b6 Pack configuration data efficiently Use mappings for participant tracking Optimize claim topic storage Cache frequently accessed data Error Handling \u00b6 Common Errors \u00b6 Trade deal not found Participant already exists/doesn't exist Invalid token addresses Insufficient permissions Interest distribution failures Best Practices \u00b6 Validate all inputs before processing Check trade deal state before operations Verify participant eligibility Handle token contract failures gracefully Testing Considerations \u00b6 Unit Tests \u00b6 Participant addition and removal Interest distribution calculations Configuration updates Access control enforcement Integration Tests \u00b6 Multi-participant scenarios Interest distribution workflows Configuration change impacts Event emission verification Related Documentation \u00b6 TradeDealManagementFacet - Core trade deal operations TradeDealOperationsFacet - Operational functions TradeDealLib - Trade deal utilities IdentityRegistryFacet - Identity verification Trade Deal Guide - Implementation guide This facet provides comprehensive administrative functionality for trade deal management within the Gemforce platform, enabling secure participant management, interest distribution, and configuration control.","title":"Trade Deal Admin Facet"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#tradedealadminfacet","text":"","title":"TradeDealAdminFacet"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#overview","text":"The TradeDealAdminFacet.sol provides administrative functionality for managing trade deals within the Gemforce diamond system. This facet handles participant management, interest distribution, claim topic configuration, and token address management for trade deal operations.","title":"Overview"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#contract-details","text":"Contract Name : TradeDealAdminFacet Inheritance : Modifiers License : MIT Solidity Version : ^0.8.0","title":"Contract Details"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#participant-management","text":"Add and remove trade deal participants Access control for participant operations Event-driven participant tracking Integration with identity verification","title":"\ud83d\udd39 Participant Management"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#interest-distribution","text":"Automated interest calculation and distribution Multi-pool interest allocation Token minting for interest payments Transparent distribution tracking","title":"\ud83d\udd39 Interest Distribution"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#configuration-management","text":"Set required claim topics for verification Configure token addresses for trade deals Update trade deal parameters Backward compatibility support","title":"\ud83d\udd39 Configuration Management"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#administrative-controls","text":"Owner-only access for sensitive operations Comprehensive event logging Integration with TradeDealLib utilities Secure parameter validation","title":"\ud83d\udd39 Administrative Controls"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#participant-management-functions","text":"","title":"Participant Management Functions"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#addtradedealparticipant","text":"function addTradeDealParticipant ( uint256 tradeDealId , address participant ) external onlyOwner Purpose : Adds a new participant to an existing trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal - participant (address): Address of the participant to add Access Control : Owner only Process : 1. Validates trade deal exists and is active 2. Checks participant eligibility and identity verification 3. Adds participant to trade deal participant list 4. Updates participant tracking and permissions 5. Emits TradeDealParticipantAdded event Events : TradeDealParticipantAdded(tradeDealId, participant) Example Usage : // Add verified participant to trade deal address newParticipant = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; uint256 tradeDealId = 1 ; ITradeDealAdmin ( diamond ). addTradeDealParticipant ( tradeDealId , newParticipant ); console . log ( \"Participant added to trade deal:\" , tradeDealId ); Requirements : - Trade deal must exist and be active - Participant must not already be in the trade deal - Participant must meet identity verification requirements - Caller must be contract owner","title":"addTradeDealParticipant()"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#removetradedealparticipant","text":"function removeTradeDealParticipant ( uint256 tradeDealId , address participant ) external onlyOwner Purpose : Removes a participant from an existing trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal - participant (address): Address of the participant to remove Access Control : Owner only Process : 1. Validates trade deal exists 2. Confirms participant is currently in the trade deal 3. Checks for outstanding obligations or positions 4. Removes participant from trade deal 5. Updates tracking and revokes permissions 6. Emits TradeDealParticipantRemoved event Events : TradeDealParticipantRemoved(tradeDealId, participant) Example Usage : // Remove participant from trade deal address participantToRemove = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; uint256 tradeDealId = 1 ; ITradeDealAdmin ( diamond ). removeTradeDealParticipant ( tradeDealId , participantToRemove ); console . log ( \"Participant removed from trade deal:\" , tradeDealId ); Requirements : - Trade deal must exist - Participant must be currently in the trade deal - Participant must not have outstanding obligations - Caller must be contract owner","title":"removeTradeDealParticipant()"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#interest-distribution-functions","text":"","title":"Interest Distribution Functions"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#tddistributeinterest","text":"function tdDistributeInterest ( uint256 tradeDealId ) external onlyOwner Purpose : Distributes accumulated interest for a specific trade deal across multiple pools and participants. Parameters : - tradeDealId (uint256): ID of the trade deal for interest distribution Access Control : Owner only Process : 1. Calculates total accumulated interest for the trade deal 2. Distributes interest across different pools: - Invoice pool interest - Interest pool allocation - Participant distributions 3. Mints interest tokens as needed 4. Updates interest tracking and balances 5. Emits InterestDistributedForTradeDeal event Events : InterestDistributedForTradeDeal(tradeDealId, totalInterest, invoicePoolInterest, interestInterest, interestTokensMinted) Example Usage : // Distribute interest for trade deal uint256 tradeDealId = 1 ; ITradeDealAdmin ( diamond ). tdDistributeInterest ( tradeDealId ); console . log ( \"Interest distributed for trade deal:\" , tradeDealId ); Interest Distribution Breakdown : - Total Interest : Complete interest amount calculated - Invoice Pool Interest : Portion allocated to invoice backing - Interest Interest : Compound interest on existing interest - Interest Tokens Minted : New tokens created for distribution Requirements : - Trade deal must exist and be active - Interest must have accumulated since last distribution - Trade deal must have active participants - Caller must be contract owner","title":"tdDistributeInterest()"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#configuration-management-functions","text":"","title":"Configuration Management Functions"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#settradedealrequiredclaimtopics","text":"function setTradeDealRequiredClaimTopics ( uint256 tradeDealId , uint256 [] memory claimTopics ) external onlyOwner Purpose : Sets the required identity claim topics for trade deal participation. Parameters : - tradeDealId (uint256): ID of the trade deal - claimTopics (uint256[]): Array of claim topic IDs required for participation Access Control : Owner only Process : 1. Validates trade deal exists 2. Updates required claim topics for the trade deal 3. Applies new requirements to future participants 4. Existing participants may need re-verification 5. Emits TradeDealRequiredClaimTopicsSet event Events : TradeDealRequiredClaimTopicsSet(tradeDealId, claimTopics) Example Usage : // Set KYC and accreditation requirements uint256 [] memory requiredClaims = new uint256 []( 3 ); requiredClaims [ 0 ] = 1 ; // KYC verification requiredClaims [ 1 ] = 2 ; // Accredited investor status requiredClaims [ 2 ] = 3 ; // Geographic eligibility ITradeDealAdmin ( diamond ). setTradeDealRequiredClaimTopics ( tradeDealId , requiredClaims ); console . log ( \"Claim topics set for trade deal:\" , tradeDealId ); Common Claim Topics : - 1 : KYC (Know Your Customer) verification - 2 : Accredited investor status - 3 : Geographic eligibility - 4 : Professional investor qualification - 5 : Institutional investor status","title":"setTradeDealRequiredClaimTopics()"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#settradedealtokenaddresses","text":"function setTradeDealTokenAddresses ( uint256 tradeDealId , address nftAddress , address collateralAddress , address interestAddress , address usdcAddress ) external onlyOwner Purpose : Configures the token contract addresses used by a trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal - nftAddress (address): Address of the NFT contract (currently unused) - collateralAddress (address): Address of the collateral token contract - interestAddress (address): Address of the interest token contract - usdcAddress (address): Address of the USDC token contract Access Control : Owner only Process : 1. Validates trade deal exists 2. Updates token contract addresses in trade deal configuration 3. Validates token contracts implement required interfaces 4. Updates trade deal settings and parameters 5. Emits TradeDealUpdated event with complete configuration Events : TradeDealUpdated(tradeDealId, name, symbol, interestRate, collateralToInterestRatio, active, collateralAddress, interestAddress, usdcAddress) Example Usage : // Configure token addresses for trade deal address collateralToken = 0x1234567890123456789012345678901234567890 ; address interestToken = 0x2345678901234567890123456789012345678901 ; address usdcToken = 0x3456789012345678901234567890123456789012 ; ITradeDealAdmin ( diamond ). setTradeDealTokenAddresses ( tradeDealId , address ( 0 ), // NFT address not used collateralToken , interestToken , usdcToken ); Token Address Roles : - Collateral Address : Token used as collateral backing - Interest Address : Token used for interest payments - USDC Address : Stablecoin for value reference and payments","title":"setTradeDealTokenAddresses()"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#settradedealnftaddress","text":"function setTradeDealNFTAddress ( uint256 tradeDealId , address nftAddress ) external onlyOwner Purpose : Legacy function maintained for backward compatibility. Currently performs no operation. Parameters : - tradeDealId (uint256): ID of the trade deal - nftAddress (address): NFT contract address (ignored) Access Control : Owner only Note : This function is a no-op maintained for backward compatibility with older integrations.","title":"setTradeDealNFTAddress()"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#trade-deal-participant-management","text":"// Comprehensive participant management system contract TradeDealParticipantManager { struct ParticipantInfo { address participant ; uint256 joinedAt ; uint256 [] claimTopics ; bool active ; } mapping ( uint256 => mapping ( address => ParticipantInfo )) public tradeDealParticipants ; mapping ( uint256 => address []) public participantLists ; function addVerifiedParticipant ( uint256 tradeDealId , address participant , uint256 [] memory verifiedClaims ) external onlyOwner { // Verify participant has required claims uint256 [] memory requiredClaims = getTradeDealRequiredClaims ( tradeDealId ); require ( hasRequiredClaims ( verifiedClaims , requiredClaims ), \"Missing required claims\" ); // Add to trade deal ITradeDealAdmin ( diamond ). addTradeDealParticipant ( tradeDealId , participant ); // Track participant info tradeDealParticipants [ tradeDealId ][ participant ] = ParticipantInfo ({ participant : participant , joinedAt : block.timestamp , claimTopics : verifiedClaims , active : true }); participantLists [ tradeDealId ]. push ( participant ); emit ParticipantAdded ( tradeDealId , participant , verifiedClaims ); } function removeParticipant ( uint256 tradeDealId , address participant ) external onlyOwner { require ( tradeDealParticipants [ tradeDealId ][ participant ]. active , \"Participant not active\" ); // Remove from trade deal ITradeDealAdmin ( diamond ). removeTradeDealParticipant ( tradeDealId , participant ); // Update tracking tradeDealParticipants [ tradeDealId ][ participant ]. active = false ; // Remove from list _removeFromParticipantList ( tradeDealId , participant ); emit ParticipantRemoved ( tradeDealId , participant ); } function hasRequiredClaims ( uint256 [] memory userClaims , uint256 [] memory requiredClaims ) internal pure returns ( bool ) { for ( uint256 i = 0 ; i < requiredClaims . length ; i ++ ) { bool hasRequiredClaim = false ; for ( uint256 j = 0 ; j < userClaims . length ; j ++ ) { if ( userClaims [ j ] == requiredClaims [ i ]) { hasRequiredClaim = true ; break ; } } if ( ! hasRequiredClaim ) { return false ; } } return true ; } }","title":"Trade Deal Participant Management"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#automated-interest-distribution-system","text":"// Automated interest distribution with scheduling contract InterestDistributionScheduler { struct DistributionSchedule { uint256 tradeDealId ; uint256 frequency ; // in seconds uint256 lastDistribution ; bool active ; } mapping ( uint256 => DistributionSchedule ) public distributionSchedules ; uint256 [] public scheduledTradeDealIds ; function setDistributionSchedule ( uint256 tradeDealId , uint256 frequency ) external onlyOwner { distributionSchedules [ tradeDealId ] = DistributionSchedule ({ tradeDealId : tradeDealId , frequency : frequency , lastDistribution : block.timestamp , active : true }); scheduledTradeDealIds . push ( tradeDealId ); emit DistributionScheduleSet ( tradeDealId , frequency ); } function executeScheduledDistributions () external { for ( uint256 i = 0 ; i < scheduledTradeDealIds . length ; i ++ ) { uint256 tradeDealId = scheduledTradeDealIds [ i ]; DistributionSchedule storage schedule = distributionSchedules [ tradeDealId ]; if ( schedule . active && block.timestamp >= schedule . lastDistribution + schedule . frequency ) { // Execute distribution ITradeDealAdmin ( diamond ). tdDistributeInterest ( tradeDealId ); // Update schedule schedule . lastDistribution = block.timestamp ; emit ScheduledDistributionExecuted ( tradeDealId , block.timestamp ); } } } function getDistributionStatus ( uint256 tradeDealId ) external view returns ( bool isDue , uint256 nextDistribution , uint256 timeSinceLastDistribution ) { DistributionSchedule memory schedule = distributionSchedules [ tradeDealId ]; if ( ! schedule . active ) { return ( false , 0 , 0 ); } timeSinceLastDistribution = block.timestamp - schedule . lastDistribution ; nextDistribution = schedule . lastDistribution + schedule . frequency ; isDue = block.timestamp >= nextDistribution ; } }","title":"Automated Interest Distribution System"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#trade-deal-configuration-manager","text":"// Comprehensive trade deal configuration management contract TradeDealConfigManager { struct TradeDealConfig { string name ; string symbol ; uint256 interestRate ; uint256 collateralToInterestRatio ; address collateralAddress ; address interestAddress ; address usdcAddress ; uint256 [] requiredClaimTopics ; bool active ; } mapping ( uint256 => TradeDealConfig ) public tradeDealConfigs ; function configureTradeDeal ( uint256 tradeDealId , TradeDealConfig memory config ) external onlyOwner { // Set token addresses ITradeDealAdmin ( diamond ). setTradeDealTokenAddresses ( tradeDealId , address ( 0 ), // NFT address not used config . collateralAddress , config . interestAddress , config . usdcAddress ); // Set required claim topics ITradeDealAdmin ( diamond ). setTradeDealRequiredClaimTopics ( tradeDealId , config . requiredClaimTopics ); // Store configuration tradeDealConfigs [ tradeDealId ] = config ; emit TradeDealConfigured ( tradeDealId , config ); } function updateTradeDealTokens ( uint256 tradeDealId , address newCollateralAddress , address newInterestAddress , address newUsdcAddress ) external onlyOwner { TradeDealConfig storage config = tradeDealConfigs [ tradeDealId ]; // Update addresses ITradeDealAdmin ( diamond ). setTradeDealTokenAddresses ( tradeDealId , address ( 0 ), newCollateralAddress , newInterestAddress , newUsdcAddress ); // Update stored config config . collateralAddress = newCollateralAddress ; config . interestAddress = newInterestAddress ; config . usdcAddress = newUsdcAddress ; emit TradeDealTokensUpdated ( tradeDealId , newCollateralAddress , newInterestAddress , newUsdcAddress ); } function updateRequiredClaims ( uint256 tradeDealId , uint256 [] memory newClaimTopics ) external onlyOwner { // Update claim topics ITradeDealAdmin ( diamond ). setTradeDealRequiredClaimTopics ( tradeDealId , newClaimTopics ); // Update stored config tradeDealConfigs [ tradeDealId ]. requiredClaimTopics = newClaimTopics ; emit RequiredClaimsUpdated ( tradeDealId , newClaimTopics ); } }","title":"Trade Deal Configuration Manager"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#interest-distribution-analytics","text":"// Analytics and reporting for interest distributions contract InterestDistributionAnalytics { struct DistributionRecord { uint256 timestamp ; uint256 totalInterest ; uint256 invoicePoolInterest ; uint256 interestInterest ; uint256 interestTokensMinted ; uint256 participantCount ; } mapping ( uint256 => DistributionRecord []) public distributionHistory ; mapping ( uint256 => uint256 ) public totalDistributedInterest ; mapping ( uint256 => uint256 ) public totalTokensMinted ; function recordDistribution ( uint256 tradeDealId , uint256 totalInterest , uint256 invoicePoolInterest , uint256 interestInterest , uint256 interestTokensMinted , uint256 participantCount ) external onlyAuthorized { DistributionRecord memory record = DistributionRecord ({ timestamp : block.timestamp , totalInterest : totalInterest , invoicePoolInterest : invoicePoolInterest , interestInterest : interestInterest , interestTokensMinted : interestTokensMinted , participantCount : participantCount }); distributionHistory [ tradeDealId ]. push ( record ); totalDistributedInterest [ tradeDealId ] += totalInterest ; totalTokensMinted [ tradeDealId ] += interestTokensMinted ; emit DistributionRecorded ( tradeDealId , record ); } function getDistributionStats ( uint256 tradeDealId ) external view returns ( uint256 totalDistributions , uint256 totalInterestDistributed , uint256 totalTokensMintedForInterest , uint256 averageDistributionAmount , uint256 lastDistributionTime ) { DistributionRecord [] memory history = distributionHistory [ tradeDealId ]; totalDistributions = history . length ; totalInterestDistributed = totalDistributedInterest [ tradeDealId ]; totalTokensMintedForInterest = totalTokensMinted [ tradeDealId ]; if ( totalDistributions > 0 ) { averageDistributionAmount = totalInterestDistributed / totalDistributions ; lastDistributionTime = history [ totalDistributions - 1 ]. timestamp ; } } function getRecentDistributions ( uint256 tradeDealId , uint256 count ) external view returns ( DistributionRecord [] memory ) { DistributionRecord [] memory history = distributionHistory [ tradeDealId ]; if ( history . length == 0 ) { return new DistributionRecord []( 0 ); } uint256 startIndex = history . length > count ? history . length - count : 0 ; uint256 resultLength = history . length - startIndex ; DistributionRecord [] memory recent = new DistributionRecord []( resultLength ); for ( uint256 i = 0 ; i < resultLength ; i ++ ) { recent [ i ] = history [ startIndex + i ]; } return recent ; } }","title":"Interest Distribution Analytics"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#events","text":"","title":"Events"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#participant-management-events","text":"event TradeDealParticipantAdded ( uint256 indexed tradeDealId , address indexed participant ); event TradeDealParticipantRemoved ( uint256 indexed tradeDealId , address indexed participant );","title":"Participant Management Events"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#interest-distribution-events","text":"event InterestDistributedForTradeDeal ( uint256 indexed tradeDealId , uint256 totalInterest , uint256 invoicePoolInterest , uint256 interestInterest , uint256 interestTokensMinted );","title":"Interest Distribution Events"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#configuration-events","text":"event TradeDealRequiredClaimTopicsSet ( uint256 indexed tradeDealId , uint256 [] claimTopics ); event TradeDealUpdated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address collateralAddress , address interestAddress , address usdcAddress );","title":"Configuration Events"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#access-control","text":"All functions restricted to contract owner Participant validation before addition/removal Token address validation before configuration Claim topic verification for participants","title":"Access Control"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#interest-distribution-security","text":"Precise interest calculation validation Overflow protection for large distributions Token minting authorization checks Distribution frequency limits","title":"Interest Distribution Security"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#configuration-security","text":"Token contract interface validation Address zero checks for critical addresses Claim topic existence verification Configuration change event logging","title":"Configuration Security"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#batch-operations","text":"Consider batching participant operations Optimize interest distribution calculations Minimize storage operations Use events for off-chain tracking","title":"Batch Operations"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#efficient-storage","text":"Pack configuration data efficiently Use mappings for participant tracking Optimize claim topic storage Cache frequently accessed data","title":"Efficient Storage"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#common-errors","text":"Trade deal not found Participant already exists/doesn't exist Invalid token addresses Insufficient permissions Interest distribution failures","title":"Common Errors"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#best-practices","text":"Validate all inputs before processing Check trade deal state before operations Verify participant eligibility Handle token contract failures gracefully","title":"Best Practices"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#unit-tests","text":"Participant addition and removal Interest distribution calculations Configuration updates Access control enforcement","title":"Unit Tests"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#integration-tests","text":"Multi-participant scenarios Interest distribution workflows Configuration change impacts Event emission verification","title":"Integration Tests"},{"location":"smart-contracts/facets/trade-deal-admin-facet/#related-documentation","text":"TradeDealManagementFacet - Core trade deal operations TradeDealOperationsFacet - Operational functions TradeDealLib - Trade deal utilities IdentityRegistryFacet - Identity verification Trade Deal Guide - Implementation guide This facet provides comprehensive administrative functionality for trade deal management within the Gemforce platform, enabling secure participant management, interest distribution, and configuration control.","title":"Related Documentation"},{"location":"smart-contracts/facets/trade-deal-management-facet/","text":"TradeDealManagementFacet \u00b6 Overview \u00b6 The TradeDealManagementFacet.sol provides comprehensive CRUD (Create, Read, Update, Delete) operations and basic management functionality for trade deals within the Gemforce diamond system. This facet enables the creation and management of collateralized trade deals for invoice financing and other financial instruments. Contract Details \u00b6 Contract Name : TradeDealManagementFacet Inheritance : Modifiers License : MIT Solidity Version : ^0.8.0 Key Features \u00b6 \ud83d\udd39 Trade Deal Lifecycle Management \u00b6 Create new trade deals with configurable parameters Update existing trade deal configurations Activate and deactivate trade deals Comprehensive status tracking \ud83d\udd39 Multi-Token Architecture \u00b6 NFT collateral support (invoice NFTs) Collateral token management Interest token distribution USDC payment integration \ud83d\udd39 Operation Modes \u00b6 Flexible operation modes for different financing scenarios Configurable interest rates and collateral ratios Identity-based access control through claim topics \ud83d\udd39 Comprehensive Monitoring \u00b6 Real-time funding status tracking Debt and repayment monitoring Participant verification Financial metrics calculation Core Data Structures \u00b6 Operation Modes \u00b6 enum OperationMode { STANDARD , // Standard trade deal operation ACCELERATED , // Accelerated funding mode CONSERVATIVE , // Conservative risk mode CUSTOM // Custom operation parameters } Trade Deal Parameters \u00b6 struct CreateTradeDealParams { string name ; // Trade deal name string symbol ; // Trade deal symbol uint256 interestRate ; // Interest rate (basis points) uint256 collateralToInterestRatio ; // Collateral to interest ratio uint256 [] requiredClaimTopics ; // Required identity claims address collateralAddress ; // Collateral token contract address interestAddress ; // Interest token contract address usdcAddress ; // USDC payment token OperationMode operationMode ; // Operation mode } Core Functions \u00b6 Trade Deal Creation \u00b6 createTradeDeal() \u00b6 function createTradeDeal ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , uint256 [] memory requiredClaimTopics , address collateralAddress , address interestAddress , address usdcAddress , TradeDealLib . OperationMode operationMode ) public onlyOwner returns ( uint256 ) Purpose : Creates a new trade deal with specified parameters and returns the trade deal ID. Parameters : - name : Human-readable name for the trade deal - symbol : Short symbol identifier for the trade deal - interestRate : Interest rate in basis points (e.g., 500 = 5%) - collateralToInterestRatio : Ratio of collateral to interest tokens - requiredClaimTopics : Array of required identity claim topics for participation - collateralAddress : Address of the collateral token contract - interestAddress : Address of the interest token contract - usdcAddress : Address of the USDC token contract for payments - operationMode : Operation mode for the trade deal Access Control : Owner only Returns : uint256 - The newly created trade deal ID Process : 1. Validates all input parameters 2. Creates trade deal using TradeDealLib 3. Emits TradeDealCreated event 4. Sets required claim topics if provided 5. Returns the trade deal ID Events : - TradeDealCreated - Emitted with complete trade deal information - TradeDealRequiredClaimTopicsSet - Emitted if claim topics are set Example Usage : // Create a standard trade deal for invoice financing uint256 tradeDealId = ITradeDeal ( diamond ). createTradeDeal ( \"Invoice Financing Deal #1\" , \"IFD1\" , 750 , // 7.5% interest rate 150 , // 1.5x collateral ratio [ 1 , 2 , 3 ], // Required claim topics collateralTokenAddress , interestTokenAddress , usdcTokenAddress , TradeDealLib . OperationMode . STANDARD ); Trade Deal Updates \u00b6 updateTradeDeal() \u00b6 function updateTradeDeal ( uint256 tradeDealId , string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , address collateralAddress , address interestAddress , address usdcAddress ) external onlyOwner Purpose : Updates an existing trade deal's configuration parameters. Parameters : - tradeDealId : ID of the trade deal to update - name : New name for the trade deal - symbol : New symbol for the trade deal - interestRate : New interest rate in basis points - collateralToInterestRatio : New collateral to interest ratio - collateralAddress : New collateral token address - interestAddress : New interest token address - usdcAddress : New USDC token address Access Control : Owner only Validation : - Trade deal must exist - New parameters must be valid - Cannot update active funded deals Events : TradeDealUpdated - Emitted with updated parameters State Management \u00b6 activateTradeDeal() \u00b6 function activateTradeDeal ( uint256 tradeDealId ) external onlyOwner Purpose : Activates a trade deal, making it available for funding. Parameters : - tradeDealId : ID of the trade deal to activate Access Control : Owner only Events : TradeDealActivated deactivateTradeDeal() \u00b6 function deactivateTradeDeal ( uint256 tradeDealId ) external onlyOwner Purpose : Deactivates a trade deal, preventing new funding. Parameters : - tradeDealId : ID of the trade deal to deactivate Access Control : Owner only Events : TradeDealDeactivated Information Retrieval \u00b6 getTradeDealInfo() \u00b6 function getTradeDealInfo ( uint256 tradeDealId ) external view returns ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , TradeDealLib . OperationMode operationMode ) Purpose : Retrieves basic information about a trade deal. Parameters : - tradeDealId : ID of the trade deal Returns : Basic trade deal configuration and status getTradeDealFullStatus() \u00b6 function getTradeDealFullStatus ( uint256 tradeDealId ) external view returns ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) Purpose : Retrieves comprehensive financial status of a trade deal. Parameters : - tradeDealId : ID of the trade deal Returns : Complete financial status including funding, debt, and repayment information getAllTradeDealIds() \u00b6 function getAllTradeDealIds () external view returns ( uint256 [] memory ) Purpose : Returns an array of all trade deal IDs in the system. Returns : Array of trade deal IDs Participant and Status Checks \u00b6 isTradeDealParticipant() \u00b6 function isTradeDealParticipant ( uint256 tradeDealId , address user ) external view returns ( bool ) Purpose : Checks if a user is a participant in a specific trade deal. Parameters : - tradeDealId : ID of the trade deal - user : Address to check Returns : true if user is a participant, false otherwise isTradeDealFunded() \u00b6 function isTradeDealFunded ( uint256 tradeDealId ) external view returns ( bool ) Purpose : Checks if a trade deal has reached its funding target. isTradeDealRepaid() \u00b6 function isTradeDealRepaid ( uint256 tradeDealId ) external view returns ( bool ) Purpose : Checks if a trade deal has been fully repaid. Utility Functions \u00b6 getNFTInvoiceTotalAmount() \u00b6 function getNFTInvoiceTotalAmount ( uint256 tokenId ) external view returns ( uint256 ) Purpose : Gets the total amount of an invoice NFT used as collateral. Parameters : - tokenId : ID of the invoice NFT Returns : Total invoice amount getTradeDealTokenAddresses() \u00b6 function getTradeDealTokenAddresses ( uint256 tradeDealId ) external view returns ( address nftAddress , address collateralAddress , address interestAddress , address usdcAddress ) Purpose : Retrieves all token contract addresses associated with a trade deal. Events \u00b6 TradeDealCreated \u00b6 event TradeDealCreated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address nftAddress , address collateralAddress , address interestAddress , address usdcAddress , TradeDealLib . OperationMode operationMode ); Emitted when a new trade deal is created. TradeDealUpdated \u00b6 event TradeDealUpdated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address collateralAddress , address interestAddress , address usdcAddress ); Emitted when a trade deal is updated. TradeDealActivated / TradeDealDeactivated \u00b6 event TradeDealActivated ( uint256 indexed tradeDealId ); event TradeDealDeactivated ( uint256 indexed tradeDealId ); Emitted when trade deals are activated or deactivated. TradeDealRequiredClaimTopicsSet \u00b6 event TradeDealRequiredClaimTopicsSet ( uint256 indexed tradeDealId , uint256 [] claimTopics ); Emitted when required claim topics are set for a trade deal. Integration Examples \u00b6 Create Invoice Financing Deal \u00b6 // Deploy collateral and interest tokens first address collateralToken = deployCollateralToken (); address interestToken = deployInterestToken (); // Create trade deal for invoice financing uint256 tradeDealId = ITradeDeal ( diamond ). createTradeDeal ( \"Q1 2024 Invoice Financing\" , \"Q1IF24\" , 800 , // 8% annual interest rate 120 , // 1.2x collateral ratio [ 1 , 2 ], // KYC and accreditation claims required collateralToken , interestToken , usdcAddress , TradeDealLib . OperationMode . STANDARD ); // Activate the trade deal ITradeDeal ( diamond ). activateTradeDeal ( tradeDealId ); Monitor Trade Deal Status \u00b6 // Get basic trade deal information ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralRatio , bool active , TradeDealLib . OperationMode mode ) = ITradeDeal ( diamond ). getTradeDealInfo ( tradeDealId ); // Get detailed financial status ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = ITradeDeal ( diamond ). getTradeDealFullStatus ( tradeDealId ); console . log ( \"Trade Deal:\" , name ); console . log ( \"Funding Progress:\" , currentBalance , \"/\" , fundingTarget ); console . log ( \"Is Funded:\" , isFunded ); console . log ( \"Total Debt:\" , totalDebt ); console . log ( \"Repaid Amount:\" , repaidAmount ); Update Trade Deal Parameters \u00b6 // Update interest rate and collateral ratio ITradeDeal ( diamond ). updateTradeDeal ( tradeDealId , \"Updated Invoice Financing Deal\" , \"UIFD24\" , 750 , // Reduced to 7.5% interest rate 110 , // Reduced to 1.1x collateral ratio collateralToken , interestToken , usdcAddress ); Security Considerations \u00b6 Access Control \u00b6 All management functions are owner-only Participant verification through identity claims State validation before operations Financial Security \u00b6 Interest rate and ratio validation Funding target verification Debt tracking and repayment monitoring Operational Security \u00b6 Trade deal state management Token address validation Operation mode enforcement Integration with Other Facets \u00b6 TradeDealOperationsFacet \u00b6 Handles funding, withdrawal, and repayment operations Manages participant interactions Processes collateral and interest distributions IdentityRegistryFacet \u00b6 Validates participant eligibility Enforces claim topic requirements Manages access control Token Contracts \u00b6 Collateral token for securing deals Interest token for profit distribution USDC for stable value payments Error Handling \u00b6 Common Errors \u00b6 \"Trade deal does not exist\" - Invalid trade deal ID \"Only owner can perform this action\" - Unauthorized access \"Invalid parameters\" - Parameter validation failure \"Trade deal already active/inactive\" - Invalid state transition Testing Considerations \u00b6 Unit Tests \u00b6 Trade deal creation with various parameters Update operations and validation State transitions (activate/deactivate) Information retrieval accuracy Integration Tests \u00b6 Multi-facet interactions Token contract integration Identity system integration End-to-end trade deal lifecycle Related Documentation \u00b6 TradeDealOperationsFacet - Trade deal operations ITradeDeal - Trade deal interface TradeDealLib - Trade deal utility library EIP-DRAFT-Collateralized-Trade-Deal-Standard - EIP specification This facet provides the foundation for trade deal management in the Gemforce collateralized finance system.","title":"Trade Deal Management Facet"},{"location":"smart-contracts/facets/trade-deal-management-facet/#tradedealmanagementfacet","text":"","title":"TradeDealManagementFacet"},{"location":"smart-contracts/facets/trade-deal-management-facet/#overview","text":"The TradeDealManagementFacet.sol provides comprehensive CRUD (Create, Read, Update, Delete) operations and basic management functionality for trade deals within the Gemforce diamond system. This facet enables the creation and management of collateralized trade deals for invoice financing and other financial instruments.","title":"Overview"},{"location":"smart-contracts/facets/trade-deal-management-facet/#contract-details","text":"Contract Name : TradeDealManagementFacet Inheritance : Modifiers License : MIT Solidity Version : ^0.8.0","title":"Contract Details"},{"location":"smart-contracts/facets/trade-deal-management-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/trade-deal-management-facet/#trade-deal-lifecycle-management","text":"Create new trade deals with configurable parameters Update existing trade deal configurations Activate and deactivate trade deals Comprehensive status tracking","title":"\ud83d\udd39 Trade Deal Lifecycle Management"},{"location":"smart-contracts/facets/trade-deal-management-facet/#multi-token-architecture","text":"NFT collateral support (invoice NFTs) Collateral token management Interest token distribution USDC payment integration","title":"\ud83d\udd39 Multi-Token Architecture"},{"location":"smart-contracts/facets/trade-deal-management-facet/#operation-modes","text":"Flexible operation modes for different financing scenarios Configurable interest rates and collateral ratios Identity-based access control through claim topics","title":"\ud83d\udd39 Operation Modes"},{"location":"smart-contracts/facets/trade-deal-management-facet/#comprehensive-monitoring","text":"Real-time funding status tracking Debt and repayment monitoring Participant verification Financial metrics calculation","title":"\ud83d\udd39 Comprehensive Monitoring"},{"location":"smart-contracts/facets/trade-deal-management-facet/#core-data-structures","text":"","title":"Core Data Structures"},{"location":"smart-contracts/facets/trade-deal-management-facet/#operation-modes_1","text":"enum OperationMode { STANDARD , // Standard trade deal operation ACCELERATED , // Accelerated funding mode CONSERVATIVE , // Conservative risk mode CUSTOM // Custom operation parameters }","title":"Operation Modes"},{"location":"smart-contracts/facets/trade-deal-management-facet/#trade-deal-parameters","text":"struct CreateTradeDealParams { string name ; // Trade deal name string symbol ; // Trade deal symbol uint256 interestRate ; // Interest rate (basis points) uint256 collateralToInterestRatio ; // Collateral to interest ratio uint256 [] requiredClaimTopics ; // Required identity claims address collateralAddress ; // Collateral token contract address interestAddress ; // Interest token contract address usdcAddress ; // USDC payment token OperationMode operationMode ; // Operation mode }","title":"Trade Deal Parameters"},{"location":"smart-contracts/facets/trade-deal-management-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/trade-deal-management-facet/#trade-deal-creation","text":"","title":"Trade Deal Creation"},{"location":"smart-contracts/facets/trade-deal-management-facet/#createtradedeal","text":"function createTradeDeal ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , uint256 [] memory requiredClaimTopics , address collateralAddress , address interestAddress , address usdcAddress , TradeDealLib . OperationMode operationMode ) public onlyOwner returns ( uint256 ) Purpose : Creates a new trade deal with specified parameters and returns the trade deal ID. Parameters : - name : Human-readable name for the trade deal - symbol : Short symbol identifier for the trade deal - interestRate : Interest rate in basis points (e.g., 500 = 5%) - collateralToInterestRatio : Ratio of collateral to interest tokens - requiredClaimTopics : Array of required identity claim topics for participation - collateralAddress : Address of the collateral token contract - interestAddress : Address of the interest token contract - usdcAddress : Address of the USDC token contract for payments - operationMode : Operation mode for the trade deal Access Control : Owner only Returns : uint256 - The newly created trade deal ID Process : 1. Validates all input parameters 2. Creates trade deal using TradeDealLib 3. Emits TradeDealCreated event 4. Sets required claim topics if provided 5. Returns the trade deal ID Events : - TradeDealCreated - Emitted with complete trade deal information - TradeDealRequiredClaimTopicsSet - Emitted if claim topics are set Example Usage : // Create a standard trade deal for invoice financing uint256 tradeDealId = ITradeDeal ( diamond ). createTradeDeal ( \"Invoice Financing Deal #1\" , \"IFD1\" , 750 , // 7.5% interest rate 150 , // 1.5x collateral ratio [ 1 , 2 , 3 ], // Required claim topics collateralTokenAddress , interestTokenAddress , usdcTokenAddress , TradeDealLib . OperationMode . STANDARD );","title":"createTradeDeal()"},{"location":"smart-contracts/facets/trade-deal-management-facet/#trade-deal-updates","text":"","title":"Trade Deal Updates"},{"location":"smart-contracts/facets/trade-deal-management-facet/#updatetradedeal","text":"function updateTradeDeal ( uint256 tradeDealId , string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , address collateralAddress , address interestAddress , address usdcAddress ) external onlyOwner Purpose : Updates an existing trade deal's configuration parameters. Parameters : - tradeDealId : ID of the trade deal to update - name : New name for the trade deal - symbol : New symbol for the trade deal - interestRate : New interest rate in basis points - collateralToInterestRatio : New collateral to interest ratio - collateralAddress : New collateral token address - interestAddress : New interest token address - usdcAddress : New USDC token address Access Control : Owner only Validation : - Trade deal must exist - New parameters must be valid - Cannot update active funded deals Events : TradeDealUpdated - Emitted with updated parameters","title":"updateTradeDeal()"},{"location":"smart-contracts/facets/trade-deal-management-facet/#state-management","text":"","title":"State Management"},{"location":"smart-contracts/facets/trade-deal-management-facet/#activatetradedeal","text":"function activateTradeDeal ( uint256 tradeDealId ) external onlyOwner Purpose : Activates a trade deal, making it available for funding. Parameters : - tradeDealId : ID of the trade deal to activate Access Control : Owner only Events : TradeDealActivated","title":"activateTradeDeal()"},{"location":"smart-contracts/facets/trade-deal-management-facet/#deactivatetradedeal","text":"function deactivateTradeDeal ( uint256 tradeDealId ) external onlyOwner Purpose : Deactivates a trade deal, preventing new funding. Parameters : - tradeDealId : ID of the trade deal to deactivate Access Control : Owner only Events : TradeDealDeactivated","title":"deactivateTradeDeal()"},{"location":"smart-contracts/facets/trade-deal-management-facet/#information-retrieval","text":"","title":"Information Retrieval"},{"location":"smart-contracts/facets/trade-deal-management-facet/#gettradedealinfo","text":"function getTradeDealInfo ( uint256 tradeDealId ) external view returns ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , TradeDealLib . OperationMode operationMode ) Purpose : Retrieves basic information about a trade deal. Parameters : - tradeDealId : ID of the trade deal Returns : Basic trade deal configuration and status","title":"getTradeDealInfo()"},{"location":"smart-contracts/facets/trade-deal-management-facet/#gettradedealfullstatus","text":"function getTradeDealFullStatus ( uint256 tradeDealId ) external view returns ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) Purpose : Retrieves comprehensive financial status of a trade deal. Parameters : - tradeDealId : ID of the trade deal Returns : Complete financial status including funding, debt, and repayment information","title":"getTradeDealFullStatus()"},{"location":"smart-contracts/facets/trade-deal-management-facet/#getalltradedealids","text":"function getAllTradeDealIds () external view returns ( uint256 [] memory ) Purpose : Returns an array of all trade deal IDs in the system. Returns : Array of trade deal IDs","title":"getAllTradeDealIds()"},{"location":"smart-contracts/facets/trade-deal-management-facet/#participant-and-status-checks","text":"","title":"Participant and Status Checks"},{"location":"smart-contracts/facets/trade-deal-management-facet/#istradedealparticipant","text":"function isTradeDealParticipant ( uint256 tradeDealId , address user ) external view returns ( bool ) Purpose : Checks if a user is a participant in a specific trade deal. Parameters : - tradeDealId : ID of the trade deal - user : Address to check Returns : true if user is a participant, false otherwise","title":"isTradeDealParticipant()"},{"location":"smart-contracts/facets/trade-deal-management-facet/#istradedealfunded","text":"function isTradeDealFunded ( uint256 tradeDealId ) external view returns ( bool ) Purpose : Checks if a trade deal has reached its funding target.","title":"isTradeDealFunded()"},{"location":"smart-contracts/facets/trade-deal-management-facet/#istradedealrepaid","text":"function isTradeDealRepaid ( uint256 tradeDealId ) external view returns ( bool ) Purpose : Checks if a trade deal has been fully repaid.","title":"isTradeDealRepaid()"},{"location":"smart-contracts/facets/trade-deal-management-facet/#utility-functions","text":"","title":"Utility Functions"},{"location":"smart-contracts/facets/trade-deal-management-facet/#getnftinvoicetotalamount","text":"function getNFTInvoiceTotalAmount ( uint256 tokenId ) external view returns ( uint256 ) Purpose : Gets the total amount of an invoice NFT used as collateral. Parameters : - tokenId : ID of the invoice NFT Returns : Total invoice amount","title":"getNFTInvoiceTotalAmount()"},{"location":"smart-contracts/facets/trade-deal-management-facet/#gettradedealtokenaddresses","text":"function getTradeDealTokenAddresses ( uint256 tradeDealId ) external view returns ( address nftAddress , address collateralAddress , address interestAddress , address usdcAddress ) Purpose : Retrieves all token contract addresses associated with a trade deal.","title":"getTradeDealTokenAddresses()"},{"location":"smart-contracts/facets/trade-deal-management-facet/#events","text":"","title":"Events"},{"location":"smart-contracts/facets/trade-deal-management-facet/#tradedealcreated","text":"event TradeDealCreated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address nftAddress , address collateralAddress , address interestAddress , address usdcAddress , TradeDealLib . OperationMode operationMode ); Emitted when a new trade deal is created.","title":"TradeDealCreated"},{"location":"smart-contracts/facets/trade-deal-management-facet/#tradedealupdated","text":"event TradeDealUpdated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address collateralAddress , address interestAddress , address usdcAddress ); Emitted when a trade deal is updated.","title":"TradeDealUpdated"},{"location":"smart-contracts/facets/trade-deal-management-facet/#tradedealactivated-tradedealdeactivated","text":"event TradeDealActivated ( uint256 indexed tradeDealId ); event TradeDealDeactivated ( uint256 indexed tradeDealId ); Emitted when trade deals are activated or deactivated.","title":"TradeDealActivated / TradeDealDeactivated"},{"location":"smart-contracts/facets/trade-deal-management-facet/#tradedealrequiredclaimtopicsset","text":"event TradeDealRequiredClaimTopicsSet ( uint256 indexed tradeDealId , uint256 [] claimTopics ); Emitted when required claim topics are set for a trade deal.","title":"TradeDealRequiredClaimTopicsSet"},{"location":"smart-contracts/facets/trade-deal-management-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/facets/trade-deal-management-facet/#create-invoice-financing-deal","text":"// Deploy collateral and interest tokens first address collateralToken = deployCollateralToken (); address interestToken = deployInterestToken (); // Create trade deal for invoice financing uint256 tradeDealId = ITradeDeal ( diamond ). createTradeDeal ( \"Q1 2024 Invoice Financing\" , \"Q1IF24\" , 800 , // 8% annual interest rate 120 , // 1.2x collateral ratio [ 1 , 2 ], // KYC and accreditation claims required collateralToken , interestToken , usdcAddress , TradeDealLib . OperationMode . STANDARD ); // Activate the trade deal ITradeDeal ( diamond ). activateTradeDeal ( tradeDealId );","title":"Create Invoice Financing Deal"},{"location":"smart-contracts/facets/trade-deal-management-facet/#monitor-trade-deal-status","text":"// Get basic trade deal information ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralRatio , bool active , TradeDealLib . OperationMode mode ) = ITradeDeal ( diamond ). getTradeDealInfo ( tradeDealId ); // Get detailed financial status ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = ITradeDeal ( diamond ). getTradeDealFullStatus ( tradeDealId ); console . log ( \"Trade Deal:\" , name ); console . log ( \"Funding Progress:\" , currentBalance , \"/\" , fundingTarget ); console . log ( \"Is Funded:\" , isFunded ); console . log ( \"Total Debt:\" , totalDebt ); console . log ( \"Repaid Amount:\" , repaidAmount );","title":"Monitor Trade Deal Status"},{"location":"smart-contracts/facets/trade-deal-management-facet/#update-trade-deal-parameters","text":"// Update interest rate and collateral ratio ITradeDeal ( diamond ). updateTradeDeal ( tradeDealId , \"Updated Invoice Financing Deal\" , \"UIFD24\" , 750 , // Reduced to 7.5% interest rate 110 , // Reduced to 1.1x collateral ratio collateralToken , interestToken , usdcAddress );","title":"Update Trade Deal Parameters"},{"location":"smart-contracts/facets/trade-deal-management-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/trade-deal-management-facet/#access-control","text":"All management functions are owner-only Participant verification through identity claims State validation before operations","title":"Access Control"},{"location":"smart-contracts/facets/trade-deal-management-facet/#financial-security","text":"Interest rate and ratio validation Funding target verification Debt tracking and repayment monitoring","title":"Financial Security"},{"location":"smart-contracts/facets/trade-deal-management-facet/#operational-security","text":"Trade deal state management Token address validation Operation mode enforcement","title":"Operational Security"},{"location":"smart-contracts/facets/trade-deal-management-facet/#integration-with-other-facets","text":"","title":"Integration with Other Facets"},{"location":"smart-contracts/facets/trade-deal-management-facet/#tradedealoperationsfacet","text":"Handles funding, withdrawal, and repayment operations Manages participant interactions Processes collateral and interest distributions","title":"TradeDealOperationsFacet"},{"location":"smart-contracts/facets/trade-deal-management-facet/#identityregistryfacet","text":"Validates participant eligibility Enforces claim topic requirements Manages access control","title":"IdentityRegistryFacet"},{"location":"smart-contracts/facets/trade-deal-management-facet/#token-contracts","text":"Collateral token for securing deals Interest token for profit distribution USDC for stable value payments","title":"Token Contracts"},{"location":"smart-contracts/facets/trade-deal-management-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/trade-deal-management-facet/#common-errors","text":"\"Trade deal does not exist\" - Invalid trade deal ID \"Only owner can perform this action\" - Unauthorized access \"Invalid parameters\" - Parameter validation failure \"Trade deal already active/inactive\" - Invalid state transition","title":"Common Errors"},{"location":"smart-contracts/facets/trade-deal-management-facet/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/facets/trade-deal-management-facet/#unit-tests","text":"Trade deal creation with various parameters Update operations and validation State transitions (activate/deactivate) Information retrieval accuracy","title":"Unit Tests"},{"location":"smart-contracts/facets/trade-deal-management-facet/#integration-tests","text":"Multi-facet interactions Token contract integration Identity system integration End-to-end trade deal lifecycle","title":"Integration Tests"},{"location":"smart-contracts/facets/trade-deal-management-facet/#related-documentation","text":"TradeDealOperationsFacet - Trade deal operations ITradeDeal - Trade deal interface TradeDealLib - Trade deal utility library EIP-DRAFT-Collateralized-Trade-Deal-Standard - EIP specification This facet provides the foundation for trade deal management in the Gemforce collateralized finance system.","title":"Related Documentation"},{"location":"smart-contracts/facets/trade-deal-operations-facet/","text":"TradeDealOperationsFacet \u00b6 Overview \u00b6 The TradeDealOperationsFacet.sol provides core operational functionality for trade deals within the Gemforce diamond system. This facet handles the essential operations including invoice deposits/withdrawals, USDC funding, collateral management, repayments, and redemptions that form the backbone of the trade deal lifecycle. Contract Details \u00b6 Contract Name : TradeDealOperationsFacet Inheritance : Modifiers License : MIT Solidity Version : ^0.8.0 Key Features \u00b6 \ud83d\udd39 Invoice Management \u00b6 Deposit invoices as collateral backing Withdraw invoices from trade deals Participant validation for invoice operations Invoice ownership and transfer tracking \ud83d\udd39 USDC Funding Operations \u00b6 Deposit USDC to fund trade deals Withdraw USDC with proper authorization Automatic collateral token distribution Funding target tracking and completion \ud83d\udd39 Funding Withdrawal System \u00b6 Borrower funding withdrawal (admin-controlled) Self-service funding withdrawal Validation and authorization checks Funding distribution tracking \ud83d\udd39 Repayment Processing \u00b6 Trade deal repayment by borrowers Admin-assisted repayment processing Partial and full repayment support Repayment validation and tracking \ud83d\udd39 Collateral Redemption \u00b6 Redeem collateral tokens for USDC Proportional redemption calculations Participant validation for redemptions Collateral-to-USDC conversion tracking Core Functions \u00b6 Invoice Management Functions \u00b6 tdDepositInvoice() \u00b6 function tdDepositInvoice ( uint256 tradeDealId , uint256 tokenId ) external Purpose : Deposits an invoice NFT as collateral backing for a trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal - tokenId (uint256): ID of the invoice NFT to deposit Access Control : Public (with validation) Process : 1. Validates invoice deposit eligibility and ownership 2. Transfers invoice NFT to trade deal contract 3. Updates trade deal collateral backing 4. Records invoice in trade deal storage 5. Emits InvoiceDepositedToTradeDeal event Events : InvoiceDepositedToTradeDeal(tradeDealId, tokenId) Example Usage : // Deposit invoice as collateral for trade deal uint256 tradeDealId = 1 ; uint256 invoiceTokenId = 123 ; // First approve the diamond to transfer the invoice IERC721 ( invoiceContract ). approve ( diamond , invoiceTokenId ); // Deposit the invoice ITradeDealOperations ( diamond ). tdDepositInvoice ( tradeDealId , invoiceTokenId ); console . log ( \"Invoice\" , invoiceTokenId , \"deposited to trade deal\" , tradeDealId ); Requirements : - Caller must own the invoice NFT - Invoice must be eligible for the trade deal - Trade deal must be active and accepting deposits - Invoice must not already be deposited tdWithdrawInvoice() \u00b6 function tdWithdrawInvoice ( uint256 tradeDealId , uint256 tokenId ) external Purpose : Withdraws an invoice NFT from a trade deal back to the participant. Parameters : - tradeDealId (uint256): ID of the trade deal - tokenId (uint256): ID of the invoice NFT to withdraw Access Control : Trade deal participants only Process : 1. Validates caller is a trade deal participant 2. Confirms invoice is deposited in the trade deal 3. Checks withdrawal eligibility (no outstanding obligations) 4. Transfers invoice NFT back to participant 5. Updates trade deal collateral records 6. Emits InvoiceWithdrawnFromTradeDeal event Events : InvoiceWithdrawnFromTradeDeal(tradeDealId, tokenId) Example Usage : // Withdraw invoice from trade deal uint256 tradeDealId = 1 ; uint256 invoiceTokenId = 123 ; ITradeDealOperations ( diamond ). tdWithdrawInvoice ( tradeDealId , invoiceTokenId ); console . log ( \"Invoice\" , invoiceTokenId , \"withdrawn from trade deal\" , tradeDealId ); Requirements : - Caller must be a trade deal participant - Invoice must be deposited in the trade deal - No outstanding obligations against the invoice - Trade deal must allow withdrawals USDC Funding Functions \u00b6 tdDepositUSDC() \u00b6 function tdDepositUSDC ( uint256 tradeDealId , uint256 amount ) external Purpose : Deposits USDC to fund a trade deal and receives collateral tokens in return. Parameters : - tradeDealId (uint256): ID of the trade deal to fund - amount (uint256): Amount of USDC to deposit Access Control : Public (with validation) Process : 1. Validates trade deal is active and accepting funding 2. Transfers USDC from depositor to trade deal 3. Calculates and mints collateral tokens for depositor 4. Updates trade deal funding status 5. Checks if trade deal is fully funded 6. Emits multiple events for tracking Events : - USDCDepositedToTradeDeal(tradeDealId, amount, depositor) - CollateralTokensDistributed(tradeDealId, recipient, amount) - TradeDealFullyFunded(tradeDealId, fundingTarget) (if applicable) Example Usage : // Fund trade deal with USDC uint256 tradeDealId = 1 ; uint256 fundingAmount = 10000 * 10 ** 6 ; // 10,000 USDC // First approve USDC transfer IERC20 ( usdcToken ). approve ( diamond , fundingAmount ); // Deposit USDC and receive collateral tokens ITradeDealOperations ( diamond ). tdDepositUSDC ( tradeDealId , fundingAmount ); console . log ( \"Deposited\" , fundingAmount , \"USDC to trade deal\" , tradeDealId ); Collateral Token Calculation : - Collateral tokens are minted based on the collateral-to-interest ratio - Tokens represent proportional ownership in the trade deal - Used for interest distribution and redemption rights tdWithdrawUSDC() \u00b6 function tdWithdrawUSDC ( uint256 tradeDealId , uint256 amount ) external onlyOwner Purpose : Withdraws USDC from a trade deal (admin function). Parameters : - tradeDealId (uint256): ID of the trade deal - amount (uint256): Amount of USDC to withdraw Access Control : Owner only Process : 1. Validates withdrawal amount and availability 2. Transfers USDC from trade deal to owner 3. Updates trade deal funding records 4. Emits USDCWithdrawnFromTradeDeal event Events : USDCWithdrawnFromTradeDeal(tradeDealId, amount) Example Usage : // Admin withdrawal of excess USDC uint256 tradeDealId = 1 ; uint256 withdrawAmount = 5000 * 10 ** 6 ; // 5,000 USDC ITradeDealOperations ( diamond ). tdWithdrawUSDC ( tradeDealId , withdrawAmount ); console . log ( \"Withdrew\" , withdrawAmount , \"USDC from trade deal\" , tradeDealId ); Funding Withdrawal Functions \u00b6 withdrawTradeDealFundingForBorrower() \u00b6 function withdrawTradeDealFundingForBorrower ( uint256 tradeDealId , address borrowerAddress ) external onlyOwner Purpose : Allows admin to withdraw funding on behalf of a borrower. Parameters : - tradeDealId (uint256): ID of the trade deal - borrowerAddress (address): Address of the borrower receiving funds Access Control : Owner only Process : 1. Validates funding withdrawal eligibility 2. Confirms trade deal is fully funded 3. Transfers available funding to borrower 4. Updates trade deal status and records 5. Emits TradeDealFundingWithdrawn event Events : TradeDealFundingWithdrawn(tradeDealId, recipient, amount) Example Usage : // Admin withdraws funding for borrower uint256 tradeDealId = 1 ; address borrower = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; ITradeDealOperations ( diamond ). withdrawTradeDealFundingForBorrower ( tradeDealId , borrower ); console . log ( \"Funding withdrawn for borrower:\" , borrower ); withdrawTradeDealFundingSelf() \u00b6 function withdrawTradeDealFundingSelf ( uint256 tradeDealId ) external Purpose : Allows eligible borrowers to withdraw funding themselves. Parameters : - tradeDealId (uint256): ID of the trade deal Access Control : Validated borrowers only Process : 1. Validates caller is authorized borrower for the trade deal 2. Confirms self-service withdrawal is enabled 3. Checks trade deal funding status and eligibility 4. Transfers available funding to caller 5. Updates trade deal records 6. Emits TradeDealFundingWithdrawn event Events : TradeDealFundingWithdrawn(tradeDealId, recipient, amount) Example Usage : // Borrower withdraws funding themselves uint256 tradeDealId = 1 ; ITradeDealOperations ( diamond ). withdrawTradeDealFundingSelf ( tradeDealId ); console . log ( \"Self-service funding withdrawal completed\" ); Requirements : - Caller must be authorized borrower - Trade deal must be fully funded - Self-service withdrawal must be enabled - No outstanding compliance issues Repayment Functions \u00b6 repayTradeDeal() \u00b6 function repayTradeDeal ( uint256 tradeDealId , uint256 amount ) external Purpose : Allows borrowers to repay trade deal obligations. Parameters : - tradeDealId (uint256): ID of the trade deal - amount (uint256): Amount to repay (in USDC) Access Control : Authorized repayers only Process : 1. Validates repayment parameters and authorization 2. Transfers repayment amount from caller 3. Updates trade deal outstanding balance 4. Calculates interest and principal allocation 5. Updates repayment tracking and status 6. Emits TradeDealRepaid event Events : TradeDealRepaid(tradeDealId, repayer, amount, fullyRepaid) Example Usage : // Borrower makes partial repayment uint256 tradeDealId = 1 ; uint256 repaymentAmount = 5000 * 10 ** 6 ; // 5,000 USDC // First approve USDC transfer IERC20 ( usdcToken ). approve ( diamond , repaymentAmount ); // Make repayment ITradeDealOperations ( diamond ). repayTradeDeal ( tradeDealId , repaymentAmount ); console . log ( \"Repaid\" , repaymentAmount , \"to trade deal\" , tradeDealId ); Repayment Allocation : - Interest payments processed first - Principal reduction after interest - Full repayment triggers completion status - Partial repayments update outstanding balance repayTradeDealForBorrower() \u00b6 function repayTradeDealForBorrower ( uint256 tradeDealId , address borrower , uint256 amount ) external onlyOwner Purpose : Allows admin to make repayments on behalf of borrowers. Parameters : - tradeDealId (uint256): ID of the trade deal - borrower (address): Address of the borrower - amount (uint256): Amount to repay Access Control : Owner only Process : 1. Validates repayment parameters 2. Processes repayment on behalf of borrower 3. Updates trade deal records and status 4. Handles interest and principal allocation 5. Emits TradeDealRepaid event Events : TradeDealRepaid(tradeDealId, repayer, amount, fullyRepaid) Example Usage : // Admin makes repayment for borrower uint256 tradeDealId = 1 ; address borrower = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; uint256 repaymentAmount = 10000 * 10 ** 6 ; // 10,000 USDC ITradeDealOperations ( diamond ). repayTradeDealForBorrower ( tradeDealId , borrower , repaymentAmount ); console . log ( \"Admin repayment made for borrower:\" , borrower ); Collateral Redemption Functions \u00b6 redeemCollateralTokens() \u00b6 function redeemCollateralTokens ( uint256 tradeDealId , uint256 collateralAmount ) external Purpose : Allows collateral token holders to redeem tokens for USDC. Parameters : - tradeDealId (uint256): ID of the trade deal - collateralAmount (uint256): Amount of collateral tokens to redeem Access Control : Collateral token holders only Process : 1. Validates collateral redemption eligibility 2. Calculates USDC amount based on current redemption rate 3. Burns collateral tokens from caller 4. Transfers proportional USDC to caller 5. Updates trade deal collateral tracking 6. Emits CollateralTokensRedeemed event Events : CollateralTokensRedeemed(tradeDealId, redeemer, collateralAmount, usdcAmount) Example Usage : // Redeem collateral tokens for USDC uint256 tradeDealId = 1 ; uint256 collateralToRedeem = 1000 * 10 ** 18 ; // 1,000 collateral tokens ITradeDealOperations ( diamond ). redeemCollateralTokens ( tradeDealId , collateralToRedeem ); console . log ( \"Redeemed\" , collateralToRedeem , \"collateral tokens\" ); Redemption Calculation : - USDC amount = (collateral tokens \u00d7 current USDC pool) \u00f7 total collateral tokens - Redemption rate varies based on trade deal performance - Interest distributions affect redemption value - Early redemption may have different rates than maturity Integration Examples \u00b6 Complete Trade Deal Lifecycle \u00b6 // Comprehensive trade deal operations workflow contract TradeDealWorkflow { struct TradeDealState { uint256 tradeDealId ; uint256 fundingTarget ; uint256 currentFunding ; uint256 outstandingBalance ; bool fullyFunded ; bool repaid ; } mapping ( uint256 => TradeDealState ) public tradeDealStates ; function participateInTradeDeal ( uint256 tradeDealId , uint256 usdcAmount , uint256 [] memory invoiceTokenIds ) external { // Deposit invoices as collateral for ( uint256 i = 0 ; i < invoiceTokenIds . length ; i ++ ) { ITradeDealOperations ( diamond ). tdDepositInvoice ( tradeDealId , invoiceTokenIds [ i ]); } // Fund with USDC ITradeDealOperations ( diamond ). tdDepositUSDC ( tradeDealId , usdcAmount ); // Update state tracking TradeDealState storage state = tradeDealStates [ tradeDealId ]; state . currentFunding += usdcAmount ; emit ParticipationCompleted ( tradeDealId , msg.sender , usdcAmount , invoiceTokenIds ); } function borrowerWithdrawFunding ( uint256 tradeDealId ) external { require ( tradeDealStates [ tradeDealId ]. fullyFunded , \"Not fully funded\" ); // Borrower withdraws funding ITradeDealOperations ( diamond ). withdrawTradeDealFundingSelf ( tradeDealId ); // Update state tradeDealStates [ tradeDealId ]. outstandingBalance = tradeDealStates [ tradeDealId ]. currentFunding ; emit FundingWithdrawn ( tradeDealId , msg.sender ); } function makeRepayment ( uint256 tradeDealId , uint256 amount ) external { // Make repayment ITradeDealOperations ( diamond ). repayTradeDeal ( tradeDealId , amount ); // Update state TradeDealState storage state = tradeDealStates [ tradeDealId ]; if ( amount >= state . outstandingBalance ) { state . repaid = true ; state . outstandingBalance = 0 ; } else { state . outstandingBalance -= amount ; } emit RepaymentMade ( tradeDealId , msg.sender , amount ); } function redeemInvestment ( uint256 tradeDealId , uint256 collateralAmount ) external { require ( tradeDealStates [ tradeDealId ]. repaid , \"Trade deal not repaid\" ); // Redeem collateral tokens ITradeDealOperations ( diamond ). redeemCollateralTokens ( tradeDealId , collateralAmount ); emit InvestmentRedeemed ( tradeDealId , msg.sender , collateralAmount ); } } Automated Repayment System \u00b6 // Automated repayment scheduling and processing contract AutomatedRepaymentSystem { struct RepaymentSchedule { uint256 tradeDealId ; uint256 totalAmount ; uint256 installmentAmount ; uint256 frequency ; // in seconds uint256 nextPaymentDue ; uint256 remainingPayments ; bool active ; } mapping ( uint256 => RepaymentSchedule ) public repaymentSchedules ; mapping ( address => uint256 []) public borrowerTradeDealIds ; function setupRepaymentSchedule ( uint256 tradeDealId , uint256 totalAmount , uint256 numberOfPayments , uint256 frequency ) external onlyAuthorizedBorrower ( tradeDealId ) { uint256 installmentAmount = totalAmount / numberOfPayments ; repaymentSchedules [ tradeDealId ] = RepaymentSchedule ({ tradeDealId : tradeDealId , totalAmount : totalAmount , installmentAmount : installmentAmount , frequency : frequency , nextPaymentDue : block.timestamp + frequency , remainingPayments : numberOfPayments , active : true }); borrowerTradeDealIds [ msg.sender ]. push ( tradeDealId ); emit RepaymentScheduleCreated ( tradeDealId , totalAmount , numberOfPayments , frequency ); } function executeScheduledRepayment ( uint256 tradeDealId ) external { RepaymentSchedule storage schedule = repaymentSchedules [ tradeDealId ]; require ( schedule . active , \"Schedule not active\" ); require ( block.timestamp >= schedule . nextPaymentDue , \"Payment not due yet\" ); require ( schedule . remainingPayments > 0 , \"All payments completed\" ); // Execute repayment ITradeDealOperations ( diamond ). repayTradeDeal ( tradeDealId , schedule . installmentAmount ); // Update schedule schedule . remainingPayments -- ; if ( schedule . remainingPayments > 0 ) { schedule . nextPaymentDue += schedule . frequency ; } else { schedule . active = false ; } emit ScheduledRepaymentExecuted ( tradeDealId , schedule . installmentAmount , schedule . remainingPayments ); } function getOverduePayments ( address borrower ) external view returns ( uint256 [] memory ) { uint256 [] memory tradeDealIds = borrowerTradeDealIds [ borrower ]; uint256 [] memory overdueIds = new uint256 []( tradeDealIds . length ); uint256 overdueCount = 0 ; for ( uint256 i = 0 ; i < tradeDealIds . length ; i ++ ) { RepaymentSchedule memory schedule = repaymentSchedules [ tradeDealIds [ i ]]; if ( schedule . active && block.timestamp > schedule . nextPaymentDue ) { overdueIds [ overdueCount ] = tradeDealIds [ i ]; overdueCount ++ ; } } // Resize array to actual count uint256 [] memory result = new uint256 []( overdueCount ); for ( uint256 i = 0 ; i < overdueCount ; i ++ ) { result [ i ] = overdueIds [ i ]; } return result ; } } Collateral Management System \u00b6 // Advanced collateral tracking and management contract CollateralManagementSystem { struct CollateralPosition { uint256 tradeDealId ; uint256 collateralTokens ; uint256 originalUSDCDeposit ; uint256 accruedInterest ; uint256 lastInterestUpdate ; } mapping ( address => mapping ( uint256 => CollateralPosition )) public positions ; mapping ( uint256 => uint256 ) public totalCollateralTokens ; mapping ( uint256 => uint256 ) public totalUSDCPool ; function trackCollateralDeposit ( uint256 tradeDealId , address depositor , uint256 usdcAmount , uint256 collateralTokens ) external onlyAuthorized { CollateralPosition storage position = positions [ depositor ][ tradeDealId ]; position . tradeDealId = tradeDealId ; position . collateralTokens += collateralTokens ; position . originalUSDCDeposit += usdcAmount ; position . lastInterestUpdate = block.timestamp ; totalCollateralTokens [ tradeDealId ] += collateralTokens ; totalUSDCPool [ tradeDealId ] += usdcAmount ; emit CollateralPositionUpdated ( depositor , tradeDealId , position ); } function calculateRedemptionValue ( address holder , uint256 tradeDealId , uint256 collateralAmount ) external view returns ( uint256 usdcAmount , uint256 interestAmount ) { CollateralPosition memory position = positions [ holder ][ tradeDealId ]; require ( position . collateralTokens >= collateralAmount , \"Insufficient collateral\" ); // Calculate proportional USDC uint256 totalCollateral = totalCollateralTokens [ tradeDealId ]; uint256 totalUSDC = totalUSDCPool [ tradeDealId ]; usdcAmount = ( collateralAmount * totalUSDC ) / totalCollateral ; // Calculate accrued interest uint256 proportionalInterest = ( position . accruedInterest * collateralAmount ) / position . collateralTokens ; interestAmount = proportionalInterest ; } function executeRedemption ( uint256 tradeDealId , uint256 collateralAmount ) external { ( uint256 usdcAmount , uint256 interestAmount ) = calculateRedemptionValue ( msg.sender , tradeDealId , collateralAmount ); // Execute redemption through operations facet ITradeDealOperations ( diamond ). redeemCollateralTokens ( tradeDealId , collateralAmount ); // Update position tracking CollateralPosition storage position = positions [ msg.sender ][ tradeDealId ]; position . collateralTokens -= collateralAmount ; position . accruedInterest -= interestAmount ; totalCollateralTokens [ tradeDealId ] -= collateralAmount ; totalUSDCPool [ tradeDealId ] -= usdcAmount ; emit RedemptionExecuted ( msg.sender , tradeDealId , collateralAmount , usdcAmount , interestAmount ); } function getPositionSummary ( address holder , uint256 tradeDealId ) external view returns ( uint256 collateralTokens , uint256 currentValue , uint256 originalDeposit , uint256 totalReturn , uint256 returnPercentage ) { CollateralPosition memory position = positions [ holder ][ tradeDealId ]; collateralTokens = position . collateralTokens ; originalDeposit = position . originalUSDCDeposit ; if ( collateralTokens > 0 ) { ( currentValue ,) = calculateRedemptionValue ( holder , tradeDealId , collateralTokens ); totalReturn = currentValue > originalDeposit ? currentValue - originalDeposit : 0 ; returnPercentage = originalDeposit > 0 ? ( totalReturn * 10000 ) / originalDeposit : 0 ; // basis points } } } Invoice Collateral Tracker \u00b6 // Track invoice collateral deposits and withdrawals contract InvoiceCollateralTracker { struct InvoiceCollateral { uint256 tokenId ; uint256 tradeDealId ; address depositor ; uint256 depositTime ; uint256 invoiceValue ; bool active ; } mapping ( uint256 => InvoiceCollateral ) public invoiceCollaterals ; mapping ( uint256 => uint256 []) public tradeDealInvoices ; mapping ( address => uint256 []) public depositorInvoices ; function trackInvoiceDeposit ( uint256 tokenId , uint256 tradeDealId , address depositor , uint256 invoiceValue ) external onlyAuthorized { invoiceCollaterals [ tokenId ] = InvoiceCollateral ({ tokenId : tokenId , tradeDealId : tradeDealId , depositor : depositor , depositTime : block.timestamp , invoiceValue : invoiceValue , active : true }); tradeDealInvoices [ tradeDealId ]. push ( tokenId ); depositorInvoices [ depositor ]. push ( tokenId ); emit InvoiceCollateralTracked ( tokenId , tradeDealId , depositor , invoiceValue ); } function executeInvoiceDeposit ( uint256 tradeDealId , uint256 tokenId , uint256 invoiceValue ) external { // Execute deposit through operations facet ITradeDealOperations ( diamond ). tdDepositInvoice ( tradeDealId , tokenId ); // Track the deposit trackInvoiceDeposit ( tokenId , tradeDealId , msg.sender , invoiceValue ); } function executeInvoiceWithdrawal ( uint256 tradeDealId , uint256 tokenId ) external { require ( invoiceCollaterals [ tokenId ]. depositor == msg.sender , \"Not depositor\" ); require ( invoiceCollaterals [ tokenId ]. active , \"Invoice not active\" ); // Execute withdrawal through operations facet ITradeDealOperations ( diamond ). tdWithdrawInvoice ( tradeDealId , tokenId ); // Update tracking invoiceCollaterals [ tokenId ]. active = false ; emit InvoiceWithdrawn ( tokenId , tradeDealId , msg.sender ); } function getTradeDealCollateralValue ( uint256 tradeDealId ) external view returns ( uint256 totalValue ) { uint256 [] memory invoiceIds = tradeDealInvoices [ tradeDealId ]; for ( uint256 i = 0 ; i < invoiceIds . length ; i ++ ) { InvoiceCollateral memory collateral = invoiceCollaterals [ invoiceIds [ i ]]; if ( collateral . active ) { totalValue += collateral . invoiceValue ; } } } function getDepositorCollateral ( address depositor ) external view returns ( uint256 [] memory tokenIds , uint256 [] memory tradeDealIds , uint256 [] memory values , bool [] memory activeStatus ) { uint256 [] memory depositorTokenIds = depositorInvoices [ depositor ]; tokenIds = new uint256 []( depositorTokenIds . length ); tradeDealIds = new uint256 []( depositorTokenIds . length ); values = new uint256 []( depositorTokenIds . length ); activeStatus = new bool []( depositorTokenIds . length ); for ( uint256 i = 0 ; i < depositorTokenIds . length ; i ++ ) { InvoiceCollateral memory collateral = invoiceCollaterals [ depositorTokenIds [ i ]]; tokenIds [ i ] = collateral . tokenId ; tradeDealIds [ i ] = collateral . tradeDealId ; values [ i ] = collateral . invoiceValue ; activeStatus [ i ] = collateral . active ; } } } Events \u00b6 Invoice Management Events \u00b6 event InvoiceDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event InvoiceWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); USDC Funding Events \u00b6 event USDCDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 amount , address depositor ); event USDCWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 amount ); event TradeDealFullyFunded ( uint256 indexed tradeDealId , uint256 fundingTarget ); event CollateralTokensDistributed ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount ); Funding Withdrawal Events \u00b6 event TradeDealFundingWithdrawn ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount ); Repayment Events \u00b6 event TradeDealRepaid ( uint256 indexed tradeDealId , address indexed repayer , uint256 amount , bool fullyRepaid ); Redemption Events \u00b6 event CollateralTokensRedeemed ( uint256 indexed tradeDealId , address indexed redeemer , uint256 collateralAmount , uint256 usdcAmount ); Security Considerations \u00b6 Access Control \u00b6 Participant validation for invoice operations Owner-only functions for admin operations Borrower authorization for funding withdrawals Collateral token holder validation for redemptions Financial Security \u00b6 Precise amount calculations and validations Overflow protection for large transactions Token transfer authorization checks Balance verification before operations Operational Security \u00b6 Trade deal state validation before operations Invoice ownership verification Funding availability checks Repayment authorization validation Gas Optimization \u00b6 Efficient Operations \u00b6 Batch invoice deposits when possible Optimize token transfer operations Minimize storage updates Use events for off-chain tracking Storage Optimization \u00b6 Pack related data efficiently Use mappings for participant tracking Cache frequently accessed values Optimize collateral calculations Error Handling \u00b6 Common Errors \u00b6 Insufficient balances or allowances Invalid trade deal states Unauthorized operations Invoice ownership mismatches Funding availability issues Best Practices \u00b6 Validate all inputs before processing Check authorization before","title":"Trade Deal Operations Facet"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#tradedealoperationsfacet","text":"","title":"TradeDealOperationsFacet"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#overview","text":"The TradeDealOperationsFacet.sol provides core operational functionality for trade deals within the Gemforce diamond system. This facet handles the essential operations including invoice deposits/withdrawals, USDC funding, collateral management, repayments, and redemptions that form the backbone of the trade deal lifecycle.","title":"Overview"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#contract-details","text":"Contract Name : TradeDealOperationsFacet Inheritance : Modifiers License : MIT Solidity Version : ^0.8.0","title":"Contract Details"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#invoice-management","text":"Deposit invoices as collateral backing Withdraw invoices from trade deals Participant validation for invoice operations Invoice ownership and transfer tracking","title":"\ud83d\udd39 Invoice Management"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#usdc-funding-operations","text":"Deposit USDC to fund trade deals Withdraw USDC with proper authorization Automatic collateral token distribution Funding target tracking and completion","title":"\ud83d\udd39 USDC Funding Operations"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#funding-withdrawal-system","text":"Borrower funding withdrawal (admin-controlled) Self-service funding withdrawal Validation and authorization checks Funding distribution tracking","title":"\ud83d\udd39 Funding Withdrawal System"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#repayment-processing","text":"Trade deal repayment by borrowers Admin-assisted repayment processing Partial and full repayment support Repayment validation and tracking","title":"\ud83d\udd39 Repayment Processing"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#collateral-redemption","text":"Redeem collateral tokens for USDC Proportional redemption calculations Participant validation for redemptions Collateral-to-USDC conversion tracking","title":"\ud83d\udd39 Collateral Redemption"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#invoice-management-functions","text":"","title":"Invoice Management Functions"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#tddepositinvoice","text":"function tdDepositInvoice ( uint256 tradeDealId , uint256 tokenId ) external Purpose : Deposits an invoice NFT as collateral backing for a trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal - tokenId (uint256): ID of the invoice NFT to deposit Access Control : Public (with validation) Process : 1. Validates invoice deposit eligibility and ownership 2. Transfers invoice NFT to trade deal contract 3. Updates trade deal collateral backing 4. Records invoice in trade deal storage 5. Emits InvoiceDepositedToTradeDeal event Events : InvoiceDepositedToTradeDeal(tradeDealId, tokenId) Example Usage : // Deposit invoice as collateral for trade deal uint256 tradeDealId = 1 ; uint256 invoiceTokenId = 123 ; // First approve the diamond to transfer the invoice IERC721 ( invoiceContract ). approve ( diamond , invoiceTokenId ); // Deposit the invoice ITradeDealOperations ( diamond ). tdDepositInvoice ( tradeDealId , invoiceTokenId ); console . log ( \"Invoice\" , invoiceTokenId , \"deposited to trade deal\" , tradeDealId ); Requirements : - Caller must own the invoice NFT - Invoice must be eligible for the trade deal - Trade deal must be active and accepting deposits - Invoice must not already be deposited","title":"tdDepositInvoice()"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#tdwithdrawinvoice","text":"function tdWithdrawInvoice ( uint256 tradeDealId , uint256 tokenId ) external Purpose : Withdraws an invoice NFT from a trade deal back to the participant. Parameters : - tradeDealId (uint256): ID of the trade deal - tokenId (uint256): ID of the invoice NFT to withdraw Access Control : Trade deal participants only Process : 1. Validates caller is a trade deal participant 2. Confirms invoice is deposited in the trade deal 3. Checks withdrawal eligibility (no outstanding obligations) 4. Transfers invoice NFT back to participant 5. Updates trade deal collateral records 6. Emits InvoiceWithdrawnFromTradeDeal event Events : InvoiceWithdrawnFromTradeDeal(tradeDealId, tokenId) Example Usage : // Withdraw invoice from trade deal uint256 tradeDealId = 1 ; uint256 invoiceTokenId = 123 ; ITradeDealOperations ( diamond ). tdWithdrawInvoice ( tradeDealId , invoiceTokenId ); console . log ( \"Invoice\" , invoiceTokenId , \"withdrawn from trade deal\" , tradeDealId ); Requirements : - Caller must be a trade deal participant - Invoice must be deposited in the trade deal - No outstanding obligations against the invoice - Trade deal must allow withdrawals","title":"tdWithdrawInvoice()"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#usdc-funding-functions","text":"","title":"USDC Funding Functions"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#tddepositusdc","text":"function tdDepositUSDC ( uint256 tradeDealId , uint256 amount ) external Purpose : Deposits USDC to fund a trade deal and receives collateral tokens in return. Parameters : - tradeDealId (uint256): ID of the trade deal to fund - amount (uint256): Amount of USDC to deposit Access Control : Public (with validation) Process : 1. Validates trade deal is active and accepting funding 2. Transfers USDC from depositor to trade deal 3. Calculates and mints collateral tokens for depositor 4. Updates trade deal funding status 5. Checks if trade deal is fully funded 6. Emits multiple events for tracking Events : - USDCDepositedToTradeDeal(tradeDealId, amount, depositor) - CollateralTokensDistributed(tradeDealId, recipient, amount) - TradeDealFullyFunded(tradeDealId, fundingTarget) (if applicable) Example Usage : // Fund trade deal with USDC uint256 tradeDealId = 1 ; uint256 fundingAmount = 10000 * 10 ** 6 ; // 10,000 USDC // First approve USDC transfer IERC20 ( usdcToken ). approve ( diamond , fundingAmount ); // Deposit USDC and receive collateral tokens ITradeDealOperations ( diamond ). tdDepositUSDC ( tradeDealId , fundingAmount ); console . log ( \"Deposited\" , fundingAmount , \"USDC to trade deal\" , tradeDealId ); Collateral Token Calculation : - Collateral tokens are minted based on the collateral-to-interest ratio - Tokens represent proportional ownership in the trade deal - Used for interest distribution and redemption rights","title":"tdDepositUSDC()"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#tdwithdrawusdc","text":"function tdWithdrawUSDC ( uint256 tradeDealId , uint256 amount ) external onlyOwner Purpose : Withdraws USDC from a trade deal (admin function). Parameters : - tradeDealId (uint256): ID of the trade deal - amount (uint256): Amount of USDC to withdraw Access Control : Owner only Process : 1. Validates withdrawal amount and availability 2. Transfers USDC from trade deal to owner 3. Updates trade deal funding records 4. Emits USDCWithdrawnFromTradeDeal event Events : USDCWithdrawnFromTradeDeal(tradeDealId, amount) Example Usage : // Admin withdrawal of excess USDC uint256 tradeDealId = 1 ; uint256 withdrawAmount = 5000 * 10 ** 6 ; // 5,000 USDC ITradeDealOperations ( diamond ). tdWithdrawUSDC ( tradeDealId , withdrawAmount ); console . log ( \"Withdrew\" , withdrawAmount , \"USDC from trade deal\" , tradeDealId );","title":"tdWithdrawUSDC()"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#funding-withdrawal-functions","text":"","title":"Funding Withdrawal Functions"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#withdrawtradedealfundingforborrower","text":"function withdrawTradeDealFundingForBorrower ( uint256 tradeDealId , address borrowerAddress ) external onlyOwner Purpose : Allows admin to withdraw funding on behalf of a borrower. Parameters : - tradeDealId (uint256): ID of the trade deal - borrowerAddress (address): Address of the borrower receiving funds Access Control : Owner only Process : 1. Validates funding withdrawal eligibility 2. Confirms trade deal is fully funded 3. Transfers available funding to borrower 4. Updates trade deal status and records 5. Emits TradeDealFundingWithdrawn event Events : TradeDealFundingWithdrawn(tradeDealId, recipient, amount) Example Usage : // Admin withdraws funding for borrower uint256 tradeDealId = 1 ; address borrower = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; ITradeDealOperations ( diamond ). withdrawTradeDealFundingForBorrower ( tradeDealId , borrower ); console . log ( \"Funding withdrawn for borrower:\" , borrower );","title":"withdrawTradeDealFundingForBorrower()"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#withdrawtradedealfundingself","text":"function withdrawTradeDealFundingSelf ( uint256 tradeDealId ) external Purpose : Allows eligible borrowers to withdraw funding themselves. Parameters : - tradeDealId (uint256): ID of the trade deal Access Control : Validated borrowers only Process : 1. Validates caller is authorized borrower for the trade deal 2. Confirms self-service withdrawal is enabled 3. Checks trade deal funding status and eligibility 4. Transfers available funding to caller 5. Updates trade deal records 6. Emits TradeDealFundingWithdrawn event Events : TradeDealFundingWithdrawn(tradeDealId, recipient, amount) Example Usage : // Borrower withdraws funding themselves uint256 tradeDealId = 1 ; ITradeDealOperations ( diamond ). withdrawTradeDealFundingSelf ( tradeDealId ); console . log ( \"Self-service funding withdrawal completed\" ); Requirements : - Caller must be authorized borrower - Trade deal must be fully funded - Self-service withdrawal must be enabled - No outstanding compliance issues","title":"withdrawTradeDealFundingSelf()"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#repayment-functions","text":"","title":"Repayment Functions"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#repaytradedeal","text":"function repayTradeDeal ( uint256 tradeDealId , uint256 amount ) external Purpose : Allows borrowers to repay trade deal obligations. Parameters : - tradeDealId (uint256): ID of the trade deal - amount (uint256): Amount to repay (in USDC) Access Control : Authorized repayers only Process : 1. Validates repayment parameters and authorization 2. Transfers repayment amount from caller 3. Updates trade deal outstanding balance 4. Calculates interest and principal allocation 5. Updates repayment tracking and status 6. Emits TradeDealRepaid event Events : TradeDealRepaid(tradeDealId, repayer, amount, fullyRepaid) Example Usage : // Borrower makes partial repayment uint256 tradeDealId = 1 ; uint256 repaymentAmount = 5000 * 10 ** 6 ; // 5,000 USDC // First approve USDC transfer IERC20 ( usdcToken ). approve ( diamond , repaymentAmount ); // Make repayment ITradeDealOperations ( diamond ). repayTradeDeal ( tradeDealId , repaymentAmount ); console . log ( \"Repaid\" , repaymentAmount , \"to trade deal\" , tradeDealId ); Repayment Allocation : - Interest payments processed first - Principal reduction after interest - Full repayment triggers completion status - Partial repayments update outstanding balance","title":"repayTradeDeal()"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#repaytradedealforborrower","text":"function repayTradeDealForBorrower ( uint256 tradeDealId , address borrower , uint256 amount ) external onlyOwner Purpose : Allows admin to make repayments on behalf of borrowers. Parameters : - tradeDealId (uint256): ID of the trade deal - borrower (address): Address of the borrower - amount (uint256): Amount to repay Access Control : Owner only Process : 1. Validates repayment parameters 2. Processes repayment on behalf of borrower 3. Updates trade deal records and status 4. Handles interest and principal allocation 5. Emits TradeDealRepaid event Events : TradeDealRepaid(tradeDealId, repayer, amount, fullyRepaid) Example Usage : // Admin makes repayment for borrower uint256 tradeDealId = 1 ; address borrower = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; uint256 repaymentAmount = 10000 * 10 ** 6 ; // 10,000 USDC ITradeDealOperations ( diamond ). repayTradeDealForBorrower ( tradeDealId , borrower , repaymentAmount ); console . log ( \"Admin repayment made for borrower:\" , borrower );","title":"repayTradeDealForBorrower()"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#collateral-redemption-functions","text":"","title":"Collateral Redemption Functions"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#redeemcollateraltokens","text":"function redeemCollateralTokens ( uint256 tradeDealId , uint256 collateralAmount ) external Purpose : Allows collateral token holders to redeem tokens for USDC. Parameters : - tradeDealId (uint256): ID of the trade deal - collateralAmount (uint256): Amount of collateral tokens to redeem Access Control : Collateral token holders only Process : 1. Validates collateral redemption eligibility 2. Calculates USDC amount based on current redemption rate 3. Burns collateral tokens from caller 4. Transfers proportional USDC to caller 5. Updates trade deal collateral tracking 6. Emits CollateralTokensRedeemed event Events : CollateralTokensRedeemed(tradeDealId, redeemer, collateralAmount, usdcAmount) Example Usage : // Redeem collateral tokens for USDC uint256 tradeDealId = 1 ; uint256 collateralToRedeem = 1000 * 10 ** 18 ; // 1,000 collateral tokens ITradeDealOperations ( diamond ). redeemCollateralTokens ( tradeDealId , collateralToRedeem ); console . log ( \"Redeemed\" , collateralToRedeem , \"collateral tokens\" ); Redemption Calculation : - USDC amount = (collateral tokens \u00d7 current USDC pool) \u00f7 total collateral tokens - Redemption rate varies based on trade deal performance - Interest distributions affect redemption value - Early redemption may have different rates than maturity","title":"redeemCollateralTokens()"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#complete-trade-deal-lifecycle","text":"// Comprehensive trade deal operations workflow contract TradeDealWorkflow { struct TradeDealState { uint256 tradeDealId ; uint256 fundingTarget ; uint256 currentFunding ; uint256 outstandingBalance ; bool fullyFunded ; bool repaid ; } mapping ( uint256 => TradeDealState ) public tradeDealStates ; function participateInTradeDeal ( uint256 tradeDealId , uint256 usdcAmount , uint256 [] memory invoiceTokenIds ) external { // Deposit invoices as collateral for ( uint256 i = 0 ; i < invoiceTokenIds . length ; i ++ ) { ITradeDealOperations ( diamond ). tdDepositInvoice ( tradeDealId , invoiceTokenIds [ i ]); } // Fund with USDC ITradeDealOperations ( diamond ). tdDepositUSDC ( tradeDealId , usdcAmount ); // Update state tracking TradeDealState storage state = tradeDealStates [ tradeDealId ]; state . currentFunding += usdcAmount ; emit ParticipationCompleted ( tradeDealId , msg.sender , usdcAmount , invoiceTokenIds ); } function borrowerWithdrawFunding ( uint256 tradeDealId ) external { require ( tradeDealStates [ tradeDealId ]. fullyFunded , \"Not fully funded\" ); // Borrower withdraws funding ITradeDealOperations ( diamond ). withdrawTradeDealFundingSelf ( tradeDealId ); // Update state tradeDealStates [ tradeDealId ]. outstandingBalance = tradeDealStates [ tradeDealId ]. currentFunding ; emit FundingWithdrawn ( tradeDealId , msg.sender ); } function makeRepayment ( uint256 tradeDealId , uint256 amount ) external { // Make repayment ITradeDealOperations ( diamond ). repayTradeDeal ( tradeDealId , amount ); // Update state TradeDealState storage state = tradeDealStates [ tradeDealId ]; if ( amount >= state . outstandingBalance ) { state . repaid = true ; state . outstandingBalance = 0 ; } else { state . outstandingBalance -= amount ; } emit RepaymentMade ( tradeDealId , msg.sender , amount ); } function redeemInvestment ( uint256 tradeDealId , uint256 collateralAmount ) external { require ( tradeDealStates [ tradeDealId ]. repaid , \"Trade deal not repaid\" ); // Redeem collateral tokens ITradeDealOperations ( diamond ). redeemCollateralTokens ( tradeDealId , collateralAmount ); emit InvestmentRedeemed ( tradeDealId , msg.sender , collateralAmount ); } }","title":"Complete Trade Deal Lifecycle"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#automated-repayment-system","text":"// Automated repayment scheduling and processing contract AutomatedRepaymentSystem { struct RepaymentSchedule { uint256 tradeDealId ; uint256 totalAmount ; uint256 installmentAmount ; uint256 frequency ; // in seconds uint256 nextPaymentDue ; uint256 remainingPayments ; bool active ; } mapping ( uint256 => RepaymentSchedule ) public repaymentSchedules ; mapping ( address => uint256 []) public borrowerTradeDealIds ; function setupRepaymentSchedule ( uint256 tradeDealId , uint256 totalAmount , uint256 numberOfPayments , uint256 frequency ) external onlyAuthorizedBorrower ( tradeDealId ) { uint256 installmentAmount = totalAmount / numberOfPayments ; repaymentSchedules [ tradeDealId ] = RepaymentSchedule ({ tradeDealId : tradeDealId , totalAmount : totalAmount , installmentAmount : installmentAmount , frequency : frequency , nextPaymentDue : block.timestamp + frequency , remainingPayments : numberOfPayments , active : true }); borrowerTradeDealIds [ msg.sender ]. push ( tradeDealId ); emit RepaymentScheduleCreated ( tradeDealId , totalAmount , numberOfPayments , frequency ); } function executeScheduledRepayment ( uint256 tradeDealId ) external { RepaymentSchedule storage schedule = repaymentSchedules [ tradeDealId ]; require ( schedule . active , \"Schedule not active\" ); require ( block.timestamp >= schedule . nextPaymentDue , \"Payment not due yet\" ); require ( schedule . remainingPayments > 0 , \"All payments completed\" ); // Execute repayment ITradeDealOperations ( diamond ). repayTradeDeal ( tradeDealId , schedule . installmentAmount ); // Update schedule schedule . remainingPayments -- ; if ( schedule . remainingPayments > 0 ) { schedule . nextPaymentDue += schedule . frequency ; } else { schedule . active = false ; } emit ScheduledRepaymentExecuted ( tradeDealId , schedule . installmentAmount , schedule . remainingPayments ); } function getOverduePayments ( address borrower ) external view returns ( uint256 [] memory ) { uint256 [] memory tradeDealIds = borrowerTradeDealIds [ borrower ]; uint256 [] memory overdueIds = new uint256 []( tradeDealIds . length ); uint256 overdueCount = 0 ; for ( uint256 i = 0 ; i < tradeDealIds . length ; i ++ ) { RepaymentSchedule memory schedule = repaymentSchedules [ tradeDealIds [ i ]]; if ( schedule . active && block.timestamp > schedule . nextPaymentDue ) { overdueIds [ overdueCount ] = tradeDealIds [ i ]; overdueCount ++ ; } } // Resize array to actual count uint256 [] memory result = new uint256 []( overdueCount ); for ( uint256 i = 0 ; i < overdueCount ; i ++ ) { result [ i ] = overdueIds [ i ]; } return result ; } }","title":"Automated Repayment System"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#collateral-management-system","text":"// Advanced collateral tracking and management contract CollateralManagementSystem { struct CollateralPosition { uint256 tradeDealId ; uint256 collateralTokens ; uint256 originalUSDCDeposit ; uint256 accruedInterest ; uint256 lastInterestUpdate ; } mapping ( address => mapping ( uint256 => CollateralPosition )) public positions ; mapping ( uint256 => uint256 ) public totalCollateralTokens ; mapping ( uint256 => uint256 ) public totalUSDCPool ; function trackCollateralDeposit ( uint256 tradeDealId , address depositor , uint256 usdcAmount , uint256 collateralTokens ) external onlyAuthorized { CollateralPosition storage position = positions [ depositor ][ tradeDealId ]; position . tradeDealId = tradeDealId ; position . collateralTokens += collateralTokens ; position . originalUSDCDeposit += usdcAmount ; position . lastInterestUpdate = block.timestamp ; totalCollateralTokens [ tradeDealId ] += collateralTokens ; totalUSDCPool [ tradeDealId ] += usdcAmount ; emit CollateralPositionUpdated ( depositor , tradeDealId , position ); } function calculateRedemptionValue ( address holder , uint256 tradeDealId , uint256 collateralAmount ) external view returns ( uint256 usdcAmount , uint256 interestAmount ) { CollateralPosition memory position = positions [ holder ][ tradeDealId ]; require ( position . collateralTokens >= collateralAmount , \"Insufficient collateral\" ); // Calculate proportional USDC uint256 totalCollateral = totalCollateralTokens [ tradeDealId ]; uint256 totalUSDC = totalUSDCPool [ tradeDealId ]; usdcAmount = ( collateralAmount * totalUSDC ) / totalCollateral ; // Calculate accrued interest uint256 proportionalInterest = ( position . accruedInterest * collateralAmount ) / position . collateralTokens ; interestAmount = proportionalInterest ; } function executeRedemption ( uint256 tradeDealId , uint256 collateralAmount ) external { ( uint256 usdcAmount , uint256 interestAmount ) = calculateRedemptionValue ( msg.sender , tradeDealId , collateralAmount ); // Execute redemption through operations facet ITradeDealOperations ( diamond ). redeemCollateralTokens ( tradeDealId , collateralAmount ); // Update position tracking CollateralPosition storage position = positions [ msg.sender ][ tradeDealId ]; position . collateralTokens -= collateralAmount ; position . accruedInterest -= interestAmount ; totalCollateralTokens [ tradeDealId ] -= collateralAmount ; totalUSDCPool [ tradeDealId ] -= usdcAmount ; emit RedemptionExecuted ( msg.sender , tradeDealId , collateralAmount , usdcAmount , interestAmount ); } function getPositionSummary ( address holder , uint256 tradeDealId ) external view returns ( uint256 collateralTokens , uint256 currentValue , uint256 originalDeposit , uint256 totalReturn , uint256 returnPercentage ) { CollateralPosition memory position = positions [ holder ][ tradeDealId ]; collateralTokens = position . collateralTokens ; originalDeposit = position . originalUSDCDeposit ; if ( collateralTokens > 0 ) { ( currentValue ,) = calculateRedemptionValue ( holder , tradeDealId , collateralTokens ); totalReturn = currentValue > originalDeposit ? currentValue - originalDeposit : 0 ; returnPercentage = originalDeposit > 0 ? ( totalReturn * 10000 ) / originalDeposit : 0 ; // basis points } } }","title":"Collateral Management System"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#invoice-collateral-tracker","text":"// Track invoice collateral deposits and withdrawals contract InvoiceCollateralTracker { struct InvoiceCollateral { uint256 tokenId ; uint256 tradeDealId ; address depositor ; uint256 depositTime ; uint256 invoiceValue ; bool active ; } mapping ( uint256 => InvoiceCollateral ) public invoiceCollaterals ; mapping ( uint256 => uint256 []) public tradeDealInvoices ; mapping ( address => uint256 []) public depositorInvoices ; function trackInvoiceDeposit ( uint256 tokenId , uint256 tradeDealId , address depositor , uint256 invoiceValue ) external onlyAuthorized { invoiceCollaterals [ tokenId ] = InvoiceCollateral ({ tokenId : tokenId , tradeDealId : tradeDealId , depositor : depositor , depositTime : block.timestamp , invoiceValue : invoiceValue , active : true }); tradeDealInvoices [ tradeDealId ]. push ( tokenId ); depositorInvoices [ depositor ]. push ( tokenId ); emit InvoiceCollateralTracked ( tokenId , tradeDealId , depositor , invoiceValue ); } function executeInvoiceDeposit ( uint256 tradeDealId , uint256 tokenId , uint256 invoiceValue ) external { // Execute deposit through operations facet ITradeDealOperations ( diamond ). tdDepositInvoice ( tradeDealId , tokenId ); // Track the deposit trackInvoiceDeposit ( tokenId , tradeDealId , msg.sender , invoiceValue ); } function executeInvoiceWithdrawal ( uint256 tradeDealId , uint256 tokenId ) external { require ( invoiceCollaterals [ tokenId ]. depositor == msg.sender , \"Not depositor\" ); require ( invoiceCollaterals [ tokenId ]. active , \"Invoice not active\" ); // Execute withdrawal through operations facet ITradeDealOperations ( diamond ). tdWithdrawInvoice ( tradeDealId , tokenId ); // Update tracking invoiceCollaterals [ tokenId ]. active = false ; emit InvoiceWithdrawn ( tokenId , tradeDealId , msg.sender ); } function getTradeDealCollateralValue ( uint256 tradeDealId ) external view returns ( uint256 totalValue ) { uint256 [] memory invoiceIds = tradeDealInvoices [ tradeDealId ]; for ( uint256 i = 0 ; i < invoiceIds . length ; i ++ ) { InvoiceCollateral memory collateral = invoiceCollaterals [ invoiceIds [ i ]]; if ( collateral . active ) { totalValue += collateral . invoiceValue ; } } } function getDepositorCollateral ( address depositor ) external view returns ( uint256 [] memory tokenIds , uint256 [] memory tradeDealIds , uint256 [] memory values , bool [] memory activeStatus ) { uint256 [] memory depositorTokenIds = depositorInvoices [ depositor ]; tokenIds = new uint256 []( depositorTokenIds . length ); tradeDealIds = new uint256 []( depositorTokenIds . length ); values = new uint256 []( depositorTokenIds . length ); activeStatus = new bool []( depositorTokenIds . length ); for ( uint256 i = 0 ; i < depositorTokenIds . length ; i ++ ) { InvoiceCollateral memory collateral = invoiceCollaterals [ depositorTokenIds [ i ]]; tokenIds [ i ] = collateral . tokenId ; tradeDealIds [ i ] = collateral . tradeDealId ; values [ i ] = collateral . invoiceValue ; activeStatus [ i ] = collateral . active ; } } }","title":"Invoice Collateral Tracker"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#events","text":"","title":"Events"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#invoice-management-events","text":"event InvoiceDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event InvoiceWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId );","title":"Invoice Management Events"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#usdc-funding-events","text":"event USDCDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 amount , address depositor ); event USDCWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 amount ); event TradeDealFullyFunded ( uint256 indexed tradeDealId , uint256 fundingTarget ); event CollateralTokensDistributed ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount );","title":"USDC Funding Events"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#funding-withdrawal-events","text":"event TradeDealFundingWithdrawn ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount );","title":"Funding Withdrawal Events"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#repayment-events","text":"event TradeDealRepaid ( uint256 indexed tradeDealId , address indexed repayer , uint256 amount , bool fullyRepaid );","title":"Repayment Events"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#redemption-events","text":"event CollateralTokensRedeemed ( uint256 indexed tradeDealId , address indexed redeemer , uint256 collateralAmount , uint256 usdcAmount );","title":"Redemption Events"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#access-control","text":"Participant validation for invoice operations Owner-only functions for admin operations Borrower authorization for funding withdrawals Collateral token holder validation for redemptions","title":"Access Control"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#financial-security","text":"Precise amount calculations and validations Overflow protection for large transactions Token transfer authorization checks Balance verification before operations","title":"Financial Security"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#operational-security","text":"Trade deal state validation before operations Invoice ownership verification Funding availability checks Repayment authorization validation","title":"Operational Security"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#efficient-operations","text":"Batch invoice deposits when possible Optimize token transfer operations Minimize storage updates Use events for off-chain tracking","title":"Efficient Operations"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#storage-optimization","text":"Pack related data efficiently Use mappings for participant tracking Cache frequently accessed values Optimize collateral calculations","title":"Storage Optimization"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#common-errors","text":"Insufficient balances or allowances Invalid trade deal states Unauthorized operations Invoice ownership mismatches Funding availability issues","title":"Common Errors"},{"location":"smart-contracts/facets/trade-deal-operations-facet/#best-practices","text":"Validate all inputs before processing Check authorization before","title":"Best Practices"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/","text":"TrustedIssuersRegistryFacet \u00b6 Overview \u00b6 The TrustedIssuersRegistryFacet.sol manages the registry of trusted issuers within the Gemforce identity system. This facet provides comprehensive functionality for authorizing, managing, and querying trusted entities that can issue and manage identity claims within the decentralized identity framework. Contract Details \u00b6 Contract Name : TrustedIssuersRegistryFacet Inheritance : ITrustedIssuersRegistry , Modifiers License : MIT Solidity Version : ^0.8.0 Key Features \u00b6 \ud83d\udd39 Trusted Issuer Management \u00b6 Add and remove trusted issuers from the registry Update issuer permissions and claim topic authorizations Complete lifecycle management of issuer credentials \ud83d\udd39 Claim Topic Authorization \u00b6 Granular control over which claim topics each issuer can manage Add and remove specific claim topic permissions Batch claim topic management for efficient operations \ud83d\udd39 Registry Operations \u00b6 Query all trusted issuers in the system Check issuer status and permissions Retrieve issuer-specific claim topic authorizations \ud83d\udd39 Access Control Integration \u00b6 Owner-only administrative functions Integration with identity registry access control Secure permission management for claim operations Core Data Structures \u00b6 TrustedIssuer Struct \u00b6 struct TrustedIssuer { address issuerAddress ; // Address of the trusted issuer uint [] claimTopics ; // Array of authorized claim topics bool exists ; // Flag indicating if issuer exists } Storage Pattern \u00b6 Uses diamond storage pattern via IdentitySystemStorage : - Prevents storage collisions in diamond architecture - Efficient mappings for issuer data and permissions - Persistent storage across contract upgrades Core Functions \u00b6 Issuer Management Functions \u00b6 addTrustedIssuer() \u00b6 function addTrustedIssuer ( address _trustedIssuer , uint [] calldata _claimTopics ) external override onlyOwner Purpose : Adds a new trusted issuer to the registry with specified claim topic permissions. Parameters : - _trustedIssuer (address): Address of the issuer to add - _claimTopics (uint[]): Array of claim topics the issuer is authorized for Access Control : Owner only Validation : - Issuer must not already exist in the registry - Address must be valid (non-zero) Process : 1. Validates issuer doesn't already exist 2. Adds issuer to storage with specified claim topics 3. Updates issuer address list 4. Emits TrustedIssuerAdded event Events : TrustedIssuerAdded(issuerAddress, claimTopics) Example Usage : // Add KYC provider as trusted issuer uint [] memory kycTopics = new uint []( 2 ); kycTopics [ 0 ] = 1 ; // KYC_TOPIC kycTopics [ 1 ] = 2 ; // ACCREDITED_INVESTOR_TOPIC ITrustedIssuersRegistry ( diamond ). addTrustedIssuer ( kycProviderAddress , kycTopics ); Error Conditions : - \"Trusted issuer already exists\" - Issuer is already registered removeTrustedIssuer() \u00b6 function removeTrustedIssuer ( address _trustedIssuer ) external override onlyOwner Purpose : Removes a trusted issuer from the registry, revoking all their permissions. Parameters : - _trustedIssuer (address): Address of the issuer to remove Access Control : Owner only Validation : Issuer must exist in the registry Process : 1. Validates issuer exists 2. Removes issuer from storage 3. Cleans up issuer address list 4. Emits TrustedIssuerRemoved event Events : TrustedIssuerRemoved(issuerAddress) Example Usage : // Remove compromised or expired issuer ITrustedIssuersRegistry ( diamond ). removeTrustedIssuer ( expiredIssuerAddress ); Error Conditions : - \"Trusted issuer does not exist\" - Issuer is not registered updateIssuerClaimTopics() \u00b6 function updateIssuerClaimTopics ( address _trustedIssuer , uint [] calldata _claimTopics ) external override onlyOwner Purpose : Updates the claim topics that a trusted issuer is authorized to manage. Parameters : - _trustedIssuer (address): Address of the issuer to update - _claimTopics (uint[]): New array of authorized claim topics Access Control : Owner only Validation : Issuer must exist in the registry Process : 1. Validates issuer exists 2. Replaces existing claim topics with new ones 3. Updates storage mappings 4. Emits ClaimTopicsUpdated event Events : ClaimTopicsUpdated(issuerAddress, claimTopics) Example Usage : // Update issuer permissions to include new claim types uint [] memory updatedTopics = new uint []( 3 ); updatedTopics [ 0 ] = 1 ; // KYC_TOPIC updatedTopics [ 1 ] = 2 ; // ACCREDITED_INVESTOR_TOPIC updatedTopics [ 2 ] = 5 ; // JURISDICTION_TOPIC ITrustedIssuersRegistry ( diamond ). updateIssuerClaimTopics ( issuerAddress , updatedTopics ); Error Conditions : - \"Trusted issuer does not exist\" - Issuer is not registered Claim Topic Management Functions \u00b6 addTrustedIssuerClaimTopic() \u00b6 function addTrustedIssuerClaimTopic ( address _issuer , uint _claimTopic ) external onlyOwner Purpose : Adds a single claim topic to an existing trusted issuer's permissions. Parameters : - _issuer (address): Address of the trusted issuer - _claimTopic (uint): Claim topic to add Access Control : Owner only Validation : Issuer must exist in the registry Process : 1. Validates issuer exists 2. Adds claim topic to issuer's authorized topics 3. Updates storage mappings Example Usage : // Grant additional claim topic permission to existing issuer ITrustedIssuersRegistry ( diamond ). addTrustedIssuerClaimTopic ( issuerAddress , NEW_CLAIM_TOPIC ); Error Conditions : - \"Trusted issuer does not exist\" - Issuer is not registered removeTrustedIssuerClaimTopic() \u00b6 function removeTrustedIssuerClaimTopic ( address _issuer , uint _claimTopic ) external onlyOwner Purpose : Removes a specific claim topic from a trusted issuer's permissions. Parameters : - _issuer (address): Address of the trusted issuer - _claimTopic (uint): Claim topic to remove Access Control : Owner only Validation : Issuer must exist in the registry Process : 1. Validates issuer exists 2. Removes claim topic from issuer's authorized topics 3. Updates storage mappings 4. Emits ClaimTopicRemoved event Events : ClaimTopicRemoved(issuer, claimTopic) Example Usage : // Revoke specific claim topic permission ITrustedIssuersRegistry ( diamond ). removeTrustedIssuerClaimTopic ( issuerAddress , REVOKED_CLAIM_TOPIC ); Error Conditions : - \"Trusted issuer does not exist\" - Issuer is not registered Query Functions \u00b6 getTrustedIssuer() \u00b6 function getTrustedIssuer ( address issuerAddress ) external view override returns ( TrustedIssuer memory ) Purpose : Returns the complete trusted issuer struct for a given address. Parameters : - issuerAddress (address): Address of the issuer to query Returns : TrustedIssuer struct containing issuer details and permissions Example Usage : TrustedIssuer memory issuer = ITrustedIssuersRegistry ( diamond ). getTrustedIssuer ( issuerAddress ); if ( issuer . exists ) { console . log ( \"Issuer has\" , issuer . claimTopics . length , \"authorized claim topics\" ); } getTrustedIssuers() \u00b6 function getTrustedIssuers () external view override returns ( TrustedIssuer [] memory ) Purpose : Returns an array of all trusted issuers in the registry. Returns : Array of TrustedIssuer structs Example Usage : TrustedIssuer [] memory allIssuers = ITrustedIssuersRegistry ( diamond ). getTrustedIssuers (); for ( uint256 i = 0 ; i < allIssuers . length ; i ++ ) { console . log ( \"Issuer:\" , allIssuers [ i ]. issuerAddress ); console . log ( \"Topics:\" , allIssuers [ i ]. claimTopics . length ); } isTrustedIssuer() \u00b6 function isTrustedIssuer ( address _issuer ) external view override returns ( bool ) Purpose : Checks if an address is registered as a trusted issuer. Parameters : - _issuer (address): Address to check Returns : True if the address is a trusted issuer, false otherwise Example Usage : bool isTrusted = ITrustedIssuersRegistry ( diamond ). isTrustedIssuer ( issuerAddress ); if ( isTrusted ) { // Allow issuer operations } else { revert ( \"Unauthorized issuer\" ); } getTrustedIssuerClaimTopics() \u00b6 function getTrustedIssuerClaimTopics ( address _trustedIssuer ) external view override returns ( uint [] memory ) Purpose : Returns all claim topics that a trusted issuer is authorized for. Parameters : - _trustedIssuer (address): Address of the trusted issuer Returns : Array of authorized claim topic IDs Example Usage : uint [] memory authorizedTopics = ITrustedIssuersRegistry ( diamond ). getTrustedIssuerClaimTopics ( issuerAddress ); for ( uint256 i = 0 ; i < authorizedTopics . length ; i ++ ) { console . log ( \"Authorized for claim topic:\" , authorizedTopics [ i ]); } hasTrustedIssuerClaimTopic() \u00b6 function hasTrustedIssuerClaimTopic ( address _issuer , uint _claimTopic ) external view override returns ( bool ) Purpose : Checks if a trusted issuer is authorized for a specific claim topic. Parameters : - _issuer (address): Address of the issuer - _claimTopic (uint): Claim topic to check Returns : True if the issuer is authorized for the claim topic, false otherwise Example Usage : bool canIssueKYC = ITrustedIssuersRegistry ( diamond ). hasTrustedIssuerClaimTopic ( issuerAddress , KYC_TOPIC ); require ( canIssueKYC , \"Issuer not authorized for KYC claims\" ); Integration Examples \u00b6 KYC Provider Management \u00b6 // Complete KYC provider setup contract KYCProviderManager { uint256 constant KYC_TOPIC = 1 ; uint256 constant ACCREDITED_TOPIC = 2 ; uint256 constant JURISDICTION_TOPIC = 3 ; function setupKYCProvider ( address provider ) external onlyOwner { // 1. Define claim topics for KYC provider uint [] memory kycTopics = new uint []( 3 ); kycTopics [ 0 ] = KYC_TOPIC ; kycTopics [ 1 ] = ACCREDITED_TOPIC ; kycTopics [ 2 ] = JURISDICTION_TOPIC ; // 2. Add as trusted issuer ITrustedIssuersRegistry ( diamond ). addTrustedIssuer ( provider , kycTopics ); // 3. Verify setup require ( ITrustedIssuersRegistry ( diamond ). isTrustedIssuer ( provider ), \"KYC provider setup failed\" ); } function revokeKYCProvider ( address provider ) external onlyOwner { // Remove all permissions ITrustedIssuersRegistry ( diamond ). removeTrustedIssuer ( provider ); } } Dynamic Permission Management \u00b6 // Manage issuer permissions dynamically contract IssuerPermissionManager { function grantClaimTopicPermission ( address issuer , uint claimTopic ) external onlyOwner { require ( ITrustedIssuersRegistry ( diamond ). isTrustedIssuer ( issuer ), \"Not a trusted issuer\" ); // Check if issuer already has this permission if ( ! ITrustedIssuersRegistry ( diamond ). hasTrustedIssuerClaimTopic ( issuer , claimTopic )) { ITrustedIssuersRegistry ( diamond ). addTrustedIssuerClaimTopic ( issuer , claimTopic ); } } function revokeClaimTopicPermission ( address issuer , uint claimTopic ) external onlyOwner { if ( ITrustedIssuersRegistry ( diamond ). hasTrustedIssuerClaimTopic ( issuer , claimTopic )) { ITrustedIssuersRegistry ( diamond ). removeTrustedIssuerClaimTopic ( issuer , claimTopic ); } } } Issuer Authorization Middleware \u00b6 // Middleware for validating issuer permissions contract IssuerAuthorizationMiddleware { modifier requiresTrustedIssuer ( address issuer ) { require ( ITrustedIssuersRegistry ( diamond ). isTrustedIssuer ( issuer ), \"Not a trusted issuer\" ); _ ; } modifier requiresClaimTopicPermission ( address issuer , uint claimTopic ) { require ( ITrustedIssuersRegistry ( diamond ). hasTrustedIssuerClaimTopic ( issuer , claimTopic ), \"Issuer not authorized for claim topic\" ); _ ; } function issueClaimWithValidation ( address user , uint claimTopic , bytes calldata claimData ) external requiresTrustedIssuer ( msg.sender ) requiresClaimTopicPermission ( msg.sender , claimTopic ) { // Proceed with claim issuance IIdentityRegistry ( diamond ). addClaim ( user , claimTopic , claimData ); } } Registry Analytics \u00b6 // Analytics and reporting for trusted issuers contract TrustedIssuerAnalytics { function getRegistryStats () external view returns ( uint256 totalIssuers , uint256 totalClaimTopics , address [] memory issuerAddresses ) { TrustedIssuer [] memory issuers = ITrustedIssuersRegistry ( diamond ). getTrustedIssuers (); totalIssuers = issuers . length ; issuerAddresses = new address []( totalIssuers ); uint256 uniqueTopics = 0 ; mapping ( uint => bool ) seenTopics ; for ( uint256 i = 0 ; i < issuers . length ; i ++ ) { issuerAddresses [ i ] = issuers [ i ]. issuerAddress ; // Count unique claim topics for ( uint256 j = 0 ; j < issuers [ i ]. claimTopics . length ; j ++ ) { if ( ! seenTopics [ issuers [ i ]. claimTopics [ j ]]) { seenTopics [ issuers [ i ]. claimTopics [ j ]] = true ; uniqueTopics ++ ; } } } totalClaimTopics = uniqueTopics ; } function getIssuersByClaimTopic ( uint claimTopic ) external view returns ( address [] memory ) { TrustedIssuer [] memory allIssuers = ITrustedIssuersRegistry ( diamond ). getTrustedIssuers (); address [] memory authorizedIssuers = new address []( allIssuers . length ); uint256 count = 0 ; for ( uint256 i = 0 ; i < allIssuers . length ; i ++ ) { if ( ITrustedIssuersRegistry ( diamond ). hasTrustedIssuerClaimTopic ( allIssuers [ i ]. issuerAddress , claimTopic )) { authorizedIssuers [ count ] = allIssuers [ i ]. issuerAddress ; count ++ ; } } // Resize array to actual count assembly { mstore ( authorizedIssuers , count ) } return authorizedIssuers ; } } Events \u00b6 Issuer Management Events \u00b6 event TrustedIssuerAdded ( address indexed issuer , uint [] claimTopics ); event TrustedIssuerRemoved ( address indexed issuer ); event ClaimTopicsUpdated ( address indexed issuer , uint [] claimTopics ); Claim Topic Events \u00b6 event ClaimTopicRemoved ( address indexed issuer , uint claimTopic ); Security Considerations \u00b6 Access Control \u00b6 All administrative functions restricted to contract owner Prevents unauthorized issuer registration or permission changes Secure integration with identity registry access control Data Integrity \u00b6 Comprehensive validation ensures consistent issuer state Diamond storage pattern prevents storage collisions Event logging provides complete audit trail Permission Management \u00b6 Granular claim topic permissions prevent unauthorized claim issuance Clear separation between issuer existence and topic authorization Secure permission revocation without affecting other permissions Gas Optimization \u00b6 Storage Efficiency \u00b6 Efficient mapping structures for issuer data Minimal storage footprint per issuer Optimized array operations for claim topics Query Optimization \u00b6 Direct mapping lookups for permission checks Efficient enumeration of all issuers Batch operations where applicable Error Handling \u00b6 Issuer Management Errors \u00b6 \"Trusted issuer already exists\" - Duplicate registration attempt \"Trusted issuer does not exist\" - Operation on non-existent issuer Permission Errors \u00b6 Authorization failures handled by calling contracts Clear error messages for debugging and user feedback Testing Considerations \u00b6 Unit Tests \u00b6 Issuer addition, removal, and updates Claim topic permission management Query function accuracy Access control validation Integration Tests \u00b6 Integration with IdentityRegistryFacet End-to-end claim issuance workflows Permission validation in claim operations Event emission verification Related Documentation \u00b6 ITrustedIssuersRegistry - Trusted issuers registry interface IdentityRegistryFacet - Identity registry implementation IdentitySystemStorage - Storage library EIP-DRAFT-Enhanced-Identity-System - EIP specification Identity Integration Guide - Implementation guide This facet provides the foundation for trusted issuer management within the Gemforce Enhanced Identity System, enabling secure and granular control over identity claim issuance permissions.","title":"Trusted Issuers Registry Facet"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#trustedissuersregistryfacet","text":"","title":"TrustedIssuersRegistryFacet"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#overview","text":"The TrustedIssuersRegistryFacet.sol manages the registry of trusted issuers within the Gemforce identity system. This facet provides comprehensive functionality for authorizing, managing, and querying trusted entities that can issue and manage identity claims within the decentralized identity framework.","title":"Overview"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#contract-details","text":"Contract Name : TrustedIssuersRegistryFacet Inheritance : ITrustedIssuersRegistry , Modifiers License : MIT Solidity Version : ^0.8.0","title":"Contract Details"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#trusted-issuer-management","text":"Add and remove trusted issuers from the registry Update issuer permissions and claim topic authorizations Complete lifecycle management of issuer credentials","title":"\ud83d\udd39 Trusted Issuer Management"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#claim-topic-authorization","text":"Granular control over which claim topics each issuer can manage Add and remove specific claim topic permissions Batch claim topic management for efficient operations","title":"\ud83d\udd39 Claim Topic Authorization"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#registry-operations","text":"Query all trusted issuers in the system Check issuer status and permissions Retrieve issuer-specific claim topic authorizations","title":"\ud83d\udd39 Registry Operations"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#access-control-integration","text":"Owner-only administrative functions Integration with identity registry access control Secure permission management for claim operations","title":"\ud83d\udd39 Access Control Integration"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#core-data-structures","text":"","title":"Core Data Structures"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#trustedissuer-struct","text":"struct TrustedIssuer { address issuerAddress ; // Address of the trusted issuer uint [] claimTopics ; // Array of authorized claim topics bool exists ; // Flag indicating if issuer exists }","title":"TrustedIssuer Struct"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#storage-pattern","text":"Uses diamond storage pattern via IdentitySystemStorage : - Prevents storage collisions in diamond architecture - Efficient mappings for issuer data and permissions - Persistent storage across contract upgrades","title":"Storage Pattern"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#issuer-management-functions","text":"","title":"Issuer Management Functions"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#addtrustedissuer","text":"function addTrustedIssuer ( address _trustedIssuer , uint [] calldata _claimTopics ) external override onlyOwner Purpose : Adds a new trusted issuer to the registry with specified claim topic permissions. Parameters : - _trustedIssuer (address): Address of the issuer to add - _claimTopics (uint[]): Array of claim topics the issuer is authorized for Access Control : Owner only Validation : - Issuer must not already exist in the registry - Address must be valid (non-zero) Process : 1. Validates issuer doesn't already exist 2. Adds issuer to storage with specified claim topics 3. Updates issuer address list 4. Emits TrustedIssuerAdded event Events : TrustedIssuerAdded(issuerAddress, claimTopics) Example Usage : // Add KYC provider as trusted issuer uint [] memory kycTopics = new uint []( 2 ); kycTopics [ 0 ] = 1 ; // KYC_TOPIC kycTopics [ 1 ] = 2 ; // ACCREDITED_INVESTOR_TOPIC ITrustedIssuersRegistry ( diamond ). addTrustedIssuer ( kycProviderAddress , kycTopics ); Error Conditions : - \"Trusted issuer already exists\" - Issuer is already registered","title":"addTrustedIssuer()"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#removetrustedissuer","text":"function removeTrustedIssuer ( address _trustedIssuer ) external override onlyOwner Purpose : Removes a trusted issuer from the registry, revoking all their permissions. Parameters : - _trustedIssuer (address): Address of the issuer to remove Access Control : Owner only Validation : Issuer must exist in the registry Process : 1. Validates issuer exists 2. Removes issuer from storage 3. Cleans up issuer address list 4. Emits TrustedIssuerRemoved event Events : TrustedIssuerRemoved(issuerAddress) Example Usage : // Remove compromised or expired issuer ITrustedIssuersRegistry ( diamond ). removeTrustedIssuer ( expiredIssuerAddress ); Error Conditions : - \"Trusted issuer does not exist\" - Issuer is not registered","title":"removeTrustedIssuer()"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#updateissuerclaimtopics","text":"function updateIssuerClaimTopics ( address _trustedIssuer , uint [] calldata _claimTopics ) external override onlyOwner Purpose : Updates the claim topics that a trusted issuer is authorized to manage. Parameters : - _trustedIssuer (address): Address of the issuer to update - _claimTopics (uint[]): New array of authorized claim topics Access Control : Owner only Validation : Issuer must exist in the registry Process : 1. Validates issuer exists 2. Replaces existing claim topics with new ones 3. Updates storage mappings 4. Emits ClaimTopicsUpdated event Events : ClaimTopicsUpdated(issuerAddress, claimTopics) Example Usage : // Update issuer permissions to include new claim types uint [] memory updatedTopics = new uint []( 3 ); updatedTopics [ 0 ] = 1 ; // KYC_TOPIC updatedTopics [ 1 ] = 2 ; // ACCREDITED_INVESTOR_TOPIC updatedTopics [ 2 ] = 5 ; // JURISDICTION_TOPIC ITrustedIssuersRegistry ( diamond ). updateIssuerClaimTopics ( issuerAddress , updatedTopics ); Error Conditions : - \"Trusted issuer does not exist\" - Issuer is not registered","title":"updateIssuerClaimTopics()"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#claim-topic-management-functions","text":"","title":"Claim Topic Management Functions"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#addtrustedissuerclaimtopic","text":"function addTrustedIssuerClaimTopic ( address _issuer , uint _claimTopic ) external onlyOwner Purpose : Adds a single claim topic to an existing trusted issuer's permissions. Parameters : - _issuer (address): Address of the trusted issuer - _claimTopic (uint): Claim topic to add Access Control : Owner only Validation : Issuer must exist in the registry Process : 1. Validates issuer exists 2. Adds claim topic to issuer's authorized topics 3. Updates storage mappings Example Usage : // Grant additional claim topic permission to existing issuer ITrustedIssuersRegistry ( diamond ). addTrustedIssuerClaimTopic ( issuerAddress , NEW_CLAIM_TOPIC ); Error Conditions : - \"Trusted issuer does not exist\" - Issuer is not registered","title":"addTrustedIssuerClaimTopic()"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#removetrustedissuerclaimtopic","text":"function removeTrustedIssuerClaimTopic ( address _issuer , uint _claimTopic ) external onlyOwner Purpose : Removes a specific claim topic from a trusted issuer's permissions. Parameters : - _issuer (address): Address of the trusted issuer - _claimTopic (uint): Claim topic to remove Access Control : Owner only Validation : Issuer must exist in the registry Process : 1. Validates issuer exists 2. Removes claim topic from issuer's authorized topics 3. Updates storage mappings 4. Emits ClaimTopicRemoved event Events : ClaimTopicRemoved(issuer, claimTopic) Example Usage : // Revoke specific claim topic permission ITrustedIssuersRegistry ( diamond ). removeTrustedIssuerClaimTopic ( issuerAddress , REVOKED_CLAIM_TOPIC ); Error Conditions : - \"Trusted issuer does not exist\" - Issuer is not registered","title":"removeTrustedIssuerClaimTopic()"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#query-functions","text":"","title":"Query Functions"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#gettrustedissuer","text":"function getTrustedIssuer ( address issuerAddress ) external view override returns ( TrustedIssuer memory ) Purpose : Returns the complete trusted issuer struct for a given address. Parameters : - issuerAddress (address): Address of the issuer to query Returns : TrustedIssuer struct containing issuer details and permissions Example Usage : TrustedIssuer memory issuer = ITrustedIssuersRegistry ( diamond ). getTrustedIssuer ( issuerAddress ); if ( issuer . exists ) { console . log ( \"Issuer has\" , issuer . claimTopics . length , \"authorized claim topics\" ); }","title":"getTrustedIssuer()"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#gettrustedissuers","text":"function getTrustedIssuers () external view override returns ( TrustedIssuer [] memory ) Purpose : Returns an array of all trusted issuers in the registry. Returns : Array of TrustedIssuer structs Example Usage : TrustedIssuer [] memory allIssuers = ITrustedIssuersRegistry ( diamond ). getTrustedIssuers (); for ( uint256 i = 0 ; i < allIssuers . length ; i ++ ) { console . log ( \"Issuer:\" , allIssuers [ i ]. issuerAddress ); console . log ( \"Topics:\" , allIssuers [ i ]. claimTopics . length ); }","title":"getTrustedIssuers()"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#istrustedissuer","text":"function isTrustedIssuer ( address _issuer ) external view override returns ( bool ) Purpose : Checks if an address is registered as a trusted issuer. Parameters : - _issuer (address): Address to check Returns : True if the address is a trusted issuer, false otherwise Example Usage : bool isTrusted = ITrustedIssuersRegistry ( diamond ). isTrustedIssuer ( issuerAddress ); if ( isTrusted ) { // Allow issuer operations } else { revert ( \"Unauthorized issuer\" ); }","title":"isTrustedIssuer()"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#gettrustedissuerclaimtopics","text":"function getTrustedIssuerClaimTopics ( address _trustedIssuer ) external view override returns ( uint [] memory ) Purpose : Returns all claim topics that a trusted issuer is authorized for. Parameters : - _trustedIssuer (address): Address of the trusted issuer Returns : Array of authorized claim topic IDs Example Usage : uint [] memory authorizedTopics = ITrustedIssuersRegistry ( diamond ). getTrustedIssuerClaimTopics ( issuerAddress ); for ( uint256 i = 0 ; i < authorizedTopics . length ; i ++ ) { console . log ( \"Authorized for claim topic:\" , authorizedTopics [ i ]); }","title":"getTrustedIssuerClaimTopics()"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#hastrustedissuerclaimtopic","text":"function hasTrustedIssuerClaimTopic ( address _issuer , uint _claimTopic ) external view override returns ( bool ) Purpose : Checks if a trusted issuer is authorized for a specific claim topic. Parameters : - _issuer (address): Address of the issuer - _claimTopic (uint): Claim topic to check Returns : True if the issuer is authorized for the claim topic, false otherwise Example Usage : bool canIssueKYC = ITrustedIssuersRegistry ( diamond ). hasTrustedIssuerClaimTopic ( issuerAddress , KYC_TOPIC ); require ( canIssueKYC , \"Issuer not authorized for KYC claims\" );","title":"hasTrustedIssuerClaimTopic()"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#kyc-provider-management","text":"// Complete KYC provider setup contract KYCProviderManager { uint256 constant KYC_TOPIC = 1 ; uint256 constant ACCREDITED_TOPIC = 2 ; uint256 constant JURISDICTION_TOPIC = 3 ; function setupKYCProvider ( address provider ) external onlyOwner { // 1. Define claim topics for KYC provider uint [] memory kycTopics = new uint []( 3 ); kycTopics [ 0 ] = KYC_TOPIC ; kycTopics [ 1 ] = ACCREDITED_TOPIC ; kycTopics [ 2 ] = JURISDICTION_TOPIC ; // 2. Add as trusted issuer ITrustedIssuersRegistry ( diamond ). addTrustedIssuer ( provider , kycTopics ); // 3. Verify setup require ( ITrustedIssuersRegistry ( diamond ). isTrustedIssuer ( provider ), \"KYC provider setup failed\" ); } function revokeKYCProvider ( address provider ) external onlyOwner { // Remove all permissions ITrustedIssuersRegistry ( diamond ). removeTrustedIssuer ( provider ); } }","title":"KYC Provider Management"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#dynamic-permission-management","text":"// Manage issuer permissions dynamically contract IssuerPermissionManager { function grantClaimTopicPermission ( address issuer , uint claimTopic ) external onlyOwner { require ( ITrustedIssuersRegistry ( diamond ). isTrustedIssuer ( issuer ), \"Not a trusted issuer\" ); // Check if issuer already has this permission if ( ! ITrustedIssuersRegistry ( diamond ). hasTrustedIssuerClaimTopic ( issuer , claimTopic )) { ITrustedIssuersRegistry ( diamond ). addTrustedIssuerClaimTopic ( issuer , claimTopic ); } } function revokeClaimTopicPermission ( address issuer , uint claimTopic ) external onlyOwner { if ( ITrustedIssuersRegistry ( diamond ). hasTrustedIssuerClaimTopic ( issuer , claimTopic )) { ITrustedIssuersRegistry ( diamond ). removeTrustedIssuerClaimTopic ( issuer , claimTopic ); } } }","title":"Dynamic Permission Management"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#issuer-authorization-middleware","text":"// Middleware for validating issuer permissions contract IssuerAuthorizationMiddleware { modifier requiresTrustedIssuer ( address issuer ) { require ( ITrustedIssuersRegistry ( diamond ). isTrustedIssuer ( issuer ), \"Not a trusted issuer\" ); _ ; } modifier requiresClaimTopicPermission ( address issuer , uint claimTopic ) { require ( ITrustedIssuersRegistry ( diamond ). hasTrustedIssuerClaimTopic ( issuer , claimTopic ), \"Issuer not authorized for claim topic\" ); _ ; } function issueClaimWithValidation ( address user , uint claimTopic , bytes calldata claimData ) external requiresTrustedIssuer ( msg.sender ) requiresClaimTopicPermission ( msg.sender , claimTopic ) { // Proceed with claim issuance IIdentityRegistry ( diamond ). addClaim ( user , claimTopic , claimData ); } }","title":"Issuer Authorization Middleware"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#registry-analytics","text":"// Analytics and reporting for trusted issuers contract TrustedIssuerAnalytics { function getRegistryStats () external view returns ( uint256 totalIssuers , uint256 totalClaimTopics , address [] memory issuerAddresses ) { TrustedIssuer [] memory issuers = ITrustedIssuersRegistry ( diamond ). getTrustedIssuers (); totalIssuers = issuers . length ; issuerAddresses = new address []( totalIssuers ); uint256 uniqueTopics = 0 ; mapping ( uint => bool ) seenTopics ; for ( uint256 i = 0 ; i < issuers . length ; i ++ ) { issuerAddresses [ i ] = issuers [ i ]. issuerAddress ; // Count unique claim topics for ( uint256 j = 0 ; j < issuers [ i ]. claimTopics . length ; j ++ ) { if ( ! seenTopics [ issuers [ i ]. claimTopics [ j ]]) { seenTopics [ issuers [ i ]. claimTopics [ j ]] = true ; uniqueTopics ++ ; } } } totalClaimTopics = uniqueTopics ; } function getIssuersByClaimTopic ( uint claimTopic ) external view returns ( address [] memory ) { TrustedIssuer [] memory allIssuers = ITrustedIssuersRegistry ( diamond ). getTrustedIssuers (); address [] memory authorizedIssuers = new address []( allIssuers . length ); uint256 count = 0 ; for ( uint256 i = 0 ; i < allIssuers . length ; i ++ ) { if ( ITrustedIssuersRegistry ( diamond ). hasTrustedIssuerClaimTopic ( allIssuers [ i ]. issuerAddress , claimTopic )) { authorizedIssuers [ count ] = allIssuers [ i ]. issuerAddress ; count ++ ; } } // Resize array to actual count assembly { mstore ( authorizedIssuers , count ) } return authorizedIssuers ; } }","title":"Registry Analytics"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#events","text":"","title":"Events"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#issuer-management-events","text":"event TrustedIssuerAdded ( address indexed issuer , uint [] claimTopics ); event TrustedIssuerRemoved ( address indexed issuer ); event ClaimTopicsUpdated ( address indexed issuer , uint [] claimTopics );","title":"Issuer Management Events"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#claim-topic-events","text":"event ClaimTopicRemoved ( address indexed issuer , uint claimTopic );","title":"Claim Topic Events"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#access-control","text":"All administrative functions restricted to contract owner Prevents unauthorized issuer registration or permission changes Secure integration with identity registry access control","title":"Access Control"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#data-integrity","text":"Comprehensive validation ensures consistent issuer state Diamond storage pattern prevents storage collisions Event logging provides complete audit trail","title":"Data Integrity"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#permission-management","text":"Granular claim topic permissions prevent unauthorized claim issuance Clear separation between issuer existence and topic authorization Secure permission revocation without affecting other permissions","title":"Permission Management"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#storage-efficiency","text":"Efficient mapping structures for issuer data Minimal storage footprint per issuer Optimized array operations for claim topics","title":"Storage Efficiency"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#query-optimization","text":"Direct mapping lookups for permission checks Efficient enumeration of all issuers Batch operations where applicable","title":"Query Optimization"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#issuer-management-errors","text":"\"Trusted issuer already exists\" - Duplicate registration attempt \"Trusted issuer does not exist\" - Operation on non-existent issuer","title":"Issuer Management Errors"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#permission-errors","text":"Authorization failures handled by calling contracts Clear error messages for debugging and user feedback","title":"Permission Errors"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#unit-tests","text":"Issuer addition, removal, and updates Claim topic permission management Query function accuracy Access control validation","title":"Unit Tests"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#integration-tests","text":"Integration with IdentityRegistryFacet End-to-end claim issuance workflows Permission validation in claim operations Event emission verification","title":"Integration Tests"},{"location":"smart-contracts/facets/trusted-issuers-registry-facet/#related-documentation","text":"ITrustedIssuersRegistry - Trusted issuers registry interface IdentityRegistryFacet - Identity registry implementation IdentitySystemStorage - Storage library EIP-DRAFT-Enhanced-Identity-System - EIP specification Identity Integration Guide - Implementation guide This facet provides the foundation for trusted issuer management within the Gemforce Enhanced Identity System, enabling secure and granular control over identity claim issuance permissions.","title":"Related Documentation"},{"location":"smart-contracts/interfaces/iattribute/","text":"IAttribute Interface \u00b6 The IAttribute interface defines the standard for managing dynamic attributes associated with tokens or other entities within the Gemforce ecosystem. This interface provides a flexible and extensible way to store, retrieve, and update various properties or characteristics without modifying the core token contract logic. Overview \u00b6 IAttribute provides: Dynamic Attribute Management : Store and retrieve custom attributes for any entity (e.g., token IDs, identity hashes). Attribute Types : Support for different data types (e.g., string, uint, bool, bytes). Versioning (Optional) : Can support attribute versioning for historical data. Access Control : Define permissions for setting and updating attributes. Event Logging : Comprehensive event tracking for attribute changes. Key Features \u00b6 Attribute Assignment & Retrieval \u00b6 setAttribute() : Assign a specific value to an attribute key for an entity. getAttribute() : Retrieve the value of an attribute for an entity. Type-Specific Getters : Convenience functions for specific data types (e.g., getStringAttribute , getUintAttribute ). Attribute Ownership & Permissions \u00b6 Entity Identification : Attributes are linked to a unique entity identifier (e.g., tokenId or identityHash ). Authorization : Control who can set and modify attributes (e.g., only the entity owner, specific roles). Data Structure Flexibility \u00b6 Key-Value Pairs : Attributes are typically stored as key-value pairs. Bytes for Flexibility : Using bytes for raw storage offers maximum flexibility for encoding complex data. Interface Definition \u00b6 interface IAttribute { // Events event AttributeSet ( bytes32 indexed entityId , string indexed key , bytes oldValue , bytes newValue ); event AttributeRemoved ( bytes32 indexed entityId , string indexed key , bytes removedValue ); // Structs struct AttributeEntry { bytes value ; address setter ; uint256 timestamp ; } // Core Functions to Set/Get Attributes function setAttribute ( bytes32 entityId , string calldata key , bytes calldata value ) external ; function getAttribute ( bytes32 entityId , string calldata key ) external view returns ( bytes memory ); // Type-specific Getters (for convenience, can be implemented as internal decoding) function getBoolAttribute ( bytes32 entityId , string calldata key ) external view returns ( bool ); function getUintAttribute ( bytes32 entityId , string calldata key ) external view returns ( uint256 ); function getStringAttribute ( bytes32 entityId , string calldata key ) external view returns ( string memory ); function getAddressAttribute ( bytes32 entityId , string calldata key ) external view returns ( address ); function getBytes32Attribute ( bytes32 entityId , string calldata key ) external view returns ( bytes32 ); // Query Functions function hasAttribute ( bytes32 entityId , string calldata key ) external view returns ( bool ); function getAttributeSetter ( bytes32 entityId , string calldata key ) external view returns ( address ); function getAttributeTimestamp ( bytes32 entityId , string calldata key ) external view returns ( uint256 ); } Core Functions \u00b6 setAttribute() \u00b6 Sets or updates an attribute for a given entity. If the attribute already exists, its value is overwritten. Parameters: - entityId : A unique identifier for the entity (e.g., keccak256(abi.encodePacked(tokenId)) ). - key : The name of the attribute (e.g., \"color\", \"powerLevel\", \"status\"). - value : The value of the attribute, encoded as bytes . Access Control: - This function should typically be restricted to the owner of the entityId or an authorized contract. Usage: bytes32 myTokenIdHash = keccak256 ( abi . encodePacked ( 123 )); // Hash of token ID 123 attributeContract . setAttribute ( myTokenIdHash , \"color\" , abi . encodePacked ( \"red\" )); attributeContract . setAttribute ( myTokenIdHash , \"rarity\" , abi . encodePacked ( uint256 ( 5 ))); getAttribute() \u00b6 Retrieves the raw bytes value of an attribute for a specified entity and key. Parameters: - entityId : The unique identifier of the entity. - key : The name of the attribute. Returns: - bytes : The raw bytes value of the attribute. Type-specific getters (e.g., getUintAttribute() ) \u00b6 These functions provide convenience by decoding the raw bytes value into a specific Solidity type. They internally call getAttribute() and then abi.decode() . Parameters: - entityId : The unique identifier of the entity. - key : The name of the attribute. Returns: - The decoded value in the specified type (e.g., uint256 for getUintAttribute ). Implementation Example \u00b6 import \"@openzeppelin/contracts/access/Ownable.sol\" ; // This is a simplified Attribute storage contract. // In a real Gemforce Diamond context, this could be a facet. contract AttributeStorage is IAttribute , Ownable { // entityId => key => AttributeEntry mapping ( bytes32 => mapping ( string => AttributeEntry )) private _attributes ; constructor () { // Owner set to deployer by default due to Ownable } // Modifier to check if the caller is authorized to set attributes for this entityID. // In a production Diamond, this would be highly customized based on entity ownership (e.g., tokenId belongs to msg.sender). // For this generic example, we'll just allow the contract owner to set anything. modifier onlyEntityOwnerOrApproved ( bytes32 entityId ) { // Example check: only contract owner can set. // In a real system, you might check if msg.sender owns the NFT for this entityId. // Or if it's an approved operator. require ( msg.sender == owner (), \"Not authorized to set attribute\" ); _ ; } function setAttribute ( bytes32 entityId , string calldata key , bytes calldata value ) external override onlyEntityOwnerOrApproved ( entityId ) { bytes memory oldValue = _attributes [ entityId ][ key ]. value ; _attributes [ entityId ][ key ] = AttributeEntry ({ value : value , setter : msg.sender , timestamp : block.timestamp }); emit AttributeSet ( entityId , key , oldValue , value ); } function getAttribute ( bytes32 entityId , string calldata key ) external view override returns ( bytes memory ) { return _attributes [ entityId ][ key ]. value ; } function getBoolAttribute ( bytes32 entityId , string calldata key ) external view override returns ( bool ) { bytes memory val = _attributes [ entityId ][ key ]. value ; require ( val . length == 1 , \"Invalid bool attribute data\" ); return abi . decode ( val , ( bool )); } function getUintAttribute ( bytes32 entityId , string calldata key ) external view override returns ( uint256 ) { bytes memory val = _attributes [ entityId ][ key ]. value ; require ( val . length <= 32 , \"Invalid uint attribute data\" ); // uint256 is 32 bytes return abi . decode ( val , ( uint256 )); } function getStringAttribute ( bytes32 entityId , string calldata key ) external view override returns ( string memory ) { bytes memory val = _attributes [ entityId ][ key ]. value ; return abi . decode ( val , ( string )); } function getAddressAttribute ( bytes32 entityId , string calldata key ) external view override returns ( address ) { bytes memory val = _attributes [ entityId ][ key ]. value ; require ( val . length == 20 , \"Invalid address attribute data\" ); return abi . decode ( val , ( address )); } function getBytes32Attribute ( bytes32 entityId , string calldata key ) external view override returns ( bytes32 ) { bytes memory val = _attributes [ entityId ][ key ]. value ; require ( val . length == 32 , \"Invalid bytes32 attribute data\" ); return abi . decode ( val , ( bytes32 )); } function hasAttribute ( bytes32 entityId , string calldata key ) external view override returns ( bool ) { return _attributes [ entityId ][ key ]. value . length > 0 ; } function getAttributeSetter ( bytes32 entityId , string calldata key ) external view override returns ( address ) { return _attributes [ entityId ][ key ]. setter ; } function getAttributeTimestamp ( bytes32 entityId , string calldata key ) external view override returns ( uint256 ) { return _attributes [ entityId ][ key ]. timestamp ; } function removeAttribute ( bytes32 entityId , string calldata key ) external onlyEntityOwnerOrApproved ( entityId ) { bytes memory removedValue = _attributes [ entityId ][ key ]. value ; delete _attributes [ entityId ][ key ]; emit AttributeRemoved ( entityId , key , removedValue ); } } Security Considerations \u00b6 Access Control \u00b6 Authorization for setAttribute : This is paramount. Who can set or modify an attribute for a given entityId ? If entityId refers to an NFT ( tokenId ), typically only the NFT owner or an approved operator should be able to set its attributes. If entityId refers to an identity, only the identity owner or its management keys should be authorized. The provided example uses onlyOwner , which is a simplistic approach for a single contract owner. In a Diamond setup, this would be handled by the OwnershipFacet or a custom access control logic unique to the entity type. Reentrancy : Not directly applicable to this contract as it primarily stores and retrieves data. No external calls are made that could lead to reentrancy. Data Integrity \u00b6 Encoding/Decoding : Ensure consistency in abi.encode when setting attributes and abi.decode when getting them via type-specific functions. Mismatched types can lead to errors or unexpected behavior. Input Validation : Validate input key and value to prevent excessively long strings or malicious data. Best Practices \u00b6 Entity Identification ( entityId ) \u00b6 Hashing : Use bytes32 derived from keccak256(abi.encodePacked(something)) for entityId to consistently refer to the entity whose attributes are being managed. This could be a tokenId , an identityAddress , a projectHash , etc. Clarity : Clearly document what entityId represents in the context of your contract. Data Encoding \u00b6 abi.encodePacked : For simple, fixed-length types (like uint , address , bool ), abi.encodePacked can be more gas-efficient than abi.encode . Complex Data : For complex data structures, encode them into bytes using abi.encode or a custom serialization (e.g., RLP) before storing. Gas Efficiency \u00b6 bytes vs. string : Storing bytes is generally more gas-efficient than string if you control the encoding/decoding. Minimize Storage Writes : Avoid unnecessary setAttribute calls; only update when truly needed. Integration Examples \u00b6 Frontend Integration (React with Ethers.js) \u00b6 import React , { useState } from 'react' ; import { ethers , Contract } from 'ethers' ; import AttributeABI from './AttributeStorage.json' ; // ABI for IAttribute const ATTRIBUTE_CONTRACT_ADDRESS = \"0x...\" ; // Your deployed AttributeStorage contract or Diamond const getSigner = () => new ethers . providers . Web3Provider ( window . ethereum ). getSigner (); const getAttributeContract = () => new Contract ( ATTRIBUTE_CONTRACT_ADDRESS , AttributeABI , getSigner ()); interface SetAttributeProps { entityId : string ; // Hex string '0x...' key : string ; value : string ; // The value to set (e.g., \"red\", \"5\", \"true\") valueType : 'string' | 'uint' | 'bool' | 'address' | 'bytes32' ; // Type hint for encoding } async function handleSetAttribute ({ entityId , key , value , valueType } : SetAttributeProps ) { try { const attributeContract = getAttributeContract (); let encodedValue : Uint8Array ; switch ( valueType ) { case 'string' : encodedValue = ethers . utils . toUtf8Bytes ( value ); break ; case 'uint' : encodedValue = ethers . utils . arrayify ( ethers . utils . hexlify ( ethers . BigNumber . from ( value ))); break ; case 'bool' : encodedValue = ethers . utils . arrayify ( value === 'true' ? '0x01' : '0x00' ); break ; case 'address' : encodedValue = ethers . utils . arrayify ( ethers . utils . getAddress ( value )); break ; case 'bytes32' : encodedValue = ethers . utils . arrayify ( value ); break ; default : throw new Error ( \"Unsupported value type\" ); } const tx = await attributeContract . setAttribute ( entityId , key , encodedValue ); await tx . wait (); alert ( `Attribute ' ${ key } ' set for entity ' ${ entityId } ' to ' ${ value } ' successfully!` ); } catch ( error ) { console . error ( \"Error setting attribute:\" , error ); alert ( \"Failed to set attribute. Check console for details.\" ); } } interface GetAttributeProps { entityId : string ; key : string ; valueType : 'string' | 'uint' | 'bool' | 'address' | 'bytes32' ; } async function handleGetAttribute ({ entityId , key , valueType } : GetAttributeProps ) { try { const attributeContract = getAttributeContract (); let result ; switch ( valueType ) { case 'string' : result = await attributeContract . getStringAttribute ( entityId , key ); break ; case 'uint' : result = ( await attributeContract . getUintAttribute ( entityId , key )). toString (); break ; case 'bool' : result = await attributeContract . getBoolAttribute ( entityId , key ); break ; case 'address' : result = await attributeContract . getAddressAttribute ( entityId , key ); break ; case 'bytes32' : result = await attributeContract . getBytes32Attribute ( entityId , key ); break ; default : throw new Error ( \"Unsupported value type\" ); } alert ( `Attribute ' ${ key } ' for entity ' ${ entityId } ' is: ${ result } ` ); console . log ( `Attribute ' ${ key } ' for entity ' ${ entityId } ' ( ${ valueType } ):` , result ); } catch ( error ) { console . error ( \"Error getting attribute:\" , error ); alert ( \"Failed to get attribute. Check console for details.\" ); } } // Example usage in component: // <button onClick={() => handleSetAttribute({ entityId: \"0x...\", key: \"color\", value: \"blue\", valueType: \"string\" })}>Set Color</button> // <button onClick={() => handleGetAttribute({ entityId: \"0x...\", key: \"color\", valueType: \"string\" })}>Get Color</button> Backend Integration (Node.js with Web3.js) \u00b6 const Web3 = require ( 'web3' ); const AttributeABI = require ( './AttributeStorage.json' ). abi ; // ABI of IAttribute const web3 = new Web3 ( 'YOUR_ETHEREUM_RPC_URL' ); const attributeContractAddress = '0x...' ; // Your deployed AttributeStorage contract const attributeContract = new web3 . eth . Contract ( AttributeABI , attributeContractAddress ); const adminAccount = web3 . eth . accounts . privateKeyToAccount ( 'YOUR_ADMIN_PRIVATE_KEY' ); web3 . eth . accounts . wallet . add ( adminAccount ); async function setTokenAttribute ( tokenId , key , value , type ) { try { const entityId = web3 . utils . keccak256 ( web3 . eth . abi . encodePacked ( tokenId )); let encodedValue ; switch ( type ) { case 'string' : encodedValue = web3 . eth . abi . encodeParameter ( 'string' , value ); break ; case 'uint' : encodedValue = web3 . eth . abi . encodeParameter ( 'uint256' , value ); break ; case 'bool' : encodedValue = web3 . eth . abi . encodeParameter ( 'bool' , value ); break ; case 'address' : encodedValue = web3 . eth . abi . encodeParameter ( 'address' , value ); break ; case 'bytes32' : encodedValue = web3 . eth . abi . encodeParameter ( 'bytes32' , value ); break ; default : throw new Error ( \"Unsupported type for encoding\" ); } // Remove '0x' prefix for bytes if present, as setAttribute expects raw bytes encodedValue = encodedValue . startsWith ( '0x' ) ? encodedValue . substring ( 2 ) : encodedValue ; encodedValue = web3 . utils . hexToBytes ( '0x' + encodedValue ); // Convert to bytes array const tx = attributeContract . methods . setAttribute ( entityId , key , encodedValue ); const gasLimit = await tx . estimateGas ({ from : adminAccount . address }); const receipt = await tx . send ({ from : adminAccount . address , gas : gasLimit }); console . log ( `Attribute set for token ${ tokenId } , key ' ${ key } '. Tx Hash: ${ receipt . transactionHash } ` ); return receipt ; } catch ( error ) { console . error ( \"Backend: Error setting attribute:\" , error ); throw error ; } } async function getTokenAttribute ( tokenId , key , type ) { try { const entityId = web3 . utils . keccak256 ( web3 . eth . abi . encodePacked ( tokenId )); let result ; switch ( type ) { case 'string' : result = await attributeContract . methods . getStringAttribute ( entityId , key ). call (); break ; case 'uint' : result = await attributeContract . methods . getUintAttribute ( entityId , key ). call (); break ; case 'bool' : result = await attributeContract . methods . getBoolAttribute ( entityId , key ). call (); break ; case 'address' : result = await attributeContract . methods . getAddressAttribute ( entityId , key ). call (); break ; case 'bytes32' : result = await attributeContract . methods . getBytes32Attribute ( entityId , key ). call (); break ; default : throw new Error ( \"Unsupported type for decoding\" ); } console . log ( `Attribute for token ${ tokenId } , key ' ${ key } ' is: ${ result } ` ); return result ; } catch ( error ) { console . error ( \"Backend: Error getting attribute:\" , error ); throw error ; } } // Example usage // setTokenAttribute(123, \"background\", \"forest\", \"string\"); // getTokenAttribute(123, \"background\", \"string\"); Related Documentation \u00b6 Attribute Library Ownable Contract Solidity ABI Encoding and Decoding Standards Compliance \u00b6 Ownable : Utilizes OpenZeppelin's Ownable for administrative access control.","title":"IAttribute"},{"location":"smart-contracts/interfaces/iattribute/#iattribute-interface","text":"The IAttribute interface defines the standard for managing dynamic attributes associated with tokens or other entities within the Gemforce ecosystem. This interface provides a flexible and extensible way to store, retrieve, and update various properties or characteristics without modifying the core token contract logic.","title":"IAttribute Interface"},{"location":"smart-contracts/interfaces/iattribute/#overview","text":"IAttribute provides: Dynamic Attribute Management : Store and retrieve custom attributes for any entity (e.g., token IDs, identity hashes). Attribute Types : Support for different data types (e.g., string, uint, bool, bytes). Versioning (Optional) : Can support attribute versioning for historical data. Access Control : Define permissions for setting and updating attributes. Event Logging : Comprehensive event tracking for attribute changes.","title":"Overview"},{"location":"smart-contracts/interfaces/iattribute/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/iattribute/#attribute-assignment-retrieval","text":"setAttribute() : Assign a specific value to an attribute key for an entity. getAttribute() : Retrieve the value of an attribute for an entity. Type-Specific Getters : Convenience functions for specific data types (e.g., getStringAttribute , getUintAttribute ).","title":"Attribute Assignment &amp; Retrieval"},{"location":"smart-contracts/interfaces/iattribute/#attribute-ownership-permissions","text":"Entity Identification : Attributes are linked to a unique entity identifier (e.g., tokenId or identityHash ). Authorization : Control who can set and modify attributes (e.g., only the entity owner, specific roles).","title":"Attribute Ownership &amp; Permissions"},{"location":"smart-contracts/interfaces/iattribute/#data-structure-flexibility","text":"Key-Value Pairs : Attributes are typically stored as key-value pairs. Bytes for Flexibility : Using bytes for raw storage offers maximum flexibility for encoding complex data.","title":"Data Structure Flexibility"},{"location":"smart-contracts/interfaces/iattribute/#interface-definition","text":"interface IAttribute { // Events event AttributeSet ( bytes32 indexed entityId , string indexed key , bytes oldValue , bytes newValue ); event AttributeRemoved ( bytes32 indexed entityId , string indexed key , bytes removedValue ); // Structs struct AttributeEntry { bytes value ; address setter ; uint256 timestamp ; } // Core Functions to Set/Get Attributes function setAttribute ( bytes32 entityId , string calldata key , bytes calldata value ) external ; function getAttribute ( bytes32 entityId , string calldata key ) external view returns ( bytes memory ); // Type-specific Getters (for convenience, can be implemented as internal decoding) function getBoolAttribute ( bytes32 entityId , string calldata key ) external view returns ( bool ); function getUintAttribute ( bytes32 entityId , string calldata key ) external view returns ( uint256 ); function getStringAttribute ( bytes32 entityId , string calldata key ) external view returns ( string memory ); function getAddressAttribute ( bytes32 entityId , string calldata key ) external view returns ( address ); function getBytes32Attribute ( bytes32 entityId , string calldata key ) external view returns ( bytes32 ); // Query Functions function hasAttribute ( bytes32 entityId , string calldata key ) external view returns ( bool ); function getAttributeSetter ( bytes32 entityId , string calldata key ) external view returns ( address ); function getAttributeTimestamp ( bytes32 entityId , string calldata key ) external view returns ( uint256 ); }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/iattribute/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/iattribute/#setattribute","text":"Sets or updates an attribute for a given entity. If the attribute already exists, its value is overwritten. Parameters: - entityId : A unique identifier for the entity (e.g., keccak256(abi.encodePacked(tokenId)) ). - key : The name of the attribute (e.g., \"color\", \"powerLevel\", \"status\"). - value : The value of the attribute, encoded as bytes . Access Control: - This function should typically be restricted to the owner of the entityId or an authorized contract. Usage: bytes32 myTokenIdHash = keccak256 ( abi . encodePacked ( 123 )); // Hash of token ID 123 attributeContract . setAttribute ( myTokenIdHash , \"color\" , abi . encodePacked ( \"red\" )); attributeContract . setAttribute ( myTokenIdHash , \"rarity\" , abi . encodePacked ( uint256 ( 5 )));","title":"setAttribute()"},{"location":"smart-contracts/interfaces/iattribute/#getattribute","text":"Retrieves the raw bytes value of an attribute for a specified entity and key. Parameters: - entityId : The unique identifier of the entity. - key : The name of the attribute. Returns: - bytes : The raw bytes value of the attribute.","title":"getAttribute()"},{"location":"smart-contracts/interfaces/iattribute/#type-specific-getters-eg-getuintattribute","text":"These functions provide convenience by decoding the raw bytes value into a specific Solidity type. They internally call getAttribute() and then abi.decode() . Parameters: - entityId : The unique identifier of the entity. - key : The name of the attribute. Returns: - The decoded value in the specified type (e.g., uint256 for getUintAttribute ).","title":"Type-specific getters (e.g., getUintAttribute())"},{"location":"smart-contracts/interfaces/iattribute/#implementation-example","text":"import \"@openzeppelin/contracts/access/Ownable.sol\" ; // This is a simplified Attribute storage contract. // In a real Gemforce Diamond context, this could be a facet. contract AttributeStorage is IAttribute , Ownable { // entityId => key => AttributeEntry mapping ( bytes32 => mapping ( string => AttributeEntry )) private _attributes ; constructor () { // Owner set to deployer by default due to Ownable } // Modifier to check if the caller is authorized to set attributes for this entityID. // In a production Diamond, this would be highly customized based on entity ownership (e.g., tokenId belongs to msg.sender). // For this generic example, we'll just allow the contract owner to set anything. modifier onlyEntityOwnerOrApproved ( bytes32 entityId ) { // Example check: only contract owner can set. // In a real system, you might check if msg.sender owns the NFT for this entityId. // Or if it's an approved operator. require ( msg.sender == owner (), \"Not authorized to set attribute\" ); _ ; } function setAttribute ( bytes32 entityId , string calldata key , bytes calldata value ) external override onlyEntityOwnerOrApproved ( entityId ) { bytes memory oldValue = _attributes [ entityId ][ key ]. value ; _attributes [ entityId ][ key ] = AttributeEntry ({ value : value , setter : msg.sender , timestamp : block.timestamp }); emit AttributeSet ( entityId , key , oldValue , value ); } function getAttribute ( bytes32 entityId , string calldata key ) external view override returns ( bytes memory ) { return _attributes [ entityId ][ key ]. value ; } function getBoolAttribute ( bytes32 entityId , string calldata key ) external view override returns ( bool ) { bytes memory val = _attributes [ entityId ][ key ]. value ; require ( val . length == 1 , \"Invalid bool attribute data\" ); return abi . decode ( val , ( bool )); } function getUintAttribute ( bytes32 entityId , string calldata key ) external view override returns ( uint256 ) { bytes memory val = _attributes [ entityId ][ key ]. value ; require ( val . length <= 32 , \"Invalid uint attribute data\" ); // uint256 is 32 bytes return abi . decode ( val , ( uint256 )); } function getStringAttribute ( bytes32 entityId , string calldata key ) external view override returns ( string memory ) { bytes memory val = _attributes [ entityId ][ key ]. value ; return abi . decode ( val , ( string )); } function getAddressAttribute ( bytes32 entityId , string calldata key ) external view override returns ( address ) { bytes memory val = _attributes [ entityId ][ key ]. value ; require ( val . length == 20 , \"Invalid address attribute data\" ); return abi . decode ( val , ( address )); } function getBytes32Attribute ( bytes32 entityId , string calldata key ) external view override returns ( bytes32 ) { bytes memory val = _attributes [ entityId ][ key ]. value ; require ( val . length == 32 , \"Invalid bytes32 attribute data\" ); return abi . decode ( val , ( bytes32 )); } function hasAttribute ( bytes32 entityId , string calldata key ) external view override returns ( bool ) { return _attributes [ entityId ][ key ]. value . length > 0 ; } function getAttributeSetter ( bytes32 entityId , string calldata key ) external view override returns ( address ) { return _attributes [ entityId ][ key ]. setter ; } function getAttributeTimestamp ( bytes32 entityId , string calldata key ) external view override returns ( uint256 ) { return _attributes [ entityId ][ key ]. timestamp ; } function removeAttribute ( bytes32 entityId , string calldata key ) external onlyEntityOwnerOrApproved ( entityId ) { bytes memory removedValue = _attributes [ entityId ][ key ]. value ; delete _attributes [ entityId ][ key ]; emit AttributeRemoved ( entityId , key , removedValue ); } }","title":"Implementation Example"},{"location":"smart-contracts/interfaces/iattribute/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/iattribute/#access-control","text":"Authorization for setAttribute : This is paramount. Who can set or modify an attribute for a given entityId ? If entityId refers to an NFT ( tokenId ), typically only the NFT owner or an approved operator should be able to set its attributes. If entityId refers to an identity, only the identity owner or its management keys should be authorized. The provided example uses onlyOwner , which is a simplistic approach for a single contract owner. In a Diamond setup, this would be handled by the OwnershipFacet or a custom access control logic unique to the entity type. Reentrancy : Not directly applicable to this contract as it primarily stores and retrieves data. No external calls are made that could lead to reentrancy.","title":"Access Control"},{"location":"smart-contracts/interfaces/iattribute/#data-integrity","text":"Encoding/Decoding : Ensure consistency in abi.encode when setting attributes and abi.decode when getting them via type-specific functions. Mismatched types can lead to errors or unexpected behavior. Input Validation : Validate input key and value to prevent excessively long strings or malicious data.","title":"Data Integrity"},{"location":"smart-contracts/interfaces/iattribute/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/interfaces/iattribute/#entity-identification-entityid","text":"Hashing : Use bytes32 derived from keccak256(abi.encodePacked(something)) for entityId to consistently refer to the entity whose attributes are being managed. This could be a tokenId , an identityAddress , a projectHash , etc. Clarity : Clearly document what entityId represents in the context of your contract.","title":"Entity Identification (entityId)"},{"location":"smart-contracts/interfaces/iattribute/#data-encoding","text":"abi.encodePacked : For simple, fixed-length types (like uint , address , bool ), abi.encodePacked can be more gas-efficient than abi.encode . Complex Data : For complex data structures, encode them into bytes using abi.encode or a custom serialization (e.g., RLP) before storing.","title":"Data Encoding"},{"location":"smart-contracts/interfaces/iattribute/#gas-efficiency","text":"bytes vs. string : Storing bytes is generally more gas-efficient than string if you control the encoding/decoding. Minimize Storage Writes : Avoid unnecessary setAttribute calls; only update when truly needed.","title":"Gas Efficiency"},{"location":"smart-contracts/interfaces/iattribute/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/iattribute/#frontend-integration-react-with-ethersjs","text":"import React , { useState } from 'react' ; import { ethers , Contract } from 'ethers' ; import AttributeABI from './AttributeStorage.json' ; // ABI for IAttribute const ATTRIBUTE_CONTRACT_ADDRESS = \"0x...\" ; // Your deployed AttributeStorage contract or Diamond const getSigner = () => new ethers . providers . Web3Provider ( window . ethereum ). getSigner (); const getAttributeContract = () => new Contract ( ATTRIBUTE_CONTRACT_ADDRESS , AttributeABI , getSigner ()); interface SetAttributeProps { entityId : string ; // Hex string '0x...' key : string ; value : string ; // The value to set (e.g., \"red\", \"5\", \"true\") valueType : 'string' | 'uint' | 'bool' | 'address' | 'bytes32' ; // Type hint for encoding } async function handleSetAttribute ({ entityId , key , value , valueType } : SetAttributeProps ) { try { const attributeContract = getAttributeContract (); let encodedValue : Uint8Array ; switch ( valueType ) { case 'string' : encodedValue = ethers . utils . toUtf8Bytes ( value ); break ; case 'uint' : encodedValue = ethers . utils . arrayify ( ethers . utils . hexlify ( ethers . BigNumber . from ( value ))); break ; case 'bool' : encodedValue = ethers . utils . arrayify ( value === 'true' ? '0x01' : '0x00' ); break ; case 'address' : encodedValue = ethers . utils . arrayify ( ethers . utils . getAddress ( value )); break ; case 'bytes32' : encodedValue = ethers . utils . arrayify ( value ); break ; default : throw new Error ( \"Unsupported value type\" ); } const tx = await attributeContract . setAttribute ( entityId , key , encodedValue ); await tx . wait (); alert ( `Attribute ' ${ key } ' set for entity ' ${ entityId } ' to ' ${ value } ' successfully!` ); } catch ( error ) { console . error ( \"Error setting attribute:\" , error ); alert ( \"Failed to set attribute. Check console for details.\" ); } } interface GetAttributeProps { entityId : string ; key : string ; valueType : 'string' | 'uint' | 'bool' | 'address' | 'bytes32' ; } async function handleGetAttribute ({ entityId , key , valueType } : GetAttributeProps ) { try { const attributeContract = getAttributeContract (); let result ; switch ( valueType ) { case 'string' : result = await attributeContract . getStringAttribute ( entityId , key ); break ; case 'uint' : result = ( await attributeContract . getUintAttribute ( entityId , key )). toString (); break ; case 'bool' : result = await attributeContract . getBoolAttribute ( entityId , key ); break ; case 'address' : result = await attributeContract . getAddressAttribute ( entityId , key ); break ; case 'bytes32' : result = await attributeContract . getBytes32Attribute ( entityId , key ); break ; default : throw new Error ( \"Unsupported value type\" ); } alert ( `Attribute ' ${ key } ' for entity ' ${ entityId } ' is: ${ result } ` ); console . log ( `Attribute ' ${ key } ' for entity ' ${ entityId } ' ( ${ valueType } ):` , result ); } catch ( error ) { console . error ( \"Error getting attribute:\" , error ); alert ( \"Failed to get attribute. Check console for details.\" ); } } // Example usage in component: // <button onClick={() => handleSetAttribute({ entityId: \"0x...\", key: \"color\", value: \"blue\", valueType: \"string\" })}>Set Color</button> // <button onClick={() => handleGetAttribute({ entityId: \"0x...\", key: \"color\", valueType: \"string\" })}>Get Color</button>","title":"Frontend Integration (React with Ethers.js)"},{"location":"smart-contracts/interfaces/iattribute/#backend-integration-nodejs-with-web3js","text":"const Web3 = require ( 'web3' ); const AttributeABI = require ( './AttributeStorage.json' ). abi ; // ABI of IAttribute const web3 = new Web3 ( 'YOUR_ETHEREUM_RPC_URL' ); const attributeContractAddress = '0x...' ; // Your deployed AttributeStorage contract const attributeContract = new web3 . eth . Contract ( AttributeABI , attributeContractAddress ); const adminAccount = web3 . eth . accounts . privateKeyToAccount ( 'YOUR_ADMIN_PRIVATE_KEY' ); web3 . eth . accounts . wallet . add ( adminAccount ); async function setTokenAttribute ( tokenId , key , value , type ) { try { const entityId = web3 . utils . keccak256 ( web3 . eth . abi . encodePacked ( tokenId )); let encodedValue ; switch ( type ) { case 'string' : encodedValue = web3 . eth . abi . encodeParameter ( 'string' , value ); break ; case 'uint' : encodedValue = web3 . eth . abi . encodeParameter ( 'uint256' , value ); break ; case 'bool' : encodedValue = web3 . eth . abi . encodeParameter ( 'bool' , value ); break ; case 'address' : encodedValue = web3 . eth . abi . encodeParameter ( 'address' , value ); break ; case 'bytes32' : encodedValue = web3 . eth . abi . encodeParameter ( 'bytes32' , value ); break ; default : throw new Error ( \"Unsupported type for encoding\" ); } // Remove '0x' prefix for bytes if present, as setAttribute expects raw bytes encodedValue = encodedValue . startsWith ( '0x' ) ? encodedValue . substring ( 2 ) : encodedValue ; encodedValue = web3 . utils . hexToBytes ( '0x' + encodedValue ); // Convert to bytes array const tx = attributeContract . methods . setAttribute ( entityId , key , encodedValue ); const gasLimit = await tx . estimateGas ({ from : adminAccount . address }); const receipt = await tx . send ({ from : adminAccount . address , gas : gasLimit }); console . log ( `Attribute set for token ${ tokenId } , key ' ${ key } '. Tx Hash: ${ receipt . transactionHash } ` ); return receipt ; } catch ( error ) { console . error ( \"Backend: Error setting attribute:\" , error ); throw error ; } } async function getTokenAttribute ( tokenId , key , type ) { try { const entityId = web3 . utils . keccak256 ( web3 . eth . abi . encodePacked ( tokenId )); let result ; switch ( type ) { case 'string' : result = await attributeContract . methods . getStringAttribute ( entityId , key ). call (); break ; case 'uint' : result = await attributeContract . methods . getUintAttribute ( entityId , key ). call (); break ; case 'bool' : result = await attributeContract . methods . getBoolAttribute ( entityId , key ). call (); break ; case 'address' : result = await attributeContract . methods . getAddressAttribute ( entityId , key ). call (); break ; case 'bytes32' : result = await attributeContract . methods . getBytes32Attribute ( entityId , key ). call (); break ; default : throw new Error ( \"Unsupported type for decoding\" ); } console . log ( `Attribute for token ${ tokenId } , key ' ${ key } ' is: ${ result } ` ); return result ; } catch ( error ) { console . error ( \"Backend: Error getting attribute:\" , error ); throw error ; } } // Example usage // setTokenAttribute(123, \"background\", \"forest\", \"string\"); // getTokenAttribute(123, \"background\", \"string\");","title":"Backend Integration (Node.js with Web3.js)"},{"location":"smart-contracts/interfaces/iattribute/#related-documentation","text":"Attribute Library Ownable Contract Solidity ABI Encoding and Decoding","title":"Related Documentation"},{"location":"smart-contracts/interfaces/iattribute/#standards-compliance","text":"Ownable : Utilizes OpenZeppelin's Ownable for administrative access control.","title":"Standards Compliance"},{"location":"smart-contracts/interfaces/icarbon-credit/","text":"ICarbonCredit Interface \u00b6 Overview \u00b6 The ICarbonCredit interface defines the standard contract for managing carbon credits associated with ERC721 tokens within the Gemforce platform. This interface enables the tokenization of environmental assets, allowing NFTs to represent carbon credits that can be tracked, managed, and retired for environmental impact purposes. Key Features \u00b6 Carbon Credit Tokenization : Associate carbon credit balances with ERC721 tokens Credit Retirement : Permanently retire carbon credits to prevent double-counting Batch Operations : Efficiently manage multiple tokens simultaneously Status Tracking : Monitor active vs. retired carbon credit status Environmental Compliance : Support for carbon offset and sustainability programs Interface Definition \u00b6 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import { CarbonCreditStatus } from \"../libraries/CarbonCreditLib.sol\" ; interface ICarbonCredit { // Events event CarbonCreditsInitialized ( uint256 indexed tokenId , uint256 initialBalance ); event CarbonCreditsRetired ( uint256 indexed tokenId , uint256 amount , uint256 remainingBalance ); // Core Functions function initializeCarbonCredit ( uint256 tokenId , uint256 initialBalance ) external ; function retireCarbonCredits ( uint256 tokenId , uint256 amount ) external ; function getCarbonCreditStatus ( uint256 tokenId ) external view returns ( CarbonCreditStatus ); function getCarbonCreditBalance ( uint256 tokenId ) external view returns ( uint256 ); // Batch Operations function batchInitializeCarbonCredits ( uint256 [] calldata tokenIds , uint256 [] calldata initialBalances ) external ; function getAllCarbonCreditBalances ( uint256 [] calldata tokenIds ) external view returns ( uint256 [] memory ); } Core Functions \u00b6 Carbon Credit Initialization \u00b6 initializeCarbonCredit() \u00b6 function initializeCarbonCredit ( uint256 tokenId , uint256 initialBalance ) external Purpose : Initialize carbon credit balance for a specific ERC721 token. Parameters : - tokenId (uint256): The ID of the ERC721 token to associate with carbon credits - initialBalance (uint256): The initial balance of carbon credits (must be > 0) Requirements : - Token must exist and have a valid owner - Carbon credits must not already be initialized for this token - Initial balance must be greater than zero - Caller must have appropriate permissions Events Emitted : - CarbonCreditsInitialized with token ID and initial balance Example Usage : // Initialize carbon credits for a newly minted environmental NFT uint256 tokenId = 1 ; uint256 initialCredits = 1000 ; // 1000 carbon credits ICarbonCredit ( diamond ). initializeCarbonCredit ( tokenId , initialCredits ); console . log ( \"Initialized\" , initialCredits , \"carbon credits for token\" , tokenId ); Carbon Credit Retirement \u00b6 retireCarbonCredits() \u00b6 function retireCarbonCredits ( uint256 tokenId , uint256 amount ) external Purpose : Permanently retire carbon credits to prevent double-counting and demonstrate environmental impact. Parameters : - tokenId (uint256): The ID of the ERC721 token containing carbon credits - amount (uint256): The amount of carbon credits to retire (must be whole number) Requirements : - Token must have sufficient carbon credit balance - Amount must be greater than zero - Amount must be less than or equal to current balance - Caller must have appropriate permissions Events Emitted : - CarbonCreditsRetired with token ID, retired amount, and remaining balance Example Usage : // Retire carbon credits to offset emissions uint256 tokenId = 1 ; uint256 retireAmount = 250 ; // Retire 250 carbon credits // Check current balance first uint256 currentBalance = ICarbonCredit ( diamond ). getCarbonCreditBalance ( tokenId ); require ( currentBalance >= retireAmount , \"Insufficient carbon credits\" ); // Retire the credits ICarbonCredit ( diamond ). retireCarbonCredits ( tokenId , retireAmount ); console . log ( \"Retired\" , retireAmount , \"carbon credits from token\" , tokenId ); Status and Balance Queries \u00b6 getCarbonCreditStatus() \u00b6 function getCarbonCreditStatus ( uint256 tokenId ) external view returns ( CarbonCreditStatus ) Purpose : Get the current status of carbon credits for a token. Parameters : - tokenId (uint256): The ID of the ERC721 token Returns : - CarbonCreditStatus enum value: - ACTIVE : Token has remaining carbon credits - RETIRED : All carbon credits have been retired Example Usage : // Check carbon credit status uint256 tokenId = 1 ; CarbonCreditStatus status = ICarbonCredit ( diamond ). getCarbonCreditStatus ( tokenId ); if ( status == CarbonCreditStatus . ACTIVE ) { console . log ( \"Token\" , tokenId , \"has active carbon credits\" ); } else { console . log ( \"Token\" , tokenId , \"carbon credits are fully retired\" ); } getCarbonCreditBalance() \u00b6 function getCarbonCreditBalance ( uint256 tokenId ) external view returns ( uint256 ) Purpose : Get the current carbon credit balance for a specific token. Parameters : - tokenId (uint256): The ID of the ERC721 token Returns : Current balance of carbon credits for the token Example Usage : // Check current balance uint256 tokenId = 1 ; uint256 balance = ICarbonCredit ( diamond ). getCarbonCreditBalance ( tokenId ); console . log ( \"Token\" , tokenId , \"has\" , balance , \"carbon credits remaining\" ); Batch Operations \u00b6 Batch Initialization \u00b6 batchInitializeCarbonCredits() \u00b6 function batchInitializeCarbonCredits ( uint256 [] calldata tokenIds , uint256 [] calldata initialBalances ) external Purpose : Initialize carbon credits for multiple tokens in a single transaction. Parameters : - tokenIds (uint256[]): Array of ERC721 token IDs - initialBalances (uint256[]): Array of initial balances corresponding to token IDs Requirements : - Arrays must have the same length - All tokens must exist and not have carbon credits initialized - All initial balances must be greater than zero - Caller must have appropriate permissions Gas Optimization : More efficient than multiple individual calls Example Usage : // Batch initialize carbon credits for multiple environmental NFTs uint256 [] memory tokenIds = new uint256 []( 3 ); tokenIds [ 0 ] = 1 ; tokenIds [ 1 ] = 2 ; tokenIds [ 2 ] = 3 ; uint256 [] memory initialBalances = new uint256 []( 3 ); initialBalances [ 0 ] = 1000 ; // Forest conservation project initialBalances [ 1 ] = 500 ; // Solar energy project initialBalances [ 2 ] = 750 ; // Wind energy project ICarbonCredit ( diamond ). batchInitializeCarbonCredits ( tokenIds , initialBalances ); console . log ( \"Batch initialized carbon credits for\" , tokenIds . length , \"tokens\" ); Batch Balance Query \u00b6 getAllCarbonCreditBalances() \u00b6 function getAllCarbonCreditBalances ( uint256 [] calldata tokenIds ) external view returns ( uint256 [] memory ) Purpose : Get carbon credit balances for multiple tokens efficiently. Parameters : - tokenIds (uint256[]): Array of ERC721 token IDs to query Returns : Array of carbon credit balances corresponding to the input token IDs Example Usage : // Get balances for multiple tokens uint256 [] memory tokenIds = new uint256 []( 3 ); tokenIds [ 0 ] = 1 ; tokenIds [ 1 ] = 2 ; tokenIds [ 2 ] = 3 ; uint256 [] memory balances = ICarbonCredit ( diamond ). getAllCarbonCreditBalances ( tokenIds ); for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { console . log ( \"Token\" , tokenIds [ i ], \"balance:\" , balances [ i ]); } Integration Examples \u00b6 Environmental NFT Marketplace \u00b6 // Integration with environmental NFT marketplace contract EnvironmentalMarketplace { ICarbonCredit public carbonCredit ; IERC721 public environmentalNFT ; struct EnvironmentalListing { uint256 tokenId ; uint256 price ; uint256 carbonCredits ; address seller ; bool active ; } mapping ( uint256 => EnvironmentalListing ) public listings ; event EnvironmentalNFTListed ( uint256 indexed tokenId , uint256 price , uint256 carbonCredits , address indexed seller ); event CarbonCreditsRetiredOnPurchase ( uint256 indexed tokenId , uint256 retiredAmount , address indexed buyer ); constructor ( address _carbonCredit , address _environmentalNFT ) { carbonCredit = ICarbonCredit ( _carbonCredit ); environmentalNFT = IERC721 ( _environmentalNFT ); } function listEnvironmentalNFT ( uint256 tokenId , uint256 price , bool retireCreditsOnSale ) external { require ( environmentalNFT . ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); uint256 creditBalance = carbonCredit . getCarbonCreditBalance ( tokenId ); require ( creditBalance > 0 , \"No carbon credits associated\" ); listings [ tokenId ] = EnvironmentalListing ({ tokenId : tokenId , price : price , carbonCredits : creditBalance , seller : msg.sender , active : true }); emit EnvironmentalNFTListed ( tokenId , price , creditBalance , msg.sender ); } function purchaseEnvironmentalNFT ( uint256 tokenId , uint256 creditsToRetire ) external payable { EnvironmentalListing storage listing = listings [ tokenId ]; require ( listing . active , \"Listing not active\" ); require ( msg.value >= listing . price , \"Insufficient payment\" ); uint256 currentCredits = carbonCredit . getCarbonCreditBalance ( tokenId ); require ( creditsToRetire <= currentCredits , \"Cannot retire more credits than available\" ); // Transfer NFT environmentalNFT . safeTransferFrom ( listing . seller , msg.sender , tokenId ); // Retire carbon credits if requested if ( creditsToRetire > 0 ) { carbonCredit . retireCarbonCredits ( tokenId , creditsToRetire ); emit CarbonCreditsRetiredOnPurchase ( tokenId , creditsToRetire , msg.sender ); } // Transfer payment payable ( listing . seller ). transfer ( msg.value ); // Deactivate listing listing . active = false ; } function getListingWithCarbonInfo ( uint256 tokenId ) external view returns ( EnvironmentalListing memory listing , uint256 currentCarbonBalance , CarbonCreditStatus status ) { listing = listings [ tokenId ]; currentCarbonBalance = carbonCredit . getCarbonCreditBalance ( tokenId ); status = carbonCredit . getCarbonCreditStatus ( tokenId ); } } Carbon Offset Program \u00b6 // Automated carbon offset program contract CarbonOffsetProgram { ICarbonCredit public carbonCredit ; struct OffsetProject { string name ; string description ; uint256 [] tokenIds ; uint256 totalCredits ; uint256 retiredCredits ; address projectOwner ; bool active ; } mapping ( uint256 => OffsetProject ) public projects ; mapping ( address => uint256 []) public userOffsets ; uint256 public nextProjectId ; event ProjectCreated ( uint256 indexed projectId , string name , address indexed owner ); event CreditsRetiredForOffset ( uint256 indexed projectId , uint256 amount , address indexed offsetter ); event ProjectCompleted ( uint256 indexed projectId , uint256 totalRetired ); function createOffsetProject ( string memory name , string memory description , uint256 [] memory tokenIds ) external returns ( uint256 projectId ) { projectId = nextProjectId ++ ; uint256 totalCredits = 0 ; for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { uint256 balance = carbonCredit . getCarbonCreditBalance ( tokenIds [ i ]); require ( balance > 0 , \"Token has no carbon credits\" ); totalCredits += balance ; } projects [ projectId ] = OffsetProject ({ name : name , description : description , tokenIds : tokenIds , totalCredits : totalCredits , retiredCredits : 0 , projectOwner : msg.sender , active : true }); emit ProjectCreated ( projectId , name , msg.sender ); } function offsetEmissions ( uint256 projectId , uint256 creditsToOffset ) external payable { OffsetProject storage project = projects [ projectId ]; require ( project . active , \"Project not active\" ); require ( creditsToOffset > 0 , \"Must offset at least 1 credit\" ); uint256 availableCredits = project . totalCredits - project . retiredCredits ; require ( creditsToOffset <= availableCredits , \"Insufficient credits in project\" ); // Calculate payment (simplified - would integrate with pricing oracle) uint256 costPerCredit = 10 ether ; // $10 per credit in wei uint256 totalCost = creditsToOffset * costPerCredit ; require ( msg.value >= totalCost , \"Insufficient payment\" ); // Retire credits from project tokens uint256 creditsRemaining = creditsToOffset ; for ( uint256 i = 0 ; i < project . tokenIds . length && creditsRemaining > 0 ; i ++ ) { uint256 tokenId = project . tokenIds [ i ]; uint256 tokenBalance = carbonCredit . getCarbonCreditBalance ( tokenId ); if ( tokenBalance > 0 ) { uint256 toRetire = creditsRemaining > tokenBalance ? tokenBalance : creditsRemaining ; carbonCredit . retireCarbonCredits ( tokenId , toRetire ); creditsRemaining -= toRetire ; } } project . retiredCredits += creditsToOffset ; userOffsets [ msg.sender ]. push ( creditsToOffset ); // Transfer payment to project owner payable ( project . projectOwner ). transfer ( totalCost ); emit CreditsRetiredForOffset ( projectId , creditsToOffset , msg.sender ); // Check if project is completed if ( project . retiredCredits >= project . totalCredits ) { project . active = false ; emit ProjectCompleted ( projectId , project . retiredCredits ); } } function getProjectStatus ( uint256 projectId ) external view returns ( string memory name , uint256 totalCredits , uint256 retiredCredits , uint256 availableCredits , bool active , uint256 [] memory tokenBalances ) { OffsetProject memory project = projects [ projectId ]; name = project . name ; totalCredits = project . totalCredits ; retiredCredits = project . retiredCredits ; availableCredits = totalCredits - retiredCredits ; active = project . active ; tokenBalances = carbonCredit . getAllCarbonCreditBalances ( project . tokenIds ); } function getUserOffsetHistory ( address user ) external view returns ( uint256 [] memory ) { return userOffsets [ user ]; } } Carbon Credit Analytics Dashboard \u00b6 // Analytics and reporting for carbon credits contract CarbonCreditAnalytics { ICarbonCredit public carbonCredit ; struct AnalyticsData { uint256 totalTokensWithCredits ; uint256 totalActiveCredits ; uint256 totalRetiredCredits ; uint256 averageCreditsPerToken ; uint256 retirementRate ; } mapping ( uint256 => uint256 ) public tokenInitialBalances ; mapping ( uint256 => uint256 ) public tokenRetirementHistory ; uint256 [] public trackedTokens ; event AnalyticsUpdated ( AnalyticsData data ); event TokenAddedToTracking ( uint256 indexed tokenId , uint256 initialBalance ); function addTokenToTracking ( uint256 tokenId ) external { uint256 balance = carbonCredit . getCarbonCreditBalance ( tokenId ); require ( balance > 0 , \"Token has no carbon credits\" ); tokenInitialBalances [ tokenId ] = balance ; trackedTokens . push ( tokenId ); emit TokenAddedToTracking ( tokenId , balance ); } function updateAnalytics () external returns ( AnalyticsData memory data ) { uint256 [] memory balances = carbonCredit . getAllCarbonCreditBalances ( trackedTokens ); uint256 totalActive = 0 ; uint256 totalRetired = 0 ; uint256 tokensWithCredits = 0 ; for ( uint256 i = 0 ; i < trackedTokens . length ; i ++ ) { uint256 tokenId = trackedTokens [ i ]; uint256 currentBalance = balances [ i ]; uint256 initialBalance = tokenInitialBalances [ tokenId ]; if ( currentBalance > 0 ) { tokensWithCredits ++ ; } totalActive += currentBalance ; totalRetired += ( initialBalance - currentBalance ); } data = AnalyticsData ({ totalTokensWithCredits : tokensWithCredits , totalActiveCredits : totalActive , totalRetiredCredits : totalRetired , averageCreditsPerToken : tokensWithCredits > 0 ? totalActive / tokensWithCredits : 0 , retirementRate : ( totalActive + totalRetired ) > 0 ? ( totalRetired * 100 ) / ( totalActive + totalRetired ) : 0 }); emit AnalyticsUpdated ( data ); } function getTokenRetirementHistory ( uint256 tokenId ) external view returns ( uint256 initialBalance , uint256 currentBalance , uint256 totalRetired , uint256 retirementPercentage ) { initialBalance = tokenInitialBalances [ tokenId ]; currentBalance = carbonCredit . getCarbonCreditBalance ( tokenId ); totalRetired = initialBalance - currentBalance ; retirementPercentage = initialBalance > 0 ? ( totalRetired * 100 ) / initialBalance : 0 ; } function generateRetirementReport ( uint256 [] memory tokenIds ) external view returns ( uint256 totalInitial , uint256 totalCurrent , uint256 totalRetired , uint256 overallRetirementRate ) { uint256 [] memory balances = carbonCredit . getAllCarbonCreditBalances ( tokenIds ); for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { uint256 initial = tokenInitialBalances [ tokenIds [ i ]]; uint256 current = balances [ i ]; totalInitial += initial ; totalCurrent += current ; totalRetired += ( initial - current ); } overallRetirementRate = totalInitial > 0 ? ( totalRetired * 100 ) / totalInitial : 0 ; } } Events \u00b6 Carbon Credit Lifecycle Events \u00b6 event CarbonCreditsInitialized ( uint256 indexed tokenId , uint256 initialBalance ); event CarbonCreditsRetired ( uint256 indexed tokenId , uint256 amount , uint256 remainingBalance ); Data Types \u00b6 CarbonCreditStatus Enum \u00b6 enum CarbonCreditStatus { ACTIVE , // Token has remaining carbon credits RETIRED // All carbon credits have been retired } Security Considerations \u00b6 Access Control \u00b6 Initialization requires appropriate permissions Retirement operations must be authorized Token existence validation before operations Prevention of double initialization Financial Security \u00b6 Accurate balance tracking and calculations Prevention of over-retirement Secure state transitions Immutable retirement records Environmental Integrity \u00b6 Prevention of double-counting retired credits Permanent retirement to ensure environmental impact Transparent tracking of credit lifecycle Compliance with carbon accounting standards Gas Optimization \u00b6 Efficient Operations \u00b6 Batch operations for multiple tokens Optimized storage layout for balances Minimal external calls in view functions Efficient array operations for bulk queries Storage Optimization \u00b6 Packed storage structures where possible Efficient mapping usage for balance tracking Optimized batch operations Cached calculations for frequently accessed data Error Handling \u00b6 Common Errors \u00b6 Token does not exist Carbon credits already initialized Insufficient balance for retirement Invalid amounts (zero or negative) Array length mismatches in batch operations Best Practices \u00b6 Validate token existence before operations Check balances before retirement Validate array parameters in batch operations Provide clear error messages for debugging Handle edge cases gracefully Testing Considerations \u00b6 Unit Tests \u00b6 Interface compliance verification Balance initialization and tracking Retirement functionality and validation Batch operation efficiency and correctness Event emission verification Integration Tests \u00b6 Integration with ERC721 contracts Environmental marketplace workflows Carbon offset program functionality Analytics and reporting accuracy Cross-contract interaction testing Related Documentation \u00b6 CarbonCreditFacet - Implementation of carbon credit functionality CarbonCreditLib - Carbon credit utilities and data structures Environmental NFT Guide - Implementation guide for environmental assets Carbon Offset Integration - Integration with offset programs ERC721 Standards - Token standard extensions This interface defines the standard contract for carbon credit management within the Gemforce platform, enabling the tokenization and retirement of environmental assets for sustainability and carbon offset programs.","title":"ICarbonCredit"},{"location":"smart-contracts/interfaces/icarbon-credit/#icarboncredit-interface","text":"","title":"ICarbonCredit Interface"},{"location":"smart-contracts/interfaces/icarbon-credit/#overview","text":"The ICarbonCredit interface defines the standard contract for managing carbon credits associated with ERC721 tokens within the Gemforce platform. This interface enables the tokenization of environmental assets, allowing NFTs to represent carbon credits that can be tracked, managed, and retired for environmental impact purposes.","title":"Overview"},{"location":"smart-contracts/interfaces/icarbon-credit/#key-features","text":"Carbon Credit Tokenization : Associate carbon credit balances with ERC721 tokens Credit Retirement : Permanently retire carbon credits to prevent double-counting Batch Operations : Efficiently manage multiple tokens simultaneously Status Tracking : Monitor active vs. retired carbon credit status Environmental Compliance : Support for carbon offset and sustainability programs","title":"Key Features"},{"location":"smart-contracts/interfaces/icarbon-credit/#interface-definition","text":"// SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import { CarbonCreditStatus } from \"../libraries/CarbonCreditLib.sol\" ; interface ICarbonCredit { // Events event CarbonCreditsInitialized ( uint256 indexed tokenId , uint256 initialBalance ); event CarbonCreditsRetired ( uint256 indexed tokenId , uint256 amount , uint256 remainingBalance ); // Core Functions function initializeCarbonCredit ( uint256 tokenId , uint256 initialBalance ) external ; function retireCarbonCredits ( uint256 tokenId , uint256 amount ) external ; function getCarbonCreditStatus ( uint256 tokenId ) external view returns ( CarbonCreditStatus ); function getCarbonCreditBalance ( uint256 tokenId ) external view returns ( uint256 ); // Batch Operations function batchInitializeCarbonCredits ( uint256 [] calldata tokenIds , uint256 [] calldata initialBalances ) external ; function getAllCarbonCreditBalances ( uint256 [] calldata tokenIds ) external view returns ( uint256 [] memory ); }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/icarbon-credit/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/icarbon-credit/#carbon-credit-initialization","text":"","title":"Carbon Credit Initialization"},{"location":"smart-contracts/interfaces/icarbon-credit/#initializecarboncredit","text":"function initializeCarbonCredit ( uint256 tokenId , uint256 initialBalance ) external Purpose : Initialize carbon credit balance for a specific ERC721 token. Parameters : - tokenId (uint256): The ID of the ERC721 token to associate with carbon credits - initialBalance (uint256): The initial balance of carbon credits (must be > 0) Requirements : - Token must exist and have a valid owner - Carbon credits must not already be initialized for this token - Initial balance must be greater than zero - Caller must have appropriate permissions Events Emitted : - CarbonCreditsInitialized with token ID and initial balance Example Usage : // Initialize carbon credits for a newly minted environmental NFT uint256 tokenId = 1 ; uint256 initialCredits = 1000 ; // 1000 carbon credits ICarbonCredit ( diamond ). initializeCarbonCredit ( tokenId , initialCredits ); console . log ( \"Initialized\" , initialCredits , \"carbon credits for token\" , tokenId );","title":"initializeCarbonCredit()"},{"location":"smart-contracts/interfaces/icarbon-credit/#carbon-credit-retirement","text":"","title":"Carbon Credit Retirement"},{"location":"smart-contracts/interfaces/icarbon-credit/#retirecarboncredits","text":"function retireCarbonCredits ( uint256 tokenId , uint256 amount ) external Purpose : Permanently retire carbon credits to prevent double-counting and demonstrate environmental impact. Parameters : - tokenId (uint256): The ID of the ERC721 token containing carbon credits - amount (uint256): The amount of carbon credits to retire (must be whole number) Requirements : - Token must have sufficient carbon credit balance - Amount must be greater than zero - Amount must be less than or equal to current balance - Caller must have appropriate permissions Events Emitted : - CarbonCreditsRetired with token ID, retired amount, and remaining balance Example Usage : // Retire carbon credits to offset emissions uint256 tokenId = 1 ; uint256 retireAmount = 250 ; // Retire 250 carbon credits // Check current balance first uint256 currentBalance = ICarbonCredit ( diamond ). getCarbonCreditBalance ( tokenId ); require ( currentBalance >= retireAmount , \"Insufficient carbon credits\" ); // Retire the credits ICarbonCredit ( diamond ). retireCarbonCredits ( tokenId , retireAmount ); console . log ( \"Retired\" , retireAmount , \"carbon credits from token\" , tokenId );","title":"retireCarbonCredits()"},{"location":"smart-contracts/interfaces/icarbon-credit/#status-and-balance-queries","text":"","title":"Status and Balance Queries"},{"location":"smart-contracts/interfaces/icarbon-credit/#getcarboncreditstatus","text":"function getCarbonCreditStatus ( uint256 tokenId ) external view returns ( CarbonCreditStatus ) Purpose : Get the current status of carbon credits for a token. Parameters : - tokenId (uint256): The ID of the ERC721 token Returns : - CarbonCreditStatus enum value: - ACTIVE : Token has remaining carbon credits - RETIRED : All carbon credits have been retired Example Usage : // Check carbon credit status uint256 tokenId = 1 ; CarbonCreditStatus status = ICarbonCredit ( diamond ). getCarbonCreditStatus ( tokenId ); if ( status == CarbonCreditStatus . ACTIVE ) { console . log ( \"Token\" , tokenId , \"has active carbon credits\" ); } else { console . log ( \"Token\" , tokenId , \"carbon credits are fully retired\" ); }","title":"getCarbonCreditStatus()"},{"location":"smart-contracts/interfaces/icarbon-credit/#getcarboncreditbalance","text":"function getCarbonCreditBalance ( uint256 tokenId ) external view returns ( uint256 ) Purpose : Get the current carbon credit balance for a specific token. Parameters : - tokenId (uint256): The ID of the ERC721 token Returns : Current balance of carbon credits for the token Example Usage : // Check current balance uint256 tokenId = 1 ; uint256 balance = ICarbonCredit ( diamond ). getCarbonCreditBalance ( tokenId ); console . log ( \"Token\" , tokenId , \"has\" , balance , \"carbon credits remaining\" );","title":"getCarbonCreditBalance()"},{"location":"smart-contracts/interfaces/icarbon-credit/#batch-operations","text":"","title":"Batch Operations"},{"location":"smart-contracts/interfaces/icarbon-credit/#batch-initialization","text":"","title":"Batch Initialization"},{"location":"smart-contracts/interfaces/icarbon-credit/#batchinitializecarboncredits","text":"function batchInitializeCarbonCredits ( uint256 [] calldata tokenIds , uint256 [] calldata initialBalances ) external Purpose : Initialize carbon credits for multiple tokens in a single transaction. Parameters : - tokenIds (uint256[]): Array of ERC721 token IDs - initialBalances (uint256[]): Array of initial balances corresponding to token IDs Requirements : - Arrays must have the same length - All tokens must exist and not have carbon credits initialized - All initial balances must be greater than zero - Caller must have appropriate permissions Gas Optimization : More efficient than multiple individual calls Example Usage : // Batch initialize carbon credits for multiple environmental NFTs uint256 [] memory tokenIds = new uint256 []( 3 ); tokenIds [ 0 ] = 1 ; tokenIds [ 1 ] = 2 ; tokenIds [ 2 ] = 3 ; uint256 [] memory initialBalances = new uint256 []( 3 ); initialBalances [ 0 ] = 1000 ; // Forest conservation project initialBalances [ 1 ] = 500 ; // Solar energy project initialBalances [ 2 ] = 750 ; // Wind energy project ICarbonCredit ( diamond ). batchInitializeCarbonCredits ( tokenIds , initialBalances ); console . log ( \"Batch initialized carbon credits for\" , tokenIds . length , \"tokens\" );","title":"batchInitializeCarbonCredits()"},{"location":"smart-contracts/interfaces/icarbon-credit/#batch-balance-query","text":"","title":"Batch Balance Query"},{"location":"smart-contracts/interfaces/icarbon-credit/#getallcarboncreditbalances","text":"function getAllCarbonCreditBalances ( uint256 [] calldata tokenIds ) external view returns ( uint256 [] memory ) Purpose : Get carbon credit balances for multiple tokens efficiently. Parameters : - tokenIds (uint256[]): Array of ERC721 token IDs to query Returns : Array of carbon credit balances corresponding to the input token IDs Example Usage : // Get balances for multiple tokens uint256 [] memory tokenIds = new uint256 []( 3 ); tokenIds [ 0 ] = 1 ; tokenIds [ 1 ] = 2 ; tokenIds [ 2 ] = 3 ; uint256 [] memory balances = ICarbonCredit ( diamond ). getAllCarbonCreditBalances ( tokenIds ); for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { console . log ( \"Token\" , tokenIds [ i ], \"balance:\" , balances [ i ]); }","title":"getAllCarbonCreditBalances()"},{"location":"smart-contracts/interfaces/icarbon-credit/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/icarbon-credit/#environmental-nft-marketplace","text":"// Integration with environmental NFT marketplace contract EnvironmentalMarketplace { ICarbonCredit public carbonCredit ; IERC721 public environmentalNFT ; struct EnvironmentalListing { uint256 tokenId ; uint256 price ; uint256 carbonCredits ; address seller ; bool active ; } mapping ( uint256 => EnvironmentalListing ) public listings ; event EnvironmentalNFTListed ( uint256 indexed tokenId , uint256 price , uint256 carbonCredits , address indexed seller ); event CarbonCreditsRetiredOnPurchase ( uint256 indexed tokenId , uint256 retiredAmount , address indexed buyer ); constructor ( address _carbonCredit , address _environmentalNFT ) { carbonCredit = ICarbonCredit ( _carbonCredit ); environmentalNFT = IERC721 ( _environmentalNFT ); } function listEnvironmentalNFT ( uint256 tokenId , uint256 price , bool retireCreditsOnSale ) external { require ( environmentalNFT . ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); uint256 creditBalance = carbonCredit . getCarbonCreditBalance ( tokenId ); require ( creditBalance > 0 , \"No carbon credits associated\" ); listings [ tokenId ] = EnvironmentalListing ({ tokenId : tokenId , price : price , carbonCredits : creditBalance , seller : msg.sender , active : true }); emit EnvironmentalNFTListed ( tokenId , price , creditBalance , msg.sender ); } function purchaseEnvironmentalNFT ( uint256 tokenId , uint256 creditsToRetire ) external payable { EnvironmentalListing storage listing = listings [ tokenId ]; require ( listing . active , \"Listing not active\" ); require ( msg.value >= listing . price , \"Insufficient payment\" ); uint256 currentCredits = carbonCredit . getCarbonCreditBalance ( tokenId ); require ( creditsToRetire <= currentCredits , \"Cannot retire more credits than available\" ); // Transfer NFT environmentalNFT . safeTransferFrom ( listing . seller , msg.sender , tokenId ); // Retire carbon credits if requested if ( creditsToRetire > 0 ) { carbonCredit . retireCarbonCredits ( tokenId , creditsToRetire ); emit CarbonCreditsRetiredOnPurchase ( tokenId , creditsToRetire , msg.sender ); } // Transfer payment payable ( listing . seller ). transfer ( msg.value ); // Deactivate listing listing . active = false ; } function getListingWithCarbonInfo ( uint256 tokenId ) external view returns ( EnvironmentalListing memory listing , uint256 currentCarbonBalance , CarbonCreditStatus status ) { listing = listings [ tokenId ]; currentCarbonBalance = carbonCredit . getCarbonCreditBalance ( tokenId ); status = carbonCredit . getCarbonCreditStatus ( tokenId ); } }","title":"Environmental NFT Marketplace"},{"location":"smart-contracts/interfaces/icarbon-credit/#carbon-offset-program","text":"// Automated carbon offset program contract CarbonOffsetProgram { ICarbonCredit public carbonCredit ; struct OffsetProject { string name ; string description ; uint256 [] tokenIds ; uint256 totalCredits ; uint256 retiredCredits ; address projectOwner ; bool active ; } mapping ( uint256 => OffsetProject ) public projects ; mapping ( address => uint256 []) public userOffsets ; uint256 public nextProjectId ; event ProjectCreated ( uint256 indexed projectId , string name , address indexed owner ); event CreditsRetiredForOffset ( uint256 indexed projectId , uint256 amount , address indexed offsetter ); event ProjectCompleted ( uint256 indexed projectId , uint256 totalRetired ); function createOffsetProject ( string memory name , string memory description , uint256 [] memory tokenIds ) external returns ( uint256 projectId ) { projectId = nextProjectId ++ ; uint256 totalCredits = 0 ; for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { uint256 balance = carbonCredit . getCarbonCreditBalance ( tokenIds [ i ]); require ( balance > 0 , \"Token has no carbon credits\" ); totalCredits += balance ; } projects [ projectId ] = OffsetProject ({ name : name , description : description , tokenIds : tokenIds , totalCredits : totalCredits , retiredCredits : 0 , projectOwner : msg.sender , active : true }); emit ProjectCreated ( projectId , name , msg.sender ); } function offsetEmissions ( uint256 projectId , uint256 creditsToOffset ) external payable { OffsetProject storage project = projects [ projectId ]; require ( project . active , \"Project not active\" ); require ( creditsToOffset > 0 , \"Must offset at least 1 credit\" ); uint256 availableCredits = project . totalCredits - project . retiredCredits ; require ( creditsToOffset <= availableCredits , \"Insufficient credits in project\" ); // Calculate payment (simplified - would integrate with pricing oracle) uint256 costPerCredit = 10 ether ; // $10 per credit in wei uint256 totalCost = creditsToOffset * costPerCredit ; require ( msg.value >= totalCost , \"Insufficient payment\" ); // Retire credits from project tokens uint256 creditsRemaining = creditsToOffset ; for ( uint256 i = 0 ; i < project . tokenIds . length && creditsRemaining > 0 ; i ++ ) { uint256 tokenId = project . tokenIds [ i ]; uint256 tokenBalance = carbonCredit . getCarbonCreditBalance ( tokenId ); if ( tokenBalance > 0 ) { uint256 toRetire = creditsRemaining > tokenBalance ? tokenBalance : creditsRemaining ; carbonCredit . retireCarbonCredits ( tokenId , toRetire ); creditsRemaining -= toRetire ; } } project . retiredCredits += creditsToOffset ; userOffsets [ msg.sender ]. push ( creditsToOffset ); // Transfer payment to project owner payable ( project . projectOwner ). transfer ( totalCost ); emit CreditsRetiredForOffset ( projectId , creditsToOffset , msg.sender ); // Check if project is completed if ( project . retiredCredits >= project . totalCredits ) { project . active = false ; emit ProjectCompleted ( projectId , project . retiredCredits ); } } function getProjectStatus ( uint256 projectId ) external view returns ( string memory name , uint256 totalCredits , uint256 retiredCredits , uint256 availableCredits , bool active , uint256 [] memory tokenBalances ) { OffsetProject memory project = projects [ projectId ]; name = project . name ; totalCredits = project . totalCredits ; retiredCredits = project . retiredCredits ; availableCredits = totalCredits - retiredCredits ; active = project . active ; tokenBalances = carbonCredit . getAllCarbonCreditBalances ( project . tokenIds ); } function getUserOffsetHistory ( address user ) external view returns ( uint256 [] memory ) { return userOffsets [ user ]; } }","title":"Carbon Offset Program"},{"location":"smart-contracts/interfaces/icarbon-credit/#carbon-credit-analytics-dashboard","text":"// Analytics and reporting for carbon credits contract CarbonCreditAnalytics { ICarbonCredit public carbonCredit ; struct AnalyticsData { uint256 totalTokensWithCredits ; uint256 totalActiveCredits ; uint256 totalRetiredCredits ; uint256 averageCreditsPerToken ; uint256 retirementRate ; } mapping ( uint256 => uint256 ) public tokenInitialBalances ; mapping ( uint256 => uint256 ) public tokenRetirementHistory ; uint256 [] public trackedTokens ; event AnalyticsUpdated ( AnalyticsData data ); event TokenAddedToTracking ( uint256 indexed tokenId , uint256 initialBalance ); function addTokenToTracking ( uint256 tokenId ) external { uint256 balance = carbonCredit . getCarbonCreditBalance ( tokenId ); require ( balance > 0 , \"Token has no carbon credits\" ); tokenInitialBalances [ tokenId ] = balance ; trackedTokens . push ( tokenId ); emit TokenAddedToTracking ( tokenId , balance ); } function updateAnalytics () external returns ( AnalyticsData memory data ) { uint256 [] memory balances = carbonCredit . getAllCarbonCreditBalances ( trackedTokens ); uint256 totalActive = 0 ; uint256 totalRetired = 0 ; uint256 tokensWithCredits = 0 ; for ( uint256 i = 0 ; i < trackedTokens . length ; i ++ ) { uint256 tokenId = trackedTokens [ i ]; uint256 currentBalance = balances [ i ]; uint256 initialBalance = tokenInitialBalances [ tokenId ]; if ( currentBalance > 0 ) { tokensWithCredits ++ ; } totalActive += currentBalance ; totalRetired += ( initialBalance - currentBalance ); } data = AnalyticsData ({ totalTokensWithCredits : tokensWithCredits , totalActiveCredits : totalActive , totalRetiredCredits : totalRetired , averageCreditsPerToken : tokensWithCredits > 0 ? totalActive / tokensWithCredits : 0 , retirementRate : ( totalActive + totalRetired ) > 0 ? ( totalRetired * 100 ) / ( totalActive + totalRetired ) : 0 }); emit AnalyticsUpdated ( data ); } function getTokenRetirementHistory ( uint256 tokenId ) external view returns ( uint256 initialBalance , uint256 currentBalance , uint256 totalRetired , uint256 retirementPercentage ) { initialBalance = tokenInitialBalances [ tokenId ]; currentBalance = carbonCredit . getCarbonCreditBalance ( tokenId ); totalRetired = initialBalance - currentBalance ; retirementPercentage = initialBalance > 0 ? ( totalRetired * 100 ) / initialBalance : 0 ; } function generateRetirementReport ( uint256 [] memory tokenIds ) external view returns ( uint256 totalInitial , uint256 totalCurrent , uint256 totalRetired , uint256 overallRetirementRate ) { uint256 [] memory balances = carbonCredit . getAllCarbonCreditBalances ( tokenIds ); for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { uint256 initial = tokenInitialBalances [ tokenIds [ i ]]; uint256 current = balances [ i ]; totalInitial += initial ; totalCurrent += current ; totalRetired += ( initial - current ); } overallRetirementRate = totalInitial > 0 ? ( totalRetired * 100 ) / totalInitial : 0 ; } }","title":"Carbon Credit Analytics Dashboard"},{"location":"smart-contracts/interfaces/icarbon-credit/#events","text":"","title":"Events"},{"location":"smart-contracts/interfaces/icarbon-credit/#carbon-credit-lifecycle-events","text":"event CarbonCreditsInitialized ( uint256 indexed tokenId , uint256 initialBalance ); event CarbonCreditsRetired ( uint256 indexed tokenId , uint256 amount , uint256 remainingBalance );","title":"Carbon Credit Lifecycle Events"},{"location":"smart-contracts/interfaces/icarbon-credit/#data-types","text":"","title":"Data Types"},{"location":"smart-contracts/interfaces/icarbon-credit/#carboncreditstatus-enum","text":"enum CarbonCreditStatus { ACTIVE , // Token has remaining carbon credits RETIRED // All carbon credits have been retired }","title":"CarbonCreditStatus Enum"},{"location":"smart-contracts/interfaces/icarbon-credit/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/icarbon-credit/#access-control","text":"Initialization requires appropriate permissions Retirement operations must be authorized Token existence validation before operations Prevention of double initialization","title":"Access Control"},{"location":"smart-contracts/interfaces/icarbon-credit/#financial-security","text":"Accurate balance tracking and calculations Prevention of over-retirement Secure state transitions Immutable retirement records","title":"Financial Security"},{"location":"smart-contracts/interfaces/icarbon-credit/#environmental-integrity","text":"Prevention of double-counting retired credits Permanent retirement to ensure environmental impact Transparent tracking of credit lifecycle Compliance with carbon accounting standards","title":"Environmental Integrity"},{"location":"smart-contracts/interfaces/icarbon-credit/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/interfaces/icarbon-credit/#efficient-operations","text":"Batch operations for multiple tokens Optimized storage layout for balances Minimal external calls in view functions Efficient array operations for bulk queries","title":"Efficient Operations"},{"location":"smart-contracts/interfaces/icarbon-credit/#storage-optimization","text":"Packed storage structures where possible Efficient mapping usage for balance tracking Optimized batch operations Cached calculations for frequently accessed data","title":"Storage Optimization"},{"location":"smart-contracts/interfaces/icarbon-credit/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/interfaces/icarbon-credit/#common-errors","text":"Token does not exist Carbon credits already initialized Insufficient balance for retirement Invalid amounts (zero or negative) Array length mismatches in batch operations","title":"Common Errors"},{"location":"smart-contracts/interfaces/icarbon-credit/#best-practices","text":"Validate token existence before operations Check balances before retirement Validate array parameters in batch operations Provide clear error messages for debugging Handle edge cases gracefully","title":"Best Practices"},{"location":"smart-contracts/interfaces/icarbon-credit/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/interfaces/icarbon-credit/#unit-tests","text":"Interface compliance verification Balance initialization and tracking Retirement functionality and validation Batch operation efficiency and correctness Event emission verification","title":"Unit Tests"},{"location":"smart-contracts/interfaces/icarbon-credit/#integration-tests","text":"Integration with ERC721 contracts Environmental marketplace workflows Carbon offset program functionality Analytics and reporting accuracy Cross-contract interaction testing","title":"Integration Tests"},{"location":"smart-contracts/interfaces/icarbon-credit/#related-documentation","text":"CarbonCreditFacet - Implementation of carbon credit functionality CarbonCreditLib - Carbon credit utilities and data structures Environmental NFT Guide - Implementation guide for environmental assets Carbon Offset Integration - Integration with offset programs ERC721 Standards - Token standard extensions This interface defines the standard contract for carbon credit management within the Gemforce platform, enabling the tokenization and retirement of environmental assets for sustainability and carbon offset programs.","title":"Related Documentation"},{"location":"smart-contracts/interfaces/idiamond-factory/","text":"IDiamondFactory Interface \u00b6 The IDiamondFactory interface defines the standard for diamond contract factory implementations. It provides a standardized way to deploy diamond contracts with predefined facet configurations and initialization parameters. Overview \u00b6 IDiamondFactory provides: Standardized Deployment : Consistent diamond deployment patterns Template Management : Manage diamond templates and configurations Batch Deployment : Deploy multiple diamonds efficiently Configuration Validation : Validate deployment parameters Event Tracking : Track all diamond deployments Key Features \u00b6 Diamond Deployment \u00b6 Template-Based : Deploy from predefined templates Custom Configuration : Support custom facet combinations Deterministic Addresses : Predictable diamond addresses using CREATE2 Initialization Support : Handle complex initialization sequences Template Management \u00b6 Template Registry : Store and manage diamond templates Version Control : Support multiple template versions Access Control : Manage template creation permissions Validation : Validate template configurations Factory Operations \u00b6 Batch Operations : Deploy multiple diamonds in single transaction Gas Optimization : Optimize deployment gas costs Event Logging : Comprehensive event logging for tracking Error Handling : Robust error handling and recovery Interface Definition \u00b6 interface IDiamondFactory { // Events event DiamondDeployed ( address indexed diamond , address indexed deployer , string indexed templateName , bytes32 salt ); event TemplateRegistered ( string indexed name , string indexed version , address indexed creator ); event TemplateUpdated ( string indexed name , string indexed version , address indexed updater ); event TemplateDeactivated ( string indexed name , address indexed deactivator ); // Structs struct DiamondTemplate { string name ; string version ; FacetCut [] facetCuts ; address initContract ; bytes initData ; bool active ; address creator ; uint256 createdAt ; } struct FacetCut { address facetAddress ; FacetCutAction action ; bytes4 [] functionSelectors ; } enum FacetCutAction { Add , Replace , Remove } struct DeploymentConfig { string templateName ; bytes32 salt ; bytes initData ; address owner ; uint256 gasLimit ; } struct DeploymentResult { address diamond ; uint256 gasUsed ; bytes32 txHash ; } // Core Functions function deployDiamond ( DeploymentConfig calldata config ) external returns ( address diamond ); function deployDiamonds ( DeploymentConfig [] calldata configs ) external returns ( address [] memory diamonds ); function predictDiamondAddress ( DeploymentConfig calldata config ) external view returns ( address predicted ); // Template Management function registerTemplate ( DiamondTemplate calldata template ) external ; function updateTemplate ( string calldata name , DiamondTemplate calldata template ) external ; function deactivateTemplate ( string calldata name ) external ; function getTemplate ( string calldata name ) external view returns ( DiamondTemplate memory ); function getTemplateNames () external view returns ( string [] memory ); function isTemplateActive ( string calldata name ) external view returns ( bool ); // Query Functions function getDeployedDiamonds ( address deployer ) external view returns ( address [] memory ); function getDiamondTemplate ( address diamond ) external view returns ( string memory templateName ); function getDeploymentCount () external view returns ( uint256 ); function getDeploymentInfo ( address diamond ) external view returns ( address deployer , string memory templateName , uint256 deployedAt , bytes32 salt ); // Administrative Functions function setTemplateCreator ( address creator , bool authorized ) external ; function isAuthorizedCreator ( address creator ) external view returns ( bool ); function pause () external ; function unpause () external ; function paused () external view returns ( bool ); } Core Functions \u00b6 deployDiamond() \u00b6 Deploys a new diamond contract using a registered template. Parameters: - config : Deployment configuration including template name, salt, and initialization data Returns: - address : Address of the deployed diamond Usage: IDiamondFactory . DeploymentConfig memory config = IDiamondFactory . DeploymentConfig ({ templateName : \"StandardNFT\" , salt : keccak256 ( \"unique-identifier\" ), initData : abi . encode ( \"My Collection\" , \"MYC\" , \"https://api.example.com/\" ), owner : msg.sender , gasLimit : 5000000 }); address diamond = factory . deployDiamond ( config ); deployDiamonds() \u00b6 Deploys multiple diamonds in a single transaction for gas efficiency. Parameters: - configs : Array of deployment configurations Returns: - address[] : Array of deployed diamond addresses predictDiamondAddress() \u00b6 Predicts the address of a diamond before deployment using CREATE2. Parameters: - config : Deployment configuration Returns: - address : Predicted diamond address registerTemplate() \u00b6 Registers a new diamond template for deployment. Parameters: - template : Template configuration including facets and initialization Access Control: - Only authorized template creators can register templates getTemplate() \u00b6 Retrieves a registered template by name. Parameters: - name : Template name Returns: - DiamondTemplate : Complete template configuration Implementation Example \u00b6 Basic Diamond Factory \u00b6 contract DiamondFactory is IDiamondFactory , Ownable , Pausable { using Clones for address ; // Storage mapping ( string => DiamondTemplate ) private templates ; mapping ( address => bool ) public authorizedCreators ; mapping ( address => string ) public diamondTemplates ; mapping ( address => address []) public deployerDiamonds ; address [] public allDiamonds ; string [] public templateNames ; address public immutable diamondImplementation ; constructor ( address _diamondImplementation ) { diamondImplementation = _diamondImplementation ; authorizedCreators [ msg.sender ] = true ; } function deployDiamond ( DeploymentConfig calldata config ) external override whenNotPaused returns ( address diamond ) { DiamondTemplate memory template = templates [ config . templateName ]; require ( template . active , \"Template not active\" ); require ( bytes ( template . name ). length > 0 , \"Template not found\" ); // Calculate deterministic address bytes32 salt = keccak256 ( abi . encodePacked ( config . salt , msg.sender )); // Deploy diamond using CREATE2 diamond = Clones . cloneDeterministic ( diamondImplementation , salt ); // Initialize diamond with template configuration _initializeDiamond ( diamond , template , config ); // Record deployment _recordDeployment ( diamond , config . templateName , msg.sender , salt ); emit DiamondDeployed ( diamond , msg.sender , config . templateName , config . salt ); } function deployDiamonds ( DeploymentConfig [] calldata configs ) external override whenNotPaused returns ( address [] memory diamonds ) { diamonds = new address []( configs . length ); for ( uint256 i = 0 ; i < configs . length ; i ++ ) { diamonds [ i ] = this . deployDiamond ( configs [ i ]); } } function predictDiamondAddress ( DeploymentConfig calldata config ) external view override returns ( address predicted ) { bytes32 salt = keccak256 ( abi . encodePacked ( config . salt , msg.sender )); predicted = Clones . predictDeterministicAddress ( diamondImplementation , salt ); } function registerTemplate ( DiamondTemplate calldata template ) external override { require ( authorizedCreators [ msg.sender ], \"Not authorized\" ); require ( bytes ( template . name ). length > 0 , \"Invalid template name\" ); require ( template . facetCuts . length > 0 , \"No facets specified\" ); // Validate facet cuts _validateFacetCuts ( template . facetCuts ); // Store template templates [ template . name ] = DiamondTemplate ({ name : template . name , version : template . version , facetCuts : template . facetCuts , initContract : template . initContract , initData : template . initData , active : true , creator : msg.sender , createdAt : block.timestamp }); // Add to template names if new if ( ! _templateExists ( template . name )) { templateNames . push ( template . name ); } emit TemplateRegistered ( template . name , template . version , msg.sender ); } function _initializeDiamond ( address diamond , DiamondTemplate memory template , DeploymentConfig calldata config ) internal { // Perform diamond cut with template facets IDiamondCut ( diamond ). diamondCut ( template . facetCuts , template . initContract , abi . encodePacked ( template . initData , config . initData ) ); // Transfer ownership to specified owner if ( config . owner != address ( 0 )) { IOwnership ( diamond ). transferOwnership ( config . owner ); } } function _recordDeployment ( address diamond , string memory templateName , address deployer , bytes32 salt ) internal { diamondTemplates [ diamond ] = templateName ; deployerDiamonds [ deployer ]. push ( diamond ); allDiamonds . push ( diamond ); } } Advanced Template Management \u00b6 contract AdvancedDiamondFactory is DiamondFactory { // Template versioning mapping ( string => mapping ( string => DiamondTemplate )) private templateVersions ; mapping ( string => string []) private templateVersionList ; mapping ( string => string ) private latestVersion ; // Template categories mapping ( string => string ) public templateCategories ; mapping ( string => string []) public categoryTemplates ; // Deployment statistics mapping ( string => uint256 ) public templateDeploymentCount ; mapping ( address => uint256 ) public deployerCount ; function registerTemplateVersion ( string calldata name , string calldata version , DiamondTemplate calldata template ) external { require ( authorizedCreators [ msg.sender ], \"Not authorized\" ); require ( templateVersions [ name ][ version ]. createdAt == 0 , \"Version already exists\" ); templateVersions [ name ][ version ] = template ; templateVersionList [ name ]. push ( version ); latestVersion [ name ] = version ; emit TemplateRegistered ( name , version , msg.sender ); } function deployDiamondVersion ( string calldata templateName , string calldata version , DeploymentConfig calldata config ) external returns ( address diamond ) { DiamondTemplate memory template = templateVersions [ templateName ][ version ]; require ( template . active , \"Template version not active\" ); // Deploy with specific version return _deployWithTemplate ( template , config ); } function getTemplateVersions ( string calldata name ) external view returns ( string [] memory versions ) { return templateVersionList [ name ]; } function getLatestVersion ( string calldata name ) external view returns ( string memory version ) { return latestVersion [ name ]; } function categorizeTemplate ( string calldata templateName , string calldata category ) external onlyOwner { templateCategories [ templateName ] = category ; categoryTemplates [ category ]. push ( templateName ); } function getTemplatesByCategory ( string calldata category ) external view returns ( string [] memory templates ) { return categoryTemplates [ category ]; } } Template Examples \u00b6 NFT Collection Template \u00b6 function createNFTCollectionTemplate () external pure returns ( DiamondTemplate memory ) { FacetCut [] memory facetCuts = new FacetCut []( 4 ); facetCuts [ 0 ] = FacetCut ({ facetAddress : 0 x ..., // ERC721Facet action : FacetCutAction . Add , functionSelectors : getERC721Selectors () }); facetCuts [ 1 ] = FacetCut ({ facetAddress : 0 x ..., // MarketplaceFacet action : FacetCutAction . Add , functionSelectors : getMarketplaceSelectors () }); facetCuts [ 2 ] = FacetCut ({ facetAddress : 0 x ..., // MetadataFacet action : FacetCutAction . Add , functionSelectors : getMetadataSelectors () }); facetCuts [ 3 ] = FacetCut ({ facetAddress : 0 x ..., // OwnershipFacet action : FacetCutAction . Add , functionSelectors : getOwnershipSelectors () }); return DiamondTemplate ({ name : \"NFTCollection\" , version : \"1.0.0\" , facetCuts : facetCuts , initContract : 0 x ..., // NFTCollectionInit initData : \"\" , active : true , creator : msg.sender , createdAt : block.timestamp }); } DeFi Protocol Template \u00b6 function createDeFiProtocolTemplate () external pure returns ( DiamondTemplate memory ) { FacetCut [] memory facetCuts = new FacetCut []( 5 ); facetCuts [ 0 ] = FacetCut ({ facetAddress : 0 x ..., // ERC20Facet action : FacetCutAction . Add , functionSelectors : getERC20Selectors () }); facetCuts [ 1 ] = FacetCut ({ facetAddress : 0 x ..., // StakingFacet action : FacetCutAction . Add , functionSelectors : getStakingSelectors () }); facetCuts [ 2 ] = FacetCut ({ facetAddress : 0 x ..., // GovernanceFacet action : FacetCutAction . Add , functionSelectors : getGovernanceSelectors () }); facetCuts [ 3 ] = FacetCut ({ facetAddress : 0 x ..., // FeeDistributorFacet action : FacetCutAction . Add , functionSelectors : getFeeDistributorSelectors () }); facetCuts [ 4 ] = FacetCut ({ facetAddress : 0 x ..., // OwnershipFacet action : FacetCutAction . Add , functionSelectors : getOwnershipSelectors () }); return DiamondTemplate ({ name : \"DeFiProtocol\" , version : \"1.0.0\" , facetCuts : facetCuts , initContract : 0 x ..., // DeFiProtocolInit initData : \"\" , active : true , creator : msg.sender , createdAt : block.timestamp }); } Security Considerations \u00b6 Access Control \u00b6 Template Creation : Restrict template registration to authorized creators Deployment Permissions : Control who can deploy diamonds Administrative Functions : Secure administrative operations Ownership Transfer : Validate ownership transfer during deployment Template Validation \u00b6 Facet Validation : Ensure facet contracts are valid and secure Selector Conflicts : Prevent function selector conflicts Initialization Safety : Validate initialization contracts and data Gas Limits : Enforce reasonable gas limits for deployments Factory Security \u00b6 Reentrancy Protection : Prevent reentrancy attacks Integer Overflow : Protect against overflow vulnerabilities Address Validation : Validate all address parameters Pause Mechanism : Emergency pause functionality Best Practices \u00b6 Template Design \u00b6 Modular Facets : Design reusable, modular facets Standard Interfaces : Use standard interfaces for compatibility Documentation : Document template capabilities and limitations Testing : Thoroughly test template configurations Factory Management \u00b6 Access Control : Implement proper access controls Event Logging : Log all factory operations Error Handling : Implement comprehensive error handling Upgrade Planning : Plan for factory upgrades Deployment Patterns \u00b6 Deterministic Addresses : Use CREATE2 for predictable addresses Batch Operations : Support batch deployments for efficiency Gas Optimization : Optimize deployment gas costs Monitoring : Monitor deployment success and failures Integration Examples \u00b6 Frontend Integration \u00b6 class DiamondFactoryService { private contract : Contract ; constructor ( address : string , provider : Provider ) { this . contract = new Contract ( address , DIAMOND_FACTORY_ABI , provider ); } async deployDiamond ( config : DeploymentConfig ) : Promise < string > { const tx = await this . contract . deployDiamond ( config ); const receipt = await tx . wait (); const event = receipt . events ? . find ( e => e . event === 'DiamondDeployed' ); return event ? . args ? . diamond ; } async predictAddress ( config : DeploymentConfig ) : Promise < string > { return await this . contract . predictDiamondAddress ( config ); } async getTemplate ( name : string ) : Promise < DiamondTemplate > { return await this . contract . getTemplate ( name ); } async getDeployedDiamonds ( deployer : string ) : Promise < string [] > { return await this . contract . getDeployedDiamonds ( deployer ); } } CLI Integration \u00b6 # Deploy a diamond using CLI gemforce deploy-diamond \\ --template \"NFTCollection\" \\ --name \"My Collection\" \\ --symbol \"MYC\" \\ --owner \"0x...\" \\ --network \"polygon\" # Register a new template gemforce register-template \\ --name \"CustomNFT\" \\ --version \"1.0.0\" \\ --config \"./templates/custom-nft.json\" \\ --network \"polygon\" # List available templates gemforce list-templates --network \"polygon\" Related Documentation \u00b6 Diamond Standard Overview Diamond Factory Implementation Diamond Cut Facet Diamond Loupe Facet Diamond Factory Library Deployment Guide Standards Compliance \u00b6 EIP-2535 : Diamond Standard implementation EIP-1167 : Minimal Proxy Standard for cloning EIP-1014 : CREATE2 for deterministic addresses Factory Pattern : Standard factory design patterns Access Control : Role-based access control patterns","title":"IDiamondFactory"},{"location":"smart-contracts/interfaces/idiamond-factory/#idiamondfactory-interface","text":"The IDiamondFactory interface defines the standard for diamond contract factory implementations. It provides a standardized way to deploy diamond contracts with predefined facet configurations and initialization parameters.","title":"IDiamondFactory Interface"},{"location":"smart-contracts/interfaces/idiamond-factory/#overview","text":"IDiamondFactory provides: Standardized Deployment : Consistent diamond deployment patterns Template Management : Manage diamond templates and configurations Batch Deployment : Deploy multiple diamonds efficiently Configuration Validation : Validate deployment parameters Event Tracking : Track all diamond deployments","title":"Overview"},{"location":"smart-contracts/interfaces/idiamond-factory/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/idiamond-factory/#diamond-deployment","text":"Template-Based : Deploy from predefined templates Custom Configuration : Support custom facet combinations Deterministic Addresses : Predictable diamond addresses using CREATE2 Initialization Support : Handle complex initialization sequences","title":"Diamond Deployment"},{"location":"smart-contracts/interfaces/idiamond-factory/#template-management","text":"Template Registry : Store and manage diamond templates Version Control : Support multiple template versions Access Control : Manage template creation permissions Validation : Validate template configurations","title":"Template Management"},{"location":"smart-contracts/interfaces/idiamond-factory/#factory-operations","text":"Batch Operations : Deploy multiple diamonds in single transaction Gas Optimization : Optimize deployment gas costs Event Logging : Comprehensive event logging for tracking Error Handling : Robust error handling and recovery","title":"Factory Operations"},{"location":"smart-contracts/interfaces/idiamond-factory/#interface-definition","text":"interface IDiamondFactory { // Events event DiamondDeployed ( address indexed diamond , address indexed deployer , string indexed templateName , bytes32 salt ); event TemplateRegistered ( string indexed name , string indexed version , address indexed creator ); event TemplateUpdated ( string indexed name , string indexed version , address indexed updater ); event TemplateDeactivated ( string indexed name , address indexed deactivator ); // Structs struct DiamondTemplate { string name ; string version ; FacetCut [] facetCuts ; address initContract ; bytes initData ; bool active ; address creator ; uint256 createdAt ; } struct FacetCut { address facetAddress ; FacetCutAction action ; bytes4 [] functionSelectors ; } enum FacetCutAction { Add , Replace , Remove } struct DeploymentConfig { string templateName ; bytes32 salt ; bytes initData ; address owner ; uint256 gasLimit ; } struct DeploymentResult { address diamond ; uint256 gasUsed ; bytes32 txHash ; } // Core Functions function deployDiamond ( DeploymentConfig calldata config ) external returns ( address diamond ); function deployDiamonds ( DeploymentConfig [] calldata configs ) external returns ( address [] memory diamonds ); function predictDiamondAddress ( DeploymentConfig calldata config ) external view returns ( address predicted ); // Template Management function registerTemplate ( DiamondTemplate calldata template ) external ; function updateTemplate ( string calldata name , DiamondTemplate calldata template ) external ; function deactivateTemplate ( string calldata name ) external ; function getTemplate ( string calldata name ) external view returns ( DiamondTemplate memory ); function getTemplateNames () external view returns ( string [] memory ); function isTemplateActive ( string calldata name ) external view returns ( bool ); // Query Functions function getDeployedDiamonds ( address deployer ) external view returns ( address [] memory ); function getDiamondTemplate ( address diamond ) external view returns ( string memory templateName ); function getDeploymentCount () external view returns ( uint256 ); function getDeploymentInfo ( address diamond ) external view returns ( address deployer , string memory templateName , uint256 deployedAt , bytes32 salt ); // Administrative Functions function setTemplateCreator ( address creator , bool authorized ) external ; function isAuthorizedCreator ( address creator ) external view returns ( bool ); function pause () external ; function unpause () external ; function paused () external view returns ( bool ); }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/idiamond-factory/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/idiamond-factory/#deploydiamond","text":"Deploys a new diamond contract using a registered template. Parameters: - config : Deployment configuration including template name, salt, and initialization data Returns: - address : Address of the deployed diamond Usage: IDiamondFactory . DeploymentConfig memory config = IDiamondFactory . DeploymentConfig ({ templateName : \"StandardNFT\" , salt : keccak256 ( \"unique-identifier\" ), initData : abi . encode ( \"My Collection\" , \"MYC\" , \"https://api.example.com/\" ), owner : msg.sender , gasLimit : 5000000 }); address diamond = factory . deployDiamond ( config );","title":"deployDiamond()"},{"location":"smart-contracts/interfaces/idiamond-factory/#deploydiamonds","text":"Deploys multiple diamonds in a single transaction for gas efficiency. Parameters: - configs : Array of deployment configurations Returns: - address[] : Array of deployed diamond addresses","title":"deployDiamonds()"},{"location":"smart-contracts/interfaces/idiamond-factory/#predictdiamondaddress","text":"Predicts the address of a diamond before deployment using CREATE2. Parameters: - config : Deployment configuration Returns: - address : Predicted diamond address","title":"predictDiamondAddress()"},{"location":"smart-contracts/interfaces/idiamond-factory/#registertemplate","text":"Registers a new diamond template for deployment. Parameters: - template : Template configuration including facets and initialization Access Control: - Only authorized template creators can register templates","title":"registerTemplate()"},{"location":"smart-contracts/interfaces/idiamond-factory/#gettemplate","text":"Retrieves a registered template by name. Parameters: - name : Template name Returns: - DiamondTemplate : Complete template configuration","title":"getTemplate()"},{"location":"smart-contracts/interfaces/idiamond-factory/#implementation-example","text":"","title":"Implementation Example"},{"location":"smart-contracts/interfaces/idiamond-factory/#basic-diamond-factory","text":"contract DiamondFactory is IDiamondFactory , Ownable , Pausable { using Clones for address ; // Storage mapping ( string => DiamondTemplate ) private templates ; mapping ( address => bool ) public authorizedCreators ; mapping ( address => string ) public diamondTemplates ; mapping ( address => address []) public deployerDiamonds ; address [] public allDiamonds ; string [] public templateNames ; address public immutable diamondImplementation ; constructor ( address _diamondImplementation ) { diamondImplementation = _diamondImplementation ; authorizedCreators [ msg.sender ] = true ; } function deployDiamond ( DeploymentConfig calldata config ) external override whenNotPaused returns ( address diamond ) { DiamondTemplate memory template = templates [ config . templateName ]; require ( template . active , \"Template not active\" ); require ( bytes ( template . name ). length > 0 , \"Template not found\" ); // Calculate deterministic address bytes32 salt = keccak256 ( abi . encodePacked ( config . salt , msg.sender )); // Deploy diamond using CREATE2 diamond = Clones . cloneDeterministic ( diamondImplementation , salt ); // Initialize diamond with template configuration _initializeDiamond ( diamond , template , config ); // Record deployment _recordDeployment ( diamond , config . templateName , msg.sender , salt ); emit DiamondDeployed ( diamond , msg.sender , config . templateName , config . salt ); } function deployDiamonds ( DeploymentConfig [] calldata configs ) external override whenNotPaused returns ( address [] memory diamonds ) { diamonds = new address []( configs . length ); for ( uint256 i = 0 ; i < configs . length ; i ++ ) { diamonds [ i ] = this . deployDiamond ( configs [ i ]); } } function predictDiamondAddress ( DeploymentConfig calldata config ) external view override returns ( address predicted ) { bytes32 salt = keccak256 ( abi . encodePacked ( config . salt , msg.sender )); predicted = Clones . predictDeterministicAddress ( diamondImplementation , salt ); } function registerTemplate ( DiamondTemplate calldata template ) external override { require ( authorizedCreators [ msg.sender ], \"Not authorized\" ); require ( bytes ( template . name ). length > 0 , \"Invalid template name\" ); require ( template . facetCuts . length > 0 , \"No facets specified\" ); // Validate facet cuts _validateFacetCuts ( template . facetCuts ); // Store template templates [ template . name ] = DiamondTemplate ({ name : template . name , version : template . version , facetCuts : template . facetCuts , initContract : template . initContract , initData : template . initData , active : true , creator : msg.sender , createdAt : block.timestamp }); // Add to template names if new if ( ! _templateExists ( template . name )) { templateNames . push ( template . name ); } emit TemplateRegistered ( template . name , template . version , msg.sender ); } function _initializeDiamond ( address diamond , DiamondTemplate memory template , DeploymentConfig calldata config ) internal { // Perform diamond cut with template facets IDiamondCut ( diamond ). diamondCut ( template . facetCuts , template . initContract , abi . encodePacked ( template . initData , config . initData ) ); // Transfer ownership to specified owner if ( config . owner != address ( 0 )) { IOwnership ( diamond ). transferOwnership ( config . owner ); } } function _recordDeployment ( address diamond , string memory templateName , address deployer , bytes32 salt ) internal { diamondTemplates [ diamond ] = templateName ; deployerDiamonds [ deployer ]. push ( diamond ); allDiamonds . push ( diamond ); } }","title":"Basic Diamond Factory"},{"location":"smart-contracts/interfaces/idiamond-factory/#advanced-template-management","text":"contract AdvancedDiamondFactory is DiamondFactory { // Template versioning mapping ( string => mapping ( string => DiamondTemplate )) private templateVersions ; mapping ( string => string []) private templateVersionList ; mapping ( string => string ) private latestVersion ; // Template categories mapping ( string => string ) public templateCategories ; mapping ( string => string []) public categoryTemplates ; // Deployment statistics mapping ( string => uint256 ) public templateDeploymentCount ; mapping ( address => uint256 ) public deployerCount ; function registerTemplateVersion ( string calldata name , string calldata version , DiamondTemplate calldata template ) external { require ( authorizedCreators [ msg.sender ], \"Not authorized\" ); require ( templateVersions [ name ][ version ]. createdAt == 0 , \"Version already exists\" ); templateVersions [ name ][ version ] = template ; templateVersionList [ name ]. push ( version ); latestVersion [ name ] = version ; emit TemplateRegistered ( name , version , msg.sender ); } function deployDiamondVersion ( string calldata templateName , string calldata version , DeploymentConfig calldata config ) external returns ( address diamond ) { DiamondTemplate memory template = templateVersions [ templateName ][ version ]; require ( template . active , \"Template version not active\" ); // Deploy with specific version return _deployWithTemplate ( template , config ); } function getTemplateVersions ( string calldata name ) external view returns ( string [] memory versions ) { return templateVersionList [ name ]; } function getLatestVersion ( string calldata name ) external view returns ( string memory version ) { return latestVersion [ name ]; } function categorizeTemplate ( string calldata templateName , string calldata category ) external onlyOwner { templateCategories [ templateName ] = category ; categoryTemplates [ category ]. push ( templateName ); } function getTemplatesByCategory ( string calldata category ) external view returns ( string [] memory templates ) { return categoryTemplates [ category ]; } }","title":"Advanced Template Management"},{"location":"smart-contracts/interfaces/idiamond-factory/#template-examples","text":"","title":"Template Examples"},{"location":"smart-contracts/interfaces/idiamond-factory/#nft-collection-template","text":"function createNFTCollectionTemplate () external pure returns ( DiamondTemplate memory ) { FacetCut [] memory facetCuts = new FacetCut []( 4 ); facetCuts [ 0 ] = FacetCut ({ facetAddress : 0 x ..., // ERC721Facet action : FacetCutAction . Add , functionSelectors : getERC721Selectors () }); facetCuts [ 1 ] = FacetCut ({ facetAddress : 0 x ..., // MarketplaceFacet action : FacetCutAction . Add , functionSelectors : getMarketplaceSelectors () }); facetCuts [ 2 ] = FacetCut ({ facetAddress : 0 x ..., // MetadataFacet action : FacetCutAction . Add , functionSelectors : getMetadataSelectors () }); facetCuts [ 3 ] = FacetCut ({ facetAddress : 0 x ..., // OwnershipFacet action : FacetCutAction . Add , functionSelectors : getOwnershipSelectors () }); return DiamondTemplate ({ name : \"NFTCollection\" , version : \"1.0.0\" , facetCuts : facetCuts , initContract : 0 x ..., // NFTCollectionInit initData : \"\" , active : true , creator : msg.sender , createdAt : block.timestamp }); }","title":"NFT Collection Template"},{"location":"smart-contracts/interfaces/idiamond-factory/#defi-protocol-template","text":"function createDeFiProtocolTemplate () external pure returns ( DiamondTemplate memory ) { FacetCut [] memory facetCuts = new FacetCut []( 5 ); facetCuts [ 0 ] = FacetCut ({ facetAddress : 0 x ..., // ERC20Facet action : FacetCutAction . Add , functionSelectors : getERC20Selectors () }); facetCuts [ 1 ] = FacetCut ({ facetAddress : 0 x ..., // StakingFacet action : FacetCutAction . Add , functionSelectors : getStakingSelectors () }); facetCuts [ 2 ] = FacetCut ({ facetAddress : 0 x ..., // GovernanceFacet action : FacetCutAction . Add , functionSelectors : getGovernanceSelectors () }); facetCuts [ 3 ] = FacetCut ({ facetAddress : 0 x ..., // FeeDistributorFacet action : FacetCutAction . Add , functionSelectors : getFeeDistributorSelectors () }); facetCuts [ 4 ] = FacetCut ({ facetAddress : 0 x ..., // OwnershipFacet action : FacetCutAction . Add , functionSelectors : getOwnershipSelectors () }); return DiamondTemplate ({ name : \"DeFiProtocol\" , version : \"1.0.0\" , facetCuts : facetCuts , initContract : 0 x ..., // DeFiProtocolInit initData : \"\" , active : true , creator : msg.sender , createdAt : block.timestamp }); }","title":"DeFi Protocol Template"},{"location":"smart-contracts/interfaces/idiamond-factory/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/idiamond-factory/#access-control","text":"Template Creation : Restrict template registration to authorized creators Deployment Permissions : Control who can deploy diamonds Administrative Functions : Secure administrative operations Ownership Transfer : Validate ownership transfer during deployment","title":"Access Control"},{"location":"smart-contracts/interfaces/idiamond-factory/#template-validation","text":"Facet Validation : Ensure facet contracts are valid and secure Selector Conflicts : Prevent function selector conflicts Initialization Safety : Validate initialization contracts and data Gas Limits : Enforce reasonable gas limits for deployments","title":"Template Validation"},{"location":"smart-contracts/interfaces/idiamond-factory/#factory-security","text":"Reentrancy Protection : Prevent reentrancy attacks Integer Overflow : Protect against overflow vulnerabilities Address Validation : Validate all address parameters Pause Mechanism : Emergency pause functionality","title":"Factory Security"},{"location":"smart-contracts/interfaces/idiamond-factory/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/interfaces/idiamond-factory/#template-design","text":"Modular Facets : Design reusable, modular facets Standard Interfaces : Use standard interfaces for compatibility Documentation : Document template capabilities and limitations Testing : Thoroughly test template configurations","title":"Template Design"},{"location":"smart-contracts/interfaces/idiamond-factory/#factory-management","text":"Access Control : Implement proper access controls Event Logging : Log all factory operations Error Handling : Implement comprehensive error handling Upgrade Planning : Plan for factory upgrades","title":"Factory Management"},{"location":"smart-contracts/interfaces/idiamond-factory/#deployment-patterns","text":"Deterministic Addresses : Use CREATE2 for predictable addresses Batch Operations : Support batch deployments for efficiency Gas Optimization : Optimize deployment gas costs Monitoring : Monitor deployment success and failures","title":"Deployment Patterns"},{"location":"smart-contracts/interfaces/idiamond-factory/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/idiamond-factory/#frontend-integration","text":"class DiamondFactoryService { private contract : Contract ; constructor ( address : string , provider : Provider ) { this . contract = new Contract ( address , DIAMOND_FACTORY_ABI , provider ); } async deployDiamond ( config : DeploymentConfig ) : Promise < string > { const tx = await this . contract . deployDiamond ( config ); const receipt = await tx . wait (); const event = receipt . events ? . find ( e => e . event === 'DiamondDeployed' ); return event ? . args ? . diamond ; } async predictAddress ( config : DeploymentConfig ) : Promise < string > { return await this . contract . predictDiamondAddress ( config ); } async getTemplate ( name : string ) : Promise < DiamondTemplate > { return await this . contract . getTemplate ( name ); } async getDeployedDiamonds ( deployer : string ) : Promise < string [] > { return await this . contract . getDeployedDiamonds ( deployer ); } }","title":"Frontend Integration"},{"location":"smart-contracts/interfaces/idiamond-factory/#cli-integration","text":"# Deploy a diamond using CLI gemforce deploy-diamond \\ --template \"NFTCollection\" \\ --name \"My Collection\" \\ --symbol \"MYC\" \\ --owner \"0x...\" \\ --network \"polygon\" # Register a new template gemforce register-template \\ --name \"CustomNFT\" \\ --version \"1.0.0\" \\ --config \"./templates/custom-nft.json\" \\ --network \"polygon\" # List available templates gemforce list-templates --network \"polygon\"","title":"CLI Integration"},{"location":"smart-contracts/interfaces/idiamond-factory/#related-documentation","text":"Diamond Standard Overview Diamond Factory Implementation Diamond Cut Facet Diamond Loupe Facet Diamond Factory Library Deployment Guide","title":"Related Documentation"},{"location":"smart-contracts/interfaces/idiamond-factory/#standards-compliance","text":"EIP-2535 : Diamond Standard implementation EIP-1167 : Minimal Proxy Standard for cloning EIP-1014 : CREATE2 for deterministic addresses Factory Pattern : Standard factory design patterns Access Control : Role-based access control patterns","title":"Standards Compliance"},{"location":"smart-contracts/interfaces/idiamond/","text":"IDiamond Interface \u00b6 Overview \u00b6 The IDiamond.sol defines the core interface and data structures for the Diamond Standard implementation within the Gemforce platform. This interface establishes the fundamental contract for diamond proxy functionality and provides essential data structures for diamond configuration and storage. Interface Details \u00b6 Interface Name : IDiamond License : MIT Solidity Version : ^0.8.6 Key Features \u00b6 \ud83d\udd39 Diamond Standard Compliance \u00b6 Core interface for EIP-2535 Diamond Standard Standardized diamond proxy functionality Consistent diamond address resolution Integration with diamond storage patterns \ud83d\udd39 Configuration Management \u00b6 Comprehensive diamond settings structure Owner and factory address management SVG manager integration Metadata storage capabilities \ud83d\udd39 Storage Architecture \u00b6 Structured diamond storage layout Efficient metadata management Extensible configuration system Type-safe data structures Core Data Structures \u00b6 DiamondSettings \u00b6 struct DiamondSettings { address owner ; // Diamond contract owner address factory ; // Factory contract that created this diamond address svgManager ; // SVG template manager contract string symbol ; // Diamond symbol identifier string name ; // Human-readable diamond name } Purpose : Defines the core configuration parameters for a diamond instance. Fields : - owner : Address with administrative control over the diamond - factory : Address of the factory contract that deployed this diamond - svgManager : Address of the SVG template manager for dynamic graphics - symbol : Short identifier for the diamond (typically 3-5 characters) - name : Descriptive name for the diamond instance Usage Example : // Configure diamond settings DiamondSettings memory settings = DiamondSettings ({ owner : msg.sender , factory : factoryAddress , svgManager : svgManagerAddress , symbol : \"GEM1\" , name : \"Gemforce Diamond Instance 1\" }); DiamondContract \u00b6 struct DiamondContract { DiamondSettings settings ; // Core diamond configuration mapping ( string => string ) metadata ; // Extensible metadata storage } Purpose : Encapsulates the complete diamond contract state including settings and metadata. Fields : - settings : Core diamond configuration (DiamondSettings struct) - metadata : Key-value mapping for extensible metadata storage Usage Example : // Access diamond contract data DiamondContract storage diamond = diamondStorage (). diamondContract ; // Update settings diamond . settings . owner = newOwner ; // Set metadata diamond . metadata [ \"version\" ] = \"1.0.0\" ; diamond . metadata [ \"description\" ] = \"Trade deal diamond instance\" ; diamond . metadata [ \"category\" ] = \"finance\" ; Metadata Use Cases : - Version Information : Track diamond version and upgrades - Business Logic : Store business-specific configuration - Integration Data : External service integration parameters - Audit Trail : Track important state changes and events DiamondStorage \u00b6 struct DiamondStorage { DiamondContract diamondContract ; // Complete diamond state } Purpose : Root storage structure for diamond state management using diamond storage pattern. Fields : - diamondContract : Complete diamond contract state and configuration Storage Pattern : // Diamond storage access pattern function diamondStorage () internal pure returns ( DiamondStorage storage ds ) { bytes32 position = keccak256 ( \"diamond.standard.diamond.storage\" ); assembly { ds . slot := position } } Core Interface Functions \u00b6 getDiamondAddress() \u00b6 function getDiamondAddress () external view returns ( address ) Purpose : Returns the address of the diamond contract instance. Returns : - address : The address of the current diamond contract Usage : This function provides a standardized way to retrieve the diamond's own address, which is essential for: - Self-Reference : When the diamond needs to reference itself - Integration : External contracts identifying the diamond - Logging : Event emission with diamond address - Validation : Confirming diamond identity in multi-diamond systems Example Usage : // Get diamond address for integration address diamondAddr = IDiamond ( diamond ). getDiamondAddress (); console . log ( \"Diamond deployed at:\" , diamondAddr ); // Use in external contract integration ExternalContract external = ExternalContract ( externalAddress ); external . registerDiamond ( diamondAddr ); // Self-reference in diamond functions function someInternalFunction () internal { address self = IDiamond ( address ( this )). getDiamondAddress (); emit DiamondOperation ( self , \"operation_completed\" ); } Implementation Examples \u00b6 Diamond Configuration Manager \u00b6 // Comprehensive diamond configuration management contract DiamondConfigManager { using LibDiamond for DiamondStorage ; event DiamondConfigured ( address indexed diamond , DiamondSettings settings ); event MetadataUpdated ( address indexed diamond , string key , string value ); event OwnershipTransferred ( address indexed diamond , address indexed previousOwner , address indexed newOwner ); function configureDiamond ( DiamondSettings memory settings , string [] memory metadataKeys , string [] memory metadataValues ) external onlyOwner { require ( metadataKeys . length == metadataValues . length , \"Metadata arrays length mismatch\" ); DiamondStorage storage ds = LibDiamond . diamondStorage (); // Set core settings ds . diamondContract . settings = settings ; // Set metadata for ( uint256 i = 0 ; i < metadataKeys . length ; i ++ ) { ds . diamondContract . metadata [ metadataKeys [ i ]] = metadataValues [ i ]; emit MetadataUpdated ( address ( this ), metadataKeys [ i ], metadataValues [ i ]); } emit DiamondConfigured ( address ( this ), settings ); } function updateDiamondSettings ( DiamondSettings memory newSettings ) external onlyOwner { DiamondStorage storage ds = LibDiamond . diamondStorage (); address previousOwner = ds . diamondContract . settings . owner ; ds . diamondContract . settings = newSettings ; if ( previousOwner != newSettings . owner ) { emit OwnershipTransferred ( address ( this ), previousOwner , newSettings . owner ); } emit DiamondConfigured ( address ( this ), newSettings ); } function setMetadata ( string memory key , string memory value ) external onlyOwner { DiamondStorage storage ds = LibDiamond . diamondStorage (); ds . diamondContract . metadata [ key ] = value ; emit MetadataUpdated ( address ( this ), key , value ); } function getMetadata ( string memory key ) external view returns ( string memory ) { DiamondStorage storage ds = LibDiamond . diamondStorage (); return ds . diamondContract . metadata [ key ]; } function getDiamondSettings () external view returns ( DiamondSettings memory ) { DiamondStorage storage ds = LibDiamond . diamondStorage (); return ds . diamondContract . settings ; } function getAllMetadata ( string [] memory keys ) external view returns ( string [] memory values ) { DiamondStorage storage ds = LibDiamond . diamondStorage (); values = new string []( keys . length ); for ( uint256 i = 0 ; i < keys . length ; i ++ ) { values [ i ] = ds . diamondContract . metadata [ keys [ i ]]; } } } Diamond Registry System \u00b6 // Registry for tracking multiple diamond instances contract DiamondRegistry { struct DiamondInfo { address diamondAddress ; DiamondSettings settings ; uint256 createdAt ; bool active ; string category ; } mapping ( address => DiamondInfo ) public diamonds ; mapping ( string => address []) public diamondsByCategory ; mapping ( address => address []) public diamondsByOwner ; address [] public allDiamonds ; event DiamondRegistered ( address indexed diamond , address indexed owner , string category ); event DiamondDeactivated ( address indexed diamond ); event DiamondCategoryUpdated ( address indexed diamond , string oldCategory , string newCategory ); function registerDiamond ( address diamondAddress , string memory category ) external { require ( diamondAddress != address ( 0 ), \"Invalid diamond address\" ); require ( diamonds [ diamondAddress ]. diamondAddress == address ( 0 ), \"Diamond already registered\" ); // Get diamond settings DiamondSettings memory settings ; try IDiamond ( diamondAddress ). getDiamondAddress () returns ( address addr ) { require ( addr == diamondAddress , \"Diamond address mismatch\" ); // Additional calls to get settings would require extended interface } catch { revert ( \"Invalid diamond contract\" ); } // Register diamond diamonds [ diamondAddress ] = DiamondInfo ({ diamondAddress : diamondAddress , settings : settings , createdAt : block.timestamp , active : true , category : category }); allDiamonds . push ( diamondAddress ); diamondsByCategory [ category ]. push ( diamondAddress ); diamondsByOwner [ settings . owner ]. push ( diamondAddress ); emit DiamondRegistered ( diamondAddress , settings . owner , category ); } function deactivateDiamond ( address diamondAddress ) external { DiamondInfo storage info = diamonds [ diamondAddress ]; require ( info . diamondAddress != address ( 0 ), \"Diamond not registered\" ); require ( info . active , \"Diamond already deactivated\" ); info . active = false ; emit DiamondDeactivated ( diamondAddress ); } function updateDiamondCategory ( address diamondAddress , string memory newCategory ) external { DiamondInfo storage info = diamonds [ diamondAddress ]; require ( info . diamondAddress != address ( 0 ), \"Diamond not registered\" ); string memory oldCategory = info . category ; info . category = newCategory ; // Update category mapping _removeFromCategoryArray ( oldCategory , diamondAddress ); diamondsByCategory [ newCategory ]. push ( diamondAddress ); emit DiamondCategoryUpdated ( diamondAddress , oldCategory , newCategory ); } function getDiamondsByCategory ( string memory category ) external view returns ( address [] memory ) { return diamondsByCategory [ category ]; } function getDiamondsByOwner ( address owner ) external view returns ( address [] memory ) { return diamondsByOwner [ owner ]; } function getActiveDiamonds () external view returns ( address [] memory ) { uint256 activeCount = 0 ; // Count active diamonds for ( uint256 i = 0 ; i < allDiamonds . length ; i ++ ) { if ( diamonds [ allDiamonds [ i ]]. active ) { activeCount ++ ; } } // Build active diamonds array address [] memory activeDiamonds = new address []( activeCount ); uint256 index = 0 ; for ( uint256 i = 0 ; i < allDiamonds . length ; i ++ ) { if ( diamonds [ allDiamonds [ i ]]. active ) { activeDiamonds [ index ] = allDiamonds [ i ]; index ++ ; } } return activeDiamonds ; } function _removeFromCategoryArray ( string memory category , address diamondAddress ) internal { address [] storage categoryArray = diamondsByCategory [ category ]; for ( uint256 i = 0 ; i < categoryArray . length ; i ++ ) { if ( categoryArray [ i ] == diamondAddress ) { categoryArray [ i ] = categoryArray [ categoryArray . length - 1 ]; categoryArray . pop (); break ; } } } } Diamond Metadata Manager \u00b6 // Advanced metadata management for diamonds contract DiamondMetadataManager { struct MetadataSchema { string [] requiredKeys ; string [] optionalKeys ; mapping ( string => string ) defaultValues ; mapping ( string => bool ) isRequired ; } mapping ( string => MetadataSchema ) public schemas ; mapping ( address => string ) public diamondSchemas ; event SchemaCreated ( string indexed schemaName , string [] requiredKeys , string [] optionalKeys ); event DiamondSchemaAssigned ( address indexed diamond , string schemaName ); event MetadataValidated ( address indexed diamond , bool isValid ); function createMetadataSchema ( string memory schemaName , string [] memory requiredKeys , string [] memory optionalKeys , string [] memory defaultKeys , string [] memory defaultValues ) external onlyOwner { require ( defaultKeys . length == defaultValues . length , \"Default arrays length mismatch\" ); MetadataSchema storage schema = schemas [ schemaName ]; schema . requiredKeys = requiredKeys ; schema . optionalKeys = optionalKeys ; // Set required flags for ( uint256 i = 0 ; i < requiredKeys . length ; i ++ ) { schema . isRequired [ requiredKeys [ i ]] = true ; } // Set default values for ( uint256 i = 0 ; i < defaultKeys . length ; i ++ ) { schema . defaultValues [ defaultKeys [ i ]] = defaultValues [ i ]; } emit SchemaCreated ( schemaName , requiredKeys , optionalKeys ); } function assignSchemaToD diamond ( address diamondAddress , string memory schemaName ) external onlyOwner { require ( schemas [ schemaName ]. requiredKeys . length > 0 , \"Schema does not exist\" ); diamondSchemas [ diamondAddress ] = schemaName ; emit DiamondSchemaAssigned ( diamondAddress , schemaName ); } function validateDiamondMetadata ( address diamondAddress ) external view returns ( bool isValid , string [] memory missingKeys , string [] memory suggestions ) { string memory schemaName = diamondSchemas [ diamondAddress ]; require ( bytes ( schemaName ). length > 0 , \"No schema assigned to diamond\" ); MetadataSchema storage schema = schemas [ schemaName ]; string [] memory missing = new string []( schema . requiredKeys . length ); string [] memory suggest = new string []( schema . requiredKeys . length ); uint256 missingCount = 0 ; uint256 suggestCount = 0 ; // Check required keys for ( uint256 i = 0 ; i < schema . requiredKeys . length ; i ++ ) { string memory key = schema . requiredKeys [ i ]; // This would require extended interface to get metadata // For now, we'll simulate the check bool hasKey = _checkDiamondHasMetadata ( diamondAddress , key ); if ( ! hasKey ) { missing [ missingCount ] = key ; missingCount ++ ; // Suggest default value if available if ( bytes ( schema . defaultValues [ key ]). length > 0 ) { suggest [ suggestCount ] = string ( abi . encodePacked ( key , \"=\" , schema . defaultValues [ key ])); suggestCount ++ ; } } } // Resize arrays missingKeys = new string []( missingCount ); suggestions = new string []( suggestCount ); for ( uint256 i = 0 ; i < missingCount ; i ++ ) { missingKeys [ i ] = missing [ i ]; } for ( uint256 i = 0 ; i < suggestCount ; i ++ ) { suggestions [ i ] = suggest [ i ]; } isValid = missingCount == 0 ; } function getSchemaInfo ( string memory schemaName ) external view returns ( string [] memory requiredKeys , string [] memory optionalKeys ) { MetadataSchema storage schema = schemas [ schemaName ]; return ( schema . requiredKeys , schema . optionalKeys ); } function _checkDiamondHasMetadata ( address diamondAddress , string memory key ) internal view returns ( bool ) { // This would require extended interface or direct storage access // Placeholder implementation return true ; } } Diamond Factory Integration \u00b6 // Integration with diamond factory for standardized deployment contract DiamondFactoryIntegration { struct DeploymentConfig { DiamondSettings settings ; string [] metadataKeys ; string [] metadataValues ; address [] initialFacets ; bytes4 [][] facetSelectors ; } mapping ( address => DeploymentConfig ) public deploymentConfigs ; mapping ( address => address ) public factoryToDiamond ; event DiamondDeploymentConfigured ( address indexed factory , DeploymentConfig config ); event DiamondDeployed ( address indexed factory , address indexed diamond , DiamondSettings settings ); function configureDeployment ( address factory , DeploymentConfig memory config ) external onlyOwner { deploymentConfigs [ factory ] = config ; emit DiamondDeploymentConfigured ( factory , config ); } function deployDiamondWithConfig ( address factory ) external returns ( address diamond ) { DeploymentConfig memory config = deploymentConfigs [ factory ]; require ( config . settings . owner != address ( 0 ), \"No deployment config found\" ); // Deploy diamond through factory // This would integrate with actual DiamondFactory contract diamond = _deployDiamond ( factory , config ); factoryToDiamond [ factory ] = diamond ; emit DiamondDeployed ( factory , diamond , config . settings ); } function _deployDiamond ( address factory , DeploymentConfig memory config ) internal returns ( address ) { // Placeholder for actual diamond deployment // Would integrate with DiamondFactory contract return address ( 0 ); } function getDiamondByFactory ( address factory ) external view returns ( address ) { return factoryToDiamond [ factory ]; } function getDeploymentConfig ( address factory ) external view returns ( DeploymentConfig memory ) { return deploymentConfigs [ factory ]; } } Integration Patterns \u00b6 Standard Diamond Implementation \u00b6 // Standard implementation of IDiamond interface contract Diamond is IDiamond { using LibDiamond for DiamondStorage ; constructor ( DiamondSettings memory settings ) { DiamondStorage storage ds = LibDiamond . diamondStorage (); ds . diamondContract . settings = settings ; // Set initial metadata ds . diamondContract . metadata [ \"version\" ] = \"1.0.0\" ; ds . diamondContract . metadata [ \"standard\" ] = \"EIP-2535\" ; ds . diamondContract . metadata [ \"created\" ] = block.timestamp . toString (); } function getDiamondAddress () external view override returns ( address ) { return address ( this ); } // Additional diamond functionality would be implemented through facets } Extended Diamond Interface \u00b6 // Extended interface for additional diamond functionality interface IDiamondExtended is IDiamond { function getDiamondSettings () external view returns ( DiamondSettings memory ); function getMetadata ( string memory key ) external view returns ( string memory ); function setMetadata ( string memory key , string memory value ) external ; function updateSettings ( DiamondSettings memory newSettings ) external ; } Security Considerations \u00b6 Access Control \u00b6 Owner validation for configuration changes Factory address verification for deployment Metadata modification restrictions Settings update authorization Data Integrity \u00b6 Validation of diamond settings parameters Metadata key-value consistency Storage slot collision prevention Upgrade safety considerations Interface Compliance \u00b6 EIP-2535 Diamond Standard compliance Consistent interface implementation Proper function selector management Event emission standards Gas Optimization \u00b6 Storage Efficiency \u00b6 Packed storage structures where possible Efficient metadata storage patterns Minimal storage operations Optimized diamond storage access Function Optimization \u00b6 View function gas efficiency Minimal external calls Efficient data retrieval patterns Optimized event emission Testing Considerations \u00b6 Unit Tests \u00b6 Interface compliance verification Data structure validation Function return value testing Event emission verification Integration Tests \u00b6 Diamond deployment workflows Factory integration testing Metadata management scenarios Multi-diamond interactions Related Documentation \u00b6 Diamond Standard (EIP-2535) - Diamond Standard specification LibDiamond - Diamond utilities library DiamondFactory - Diamond deployment factory Diamond Contract - Core diamond implementation Diamond Architecture Guide - Implementation guide This interface defines the core contract for Diamond Standard implementation within the Gemforce platform, providing essential functionality for diamond proxy management and configuration.","title":"IDiamond"},{"location":"smart-contracts/interfaces/idiamond/#idiamond-interface","text":"","title":"IDiamond Interface"},{"location":"smart-contracts/interfaces/idiamond/#overview","text":"The IDiamond.sol defines the core interface and data structures for the Diamond Standard implementation within the Gemforce platform. This interface establishes the fundamental contract for diamond proxy functionality and provides essential data structures for diamond configuration and storage.","title":"Overview"},{"location":"smart-contracts/interfaces/idiamond/#interface-details","text":"Interface Name : IDiamond License : MIT Solidity Version : ^0.8.6","title":"Interface Details"},{"location":"smart-contracts/interfaces/idiamond/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/idiamond/#diamond-standard-compliance","text":"Core interface for EIP-2535 Diamond Standard Standardized diamond proxy functionality Consistent diamond address resolution Integration with diamond storage patterns","title":"\ud83d\udd39 Diamond Standard Compliance"},{"location":"smart-contracts/interfaces/idiamond/#configuration-management","text":"Comprehensive diamond settings structure Owner and factory address management SVG manager integration Metadata storage capabilities","title":"\ud83d\udd39 Configuration Management"},{"location":"smart-contracts/interfaces/idiamond/#storage-architecture","text":"Structured diamond storage layout Efficient metadata management Extensible configuration system Type-safe data structures","title":"\ud83d\udd39 Storage Architecture"},{"location":"smart-contracts/interfaces/idiamond/#core-data-structures","text":"","title":"Core Data Structures"},{"location":"smart-contracts/interfaces/idiamond/#diamondsettings","text":"struct DiamondSettings { address owner ; // Diamond contract owner address factory ; // Factory contract that created this diamond address svgManager ; // SVG template manager contract string symbol ; // Diamond symbol identifier string name ; // Human-readable diamond name } Purpose : Defines the core configuration parameters for a diamond instance. Fields : - owner : Address with administrative control over the diamond - factory : Address of the factory contract that deployed this diamond - svgManager : Address of the SVG template manager for dynamic graphics - symbol : Short identifier for the diamond (typically 3-5 characters) - name : Descriptive name for the diamond instance Usage Example : // Configure diamond settings DiamondSettings memory settings = DiamondSettings ({ owner : msg.sender , factory : factoryAddress , svgManager : svgManagerAddress , symbol : \"GEM1\" , name : \"Gemforce Diamond Instance 1\" });","title":"DiamondSettings"},{"location":"smart-contracts/interfaces/idiamond/#diamondcontract","text":"struct DiamondContract { DiamondSettings settings ; // Core diamond configuration mapping ( string => string ) metadata ; // Extensible metadata storage } Purpose : Encapsulates the complete diamond contract state including settings and metadata. Fields : - settings : Core diamond configuration (DiamondSettings struct) - metadata : Key-value mapping for extensible metadata storage Usage Example : // Access diamond contract data DiamondContract storage diamond = diamondStorage (). diamondContract ; // Update settings diamond . settings . owner = newOwner ; // Set metadata diamond . metadata [ \"version\" ] = \"1.0.0\" ; diamond . metadata [ \"description\" ] = \"Trade deal diamond instance\" ; diamond . metadata [ \"category\" ] = \"finance\" ; Metadata Use Cases : - Version Information : Track diamond version and upgrades - Business Logic : Store business-specific configuration - Integration Data : External service integration parameters - Audit Trail : Track important state changes and events","title":"DiamondContract"},{"location":"smart-contracts/interfaces/idiamond/#diamondstorage","text":"struct DiamondStorage { DiamondContract diamondContract ; // Complete diamond state } Purpose : Root storage structure for diamond state management using diamond storage pattern. Fields : - diamondContract : Complete diamond contract state and configuration Storage Pattern : // Diamond storage access pattern function diamondStorage () internal pure returns ( DiamondStorage storage ds ) { bytes32 position = keccak256 ( \"diamond.standard.diamond.storage\" ); assembly { ds . slot := position } }","title":"DiamondStorage"},{"location":"smart-contracts/interfaces/idiamond/#core-interface-functions","text":"","title":"Core Interface Functions"},{"location":"smart-contracts/interfaces/idiamond/#getdiamondaddress","text":"function getDiamondAddress () external view returns ( address ) Purpose : Returns the address of the diamond contract instance. Returns : - address : The address of the current diamond contract Usage : This function provides a standardized way to retrieve the diamond's own address, which is essential for: - Self-Reference : When the diamond needs to reference itself - Integration : External contracts identifying the diamond - Logging : Event emission with diamond address - Validation : Confirming diamond identity in multi-diamond systems Example Usage : // Get diamond address for integration address diamondAddr = IDiamond ( diamond ). getDiamondAddress (); console . log ( \"Diamond deployed at:\" , diamondAddr ); // Use in external contract integration ExternalContract external = ExternalContract ( externalAddress ); external . registerDiamond ( diamondAddr ); // Self-reference in diamond functions function someInternalFunction () internal { address self = IDiamond ( address ( this )). getDiamondAddress (); emit DiamondOperation ( self , \"operation_completed\" ); }","title":"getDiamondAddress()"},{"location":"smart-contracts/interfaces/idiamond/#implementation-examples","text":"","title":"Implementation Examples"},{"location":"smart-contracts/interfaces/idiamond/#diamond-configuration-manager","text":"// Comprehensive diamond configuration management contract DiamondConfigManager { using LibDiamond for DiamondStorage ; event DiamondConfigured ( address indexed diamond , DiamondSettings settings ); event MetadataUpdated ( address indexed diamond , string key , string value ); event OwnershipTransferred ( address indexed diamond , address indexed previousOwner , address indexed newOwner ); function configureDiamond ( DiamondSettings memory settings , string [] memory metadataKeys , string [] memory metadataValues ) external onlyOwner { require ( metadataKeys . length == metadataValues . length , \"Metadata arrays length mismatch\" ); DiamondStorage storage ds = LibDiamond . diamondStorage (); // Set core settings ds . diamondContract . settings = settings ; // Set metadata for ( uint256 i = 0 ; i < metadataKeys . length ; i ++ ) { ds . diamondContract . metadata [ metadataKeys [ i ]] = metadataValues [ i ]; emit MetadataUpdated ( address ( this ), metadataKeys [ i ], metadataValues [ i ]); } emit DiamondConfigured ( address ( this ), settings ); } function updateDiamondSettings ( DiamondSettings memory newSettings ) external onlyOwner { DiamondStorage storage ds = LibDiamond . diamondStorage (); address previousOwner = ds . diamondContract . settings . owner ; ds . diamondContract . settings = newSettings ; if ( previousOwner != newSettings . owner ) { emit OwnershipTransferred ( address ( this ), previousOwner , newSettings . owner ); } emit DiamondConfigured ( address ( this ), newSettings ); } function setMetadata ( string memory key , string memory value ) external onlyOwner { DiamondStorage storage ds = LibDiamond . diamondStorage (); ds . diamondContract . metadata [ key ] = value ; emit MetadataUpdated ( address ( this ), key , value ); } function getMetadata ( string memory key ) external view returns ( string memory ) { DiamondStorage storage ds = LibDiamond . diamondStorage (); return ds . diamondContract . metadata [ key ]; } function getDiamondSettings () external view returns ( DiamondSettings memory ) { DiamondStorage storage ds = LibDiamond . diamondStorage (); return ds . diamondContract . settings ; } function getAllMetadata ( string [] memory keys ) external view returns ( string [] memory values ) { DiamondStorage storage ds = LibDiamond . diamondStorage (); values = new string []( keys . length ); for ( uint256 i = 0 ; i < keys . length ; i ++ ) { values [ i ] = ds . diamondContract . metadata [ keys [ i ]]; } } }","title":"Diamond Configuration Manager"},{"location":"smart-contracts/interfaces/idiamond/#diamond-registry-system","text":"// Registry for tracking multiple diamond instances contract DiamondRegistry { struct DiamondInfo { address diamondAddress ; DiamondSettings settings ; uint256 createdAt ; bool active ; string category ; } mapping ( address => DiamondInfo ) public diamonds ; mapping ( string => address []) public diamondsByCategory ; mapping ( address => address []) public diamondsByOwner ; address [] public allDiamonds ; event DiamondRegistered ( address indexed diamond , address indexed owner , string category ); event DiamondDeactivated ( address indexed diamond ); event DiamondCategoryUpdated ( address indexed diamond , string oldCategory , string newCategory ); function registerDiamond ( address diamondAddress , string memory category ) external { require ( diamondAddress != address ( 0 ), \"Invalid diamond address\" ); require ( diamonds [ diamondAddress ]. diamondAddress == address ( 0 ), \"Diamond already registered\" ); // Get diamond settings DiamondSettings memory settings ; try IDiamond ( diamondAddress ). getDiamondAddress () returns ( address addr ) { require ( addr == diamondAddress , \"Diamond address mismatch\" ); // Additional calls to get settings would require extended interface } catch { revert ( \"Invalid diamond contract\" ); } // Register diamond diamonds [ diamondAddress ] = DiamondInfo ({ diamondAddress : diamondAddress , settings : settings , createdAt : block.timestamp , active : true , category : category }); allDiamonds . push ( diamondAddress ); diamondsByCategory [ category ]. push ( diamondAddress ); diamondsByOwner [ settings . owner ]. push ( diamondAddress ); emit DiamondRegistered ( diamondAddress , settings . owner , category ); } function deactivateDiamond ( address diamondAddress ) external { DiamondInfo storage info = diamonds [ diamondAddress ]; require ( info . diamondAddress != address ( 0 ), \"Diamond not registered\" ); require ( info . active , \"Diamond already deactivated\" ); info . active = false ; emit DiamondDeactivated ( diamondAddress ); } function updateDiamondCategory ( address diamondAddress , string memory newCategory ) external { DiamondInfo storage info = diamonds [ diamondAddress ]; require ( info . diamondAddress != address ( 0 ), \"Diamond not registered\" ); string memory oldCategory = info . category ; info . category = newCategory ; // Update category mapping _removeFromCategoryArray ( oldCategory , diamondAddress ); diamondsByCategory [ newCategory ]. push ( diamondAddress ); emit DiamondCategoryUpdated ( diamondAddress , oldCategory , newCategory ); } function getDiamondsByCategory ( string memory category ) external view returns ( address [] memory ) { return diamondsByCategory [ category ]; } function getDiamondsByOwner ( address owner ) external view returns ( address [] memory ) { return diamondsByOwner [ owner ]; } function getActiveDiamonds () external view returns ( address [] memory ) { uint256 activeCount = 0 ; // Count active diamonds for ( uint256 i = 0 ; i < allDiamonds . length ; i ++ ) { if ( diamonds [ allDiamonds [ i ]]. active ) { activeCount ++ ; } } // Build active diamonds array address [] memory activeDiamonds = new address []( activeCount ); uint256 index = 0 ; for ( uint256 i = 0 ; i < allDiamonds . length ; i ++ ) { if ( diamonds [ allDiamonds [ i ]]. active ) { activeDiamonds [ index ] = allDiamonds [ i ]; index ++ ; } } return activeDiamonds ; } function _removeFromCategoryArray ( string memory category , address diamondAddress ) internal { address [] storage categoryArray = diamondsByCategory [ category ]; for ( uint256 i = 0 ; i < categoryArray . length ; i ++ ) { if ( categoryArray [ i ] == diamondAddress ) { categoryArray [ i ] = categoryArray [ categoryArray . length - 1 ]; categoryArray . pop (); break ; } } } }","title":"Diamond Registry System"},{"location":"smart-contracts/interfaces/idiamond/#diamond-metadata-manager","text":"// Advanced metadata management for diamonds contract DiamondMetadataManager { struct MetadataSchema { string [] requiredKeys ; string [] optionalKeys ; mapping ( string => string ) defaultValues ; mapping ( string => bool ) isRequired ; } mapping ( string => MetadataSchema ) public schemas ; mapping ( address => string ) public diamondSchemas ; event SchemaCreated ( string indexed schemaName , string [] requiredKeys , string [] optionalKeys ); event DiamondSchemaAssigned ( address indexed diamond , string schemaName ); event MetadataValidated ( address indexed diamond , bool isValid ); function createMetadataSchema ( string memory schemaName , string [] memory requiredKeys , string [] memory optionalKeys , string [] memory defaultKeys , string [] memory defaultValues ) external onlyOwner { require ( defaultKeys . length == defaultValues . length , \"Default arrays length mismatch\" ); MetadataSchema storage schema = schemas [ schemaName ]; schema . requiredKeys = requiredKeys ; schema . optionalKeys = optionalKeys ; // Set required flags for ( uint256 i = 0 ; i < requiredKeys . length ; i ++ ) { schema . isRequired [ requiredKeys [ i ]] = true ; } // Set default values for ( uint256 i = 0 ; i < defaultKeys . length ; i ++ ) { schema . defaultValues [ defaultKeys [ i ]] = defaultValues [ i ]; } emit SchemaCreated ( schemaName , requiredKeys , optionalKeys ); } function assignSchemaToD diamond ( address diamondAddress , string memory schemaName ) external onlyOwner { require ( schemas [ schemaName ]. requiredKeys . length > 0 , \"Schema does not exist\" ); diamondSchemas [ diamondAddress ] = schemaName ; emit DiamondSchemaAssigned ( diamondAddress , schemaName ); } function validateDiamondMetadata ( address diamondAddress ) external view returns ( bool isValid , string [] memory missingKeys , string [] memory suggestions ) { string memory schemaName = diamondSchemas [ diamondAddress ]; require ( bytes ( schemaName ). length > 0 , \"No schema assigned to diamond\" ); MetadataSchema storage schema = schemas [ schemaName ]; string [] memory missing = new string []( schema . requiredKeys . length ); string [] memory suggest = new string []( schema . requiredKeys . length ); uint256 missingCount = 0 ; uint256 suggestCount = 0 ; // Check required keys for ( uint256 i = 0 ; i < schema . requiredKeys . length ; i ++ ) { string memory key = schema . requiredKeys [ i ]; // This would require extended interface to get metadata // For now, we'll simulate the check bool hasKey = _checkDiamondHasMetadata ( diamondAddress , key ); if ( ! hasKey ) { missing [ missingCount ] = key ; missingCount ++ ; // Suggest default value if available if ( bytes ( schema . defaultValues [ key ]). length > 0 ) { suggest [ suggestCount ] = string ( abi . encodePacked ( key , \"=\" , schema . defaultValues [ key ])); suggestCount ++ ; } } } // Resize arrays missingKeys = new string []( missingCount ); suggestions = new string []( suggestCount ); for ( uint256 i = 0 ; i < missingCount ; i ++ ) { missingKeys [ i ] = missing [ i ]; } for ( uint256 i = 0 ; i < suggestCount ; i ++ ) { suggestions [ i ] = suggest [ i ]; } isValid = missingCount == 0 ; } function getSchemaInfo ( string memory schemaName ) external view returns ( string [] memory requiredKeys , string [] memory optionalKeys ) { MetadataSchema storage schema = schemas [ schemaName ]; return ( schema . requiredKeys , schema . optionalKeys ); } function _checkDiamondHasMetadata ( address diamondAddress , string memory key ) internal view returns ( bool ) { // This would require extended interface or direct storage access // Placeholder implementation return true ; } }","title":"Diamond Metadata Manager"},{"location":"smart-contracts/interfaces/idiamond/#diamond-factory-integration","text":"// Integration with diamond factory for standardized deployment contract DiamondFactoryIntegration { struct DeploymentConfig { DiamondSettings settings ; string [] metadataKeys ; string [] metadataValues ; address [] initialFacets ; bytes4 [][] facetSelectors ; } mapping ( address => DeploymentConfig ) public deploymentConfigs ; mapping ( address => address ) public factoryToDiamond ; event DiamondDeploymentConfigured ( address indexed factory , DeploymentConfig config ); event DiamondDeployed ( address indexed factory , address indexed diamond , DiamondSettings settings ); function configureDeployment ( address factory , DeploymentConfig memory config ) external onlyOwner { deploymentConfigs [ factory ] = config ; emit DiamondDeploymentConfigured ( factory , config ); } function deployDiamondWithConfig ( address factory ) external returns ( address diamond ) { DeploymentConfig memory config = deploymentConfigs [ factory ]; require ( config . settings . owner != address ( 0 ), \"No deployment config found\" ); // Deploy diamond through factory // This would integrate with actual DiamondFactory contract diamond = _deployDiamond ( factory , config ); factoryToDiamond [ factory ] = diamond ; emit DiamondDeployed ( factory , diamond , config . settings ); } function _deployDiamond ( address factory , DeploymentConfig memory config ) internal returns ( address ) { // Placeholder for actual diamond deployment // Would integrate with DiamondFactory contract return address ( 0 ); } function getDiamondByFactory ( address factory ) external view returns ( address ) { return factoryToDiamond [ factory ]; } function getDeploymentConfig ( address factory ) external view returns ( DeploymentConfig memory ) { return deploymentConfigs [ factory ]; } }","title":"Diamond Factory Integration"},{"location":"smart-contracts/interfaces/idiamond/#integration-patterns","text":"","title":"Integration Patterns"},{"location":"smart-contracts/interfaces/idiamond/#standard-diamond-implementation","text":"// Standard implementation of IDiamond interface contract Diamond is IDiamond { using LibDiamond for DiamondStorage ; constructor ( DiamondSettings memory settings ) { DiamondStorage storage ds = LibDiamond . diamondStorage (); ds . diamondContract . settings = settings ; // Set initial metadata ds . diamondContract . metadata [ \"version\" ] = \"1.0.0\" ; ds . diamondContract . metadata [ \"standard\" ] = \"EIP-2535\" ; ds . diamondContract . metadata [ \"created\" ] = block.timestamp . toString (); } function getDiamondAddress () external view override returns ( address ) { return address ( this ); } // Additional diamond functionality would be implemented through facets }","title":"Standard Diamond Implementation"},{"location":"smart-contracts/interfaces/idiamond/#extended-diamond-interface","text":"// Extended interface for additional diamond functionality interface IDiamondExtended is IDiamond { function getDiamondSettings () external view returns ( DiamondSettings memory ); function getMetadata ( string memory key ) external view returns ( string memory ); function setMetadata ( string memory key , string memory value ) external ; function updateSettings ( DiamondSettings memory newSettings ) external ; }","title":"Extended Diamond Interface"},{"location":"smart-contracts/interfaces/idiamond/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/idiamond/#access-control","text":"Owner validation for configuration changes Factory address verification for deployment Metadata modification restrictions Settings update authorization","title":"Access Control"},{"location":"smart-contracts/interfaces/idiamond/#data-integrity","text":"Validation of diamond settings parameters Metadata key-value consistency Storage slot collision prevention Upgrade safety considerations","title":"Data Integrity"},{"location":"smart-contracts/interfaces/idiamond/#interface-compliance","text":"EIP-2535 Diamond Standard compliance Consistent interface implementation Proper function selector management Event emission standards","title":"Interface Compliance"},{"location":"smart-contracts/interfaces/idiamond/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/interfaces/idiamond/#storage-efficiency","text":"Packed storage structures where possible Efficient metadata storage patterns Minimal storage operations Optimized diamond storage access","title":"Storage Efficiency"},{"location":"smart-contracts/interfaces/idiamond/#function-optimization","text":"View function gas efficiency Minimal external calls Efficient data retrieval patterns Optimized event emission","title":"Function Optimization"},{"location":"smart-contracts/interfaces/idiamond/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/interfaces/idiamond/#unit-tests","text":"Interface compliance verification Data structure validation Function return value testing Event emission verification","title":"Unit Tests"},{"location":"smart-contracts/interfaces/idiamond/#integration-tests","text":"Diamond deployment workflows Factory integration testing Metadata management scenarios Multi-diamond interactions","title":"Integration Tests"},{"location":"smart-contracts/interfaces/idiamond/#related-documentation","text":"Diamond Standard (EIP-2535) - Diamond Standard specification LibDiamond - Diamond utilities library DiamondFactory - Diamond deployment factory Diamond Contract - Core diamond implementation Diamond Architecture Guide - Implementation guide This interface defines the core contract for Diamond Standard implementation within the Gemforce platform, providing essential functionality for diamond proxy management and configuration.","title":"Related Documentation"},{"location":"smart-contracts/interfaces/ierc1155-mint/","text":"IERC1155Mint Interface \u00b6 Overview \u00b6 The IERC1155Mint interface defines the standard contract for minting ERC1155 tokens within the Gemforce platform. This interface extends the standard ERC1155 functionality by providing controlled minting capabilities for multi-token contracts, enabling the creation of fungible, non-fungible, and semi-fungible tokens with flexible quantity management. Key Features \u00b6 Flexible Token Minting : Support for minting single and multiple token types Recipient Control : Mint tokens to specific addresses or caller Batch Operations : Efficient batch minting for multiple token types Quantity Management : Precise control over minted token quantities Event Tracking : Comprehensive event emission for minting operations Interface Definition \u00b6 // SPDX-License-Identifier: MIT pragma solidity >= 0.8.0 ; interface IERC1155Mint { // Events event ERC1155TokenMinted ( address minter , uint256 id , uint256 quantity ); // Core Minting Functions function mint ( uint256 id , uint256 quantity , bytes memory data ) external ; function mintTo ( address recipient , uint256 id , uint256 quantity , bytes memory data ) external ; function batchMintTo ( address recipient , uint256 [] memory ids , uint256 [] calldata quantities , bytes memory data ) external ; } Core Functions \u00b6 Single Token Minting \u00b6 mint() \u00b6 function mint ( uint256 id , uint256 quantity , bytes memory data ) external Purpose : Mint tokens of a specified type and quantity to the caller's address. Parameters : - id (uint256): The token type identifier to mint - quantity (uint256): The amount of tokens to mint - data (bytes): Additional data to pass to the recipient (if it's a contract) Requirements : - Caller must have minting permissions - Token ID must be valid for minting - Quantity must be greater than zero - Contract must not be paused (if pausable) Events Emitted : - ERC1155TokenMinted with minter address, token ID, and quantity Example Usage : // Mint 100 tokens of type 1 to caller uint256 tokenId = 1 ; uint256 quantity = 100 ; bytes memory data = \"\" ; IERC1155Mint ( tokenContract ). mint ( tokenId , quantity , data ); console . log ( \"Minted\" , quantity , \"tokens of type\" , tokenId , \"to caller\" ); mintTo() \u00b6 function mintTo ( address recipient , uint256 id , uint256 quantity , bytes memory data ) external Purpose : Mint tokens of a specified type and quantity to a specific recipient address. Parameters : - recipient (address): The address to receive the minted tokens - id (uint256): The token type identifier to mint - quantity (uint256): The amount of tokens to mint - data (bytes): Additional data to pass to the recipient (if it's a contract) Requirements : - Caller must have minting permissions - Recipient address must not be zero address - Token ID must be valid for minting - Quantity must be greater than zero - If recipient is a contract, it must implement ERC1155Receiver Events Emitted : - ERC1155TokenMinted with minter address, token ID, and quantity - Standard ERC1155 TransferSingle event Example Usage : // Mint 50 tokens of type 2 to specific address address recipient = 0x742d35Cc6634C0532925a3b8D4C9db96590c6C8C ; uint256 tokenId = 2 ; uint256 quantity = 50 ; bytes memory data = \"\" ; IERC1155Mint ( tokenContract ). mintTo ( recipient , tokenId , quantity , data ); console . log ( \"Minted\" , quantity , \"tokens of type\" , tokenId , \"to\" , recipient ); Batch Minting \u00b6 batchMintTo() \u00b6 function batchMintTo ( address recipient , uint256 [] memory ids , uint256 [] calldata quantities , bytes memory data ) external Purpose : Efficiently mint multiple token types with specified quantities to a recipient in a single transaction. Parameters : - recipient (address): The address to receive all minted tokens - ids (uint256[]): Array of token type identifiers to mint - quantities (uint256[]): Array of quantities corresponding to each token ID - data (bytes): Additional data to pass to the recipient (if it's a contract) Requirements : - Caller must have minting permissions - Recipient address must not be zero address - Arrays must have the same length and not be empty - All token IDs must be valid for minting - All quantities must be greater than zero - If recipient is a contract, it must implement ERC1155Receiver Events Emitted : - ERC1155TokenMinted for each token type minted - Standard ERC1155 TransferBatch event Gas Optimization : More efficient than multiple individual mint calls Example Usage : // Batch mint multiple token types address recipient = 0x742d35Cc6634C0532925a3b8D4C9db96590c6C8C ; uint256 [] memory tokenIds = new uint256 []( 3 ); tokenIds [ 0 ] = 1 ; // Common item tokenIds [ 1 ] = 2 ; // Rare item tokenIds [ 2 ] = 3 ; // Epic item uint256 [] memory quantities = new uint256 []( 3 ); quantities [ 0 ] = 100 ; // 100 common items quantities [ 1 ] = 10 ; // 10 rare items quantities [ 2 ] = 1 ; // 1 epic item bytes memory data = \"\" ; IERC1155Mint ( tokenContract ). batchMintTo ( recipient , tokenIds , quantities , data ); console . log ( \"Batch minted\" , tokenIds . length , \"token types to\" , recipient ); Integration Examples \u00b6 Gaming Item System \u00b6 // Gaming platform with different item types contract GameItemSystem { IERC1155Mint public gameItems ; // Item type definitions uint256 public constant COMMON_SWORD = 1 ; uint256 public constant RARE_SHIELD = 2 ; uint256 public constant EPIC_ARMOR = 3 ; uint256 public constant LEGENDARY_WEAPON = 4 ; // Item rarity and quantities mapping ( uint256 => uint256 ) public itemRarity ; mapping ( uint256 => uint256 ) public maxSupply ; mapping ( uint256 => uint256 ) public currentSupply ; event PlayerRewardMinted ( address indexed player , uint256 [] itemIds , uint256 [] quantities ); event QuestRewardDistributed ( uint256 indexed questId , address [] players , uint256 rewardItemId ); constructor ( address _gameItems ) { gameItems = IERC1155Mint ( _gameItems ); // Set up item rarities and max supplies itemRarity [ COMMON_SWORD ] = 1 ; itemRarity [ RARE_SHIELD ] = 2 ; itemRarity [ EPIC_ARMOR ] = 3 ; itemRarity [ LEGENDARY_WEAPON ] = 4 ; maxSupply [ COMMON_SWORD ] = 10000 ; maxSupply [ RARE_SHIELD ] = 1000 ; maxSupply [ EPIC_ARMOR ] = 100 ; maxSupply [ LEGENDARY_WEAPON ] = 10 ; } function mintStarterPack ( address player ) external onlyGameMaster { uint256 [] memory itemIds = new uint256 []( 2 ); itemIds [ 0 ] = COMMON_SWORD ; itemIds [ 1 ] = RARE_SHIELD ; uint256 [] memory quantities = new uint256 []( 2 ); quantities [ 0 ] = 1 ; // 1 common sword quantities [ 1 ] = 1 ; // 1 rare shield // Check supply limits for ( uint256 i = 0 ; i < itemIds . length ; i ++ ) { require ( currentSupply [ itemIds [ i ]] + quantities [ i ] <= maxSupply [ itemIds [ i ]], \"Would exceed max supply\" ); currentSupply [ itemIds [ i ]] += quantities [ i ]; } gameItems . batchMintTo ( player , itemIds , quantities , \"\" ); emit PlayerRewardMinted ( player , itemIds , quantities ); } function mintQuestReward ( address [] memory players , uint256 rewardItemId , uint256 quantityPerPlayer ) external onlyGameMaster { require ( players . length > 0 , \"No players specified\" ); uint256 totalQuantity = players . length * quantityPerPlayer ; require ( currentSupply [ rewardItemId ] + totalQuantity <= maxSupply [ rewardItemId ], \"Would exceed max supply\" ); currentSupply [ rewardItemId ] += totalQuantity ; for ( uint256 i = 0 ; i < players . length ; i ++ ) { gameItems . mintTo ( players [ i ], rewardItemId , quantityPerPlayer , \"\" ); } emit QuestRewardDistributed ( block.number , players , rewardItemId ); } function mintSpecialEvent ( address player , uint256 eventItemId , uint256 quantity , bytes memory eventData ) external onlyGameMaster { require ( currentSupply [ eventItemId ] + quantity <= maxSupply [ eventItemId ], \"Would exceed max supply\" ); currentSupply [ eventItemId ] += quantity ; gameItems . mintTo ( player , eventItemId , quantity , eventData ); } function getItemInfo ( uint256 itemId ) external view returns ( uint256 rarity , uint256 maxSupplyAmount , uint256 currentSupplyAmount , uint256 remainingSupply ) { rarity = itemRarity [ itemId ]; maxSupplyAmount = maxSupply [ itemId ]; currentSupplyAmount = currentSupply [ itemId ]; remainingSupply = maxSupplyAmount - currentSupplyAmount ; } modifier onlyGameMaster () { // Implementation would check for game master role _ ; } } Digital Asset Marketplace \u00b6 // Marketplace for digital assets with minting capabilities contract DigitalAssetMarketplace { IERC1155Mint public digitalAssets ; struct AssetTemplate { string name ; string description ; uint256 basePrice ; uint256 maxSupply ; uint256 currentSupply ; address creator ; uint256 royaltyPercentage ; bool active ; } mapping ( uint256 => AssetTemplate ) public assetTemplates ; mapping ( address => bool ) public authorizedCreators ; uint256 public nextAssetId = 1 ; event AssetTemplateCreated ( uint256 indexed assetId , string name , address indexed creator ); event AssetMinted ( uint256 indexed assetId , address indexed recipient , uint256 quantity ); event CreatorAuthorized ( address indexed creator , bool authorized ); constructor ( address _digitalAssets ) { digitalAssets = IERC1155Mint ( _digitalAssets ); } function createAssetTemplate ( string memory name , string memory description , uint256 basePrice , uint256 maxSupply , uint256 royaltyPercentage ) external returns ( uint256 assetId ) { require ( authorizedCreators [ msg.sender ], \"Not authorized creator\" ); require ( maxSupply > 0 , \"Max supply must be greater than 0\" ); require ( royaltyPercentage <= 1000 , \"Royalty too high\" ); // Max 10% assetId = nextAssetId ++ ; assetTemplates [ assetId ] = AssetTemplate ({ name : name , description : description , basePrice : basePrice , maxSupply : maxSupply , currentSupply : 0 , creator : msg.sender , royaltyPercentage : royaltyPercentage , active : true }); emit AssetTemplateCreated ( assetId , name , msg.sender ); } function mintAsset ( uint256 assetId , address recipient , uint256 quantity ) external payable { AssetTemplate storage template = assetTemplates [ assetId ]; require ( template . active , \"Asset template not active\" ); require ( template . currentSupply + quantity <= template . maxSupply , \"Would exceed max supply\" ); uint256 totalCost = template . basePrice * quantity ; require ( msg.value >= totalCost , \"Insufficient payment\" ); // Update supply template . currentSupply += quantity ; // Mint the assets digitalAssets . mintTo ( recipient , assetId , quantity , \"\" ); // Handle payments uint256 royalty = ( totalCost * template . royaltyPercentage ) / 10000 ; uint256 platformFee = totalCost - royalty ; if ( royalty > 0 ) { payable ( template . creator ). transfer ( royalty ); } // Platform keeps the rest (simplified - would have more complex fee structure) emit AssetMinted ( assetId , recipient , quantity ); } function batchMintAssets ( uint256 [] memory assetIds , uint256 [] memory quantities , address recipient ) external payable { require ( assetIds . length == quantities . length , \"Array length mismatch\" ); require ( assetIds . length > 0 , \"No assets specified\" ); uint256 totalCost = 0 ; // Validate and calculate total cost for ( uint256 i = 0 ; i < assetIds . length ; i ++ ) { AssetTemplate storage template = assetTemplates [ assetIds [ i ]]; require ( template . active , \"Asset template not active\" ); require ( template . currentSupply + quantities [ i ] <= template . maxSupply , \"Would exceed max supply\" ); totalCost += template . basePrice * quantities [ i ]; template . currentSupply += quantities [ i ]; } require ( msg.value >= totalCost , \"Insufficient payment\" ); // Mint all assets digitalAssets . batchMintTo ( recipient , assetIds , quantities , \"\" ); // Handle payments (simplified) // In practice, would calculate individual royalties per creator for ( uint256 i = 0 ; i < assetIds . length ; i ++ ) { emit AssetMinted ( assetIds [ i ], recipient , quantities [ i ]); } } function setCreatorAuthorization ( address creator , bool authorized ) external onlyOwner { authorizedCreators [ creator ] = authorized ; emit CreatorAuthorized ( creator , authorized ); } function getAssetInfo ( uint256 assetId ) external view returns ( AssetTemplate memory template , uint256 remainingSupply ) { template = assetTemplates [ assetId ]; remainingSupply = template . maxSupply - template . currentSupply ; } modifier onlyOwner () { // Implementation would check for owner role _ ; } } Collectible Card System \u00b6 // Trading card game with different card rarities contract CollectibleCardSystem { IERC1155Mint public gameCards ; enum CardRarity { COMMON , UNCOMMON , RARE , EPIC , LEGENDARY } struct CardTemplate { string name ; CardRarity rarity ; uint256 attack ; uint256 defense ; uint256 cost ; string artwork ; bool active ; } mapping ( uint256 => CardTemplate ) public cardTemplates ; mapping ( CardRarity => uint256 ) public packProbabilities ; mapping ( address => uint256 ) public playerPacksOpened ; uint256 public nextCardId = 1 ; uint256 public packPrice = 0 . 01 ether ; event CardTemplateCreated ( uint256 indexed cardId , string name , CardRarity rarity ); event PackOpened ( address indexed player , uint256 [] cardIds , uint256 [] quantities ); event CardMinted ( uint256 indexed cardId , address indexed recipient , uint256 quantity ); constructor ( address _gameCards ) { gameCards = IERC1155Mint ( _gameCards ); // Set pack probabilities (out of 10000) packProbabilities [ CardRarity . COMMON ] = 5000 ; // 50% packProbabilities [ CardRarity . UNCOMMON ] = 3000 ; // 30% packProbabilities [ CardRarity . RARE ] = 1500 ; // 15% packProbabilities [ CardRarity . EPIC ] = 450 ; // 4.5% packProbabilities [ CardRarity . LEGENDARY ] = 50 ; // 0.5% } function createCardTemplate ( string memory name , CardRarity rarity , uint256 attack , uint256 defense , uint256 cost , string memory artwork ) external onlyGameDesigner returns ( uint256 cardId ) { cardId = nextCardId ++ ; cardTemplates [ cardId ] = CardTemplate ({ name : name , rarity : rarity , attack : attack , defense : defense , cost : cost , artwork : artwork , active : true }); emit CardTemplateCreated ( cardId , name , rarity ); } function openBoosterPack ( address player ) external payable { require ( msg.value >= packPrice , \"Insufficient payment for pack\" ); uint256 [] memory cardIds = new uint256 []( 5 ); // 5 cards per pack uint256 [] memory quantities = new uint256 []( 5 ); // Generate 5 random cards based on rarity probabilities for ( uint256 i = 0 ; i < 5 ; i ++ ) { cardIds [ i ] = _generateRandomCard (); quantities [ i ] = 1 ; } // Mint the cards gameCards . batchMintTo ( player , cardIds , quantities , \"\" ); playerPacksOpened [ player ] ++ ; emit PackOpened ( player , cardIds , quantities ); } function mintSpecialCard ( address recipient , uint256 cardId , uint256 quantity ) external onlyGameMaster { require ( cardTemplates [ cardId ]. active , \"Card template not active\" ); gameCards . mintTo ( recipient , cardId , quantity , \"\" ); emit CardMinted ( cardId , recipient , quantity ); } function mintPromotionalCards ( address [] memory recipients , uint256 promoCardId , uint256 quantityPerPlayer ) external onlyGameMaster { require ( cardTemplates [ promoCardId ]. active , \"Card template not active\" ); for ( uint256 i = 0 ; i < recipients . length ; i ++ ) { gameCards . mintTo ( recipients [ i ], promoCardId , quantityPerPlayer , \"\" ); emit CardMinted ( promoCardId , recipients [ i ], quantityPerPlayer ); } } function _generateRandomCard () internal view returns ( uint256 ) { // Simplified random generation - in practice would use Chainlink VRF uint256 randomValue = uint256 ( keccak256 ( abi . encodePacked ( block.timestamp , block.difficulty , msg.sender ))) % 10000 ; CardRarity targetRarity ; if ( randomValue < packProbabilities [ CardRarity . LEGENDARY ]) { targetRarity = CardRarity . LEGENDARY ; } else if ( randomValue < packProbabilities [ CardRarity . LEGENDARY ] + packProbabilities [ CardRarity . EPIC ]) { targetRarity = CardRarity . EPIC ; } else if ( randomValue < packProbabilities [ CardRarity . LEGENDARY ] + packProbabilities [ CardRarity . EPIC ] + packProbabilities [ CardRarity . RARE ]) { targetRarity = CardRarity . RARE ; } else if ( randomValue < 10000 - packProbabilities [ CardRarity . COMMON ]) { targetRarity = CardRarity . UNCOMMON ; } else { targetRarity = CardRarity . COMMON ; } // Find a random card of the target rarity // Simplified - in practice would maintain arrays of cards by rarity for ( uint256 i = 1 ; i < nextCardId ; i ++ ) { if ( cardTemplates [ i ]. rarity == targetRarity && cardTemplates [ i ]. active ) { return i ; } } return 1 ; // Fallback to first card } function getCardInfo ( uint256 cardId ) external view returns ( CardTemplate memory ) { return cardTemplates [ cardId ]; } function getPlayerStats ( address player ) external view returns ( uint256 packsOpened ) { packsOpened = playerPacksOpened [ player ]; } modifier onlyGameDesigner () { // Implementation would check for game designer role _ ; } modifier onlyGameMaster () { // Implementation would check for game master role _ ; } } Events \u00b6 Token Minting Events \u00b6 event ERC1155TokenMinted ( address minter , // Address that initiated the minting uint256 id , // Token type identifier uint256 quantity // Amount of tokens minted ); Security Considerations \u00b6 Access Control \u00b6 Minting permissions must be properly restricted Role-based access control for different minting operations Prevention of unauthorized token creation Validation of minter addresses and permissions Supply Management \u00b6 Maximum supply limits to prevent inflation Current supply tracking for scarcity management Prevention of overflow in quantity calculations Validation of token ID existence and validity Recipient Validation \u00b6 Zero address checks for recipients Contract recipient compatibility (ERC1155Receiver) Batch operation array length validation Data parameter handling for contract recipients Gas Optimization \u00b6 Efficient Operations \u00b6 Batch minting for multiple token types Optimized storage layout for token data Minimal external calls during minting Efficient event emission patterns Storage Optimization \u00b6 Packed storage structures where possible Efficient mapping usage for token tracking Optimized array operations for batch minting Cached calculations for frequently accessed data Error Handling \u00b6 Common Errors \u00b6 Insufficient minting permissions Invalid token IDs or quantities Zero address recipients Array length mismatches in batch operations Contract recipient compatibility issues Best Practices \u00b6 Validate all inputs before processing Check permissions before minting operations Verify recipient addresses and contract compatibility Handle batch operation failures gracefully Provide clear error messages for debugging Testing Considerations \u00b6 Unit Tests \u00b6 Interface compliance verification Minting function parameter validation Event emission verification Access control testing Error condition handling Integration Tests \u00b6 ERC1155 standard compliance Contract recipient interaction testing Batch operation efficiency and correctness Supply management and tracking Cross-contract integration scenarios Related Documentation \u00b6 MultiSaleFacet - Multi-token sale functionality GemforceMinterFacet - Token minting implementation ERC1155 Standards - Token standard extensions Token Minting Guide - Implementation guide for token minting Gaming Integration Guide - Gaming platform integration This interface defines the standard contract for ERC1155 token minting within the Gemforce platform, enabling flexible creation of fungible, non-fungible, and semi-fungible tokens with comprehensive quantity management and batch operations.","title":"IERC1155Mint"},{"location":"smart-contracts/interfaces/ierc1155-mint/#ierc1155mint-interface","text":"","title":"IERC1155Mint Interface"},{"location":"smart-contracts/interfaces/ierc1155-mint/#overview","text":"The IERC1155Mint interface defines the standard contract for minting ERC1155 tokens within the Gemforce platform. This interface extends the standard ERC1155 functionality by providing controlled minting capabilities for multi-token contracts, enabling the creation of fungible, non-fungible, and semi-fungible tokens with flexible quantity management.","title":"Overview"},{"location":"smart-contracts/interfaces/ierc1155-mint/#key-features","text":"Flexible Token Minting : Support for minting single and multiple token types Recipient Control : Mint tokens to specific addresses or caller Batch Operations : Efficient batch minting for multiple token types Quantity Management : Precise control over minted token quantities Event Tracking : Comprehensive event emission for minting operations","title":"Key Features"},{"location":"smart-contracts/interfaces/ierc1155-mint/#interface-definition","text":"// SPDX-License-Identifier: MIT pragma solidity >= 0.8.0 ; interface IERC1155Mint { // Events event ERC1155TokenMinted ( address minter , uint256 id , uint256 quantity ); // Core Minting Functions function mint ( uint256 id , uint256 quantity , bytes memory data ) external ; function mintTo ( address recipient , uint256 id , uint256 quantity , bytes memory data ) external ; function batchMintTo ( address recipient , uint256 [] memory ids , uint256 [] calldata quantities , bytes memory data ) external ; }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/ierc1155-mint/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/ierc1155-mint/#single-token-minting","text":"","title":"Single Token Minting"},{"location":"smart-contracts/interfaces/ierc1155-mint/#mint","text":"function mint ( uint256 id , uint256 quantity , bytes memory data ) external Purpose : Mint tokens of a specified type and quantity to the caller's address. Parameters : - id (uint256): The token type identifier to mint - quantity (uint256): The amount of tokens to mint - data (bytes): Additional data to pass to the recipient (if it's a contract) Requirements : - Caller must have minting permissions - Token ID must be valid for minting - Quantity must be greater than zero - Contract must not be paused (if pausable) Events Emitted : - ERC1155TokenMinted with minter address, token ID, and quantity Example Usage : // Mint 100 tokens of type 1 to caller uint256 tokenId = 1 ; uint256 quantity = 100 ; bytes memory data = \"\" ; IERC1155Mint ( tokenContract ). mint ( tokenId , quantity , data ); console . log ( \"Minted\" , quantity , \"tokens of type\" , tokenId , \"to caller\" );","title":"mint()"},{"location":"smart-contracts/interfaces/ierc1155-mint/#mintto","text":"function mintTo ( address recipient , uint256 id , uint256 quantity , bytes memory data ) external Purpose : Mint tokens of a specified type and quantity to a specific recipient address. Parameters : - recipient (address): The address to receive the minted tokens - id (uint256): The token type identifier to mint - quantity (uint256): The amount of tokens to mint - data (bytes): Additional data to pass to the recipient (if it's a contract) Requirements : - Caller must have minting permissions - Recipient address must not be zero address - Token ID must be valid for minting - Quantity must be greater than zero - If recipient is a contract, it must implement ERC1155Receiver Events Emitted : - ERC1155TokenMinted with minter address, token ID, and quantity - Standard ERC1155 TransferSingle event Example Usage : // Mint 50 tokens of type 2 to specific address address recipient = 0x742d35Cc6634C0532925a3b8D4C9db96590c6C8C ; uint256 tokenId = 2 ; uint256 quantity = 50 ; bytes memory data = \"\" ; IERC1155Mint ( tokenContract ). mintTo ( recipient , tokenId , quantity , data ); console . log ( \"Minted\" , quantity , \"tokens of type\" , tokenId , \"to\" , recipient );","title":"mintTo()"},{"location":"smart-contracts/interfaces/ierc1155-mint/#batch-minting","text":"","title":"Batch Minting"},{"location":"smart-contracts/interfaces/ierc1155-mint/#batchmintto","text":"function batchMintTo ( address recipient , uint256 [] memory ids , uint256 [] calldata quantities , bytes memory data ) external Purpose : Efficiently mint multiple token types with specified quantities to a recipient in a single transaction. Parameters : - recipient (address): The address to receive all minted tokens - ids (uint256[]): Array of token type identifiers to mint - quantities (uint256[]): Array of quantities corresponding to each token ID - data (bytes): Additional data to pass to the recipient (if it's a contract) Requirements : - Caller must have minting permissions - Recipient address must not be zero address - Arrays must have the same length and not be empty - All token IDs must be valid for minting - All quantities must be greater than zero - If recipient is a contract, it must implement ERC1155Receiver Events Emitted : - ERC1155TokenMinted for each token type minted - Standard ERC1155 TransferBatch event Gas Optimization : More efficient than multiple individual mint calls Example Usage : // Batch mint multiple token types address recipient = 0x742d35Cc6634C0532925a3b8D4C9db96590c6C8C ; uint256 [] memory tokenIds = new uint256 []( 3 ); tokenIds [ 0 ] = 1 ; // Common item tokenIds [ 1 ] = 2 ; // Rare item tokenIds [ 2 ] = 3 ; // Epic item uint256 [] memory quantities = new uint256 []( 3 ); quantities [ 0 ] = 100 ; // 100 common items quantities [ 1 ] = 10 ; // 10 rare items quantities [ 2 ] = 1 ; // 1 epic item bytes memory data = \"\" ; IERC1155Mint ( tokenContract ). batchMintTo ( recipient , tokenIds , quantities , data ); console . log ( \"Batch minted\" , tokenIds . length , \"token types to\" , recipient );","title":"batchMintTo()"},{"location":"smart-contracts/interfaces/ierc1155-mint/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/ierc1155-mint/#gaming-item-system","text":"// Gaming platform with different item types contract GameItemSystem { IERC1155Mint public gameItems ; // Item type definitions uint256 public constant COMMON_SWORD = 1 ; uint256 public constant RARE_SHIELD = 2 ; uint256 public constant EPIC_ARMOR = 3 ; uint256 public constant LEGENDARY_WEAPON = 4 ; // Item rarity and quantities mapping ( uint256 => uint256 ) public itemRarity ; mapping ( uint256 => uint256 ) public maxSupply ; mapping ( uint256 => uint256 ) public currentSupply ; event PlayerRewardMinted ( address indexed player , uint256 [] itemIds , uint256 [] quantities ); event QuestRewardDistributed ( uint256 indexed questId , address [] players , uint256 rewardItemId ); constructor ( address _gameItems ) { gameItems = IERC1155Mint ( _gameItems ); // Set up item rarities and max supplies itemRarity [ COMMON_SWORD ] = 1 ; itemRarity [ RARE_SHIELD ] = 2 ; itemRarity [ EPIC_ARMOR ] = 3 ; itemRarity [ LEGENDARY_WEAPON ] = 4 ; maxSupply [ COMMON_SWORD ] = 10000 ; maxSupply [ RARE_SHIELD ] = 1000 ; maxSupply [ EPIC_ARMOR ] = 100 ; maxSupply [ LEGENDARY_WEAPON ] = 10 ; } function mintStarterPack ( address player ) external onlyGameMaster { uint256 [] memory itemIds = new uint256 []( 2 ); itemIds [ 0 ] = COMMON_SWORD ; itemIds [ 1 ] = RARE_SHIELD ; uint256 [] memory quantities = new uint256 []( 2 ); quantities [ 0 ] = 1 ; // 1 common sword quantities [ 1 ] = 1 ; // 1 rare shield // Check supply limits for ( uint256 i = 0 ; i < itemIds . length ; i ++ ) { require ( currentSupply [ itemIds [ i ]] + quantities [ i ] <= maxSupply [ itemIds [ i ]], \"Would exceed max supply\" ); currentSupply [ itemIds [ i ]] += quantities [ i ]; } gameItems . batchMintTo ( player , itemIds , quantities , \"\" ); emit PlayerRewardMinted ( player , itemIds , quantities ); } function mintQuestReward ( address [] memory players , uint256 rewardItemId , uint256 quantityPerPlayer ) external onlyGameMaster { require ( players . length > 0 , \"No players specified\" ); uint256 totalQuantity = players . length * quantityPerPlayer ; require ( currentSupply [ rewardItemId ] + totalQuantity <= maxSupply [ rewardItemId ], \"Would exceed max supply\" ); currentSupply [ rewardItemId ] += totalQuantity ; for ( uint256 i = 0 ; i < players . length ; i ++ ) { gameItems . mintTo ( players [ i ], rewardItemId , quantityPerPlayer , \"\" ); } emit QuestRewardDistributed ( block.number , players , rewardItemId ); } function mintSpecialEvent ( address player , uint256 eventItemId , uint256 quantity , bytes memory eventData ) external onlyGameMaster { require ( currentSupply [ eventItemId ] + quantity <= maxSupply [ eventItemId ], \"Would exceed max supply\" ); currentSupply [ eventItemId ] += quantity ; gameItems . mintTo ( player , eventItemId , quantity , eventData ); } function getItemInfo ( uint256 itemId ) external view returns ( uint256 rarity , uint256 maxSupplyAmount , uint256 currentSupplyAmount , uint256 remainingSupply ) { rarity = itemRarity [ itemId ]; maxSupplyAmount = maxSupply [ itemId ]; currentSupplyAmount = currentSupply [ itemId ]; remainingSupply = maxSupplyAmount - currentSupplyAmount ; } modifier onlyGameMaster () { // Implementation would check for game master role _ ; } }","title":"Gaming Item System"},{"location":"smart-contracts/interfaces/ierc1155-mint/#digital-asset-marketplace","text":"// Marketplace for digital assets with minting capabilities contract DigitalAssetMarketplace { IERC1155Mint public digitalAssets ; struct AssetTemplate { string name ; string description ; uint256 basePrice ; uint256 maxSupply ; uint256 currentSupply ; address creator ; uint256 royaltyPercentage ; bool active ; } mapping ( uint256 => AssetTemplate ) public assetTemplates ; mapping ( address => bool ) public authorizedCreators ; uint256 public nextAssetId = 1 ; event AssetTemplateCreated ( uint256 indexed assetId , string name , address indexed creator ); event AssetMinted ( uint256 indexed assetId , address indexed recipient , uint256 quantity ); event CreatorAuthorized ( address indexed creator , bool authorized ); constructor ( address _digitalAssets ) { digitalAssets = IERC1155Mint ( _digitalAssets ); } function createAssetTemplate ( string memory name , string memory description , uint256 basePrice , uint256 maxSupply , uint256 royaltyPercentage ) external returns ( uint256 assetId ) { require ( authorizedCreators [ msg.sender ], \"Not authorized creator\" ); require ( maxSupply > 0 , \"Max supply must be greater than 0\" ); require ( royaltyPercentage <= 1000 , \"Royalty too high\" ); // Max 10% assetId = nextAssetId ++ ; assetTemplates [ assetId ] = AssetTemplate ({ name : name , description : description , basePrice : basePrice , maxSupply : maxSupply , currentSupply : 0 , creator : msg.sender , royaltyPercentage : royaltyPercentage , active : true }); emit AssetTemplateCreated ( assetId , name , msg.sender ); } function mintAsset ( uint256 assetId , address recipient , uint256 quantity ) external payable { AssetTemplate storage template = assetTemplates [ assetId ]; require ( template . active , \"Asset template not active\" ); require ( template . currentSupply + quantity <= template . maxSupply , \"Would exceed max supply\" ); uint256 totalCost = template . basePrice * quantity ; require ( msg.value >= totalCost , \"Insufficient payment\" ); // Update supply template . currentSupply += quantity ; // Mint the assets digitalAssets . mintTo ( recipient , assetId , quantity , \"\" ); // Handle payments uint256 royalty = ( totalCost * template . royaltyPercentage ) / 10000 ; uint256 platformFee = totalCost - royalty ; if ( royalty > 0 ) { payable ( template . creator ). transfer ( royalty ); } // Platform keeps the rest (simplified - would have more complex fee structure) emit AssetMinted ( assetId , recipient , quantity ); } function batchMintAssets ( uint256 [] memory assetIds , uint256 [] memory quantities , address recipient ) external payable { require ( assetIds . length == quantities . length , \"Array length mismatch\" ); require ( assetIds . length > 0 , \"No assets specified\" ); uint256 totalCost = 0 ; // Validate and calculate total cost for ( uint256 i = 0 ; i < assetIds . length ; i ++ ) { AssetTemplate storage template = assetTemplates [ assetIds [ i ]]; require ( template . active , \"Asset template not active\" ); require ( template . currentSupply + quantities [ i ] <= template . maxSupply , \"Would exceed max supply\" ); totalCost += template . basePrice * quantities [ i ]; template . currentSupply += quantities [ i ]; } require ( msg.value >= totalCost , \"Insufficient payment\" ); // Mint all assets digitalAssets . batchMintTo ( recipient , assetIds , quantities , \"\" ); // Handle payments (simplified) // In practice, would calculate individual royalties per creator for ( uint256 i = 0 ; i < assetIds . length ; i ++ ) { emit AssetMinted ( assetIds [ i ], recipient , quantities [ i ]); } } function setCreatorAuthorization ( address creator , bool authorized ) external onlyOwner { authorizedCreators [ creator ] = authorized ; emit CreatorAuthorized ( creator , authorized ); } function getAssetInfo ( uint256 assetId ) external view returns ( AssetTemplate memory template , uint256 remainingSupply ) { template = assetTemplates [ assetId ]; remainingSupply = template . maxSupply - template . currentSupply ; } modifier onlyOwner () { // Implementation would check for owner role _ ; } }","title":"Digital Asset Marketplace"},{"location":"smart-contracts/interfaces/ierc1155-mint/#collectible-card-system","text":"// Trading card game with different card rarities contract CollectibleCardSystem { IERC1155Mint public gameCards ; enum CardRarity { COMMON , UNCOMMON , RARE , EPIC , LEGENDARY } struct CardTemplate { string name ; CardRarity rarity ; uint256 attack ; uint256 defense ; uint256 cost ; string artwork ; bool active ; } mapping ( uint256 => CardTemplate ) public cardTemplates ; mapping ( CardRarity => uint256 ) public packProbabilities ; mapping ( address => uint256 ) public playerPacksOpened ; uint256 public nextCardId = 1 ; uint256 public packPrice = 0 . 01 ether ; event CardTemplateCreated ( uint256 indexed cardId , string name , CardRarity rarity ); event PackOpened ( address indexed player , uint256 [] cardIds , uint256 [] quantities ); event CardMinted ( uint256 indexed cardId , address indexed recipient , uint256 quantity ); constructor ( address _gameCards ) { gameCards = IERC1155Mint ( _gameCards ); // Set pack probabilities (out of 10000) packProbabilities [ CardRarity . COMMON ] = 5000 ; // 50% packProbabilities [ CardRarity . UNCOMMON ] = 3000 ; // 30% packProbabilities [ CardRarity . RARE ] = 1500 ; // 15% packProbabilities [ CardRarity . EPIC ] = 450 ; // 4.5% packProbabilities [ CardRarity . LEGENDARY ] = 50 ; // 0.5% } function createCardTemplate ( string memory name , CardRarity rarity , uint256 attack , uint256 defense , uint256 cost , string memory artwork ) external onlyGameDesigner returns ( uint256 cardId ) { cardId = nextCardId ++ ; cardTemplates [ cardId ] = CardTemplate ({ name : name , rarity : rarity , attack : attack , defense : defense , cost : cost , artwork : artwork , active : true }); emit CardTemplateCreated ( cardId , name , rarity ); } function openBoosterPack ( address player ) external payable { require ( msg.value >= packPrice , \"Insufficient payment for pack\" ); uint256 [] memory cardIds = new uint256 []( 5 ); // 5 cards per pack uint256 [] memory quantities = new uint256 []( 5 ); // Generate 5 random cards based on rarity probabilities for ( uint256 i = 0 ; i < 5 ; i ++ ) { cardIds [ i ] = _generateRandomCard (); quantities [ i ] = 1 ; } // Mint the cards gameCards . batchMintTo ( player , cardIds , quantities , \"\" ); playerPacksOpened [ player ] ++ ; emit PackOpened ( player , cardIds , quantities ); } function mintSpecialCard ( address recipient , uint256 cardId , uint256 quantity ) external onlyGameMaster { require ( cardTemplates [ cardId ]. active , \"Card template not active\" ); gameCards . mintTo ( recipient , cardId , quantity , \"\" ); emit CardMinted ( cardId , recipient , quantity ); } function mintPromotionalCards ( address [] memory recipients , uint256 promoCardId , uint256 quantityPerPlayer ) external onlyGameMaster { require ( cardTemplates [ promoCardId ]. active , \"Card template not active\" ); for ( uint256 i = 0 ; i < recipients . length ; i ++ ) { gameCards . mintTo ( recipients [ i ], promoCardId , quantityPerPlayer , \"\" ); emit CardMinted ( promoCardId , recipients [ i ], quantityPerPlayer ); } } function _generateRandomCard () internal view returns ( uint256 ) { // Simplified random generation - in practice would use Chainlink VRF uint256 randomValue = uint256 ( keccak256 ( abi . encodePacked ( block.timestamp , block.difficulty , msg.sender ))) % 10000 ; CardRarity targetRarity ; if ( randomValue < packProbabilities [ CardRarity . LEGENDARY ]) { targetRarity = CardRarity . LEGENDARY ; } else if ( randomValue < packProbabilities [ CardRarity . LEGENDARY ] + packProbabilities [ CardRarity . EPIC ]) { targetRarity = CardRarity . EPIC ; } else if ( randomValue < packProbabilities [ CardRarity . LEGENDARY ] + packProbabilities [ CardRarity . EPIC ] + packProbabilities [ CardRarity . RARE ]) { targetRarity = CardRarity . RARE ; } else if ( randomValue < 10000 - packProbabilities [ CardRarity . COMMON ]) { targetRarity = CardRarity . UNCOMMON ; } else { targetRarity = CardRarity . COMMON ; } // Find a random card of the target rarity // Simplified - in practice would maintain arrays of cards by rarity for ( uint256 i = 1 ; i < nextCardId ; i ++ ) { if ( cardTemplates [ i ]. rarity == targetRarity && cardTemplates [ i ]. active ) { return i ; } } return 1 ; // Fallback to first card } function getCardInfo ( uint256 cardId ) external view returns ( CardTemplate memory ) { return cardTemplates [ cardId ]; } function getPlayerStats ( address player ) external view returns ( uint256 packsOpened ) { packsOpened = playerPacksOpened [ player ]; } modifier onlyGameDesigner () { // Implementation would check for game designer role _ ; } modifier onlyGameMaster () { // Implementation would check for game master role _ ; } }","title":"Collectible Card System"},{"location":"smart-contracts/interfaces/ierc1155-mint/#events","text":"","title":"Events"},{"location":"smart-contracts/interfaces/ierc1155-mint/#token-minting-events","text":"event ERC1155TokenMinted ( address minter , // Address that initiated the minting uint256 id , // Token type identifier uint256 quantity // Amount of tokens minted );","title":"Token Minting Events"},{"location":"smart-contracts/interfaces/ierc1155-mint/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/ierc1155-mint/#access-control","text":"Minting permissions must be properly restricted Role-based access control for different minting operations Prevention of unauthorized token creation Validation of minter addresses and permissions","title":"Access Control"},{"location":"smart-contracts/interfaces/ierc1155-mint/#supply-management","text":"Maximum supply limits to prevent inflation Current supply tracking for scarcity management Prevention of overflow in quantity calculations Validation of token ID existence and validity","title":"Supply Management"},{"location":"smart-contracts/interfaces/ierc1155-mint/#recipient-validation","text":"Zero address checks for recipients Contract recipient compatibility (ERC1155Receiver) Batch operation array length validation Data parameter handling for contract recipients","title":"Recipient Validation"},{"location":"smart-contracts/interfaces/ierc1155-mint/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/interfaces/ierc1155-mint/#efficient-operations","text":"Batch minting for multiple token types Optimized storage layout for token data Minimal external calls during minting Efficient event emission patterns","title":"Efficient Operations"},{"location":"smart-contracts/interfaces/ierc1155-mint/#storage-optimization","text":"Packed storage structures where possible Efficient mapping usage for token tracking Optimized array operations for batch minting Cached calculations for frequently accessed data","title":"Storage Optimization"},{"location":"smart-contracts/interfaces/ierc1155-mint/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/interfaces/ierc1155-mint/#common-errors","text":"Insufficient minting permissions Invalid token IDs or quantities Zero address recipients Array length mismatches in batch operations Contract recipient compatibility issues","title":"Common Errors"},{"location":"smart-contracts/interfaces/ierc1155-mint/#best-practices","text":"Validate all inputs before processing Check permissions before minting operations Verify recipient addresses and contract compatibility Handle batch operation failures gracefully Provide clear error messages for debugging","title":"Best Practices"},{"location":"smart-contracts/interfaces/ierc1155-mint/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/interfaces/ierc1155-mint/#unit-tests","text":"Interface compliance verification Minting function parameter validation Event emission verification Access control testing Error condition handling","title":"Unit Tests"},{"location":"smart-contracts/interfaces/ierc1155-mint/#integration-tests","text":"ERC1155 standard compliance Contract recipient interaction testing Batch operation efficiency and correctness Supply management and tracking Cross-contract integration scenarios","title":"Integration Tests"},{"location":"smart-contracts/interfaces/ierc1155-mint/#related-documentation","text":"MultiSaleFacet - Multi-token sale functionality GemforceMinterFacet - Token minting implementation ERC1155 Standards - Token standard extensions Token Minting Guide - Implementation guide for token minting Gaming Integration Guide - Gaming platform integration This interface defines the standard contract for ERC1155 token minting within the Gemforce platform, enabling flexible creation of fungible, non-fungible, and semi-fungible tokens with comprehensive quantity management and batch operations.","title":"Related Documentation"},{"location":"smart-contracts/interfaces/ierc721a/","text":"IERC721A Interface \u00b6 The IERC721A interface extends the standard ERC721 interface with gas-optimized batch minting capabilities. This interface is designed for projects that need to mint large quantities of NFTs efficiently while maintaining full ERC721 compatibility. Overview \u00b6 IERC721A provides: Gas-Optimized Minting : Significantly reduced gas costs for batch minting ERC721 Compatibility : Full compatibility with existing ERC721 infrastructure Sequential Token IDs : Automatic sequential token ID assignment Batch Operations : Efficient batch minting and transfers Enumeration Support : Optional enumeration capabilities Key Features \u00b6 Gas Optimization \u00b6 Batch Minting : Mint multiple tokens in a single transaction Storage Optimization : Optimized storage layout for reduced gas costs Lazy Initialization : Deferred initialization of token data Packed Storage : Efficient packing of token information ERC721 Compatibility \u00b6 Standard Compliance : Full ERC721 standard compliance Marketplace Support : Compatible with all major NFT marketplaces Wallet Support : Works with all ERC721-compatible wallets Tool Integration : Compatible with existing NFT tools and services Interface Definition \u00b6 interface IERC721A { // ERC721 Standard Events event Transfer ( address indexed from , address indexed to , uint256 indexed tokenId ); event Approval ( address indexed owner , address indexed approved , uint256 indexed tokenId ); event ApprovalForAll ( address indexed owner , address indexed operator , bool approved ); // ERC721A Specific Events event ConsecutiveTransfer ( uint256 indexed fromTokenId , uint256 toTokenId , address indexed from , address indexed to ); // ERC721 Standard Functions function balanceOf ( address owner ) external view returns ( uint256 balance ); function ownerOf ( uint256 tokenId ) external view returns ( address owner ); function safeTransferFrom ( address from , address to , uint256 tokenId , bytes calldata data ) external ; function safeTransferFrom ( address from , address to , uint256 tokenId ) external ; function transferFrom ( address from , address to , uint256 tokenId ) external ; function approve ( address to , uint256 tokenId ) external ; function setApprovalForAll ( address operator , bool approved ) external ; function getApproved ( uint256 tokenId ) external view returns ( address operator ); function isApprovedForAll ( address owner , address operator ) external view returns ( bool ); // ERC721Metadata function name () external view returns ( string memory ); function symbol () external view returns ( string memory ); function tokenURI ( uint256 tokenId ) external view returns ( string memory ); // ERC721A Specific Functions function totalSupply () external view returns ( uint256 ); function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ); // Batch Operations function safeMint ( address to , uint256 quantity ) external ; function safeMint ( address to , uint256 quantity , bytes memory data ) external ; // Advanced Queries function numberMinted ( address owner ) external view returns ( uint256 ); function numberBurned ( address owner ) external view returns ( uint256 ); function getAux ( address owner ) external view returns ( uint64 ); function setAux ( address owner , uint64 aux ) external ; // Token Existence function exists ( uint256 tokenId ) external view returns ( bool ); // Burning function burn ( uint256 tokenId ) external ; } Core Functions \u00b6 Standard ERC721 Functions \u00b6 balanceOf() \u00b6 Returns the number of tokens owned by an address. Parameters: - owner : Address to query the balance of Returns: - uint256 : Number of tokens owned ownerOf() \u00b6 Returns the owner of a specific token. Parameters: - tokenId : Token ID to query Returns: - address : Owner of the token transferFrom() \u00b6 Transfers a token from one address to another. Parameters: - from : Current owner of the token - to : Address to transfer the token to - tokenId : Token ID to transfer ERC721A Specific Functions \u00b6 safeMint() \u00b6 Mints tokens to a specified address with gas optimization. Parameters: - to : Address to mint tokens to - quantity : Number of tokens to mint - data : Optional data to pass to receiver (if contract) Gas Optimization: - Batch minting reduces gas cost per token significantly - Sequential token IDs eliminate need for individual storage numberMinted() \u00b6 Returns the total number of tokens minted by an address. Parameters: - owner : Address to query Returns: - uint256 : Total number of tokens minted numberBurned() \u00b6 Returns the total number of tokens burned by an address. Parameters: - owner : Address to query Returns: - uint256 : Total number of tokens burned getAux() / setAux() \u00b6 Get/set auxiliary data for an address (64 bits of custom data). Parameters: - owner : Address to query/modify - aux : Auxiliary data to set (setAux only) Returns: - uint64 : Auxiliary data (getAux only) Implementation Example \u00b6 Basic ERC721A Contract \u00b6 contract MyNFTCollection is IERC721A { string private _name ; string private _symbol ; string private _baseTokenURI ; uint256 private _currentIndex ; uint256 private _burnCounter ; // Mapping from token ID to ownership details mapping ( uint256 => TokenOwnership ) private _ownerships ; // Mapping owner address to address data mapping ( address => AddressData ) private _addressData ; // Mapping from token ID to approved address mapping ( uint256 => address ) private _tokenApprovals ; // Mapping from owner to operator approvals mapping ( address => mapping ( address => bool )) private _operatorApprovals ; struct TokenOwnership { address addr ; uint64 startTimestamp ; bool burned ; uint24 extraData ; } struct AddressData { uint64 balance ; uint64 numberMinted ; uint64 numberBurned ; uint64 aux ; } constructor ( string memory name_ , string memory symbol_ ) { _name = name_ ; _symbol = symbol_ ; _currentIndex = 1 ; // Start token IDs at 1 } function safeMint ( address to , uint256 quantity ) external override { require ( to != address ( 0 ), \"ERC721A: mint to zero address\" ); require ( quantity > 0 , \"ERC721A: quantity must be greater than 0\" ); uint256 startTokenId = _currentIndex ; _currentIndex += quantity ; // Update balance and minted count _addressData [ to ]. balance += uint64 ( quantity ); _addressData [ to ]. numberMinted += uint64 ( quantity ); // Set ownership for the first token in the batch _ownerships [ startTokenId ] = TokenOwnership ( to , uint64 ( block.timestamp ), false , 0 ); // Emit Transfer events for ( uint256 i = 0 ; i < quantity ; i ++ ) { emit Transfer ( address ( 0 ), to , startTokenId + i ); } // Emit ConsecutiveTransfer event for gas optimization if ( quantity > 1 ) { emit ConsecutiveTransfer ( startTokenId , startTokenId + quantity - 1 , address ( 0 ), to ); } } function ownerOf ( uint256 tokenId ) public view override returns ( address ) { require ( _exists ( tokenId ), \"ERC721A: owner query for nonexistent token\" ); uint256 curr = tokenId ; while ( true ) { TokenOwnership memory ownership = _ownerships [ curr ]; if ( ownership . addr != address ( 0 )) { return ownership . addr ; } curr -- ; } revert ( \"ERC721A: unable to determine the owner of token\" ); } function _exists ( uint256 tokenId ) internal view returns ( bool ) { return tokenId > 0 && tokenId < _currentIndex && ! _ownerships [ tokenId ]. burned ; } } Advanced Batch Minting \u00b6 contract AdvancedERC721A is IERC721A { uint256 public constant MAX_SUPPLY = 10000 ; uint256 public constant MAX_BATCH_SIZE = 20 ; uint256 public mintPrice = 0 . 01 ether ; mapping ( address => bool ) public whitelist ; bool public whitelistActive = true ; function publicMint ( uint256 quantity ) external payable { require ( ! whitelistActive , \"Whitelist phase active\" ); require ( quantity <= MAX_BATCH_SIZE , \"Exceeds max batch size\" ); require ( totalSupply () + quantity <= MAX_SUPPLY , \"Exceeds max supply\" ); require ( msg.value >= mintPrice * quantity , \"Insufficient payment\" ); _safeMint ( msg.sender , quantity ); } function whitelistMint ( uint256 quantity ) external payable { require ( whitelistActive , \"Whitelist phase not active\" ); require ( whitelist [ msg.sender ], \"Not whitelisted\" ); require ( quantity <= MAX_BATCH_SIZE , \"Exceeds max batch size\" ); require ( totalSupply () + quantity <= MAX_SUPPLY , \"Exceeds max supply\" ); require ( msg.value >= mintPrice * quantity , \"Insufficient payment\" ); _safeMint ( msg.sender , quantity ); } function airdrop ( address [] calldata recipients , uint256 [] calldata quantities ) external onlyOwner { require ( recipients . length == quantities . length , \"Arrays length mismatch\" ); for ( uint256 i = 0 ; i < recipients . length ; i ++ ) { require ( totalSupply () + quantities [ i ] <= MAX_SUPPLY , \"Exceeds max supply\" ); _safeMint ( recipients [ i ], quantities [ i ]); } } } Gas Optimization Benefits \u00b6 Comparison with Standard ERC721 \u00b6 Operation ERC721 Gas Cost ERC721A Gas Cost Savings Mint 1 NFT ~51,000 ~51,000 0% Mint 5 NFTs ~255,000 ~56,000 78% Mint 10 NFTs ~510,000 ~61,000 88% Mint 20 NFTs ~1,020,000 ~71,000 93% Storage Optimization \u00b6 // Standard ERC721 - stores owner for each token mapping ( uint256 => address ) private _owners ; // 20k gas per token // ERC721A - stores owner only for first token in batch mapping ( uint256 => TokenOwnership ) private _ownerships ; // 20k gas per batch Integration Patterns \u00b6 Marketplace Integration \u00b6 contract MarketplaceIntegration { IERC721A public nftContract ; function listToken ( uint256 tokenId , uint256 price ) external { require ( nftContract . ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); require ( nftContract . getApproved ( tokenId ) == address ( this ) || nftContract . isApprovedForAll ( msg.sender , address ( this )), \"Not approved\" ); // List token for sale _createListing ( tokenId , price , msg.sender ); } function buyToken ( uint256 tokenId ) external payable { Listing memory listing = listings [ tokenId ]; require ( listing . active , \"Token not for sale\" ); require ( msg.value >= listing . price , \"Insufficient payment\" ); // Transfer token nftContract . safeTransferFrom ( listing . seller , msg.sender , tokenId ); // Handle payment _handlePayment ( listing . seller , listing . price ); } } Staking Integration \u00b6 contract NFTStaking { IERC721A public nftContract ; mapping ( uint256 => StakeInfo ) public stakes ; struct StakeInfo { address owner ; uint256 stakedAt ; uint256 rewards ; } function stake ( uint256 [] calldata tokenIds ) external { for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { uint256 tokenId = tokenIds [ i ]; require ( nftContract . ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); // Transfer to staking contract nftContract . safeTransferFrom ( msg.sender , address ( this ), tokenId ); stakes [ tokenId ] = StakeInfo ({ owner : msg.sender , stakedAt : block.timestamp , rewards : 0 }); } } function unstake ( uint256 [] calldata tokenIds ) external { for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { uint256 tokenId = tokenIds [ i ]; StakeInfo storage stake = stakes [ tokenId ]; require ( stake . owner == msg.sender , \"Not stake owner\" ); // Calculate and distribute rewards uint256 rewards = calculateRewards ( tokenId ); _distributeRewards ( msg.sender , rewards ); // Return NFT nftContract . safeTransferFrom ( address ( this ), msg.sender , tokenId ); delete stakes [ tokenId ]; } } } Security Considerations \u00b6 Reentrancy Protection \u00b6 Use reentrancy guards for minting functions Validate external calls in safe transfer hooks Implement proper access controls Integer Overflow Protection \u00b6 Use SafeMath or Solidity 0.8+ built-in overflow protection Validate quantity parameters in minting functions Check total supply limits Access Control \u00b6 Implement proper role-based access control Validate ownership before transfers Secure administrative functions Best Practices \u00b6 Minting Guidelines \u00b6 Batch Size Limits : Implement reasonable batch size limits Supply Caps : Enforce maximum supply limits Payment Validation : Validate payment amounts for paid mints Whitelist Management : Secure whitelist functionality Gas Optimization \u00b6 Batch Operations : Encourage batch minting over individual mints Storage Packing : Pack related data into single storage slots Lazy Loading : Defer expensive operations when possible Event Optimization : Use ConsecutiveTransfer events for batch operations Integration Considerations \u00b6 Marketplace Compatibility : Ensure compatibility with major marketplaces Wallet Support : Test with popular wallet implementations Metadata Standards : Follow metadata standards for better compatibility Enumeration Support : Consider implementing enumeration for better tooling support Related Documentation \u00b6 ERC721A Library ERC721A Enumeration Library Metadata Library NFT Minting Guide Gas Optimization Guide Standards Compliance \u00b6 ERC721 : Full ERC721 standard compliance ERC721Metadata : Metadata extension support ERC721Enumerable : Optional enumeration support ERC165 : Interface detection support Gas Optimization : Optimized for batch operations","title":"IERC721A"},{"location":"smart-contracts/interfaces/ierc721a/#ierc721a-interface","text":"The IERC721A interface extends the standard ERC721 interface with gas-optimized batch minting capabilities. This interface is designed for projects that need to mint large quantities of NFTs efficiently while maintaining full ERC721 compatibility.","title":"IERC721A Interface"},{"location":"smart-contracts/interfaces/ierc721a/#overview","text":"IERC721A provides: Gas-Optimized Minting : Significantly reduced gas costs for batch minting ERC721 Compatibility : Full compatibility with existing ERC721 infrastructure Sequential Token IDs : Automatic sequential token ID assignment Batch Operations : Efficient batch minting and transfers Enumeration Support : Optional enumeration capabilities","title":"Overview"},{"location":"smart-contracts/interfaces/ierc721a/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/ierc721a/#gas-optimization","text":"Batch Minting : Mint multiple tokens in a single transaction Storage Optimization : Optimized storage layout for reduced gas costs Lazy Initialization : Deferred initialization of token data Packed Storage : Efficient packing of token information","title":"Gas Optimization"},{"location":"smart-contracts/interfaces/ierc721a/#erc721-compatibility","text":"Standard Compliance : Full ERC721 standard compliance Marketplace Support : Compatible with all major NFT marketplaces Wallet Support : Works with all ERC721-compatible wallets Tool Integration : Compatible with existing NFT tools and services","title":"ERC721 Compatibility"},{"location":"smart-contracts/interfaces/ierc721a/#interface-definition","text":"interface IERC721A { // ERC721 Standard Events event Transfer ( address indexed from , address indexed to , uint256 indexed tokenId ); event Approval ( address indexed owner , address indexed approved , uint256 indexed tokenId ); event ApprovalForAll ( address indexed owner , address indexed operator , bool approved ); // ERC721A Specific Events event ConsecutiveTransfer ( uint256 indexed fromTokenId , uint256 toTokenId , address indexed from , address indexed to ); // ERC721 Standard Functions function balanceOf ( address owner ) external view returns ( uint256 balance ); function ownerOf ( uint256 tokenId ) external view returns ( address owner ); function safeTransferFrom ( address from , address to , uint256 tokenId , bytes calldata data ) external ; function safeTransferFrom ( address from , address to , uint256 tokenId ) external ; function transferFrom ( address from , address to , uint256 tokenId ) external ; function approve ( address to , uint256 tokenId ) external ; function setApprovalForAll ( address operator , bool approved ) external ; function getApproved ( uint256 tokenId ) external view returns ( address operator ); function isApprovedForAll ( address owner , address operator ) external view returns ( bool ); // ERC721Metadata function name () external view returns ( string memory ); function symbol () external view returns ( string memory ); function tokenURI ( uint256 tokenId ) external view returns ( string memory ); // ERC721A Specific Functions function totalSupply () external view returns ( uint256 ); function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ); // Batch Operations function safeMint ( address to , uint256 quantity ) external ; function safeMint ( address to , uint256 quantity , bytes memory data ) external ; // Advanced Queries function numberMinted ( address owner ) external view returns ( uint256 ); function numberBurned ( address owner ) external view returns ( uint256 ); function getAux ( address owner ) external view returns ( uint64 ); function setAux ( address owner , uint64 aux ) external ; // Token Existence function exists ( uint256 tokenId ) external view returns ( bool ); // Burning function burn ( uint256 tokenId ) external ; }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/ierc721a/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/ierc721a/#standard-erc721-functions","text":"","title":"Standard ERC721 Functions"},{"location":"smart-contracts/interfaces/ierc721a/#balanceof","text":"Returns the number of tokens owned by an address. Parameters: - owner : Address to query the balance of Returns: - uint256 : Number of tokens owned","title":"balanceOf()"},{"location":"smart-contracts/interfaces/ierc721a/#ownerof","text":"Returns the owner of a specific token. Parameters: - tokenId : Token ID to query Returns: - address : Owner of the token","title":"ownerOf()"},{"location":"smart-contracts/interfaces/ierc721a/#transferfrom","text":"Transfers a token from one address to another. Parameters: - from : Current owner of the token - to : Address to transfer the token to - tokenId : Token ID to transfer","title":"transferFrom()"},{"location":"smart-contracts/interfaces/ierc721a/#erc721a-specific-functions","text":"","title":"ERC721A Specific Functions"},{"location":"smart-contracts/interfaces/ierc721a/#safemint","text":"Mints tokens to a specified address with gas optimization. Parameters: - to : Address to mint tokens to - quantity : Number of tokens to mint - data : Optional data to pass to receiver (if contract) Gas Optimization: - Batch minting reduces gas cost per token significantly - Sequential token IDs eliminate need for individual storage","title":"safeMint()"},{"location":"smart-contracts/interfaces/ierc721a/#numberminted","text":"Returns the total number of tokens minted by an address. Parameters: - owner : Address to query Returns: - uint256 : Total number of tokens minted","title":"numberMinted()"},{"location":"smart-contracts/interfaces/ierc721a/#numberburned","text":"Returns the total number of tokens burned by an address. Parameters: - owner : Address to query Returns: - uint256 : Total number of tokens burned","title":"numberBurned()"},{"location":"smart-contracts/interfaces/ierc721a/#getaux-setaux","text":"Get/set auxiliary data for an address (64 bits of custom data). Parameters: - owner : Address to query/modify - aux : Auxiliary data to set (setAux only) Returns: - uint64 : Auxiliary data (getAux only)","title":"getAux() / setAux()"},{"location":"smart-contracts/interfaces/ierc721a/#implementation-example","text":"","title":"Implementation Example"},{"location":"smart-contracts/interfaces/ierc721a/#basic-erc721a-contract","text":"contract MyNFTCollection is IERC721A { string private _name ; string private _symbol ; string private _baseTokenURI ; uint256 private _currentIndex ; uint256 private _burnCounter ; // Mapping from token ID to ownership details mapping ( uint256 => TokenOwnership ) private _ownerships ; // Mapping owner address to address data mapping ( address => AddressData ) private _addressData ; // Mapping from token ID to approved address mapping ( uint256 => address ) private _tokenApprovals ; // Mapping from owner to operator approvals mapping ( address => mapping ( address => bool )) private _operatorApprovals ; struct TokenOwnership { address addr ; uint64 startTimestamp ; bool burned ; uint24 extraData ; } struct AddressData { uint64 balance ; uint64 numberMinted ; uint64 numberBurned ; uint64 aux ; } constructor ( string memory name_ , string memory symbol_ ) { _name = name_ ; _symbol = symbol_ ; _currentIndex = 1 ; // Start token IDs at 1 } function safeMint ( address to , uint256 quantity ) external override { require ( to != address ( 0 ), \"ERC721A: mint to zero address\" ); require ( quantity > 0 , \"ERC721A: quantity must be greater than 0\" ); uint256 startTokenId = _currentIndex ; _currentIndex += quantity ; // Update balance and minted count _addressData [ to ]. balance += uint64 ( quantity ); _addressData [ to ]. numberMinted += uint64 ( quantity ); // Set ownership for the first token in the batch _ownerships [ startTokenId ] = TokenOwnership ( to , uint64 ( block.timestamp ), false , 0 ); // Emit Transfer events for ( uint256 i = 0 ; i < quantity ; i ++ ) { emit Transfer ( address ( 0 ), to , startTokenId + i ); } // Emit ConsecutiveTransfer event for gas optimization if ( quantity > 1 ) { emit ConsecutiveTransfer ( startTokenId , startTokenId + quantity - 1 , address ( 0 ), to ); } } function ownerOf ( uint256 tokenId ) public view override returns ( address ) { require ( _exists ( tokenId ), \"ERC721A: owner query for nonexistent token\" ); uint256 curr = tokenId ; while ( true ) { TokenOwnership memory ownership = _ownerships [ curr ]; if ( ownership . addr != address ( 0 )) { return ownership . addr ; } curr -- ; } revert ( \"ERC721A: unable to determine the owner of token\" ); } function _exists ( uint256 tokenId ) internal view returns ( bool ) { return tokenId > 0 && tokenId < _currentIndex && ! _ownerships [ tokenId ]. burned ; } }","title":"Basic ERC721A Contract"},{"location":"smart-contracts/interfaces/ierc721a/#advanced-batch-minting","text":"contract AdvancedERC721A is IERC721A { uint256 public constant MAX_SUPPLY = 10000 ; uint256 public constant MAX_BATCH_SIZE = 20 ; uint256 public mintPrice = 0 . 01 ether ; mapping ( address => bool ) public whitelist ; bool public whitelistActive = true ; function publicMint ( uint256 quantity ) external payable { require ( ! whitelistActive , \"Whitelist phase active\" ); require ( quantity <= MAX_BATCH_SIZE , \"Exceeds max batch size\" ); require ( totalSupply () + quantity <= MAX_SUPPLY , \"Exceeds max supply\" ); require ( msg.value >= mintPrice * quantity , \"Insufficient payment\" ); _safeMint ( msg.sender , quantity ); } function whitelistMint ( uint256 quantity ) external payable { require ( whitelistActive , \"Whitelist phase not active\" ); require ( whitelist [ msg.sender ], \"Not whitelisted\" ); require ( quantity <= MAX_BATCH_SIZE , \"Exceeds max batch size\" ); require ( totalSupply () + quantity <= MAX_SUPPLY , \"Exceeds max supply\" ); require ( msg.value >= mintPrice * quantity , \"Insufficient payment\" ); _safeMint ( msg.sender , quantity ); } function airdrop ( address [] calldata recipients , uint256 [] calldata quantities ) external onlyOwner { require ( recipients . length == quantities . length , \"Arrays length mismatch\" ); for ( uint256 i = 0 ; i < recipients . length ; i ++ ) { require ( totalSupply () + quantities [ i ] <= MAX_SUPPLY , \"Exceeds max supply\" ); _safeMint ( recipients [ i ], quantities [ i ]); } } }","title":"Advanced Batch Minting"},{"location":"smart-contracts/interfaces/ierc721a/#gas-optimization-benefits","text":"","title":"Gas Optimization Benefits"},{"location":"smart-contracts/interfaces/ierc721a/#comparison-with-standard-erc721","text":"Operation ERC721 Gas Cost ERC721A Gas Cost Savings Mint 1 NFT ~51,000 ~51,000 0% Mint 5 NFTs ~255,000 ~56,000 78% Mint 10 NFTs ~510,000 ~61,000 88% Mint 20 NFTs ~1,020,000 ~71,000 93%","title":"Comparison with Standard ERC721"},{"location":"smart-contracts/interfaces/ierc721a/#storage-optimization","text":"// Standard ERC721 - stores owner for each token mapping ( uint256 => address ) private _owners ; // 20k gas per token // ERC721A - stores owner only for first token in batch mapping ( uint256 => TokenOwnership ) private _ownerships ; // 20k gas per batch","title":"Storage Optimization"},{"location":"smart-contracts/interfaces/ierc721a/#integration-patterns","text":"","title":"Integration Patterns"},{"location":"smart-contracts/interfaces/ierc721a/#marketplace-integration","text":"contract MarketplaceIntegration { IERC721A public nftContract ; function listToken ( uint256 tokenId , uint256 price ) external { require ( nftContract . ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); require ( nftContract . getApproved ( tokenId ) == address ( this ) || nftContract . isApprovedForAll ( msg.sender , address ( this )), \"Not approved\" ); // List token for sale _createListing ( tokenId , price , msg.sender ); } function buyToken ( uint256 tokenId ) external payable { Listing memory listing = listings [ tokenId ]; require ( listing . active , \"Token not for sale\" ); require ( msg.value >= listing . price , \"Insufficient payment\" ); // Transfer token nftContract . safeTransferFrom ( listing . seller , msg.sender , tokenId ); // Handle payment _handlePayment ( listing . seller , listing . price ); } }","title":"Marketplace Integration"},{"location":"smart-contracts/interfaces/ierc721a/#staking-integration","text":"contract NFTStaking { IERC721A public nftContract ; mapping ( uint256 => StakeInfo ) public stakes ; struct StakeInfo { address owner ; uint256 stakedAt ; uint256 rewards ; } function stake ( uint256 [] calldata tokenIds ) external { for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { uint256 tokenId = tokenIds [ i ]; require ( nftContract . ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); // Transfer to staking contract nftContract . safeTransferFrom ( msg.sender , address ( this ), tokenId ); stakes [ tokenId ] = StakeInfo ({ owner : msg.sender , stakedAt : block.timestamp , rewards : 0 }); } } function unstake ( uint256 [] calldata tokenIds ) external { for ( uint256 i = 0 ; i < tokenIds . length ; i ++ ) { uint256 tokenId = tokenIds [ i ]; StakeInfo storage stake = stakes [ tokenId ]; require ( stake . owner == msg.sender , \"Not stake owner\" ); // Calculate and distribute rewards uint256 rewards = calculateRewards ( tokenId ); _distributeRewards ( msg.sender , rewards ); // Return NFT nftContract . safeTransferFrom ( address ( this ), msg.sender , tokenId ); delete stakes [ tokenId ]; } } }","title":"Staking Integration"},{"location":"smart-contracts/interfaces/ierc721a/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/ierc721a/#reentrancy-protection","text":"Use reentrancy guards for minting functions Validate external calls in safe transfer hooks Implement proper access controls","title":"Reentrancy Protection"},{"location":"smart-contracts/interfaces/ierc721a/#integer-overflow-protection","text":"Use SafeMath or Solidity 0.8+ built-in overflow protection Validate quantity parameters in minting functions Check total supply limits","title":"Integer Overflow Protection"},{"location":"smart-contracts/interfaces/ierc721a/#access-control","text":"Implement proper role-based access control Validate ownership before transfers Secure administrative functions","title":"Access Control"},{"location":"smart-contracts/interfaces/ierc721a/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/interfaces/ierc721a/#minting-guidelines","text":"Batch Size Limits : Implement reasonable batch size limits Supply Caps : Enforce maximum supply limits Payment Validation : Validate payment amounts for paid mints Whitelist Management : Secure whitelist functionality","title":"Minting Guidelines"},{"location":"smart-contracts/interfaces/ierc721a/#gas-optimization_1","text":"Batch Operations : Encourage batch minting over individual mints Storage Packing : Pack related data into single storage slots Lazy Loading : Defer expensive operations when possible Event Optimization : Use ConsecutiveTransfer events for batch operations","title":"Gas Optimization"},{"location":"smart-contracts/interfaces/ierc721a/#integration-considerations","text":"Marketplace Compatibility : Ensure compatibility with major marketplaces Wallet Support : Test with popular wallet implementations Metadata Standards : Follow metadata standards for better compatibility Enumeration Support : Consider implementing enumeration for better tooling support","title":"Integration Considerations"},{"location":"smart-contracts/interfaces/ierc721a/#related-documentation","text":"ERC721A Library ERC721A Enumeration Library Metadata Library NFT Minting Guide Gas Optimization Guide","title":"Related Documentation"},{"location":"smart-contracts/interfaces/ierc721a/#standards-compliance","text":"ERC721 : Full ERC721 standard compliance ERC721Metadata : Metadata extension support ERC721Enumerable : Optional enumeration support ERC165 : Interface detection support Gas Optimization : Optimized for batch operations","title":"Standards Compliance"},{"location":"smart-contracts/interfaces/ierc734/","text":"IERC734 Interface \u00b6 Overview \u00b6 The IERC734 interface defines the Key Manager standard for decentralized identity management within the Gemforce platform. This interface implements the ERC-734 standard for managing cryptographic keys associated with identity contracts, enabling multi-signature operations, role-based access control, and secure execution of transactions through key-based authorization. Key Features \u00b6 Multi-Key Management : Support for multiple cryptographic keys with different purposes Purpose-Based Authorization : Keys can be assigned specific purposes (management, action, claim, encryption) Key Type Support : Different cryptographic key types (ECDSA, RSA, etc.) Execution Management : Secure transaction execution with multi-signature approval Event Tracking : Comprehensive event emission for key and execution operations Interface Definition \u00b6 // SPDX-License-Identifier: GPL-3.0 pragma solidity ^ 0.8.0 ; import { IERC165 } from \"./IERC165.sol\" ; interface IERC734 is IERC165 { // Events event KeyAdded ( bytes32 indexed key , uint256 indexed purpose , uint256 indexed keyType ); event KeyRemoved ( bytes32 indexed key , uint256 indexed purpose , uint256 indexed keyType ); event ExecutionRequested ( uint256 indexed executionId , address indexed to , uint256 indexed value , bytes data ); event Executed ( uint256 indexed executionId , address indexed to , uint256 indexed value , bytes data ); event ExecutionFailed ( uint256 indexed executionId , address indexed to , uint256 indexed value , bytes data ); event Approved ( uint256 indexed executionId , bool approved ); // Key Management Functions function addKey ( bytes32 _key , uint256 _purpose , uint256 _keyType ) external ; function removeKey ( bytes32 _key , uint256 _purpose ) external ; function approve ( uint256 _id , bool _approve ) external ; // Query Functions function getKey ( bytes32 _key ) external view returns ( uint256 [] memory purposes , uint256 keyType , bytes32 key ); function getKeyPurposes ( bytes32 _key ) external view returns ( uint256 [] memory ); function getKeysByPurpose ( uint256 _purpose ) external view returns ( bytes32 [] memory ); function getExecution ( uint256 _id ) external view returns ( address to , uint256 value , bytes memory data , bool approved , uint256 executionType ); } Key Purpose Constants \u00b6 // Standard key purposes as defined in ERC-734 uint256 public constant MANAGEMENT_KEY = 1 ; // Can manage the identity uint256 public constant ACTION_KEY = 2 ; // Can perform actions uint256 public constant CLAIM_SIGNER_KEY = 3 ; // Can sign claims uint256 public constant ENCRYPTION_KEY = 4 ; // Can encrypt/decrypt data Key Type Constants \u00b6 // Standard key types uint256 public constant ECDSA_TYPE = 1 ; // ECDSA key type uint256 public constant RSA_TYPE = 2 ; // RSA key type uint256 public constant MULTISIG_TYPE = 3 ; // Multi-signature key type Core Functions \u00b6 Key Management \u00b6 addKey() \u00b6 function addKey ( bytes32 _key , uint256 _purpose , uint256 _keyType ) external Purpose : Add a new key to the identity with specified purpose and type. Parameters : - _key (bytes32): The key identifier (typically keccak256 hash of the public key) - _purpose (uint256): The purpose of the key (MANAGEMENT_KEY, ACTION_KEY, etc.) - _keyType (uint256): The cryptographic type of the key (ECDSA_TYPE, RSA_TYPE, etc.) Requirements : - Caller must have MANAGEMENT_KEY purpose - Key must not already exist with the same purpose - Purpose and key type must be valid Events Emitted : - KeyAdded with key, purpose, and key type Example Usage : // Add a new action key for transaction execution bytes32 newKey = keccak256 ( abi . encodePacked ( publicKey )); uint256 purpose = ACTION_KEY ; uint256 keyType = ECDSA_TYPE ; IERC734 ( identityContract ). addKey ( newKey , purpose , keyType ); console . log ( \"Added action key:\" , newKey ); removeKey() \u00b6 function removeKey ( bytes32 _key , uint256 _purpose ) external Purpose : Remove a key from the identity for a specific purpose. Parameters : - _key (bytes32): The key identifier to remove - _purpose (uint256): The purpose for which to remove the key Requirements : - Caller must have MANAGEMENT_KEY purpose - Key must exist with the specified purpose - Cannot remove the last management key Events Emitted : - KeyRemoved with key, purpose, and key type Example Usage : // Remove an action key bytes32 keyToRemove = 0x1234567890abcdef ...; uint256 purpose = ACTION_KEY ; IERC734 ( identityContract ). removeKey ( keyToRemove , purpose ); console . log ( \"Removed key:\" , keyToRemove , \"for purpose:\" , purpose ); Execution Management \u00b6 approve() \u00b6 function approve ( uint256 _id , bool _approve ) external Purpose : Approve or reject a pending execution request. Parameters : - _id (uint256): The execution ID to approve or reject - _approve (bool): True to approve, false to reject Requirements : - Caller must have appropriate key purpose for the execution - Execution must exist and be pending - Caller must not have already voted on this execution Events Emitted : - Approved with execution ID and approval status - Executed if execution is approved and executed successfully - ExecutionFailed if execution is approved but fails Example Usage : // Approve a pending execution uint256 executionId = 1 ; bool approve = true ; IERC734 ( identityContract ). approve ( executionId , approve ); console . log ( \"Approved execution:\" , executionId ); Query Functions \u00b6 Key Information \u00b6 getKey() \u00b6 function getKey ( bytes32 _key ) external view returns ( uint256 [] memory purposes , uint256 keyType , bytes32 key ) Purpose : Get detailed information about a specific key. Parameters : - _key (bytes32): The key identifier to query Returns : - purposes (uint256[]): Array of purposes assigned to this key - keyType (uint256): The cryptographic type of the key - key (bytes32): The key identifier (same as input) Example Usage : // Get key information bytes32 keyId = 0x1234567890abcdef ...; ( uint256 [] memory purposes , uint256 keyType , bytes32 key ) = IERC734 ( identityContract ). getKey ( keyId ); console . log ( \"Key purposes:\" , purposes . length ); console . log ( \"Key type:\" , keyType ); getKeyPurposes() \u00b6 function getKeyPurposes ( bytes32 _key ) external view returns ( uint256 [] memory ) Purpose : Get all purposes assigned to a specific key. Parameters : - _key (bytes32): The key identifier to query Returns : Array of purposes assigned to the key Example Usage : // Get key purposes bytes32 keyId = 0x1234567890abcdef ...; uint256 [] memory purposes = IERC734 ( identityContract ). getKeyPurposes ( keyId ); for ( uint256 i = 0 ; i < purposes . length ; i ++ ) { console . log ( \"Purpose:\" , purposes [ i ]); } getKeysByPurpose() \u00b6 function getKeysByPurpose ( uint256 _purpose ) external view returns ( bytes32 [] memory ) Purpose : Get all keys assigned to a specific purpose. Parameters : - _purpose (uint256): The purpose to query keys for Returns : Array of key identifiers with the specified purpose Example Usage : // Get all management keys uint256 purpose = MANAGEMENT_KEY ; bytes32 [] memory managementKeys = IERC734 ( identityContract ). getKeysByPurpose ( purpose ); console . log ( \"Management keys count:\" , managementKeys . length ); for ( uint256 i = 0 ; i < managementKeys . length ; i ++ ) { console . log ( \"Management key:\" , managementKeys [ i ]); } Execution Information \u00b6 getExecution() \u00b6 function getExecution ( uint256 _id ) external view returns ( address to , uint256 value , bytes memory data , bool approved , uint256 executionType ) Purpose : Get detailed information about a specific execution request. Parameters : - _id (uint256): The execution ID to query Returns : - to (address): The target address for the execution - value (uint256): The ETH value to send with the execution - data (bytes): The call data for the execution - approved (bool): Whether the execution has been approved - executionType (uint256): The type of execution Example Usage : // Get execution details uint256 executionId = 1 ; ( address to , uint256 value , bytes memory data , bool approved , uint256 executionType ) = IERC734 ( identityContract ). getExecution ( executionId ); console . log ( \"Execution target:\" , to ); console . log ( \"Execution value:\" , value ); console . log ( \"Execution approved:\" , approved ); Integration Examples \u00b6 Multi-Signature Identity Wallet \u00b6 // Multi-signature wallet using ERC-734 key management contract MultiSigIdentityWallet { IERC734 public keyManager ; struct Transaction { address to ; uint256 value ; bytes data ; bool executed ; uint256 confirmations ; mapping ( address => bool ) isConfirmed ; } mapping ( uint256 => Transaction ) public transactions ; uint256 public transactionCount ; uint256 public required ; // Required confirmations event TransactionSubmitted ( uint256 indexed transactionId , address indexed to , uint256 value ); event TransactionConfirmed ( uint256 indexed transactionId , address indexed confirmer ); event TransactionExecuted ( uint256 indexed transactionId ); constructor ( address _keyManager , uint256 _required ) { keyManager = IERC734 ( _keyManager ); required = _required ; } function submitTransaction ( address to , uint256 value , bytes memory data ) external onlyActionKey returns ( uint256 transactionId ) { transactionId = transactionCount ++ ; Transaction storage txn = transactions [ transactionId ]; txn . to = to ; txn . value = value ; txn . data = data ; txn . executed = false ; txn . confirmations = 0 ; emit TransactionSubmitted ( transactionId , to , value ); // Auto-confirm from submitter confirmTransaction ( transactionId ); } function confirmTransaction ( uint256 transactionId ) public onlyActionKey { Transaction storage txn = transactions [ transactionId ]; require ( ! txn . executed , \"Transaction already executed\" ); require ( ! txn . isConfirmed [ msg.sender ], \"Transaction already confirmed by sender\" ); txn . isConfirmed [ msg.sender ] = true ; txn . confirmations ++ ; emit TransactionConfirmed ( transactionId , msg.sender ); if ( txn . confirmations >= required ) { executeTransaction ( transactionId ); } } function executeTransaction ( uint256 transactionId ) internal { Transaction storage txn = transactions [ transactionId ]; require ( ! txn . executed , \"Transaction already executed\" ); require ( txn . confirmations >= required , \"Insufficient confirmations\" ); txn . executed = true ; ( bool success , ) = txn . to . call { value : txn . value }( txn . data ); require ( success , \"Transaction execution failed\" ); emit TransactionExecuted ( transactionId ); } function getTransactionInfo ( uint256 transactionId ) external view returns ( address to , uint256 value , bytes memory data , bool executed , uint256 confirmations , bool canExecute ) { Transaction storage txn = transactions [ transactionId ]; to = txn . to ; value = txn . value ; data = txn . data ; executed = txn . executed ; confirmations = txn . confirmations ; canExecute = ! executed && confirmations >= required ; } modifier onlyActionKey () { bytes32 senderKey = keccak256 ( abi . encodePacked ( msg.sender )); uint256 [] memory purposes = keyManager . getKeyPurposes ( senderKey ); bool hasActionKey = false ; for ( uint256 i = 0 ; i < purposes . length ; i ++ ) { if ( purposes [ i ] == 2 ) { // ACTION_KEY hasActionKey = true ; break ; } } require ( hasActionKey , \"Sender does not have action key\" ); _ ; } } Identity-Based Access Control \u00b6 // Access control system using ERC-734 identity management contract IdentityAccessControl { IERC734 public identityRegistry ; struct AccessPolicy { uint256 requiredPurpose ; uint256 minKeyType ; bool active ; string description ; } mapping ( bytes32 => AccessPolicy ) public accessPolicies ; mapping ( address => bytes32 ) public userIdentities ; mapping ( bytes32 => bool ) public authorizedIdentities ; event AccessPolicyCreated ( bytes32 indexed policyId , uint256 requiredPurpose , string description ); event IdentityAuthorized ( bytes32 indexed identityId , address indexed user ); event AccessGranted ( address indexed user , bytes32 indexed policyId ); event AccessDenied ( address indexed user , bytes32 indexed policyId , string reason ); constructor ( address _identityRegistry ) { identityRegistry = IERC734 ( _identityRegistry ); } function createAccessPolicy ( bytes32 policyId , uint256 requiredPurpose , uint256 minKeyType , string memory description ) external onlyAdmin { accessPolicies [ policyId ] = AccessPolicy ({ requiredPurpose : requiredPurpose , minKeyType : minKeyType , active : true , description : description }); emit AccessPolicyCreated ( policyId , requiredPurpose , description ); } function authorizeIdentity ( bytes32 identityId , address user ) external onlyAdmin { authorizedIdentities [ identityId ] = true ; userIdentities [ user ] = identityId ; emit IdentityAuthorized ( identityId , user ); } function checkAccess ( address user , bytes32 policyId ) external returns ( bool ) { AccessPolicy memory policy = accessPolicies [ policyId ]; require ( policy . active , \"Access policy not active\" ); bytes32 identityId = userIdentities [ user ]; if ( identityId == bytes32 ( 0 )) { emit AccessDenied ( user , policyId , \"No identity registered\" ); return false ; } if ( ! authorizedIdentities [ identityId ]) { emit AccessDenied ( user , policyId , \"Identity not authorized\" ); return false ; } // Check if user has required key purpose bytes32 userKey = keccak256 ( abi . encodePacked ( user )); uint256 [] memory purposes = identityRegistry . getKeyPurposes ( userKey ); bool hasPurpose = false ; for ( uint256 i = 0 ; i < purposes . length ; i ++ ) { if ( purposes [ i ] == policy . requiredPurpose ) { hasPurpose = true ; break ; } } if ( ! hasPurpose ) { emit AccessDenied ( user , policyId , \"Insufficient key purpose\" ); return false ; } // Check key type if specified if ( policy . minKeyType > 0 ) { (, uint256 keyType , ) = identityRegistry . getKey ( userKey ); if ( keyType < policy . minKeyType ) { emit AccessDenied ( user , policyId , \"Insufficient key type\" ); return false ; } } emit AccessGranted ( user , policyId ); return true ; } function getUserIdentityInfo ( address user ) external view returns ( bytes32 identityId , bool authorized , uint256 [] memory keyPurposes , uint256 keyType ) { identityId = userIdentities [ user ]; authorized = authorizedIdentities [ identityId ]; if ( identityId != bytes32 ( 0 )) { bytes32 userKey = keccak256 ( abi . encodePacked ( user )); keyPurposes = identityRegistry . getKeyPurposes ( userKey ); (, keyType , ) = identityRegistry . getKey ( userKey ); } } modifier onlyAdmin () { // Implementation would check for admin role _ ; } } Decentralized Identity Provider \u00b6 // Identity provider service using ERC-734 contract DecentralizedIdentityProvider { IERC734 public keyManager ; struct IdentityProfile { string name ; string email ; string organization ; uint256 createdAt ; uint256 lastUpdated ; bool verified ; mapping ( string => string ) attributes ; } mapping ( address => IdentityProfile ) public profiles ; mapping ( bytes32 => address ) public keyToIdentity ; mapping ( address => bytes32 []) public identityKeys ; event IdentityCreated ( address indexed identity , string name ); event IdentityUpdated ( address indexed identity , string attribute , string value ); event IdentityVerified ( address indexed identity , address indexed verifier ); event KeyLinked ( address indexed identity , bytes32 indexed key , uint256 purpose ); constructor ( address _keyManager ) { keyManager = IERC734 ( _keyManager ); } function createIdentity ( string memory name , string memory email , string memory organization ) external { require ( profiles [ msg.sender ]. createdAt == 0 , \"Identity already exists\" ); IdentityProfile storage profile = profiles [ msg.sender ]; profile . name = name ; profile . email = email ; profile . organization = organization ; profile . createdAt = block.timestamp ; profile . lastUpdated = block.timestamp ; profile . verified = false ; // Link primary key bytes32 primaryKey = keccak256 ( abi . encodePacked ( msg.sender )); keyToIdentity [ primaryKey ] = msg.sender ; identityKeys [ msg.sender ]. push ( primaryKey ); emit IdentityCreated ( msg.sender , name ); emit KeyLinked ( msg.sender , primaryKey , 1 ); // MANAGEMENT_KEY } function updateAttribute ( string memory attribute , string memory value ) external { require ( profiles [ msg.sender ]. createdAt > 0 , \"Identity does not exist\" ); profiles [ msg.sender ]. attributes [ attribute ] = value ; profiles [ msg.sender ]. lastUpdated = block.timestamp ; emit IdentityUpdated ( msg.sender , attribute , value ); } function linkKey ( bytes32 key , uint256 purpose ) external { require ( profiles [ msg.sender ]. createdAt > 0 , \"Identity does not exist\" ); require ( keyToIdentity [ key ] == address ( 0 ), \"Key already linked\" ); keyToIdentity [ key ] = msg.sender ; identityKeys [ msg.sender ]. push ( key ); emit KeyLinked ( msg.sender , key , purpose ); } function verifyIdentity ( address identity ) external onlyVerifier { require ( profiles [ identity ]. createdAt > 0 , \"Identity does not exist\" ); profiles [ identity ]. verified = true ; profiles [ identity ]. lastUpdated = block.timestamp ; emit IdentityVerified ( identity , msg.sender ); } function getIdentityProfile ( address identity ) external view returns ( string memory name , string memory email , string memory organization , uint256 createdAt , uint256 lastUpdated , bool verified , uint256 keyCount ) { IdentityProfile storage profile = profiles [ identity ]; name = profile . name ; email = profile . email ; organization = profile . organization ; createdAt = profile . createdAt ; lastUpdated = profile . lastUpdated ; verified = profile . verified ; keyCount = identityKeys [ identity ]. length ; } function getAttribute ( address identity , string memory attribute ) external view returns ( string memory ) { return profiles [ identity ]. attributes [ attribute ]; } function getIdentityKeys ( address identity ) external view returns ( bytes32 [] memory ) { return identityKeys [ identity ]; } function resolveKeyToIdentity ( bytes32 key ) external view returns ( address ) { return keyToIdentity [ key ]; } modifier onlyVerifier () { // Implementation would check for verifier role _ ; } } Events \u00b6 Key Management Events \u00b6 event KeyAdded ( bytes32 indexed key , // Key identifier uint256 indexed purpose , // Key purpose uint256 indexed keyType // Key type ); event KeyRemoved ( bytes32 indexed key , // Key identifier uint256 indexed purpose , // Key purpose uint256 indexed keyType // Key type ); Execution Management Events \u00b6 event ExecutionRequested ( uint256 indexed executionId , // Execution identifier address indexed to , // Target address uint256 indexed value , // ETH value bytes data // Call data ); event Executed ( uint256 indexed executionId , // Execution identifier address indexed to , // Target address uint256 indexed value , // ETH value bytes data // Call data ); event ExecutionFailed ( uint256 indexed executionId , // Execution identifier address indexed to , // Target address uint256 indexed value , // ETH value bytes data // Call data ); event Approved ( uint256 indexed executionId , // Execution identifier bool approved // Approval status ); Security Considerations \u00b6 Key Management Security \u00b6 Secure key generation and storage Prevention of key reuse across purposes Protection against key compromise Secure key rotation procedures Access Control \u00b6 Proper validation of key purposes and types Prevention of unauthorized key additions/removals Protection of management keys Secure execution approval mechanisms Multi-Signature Security \u00b6 Threshold signature validation Prevention of replay attacks Secure nonce management Protection against front-running Gas Optimization \u00b6 Efficient Operations \u00b6 Batch key operations where possible Optimized storage layout for key data Minimal external calls in view functions Efficient event emission patterns Storage Optimization \u00b6 Packed storage structures for key data Efficient mapping usage for key lookups Optimized array operations for key lists Cached calculations for frequently accessed data Error Handling \u00b6 Common Errors \u00b6 Unauthorized key management operations Invalid key purposes or types Non-existent keys or executions Insufficient approvals for execution Key already exists or doesn't exist Best Practices \u00b6 Validate caller permissions before operations Check key existence before modifications Verify execution requirements before approval Handle edge cases gracefully Provide clear error messages for debugging Testing Considerations \u00b6 Unit Tests \u00b6 Interface compliance verification Key management function testing Execution approval and execution testing Event emission verification Access control validation Integration Tests \u00b6 Multi-signature workflow testing Identity provider integration Access control system integration Cross-contract key validation Security scenario testing Related Documentation \u00b6 IERC735 - Claim Holder interface for identity claims IdentityRegistryFacet - Identity registry implementation TrustedIssuersRegistryFacet - Trusted issuer management Identity System Guide - Implementation guide for identity management Multi-Signature Guide - Multi-signature implementation patterns This interface defines the Key Manager standard (ERC-734) for decentralized identity management within the Gemforce platform, enabling secure multi-key management, role-based access control, and multi-signature transaction execution.","title":"IERC734"},{"location":"smart-contracts/interfaces/ierc734/#ierc734-interface","text":"","title":"IERC734 Interface"},{"location":"smart-contracts/interfaces/ierc734/#overview","text":"The IERC734 interface defines the Key Manager standard for decentralized identity management within the Gemforce platform. This interface implements the ERC-734 standard for managing cryptographic keys associated with identity contracts, enabling multi-signature operations, role-based access control, and secure execution of transactions through key-based authorization.","title":"Overview"},{"location":"smart-contracts/interfaces/ierc734/#key-features","text":"Multi-Key Management : Support for multiple cryptographic keys with different purposes Purpose-Based Authorization : Keys can be assigned specific purposes (management, action, claim, encryption) Key Type Support : Different cryptographic key types (ECDSA, RSA, etc.) Execution Management : Secure transaction execution with multi-signature approval Event Tracking : Comprehensive event emission for key and execution operations","title":"Key Features"},{"location":"smart-contracts/interfaces/ierc734/#interface-definition","text":"// SPDX-License-Identifier: GPL-3.0 pragma solidity ^ 0.8.0 ; import { IERC165 } from \"./IERC165.sol\" ; interface IERC734 is IERC165 { // Events event KeyAdded ( bytes32 indexed key , uint256 indexed purpose , uint256 indexed keyType ); event KeyRemoved ( bytes32 indexed key , uint256 indexed purpose , uint256 indexed keyType ); event ExecutionRequested ( uint256 indexed executionId , address indexed to , uint256 indexed value , bytes data ); event Executed ( uint256 indexed executionId , address indexed to , uint256 indexed value , bytes data ); event ExecutionFailed ( uint256 indexed executionId , address indexed to , uint256 indexed value , bytes data ); event Approved ( uint256 indexed executionId , bool approved ); // Key Management Functions function addKey ( bytes32 _key , uint256 _purpose , uint256 _keyType ) external ; function removeKey ( bytes32 _key , uint256 _purpose ) external ; function approve ( uint256 _id , bool _approve ) external ; // Query Functions function getKey ( bytes32 _key ) external view returns ( uint256 [] memory purposes , uint256 keyType , bytes32 key ); function getKeyPurposes ( bytes32 _key ) external view returns ( uint256 [] memory ); function getKeysByPurpose ( uint256 _purpose ) external view returns ( bytes32 [] memory ); function getExecution ( uint256 _id ) external view returns ( address to , uint256 value , bytes memory data , bool approved , uint256 executionType ); }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/ierc734/#key-purpose-constants","text":"// Standard key purposes as defined in ERC-734 uint256 public constant MANAGEMENT_KEY = 1 ; // Can manage the identity uint256 public constant ACTION_KEY = 2 ; // Can perform actions uint256 public constant CLAIM_SIGNER_KEY = 3 ; // Can sign claims uint256 public constant ENCRYPTION_KEY = 4 ; // Can encrypt/decrypt data","title":"Key Purpose Constants"},{"location":"smart-contracts/interfaces/ierc734/#key-type-constants","text":"// Standard key types uint256 public constant ECDSA_TYPE = 1 ; // ECDSA key type uint256 public constant RSA_TYPE = 2 ; // RSA key type uint256 public constant MULTISIG_TYPE = 3 ; // Multi-signature key type","title":"Key Type Constants"},{"location":"smart-contracts/interfaces/ierc734/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/ierc734/#key-management","text":"","title":"Key Management"},{"location":"smart-contracts/interfaces/ierc734/#addkey","text":"function addKey ( bytes32 _key , uint256 _purpose , uint256 _keyType ) external Purpose : Add a new key to the identity with specified purpose and type. Parameters : - _key (bytes32): The key identifier (typically keccak256 hash of the public key) - _purpose (uint256): The purpose of the key (MANAGEMENT_KEY, ACTION_KEY, etc.) - _keyType (uint256): The cryptographic type of the key (ECDSA_TYPE, RSA_TYPE, etc.) Requirements : - Caller must have MANAGEMENT_KEY purpose - Key must not already exist with the same purpose - Purpose and key type must be valid Events Emitted : - KeyAdded with key, purpose, and key type Example Usage : // Add a new action key for transaction execution bytes32 newKey = keccak256 ( abi . encodePacked ( publicKey )); uint256 purpose = ACTION_KEY ; uint256 keyType = ECDSA_TYPE ; IERC734 ( identityContract ). addKey ( newKey , purpose , keyType ); console . log ( \"Added action key:\" , newKey );","title":"addKey()"},{"location":"smart-contracts/interfaces/ierc734/#removekey","text":"function removeKey ( bytes32 _key , uint256 _purpose ) external Purpose : Remove a key from the identity for a specific purpose. Parameters : - _key (bytes32): The key identifier to remove - _purpose (uint256): The purpose for which to remove the key Requirements : - Caller must have MANAGEMENT_KEY purpose - Key must exist with the specified purpose - Cannot remove the last management key Events Emitted : - KeyRemoved with key, purpose, and key type Example Usage : // Remove an action key bytes32 keyToRemove = 0x1234567890abcdef ...; uint256 purpose = ACTION_KEY ; IERC734 ( identityContract ). removeKey ( keyToRemove , purpose ); console . log ( \"Removed key:\" , keyToRemove , \"for purpose:\" , purpose );","title":"removeKey()"},{"location":"smart-contracts/interfaces/ierc734/#execution-management","text":"","title":"Execution Management"},{"location":"smart-contracts/interfaces/ierc734/#approve","text":"function approve ( uint256 _id , bool _approve ) external Purpose : Approve or reject a pending execution request. Parameters : - _id (uint256): The execution ID to approve or reject - _approve (bool): True to approve, false to reject Requirements : - Caller must have appropriate key purpose for the execution - Execution must exist and be pending - Caller must not have already voted on this execution Events Emitted : - Approved with execution ID and approval status - Executed if execution is approved and executed successfully - ExecutionFailed if execution is approved but fails Example Usage : // Approve a pending execution uint256 executionId = 1 ; bool approve = true ; IERC734 ( identityContract ). approve ( executionId , approve ); console . log ( \"Approved execution:\" , executionId );","title":"approve()"},{"location":"smart-contracts/interfaces/ierc734/#query-functions","text":"","title":"Query Functions"},{"location":"smart-contracts/interfaces/ierc734/#key-information","text":"","title":"Key Information"},{"location":"smart-contracts/interfaces/ierc734/#getkey","text":"function getKey ( bytes32 _key ) external view returns ( uint256 [] memory purposes , uint256 keyType , bytes32 key ) Purpose : Get detailed information about a specific key. Parameters : - _key (bytes32): The key identifier to query Returns : - purposes (uint256[]): Array of purposes assigned to this key - keyType (uint256): The cryptographic type of the key - key (bytes32): The key identifier (same as input) Example Usage : // Get key information bytes32 keyId = 0x1234567890abcdef ...; ( uint256 [] memory purposes , uint256 keyType , bytes32 key ) = IERC734 ( identityContract ). getKey ( keyId ); console . log ( \"Key purposes:\" , purposes . length ); console . log ( \"Key type:\" , keyType );","title":"getKey()"},{"location":"smart-contracts/interfaces/ierc734/#getkeypurposes","text":"function getKeyPurposes ( bytes32 _key ) external view returns ( uint256 [] memory ) Purpose : Get all purposes assigned to a specific key. Parameters : - _key (bytes32): The key identifier to query Returns : Array of purposes assigned to the key Example Usage : // Get key purposes bytes32 keyId = 0x1234567890abcdef ...; uint256 [] memory purposes = IERC734 ( identityContract ). getKeyPurposes ( keyId ); for ( uint256 i = 0 ; i < purposes . length ; i ++ ) { console . log ( \"Purpose:\" , purposes [ i ]); }","title":"getKeyPurposes()"},{"location":"smart-contracts/interfaces/ierc734/#getkeysbypurpose","text":"function getKeysByPurpose ( uint256 _purpose ) external view returns ( bytes32 [] memory ) Purpose : Get all keys assigned to a specific purpose. Parameters : - _purpose (uint256): The purpose to query keys for Returns : Array of key identifiers with the specified purpose Example Usage : // Get all management keys uint256 purpose = MANAGEMENT_KEY ; bytes32 [] memory managementKeys = IERC734 ( identityContract ). getKeysByPurpose ( purpose ); console . log ( \"Management keys count:\" , managementKeys . length ); for ( uint256 i = 0 ; i < managementKeys . length ; i ++ ) { console . log ( \"Management key:\" , managementKeys [ i ]); }","title":"getKeysByPurpose()"},{"location":"smart-contracts/interfaces/ierc734/#execution-information","text":"","title":"Execution Information"},{"location":"smart-contracts/interfaces/ierc734/#getexecution","text":"function getExecution ( uint256 _id ) external view returns ( address to , uint256 value , bytes memory data , bool approved , uint256 executionType ) Purpose : Get detailed information about a specific execution request. Parameters : - _id (uint256): The execution ID to query Returns : - to (address): The target address for the execution - value (uint256): The ETH value to send with the execution - data (bytes): The call data for the execution - approved (bool): Whether the execution has been approved - executionType (uint256): The type of execution Example Usage : // Get execution details uint256 executionId = 1 ; ( address to , uint256 value , bytes memory data , bool approved , uint256 executionType ) = IERC734 ( identityContract ). getExecution ( executionId ); console . log ( \"Execution target:\" , to ); console . log ( \"Execution value:\" , value ); console . log ( \"Execution approved:\" , approved );","title":"getExecution()"},{"location":"smart-contracts/interfaces/ierc734/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/ierc734/#multi-signature-identity-wallet","text":"// Multi-signature wallet using ERC-734 key management contract MultiSigIdentityWallet { IERC734 public keyManager ; struct Transaction { address to ; uint256 value ; bytes data ; bool executed ; uint256 confirmations ; mapping ( address => bool ) isConfirmed ; } mapping ( uint256 => Transaction ) public transactions ; uint256 public transactionCount ; uint256 public required ; // Required confirmations event TransactionSubmitted ( uint256 indexed transactionId , address indexed to , uint256 value ); event TransactionConfirmed ( uint256 indexed transactionId , address indexed confirmer ); event TransactionExecuted ( uint256 indexed transactionId ); constructor ( address _keyManager , uint256 _required ) { keyManager = IERC734 ( _keyManager ); required = _required ; } function submitTransaction ( address to , uint256 value , bytes memory data ) external onlyActionKey returns ( uint256 transactionId ) { transactionId = transactionCount ++ ; Transaction storage txn = transactions [ transactionId ]; txn . to = to ; txn . value = value ; txn . data = data ; txn . executed = false ; txn . confirmations = 0 ; emit TransactionSubmitted ( transactionId , to , value ); // Auto-confirm from submitter confirmTransaction ( transactionId ); } function confirmTransaction ( uint256 transactionId ) public onlyActionKey { Transaction storage txn = transactions [ transactionId ]; require ( ! txn . executed , \"Transaction already executed\" ); require ( ! txn . isConfirmed [ msg.sender ], \"Transaction already confirmed by sender\" ); txn . isConfirmed [ msg.sender ] = true ; txn . confirmations ++ ; emit TransactionConfirmed ( transactionId , msg.sender ); if ( txn . confirmations >= required ) { executeTransaction ( transactionId ); } } function executeTransaction ( uint256 transactionId ) internal { Transaction storage txn = transactions [ transactionId ]; require ( ! txn . executed , \"Transaction already executed\" ); require ( txn . confirmations >= required , \"Insufficient confirmations\" ); txn . executed = true ; ( bool success , ) = txn . to . call { value : txn . value }( txn . data ); require ( success , \"Transaction execution failed\" ); emit TransactionExecuted ( transactionId ); } function getTransactionInfo ( uint256 transactionId ) external view returns ( address to , uint256 value , bytes memory data , bool executed , uint256 confirmations , bool canExecute ) { Transaction storage txn = transactions [ transactionId ]; to = txn . to ; value = txn . value ; data = txn . data ; executed = txn . executed ; confirmations = txn . confirmations ; canExecute = ! executed && confirmations >= required ; } modifier onlyActionKey () { bytes32 senderKey = keccak256 ( abi . encodePacked ( msg.sender )); uint256 [] memory purposes = keyManager . getKeyPurposes ( senderKey ); bool hasActionKey = false ; for ( uint256 i = 0 ; i < purposes . length ; i ++ ) { if ( purposes [ i ] == 2 ) { // ACTION_KEY hasActionKey = true ; break ; } } require ( hasActionKey , \"Sender does not have action key\" ); _ ; } }","title":"Multi-Signature Identity Wallet"},{"location":"smart-contracts/interfaces/ierc734/#identity-based-access-control","text":"// Access control system using ERC-734 identity management contract IdentityAccessControl { IERC734 public identityRegistry ; struct AccessPolicy { uint256 requiredPurpose ; uint256 minKeyType ; bool active ; string description ; } mapping ( bytes32 => AccessPolicy ) public accessPolicies ; mapping ( address => bytes32 ) public userIdentities ; mapping ( bytes32 => bool ) public authorizedIdentities ; event AccessPolicyCreated ( bytes32 indexed policyId , uint256 requiredPurpose , string description ); event IdentityAuthorized ( bytes32 indexed identityId , address indexed user ); event AccessGranted ( address indexed user , bytes32 indexed policyId ); event AccessDenied ( address indexed user , bytes32 indexed policyId , string reason ); constructor ( address _identityRegistry ) { identityRegistry = IERC734 ( _identityRegistry ); } function createAccessPolicy ( bytes32 policyId , uint256 requiredPurpose , uint256 minKeyType , string memory description ) external onlyAdmin { accessPolicies [ policyId ] = AccessPolicy ({ requiredPurpose : requiredPurpose , minKeyType : minKeyType , active : true , description : description }); emit AccessPolicyCreated ( policyId , requiredPurpose , description ); } function authorizeIdentity ( bytes32 identityId , address user ) external onlyAdmin { authorizedIdentities [ identityId ] = true ; userIdentities [ user ] = identityId ; emit IdentityAuthorized ( identityId , user ); } function checkAccess ( address user , bytes32 policyId ) external returns ( bool ) { AccessPolicy memory policy = accessPolicies [ policyId ]; require ( policy . active , \"Access policy not active\" ); bytes32 identityId = userIdentities [ user ]; if ( identityId == bytes32 ( 0 )) { emit AccessDenied ( user , policyId , \"No identity registered\" ); return false ; } if ( ! authorizedIdentities [ identityId ]) { emit AccessDenied ( user , policyId , \"Identity not authorized\" ); return false ; } // Check if user has required key purpose bytes32 userKey = keccak256 ( abi . encodePacked ( user )); uint256 [] memory purposes = identityRegistry . getKeyPurposes ( userKey ); bool hasPurpose = false ; for ( uint256 i = 0 ; i < purposes . length ; i ++ ) { if ( purposes [ i ] == policy . requiredPurpose ) { hasPurpose = true ; break ; } } if ( ! hasPurpose ) { emit AccessDenied ( user , policyId , \"Insufficient key purpose\" ); return false ; } // Check key type if specified if ( policy . minKeyType > 0 ) { (, uint256 keyType , ) = identityRegistry . getKey ( userKey ); if ( keyType < policy . minKeyType ) { emit AccessDenied ( user , policyId , \"Insufficient key type\" ); return false ; } } emit AccessGranted ( user , policyId ); return true ; } function getUserIdentityInfo ( address user ) external view returns ( bytes32 identityId , bool authorized , uint256 [] memory keyPurposes , uint256 keyType ) { identityId = userIdentities [ user ]; authorized = authorizedIdentities [ identityId ]; if ( identityId != bytes32 ( 0 )) { bytes32 userKey = keccak256 ( abi . encodePacked ( user )); keyPurposes = identityRegistry . getKeyPurposes ( userKey ); (, keyType , ) = identityRegistry . getKey ( userKey ); } } modifier onlyAdmin () { // Implementation would check for admin role _ ; } }","title":"Identity-Based Access Control"},{"location":"smart-contracts/interfaces/ierc734/#decentralized-identity-provider","text":"// Identity provider service using ERC-734 contract DecentralizedIdentityProvider { IERC734 public keyManager ; struct IdentityProfile { string name ; string email ; string organization ; uint256 createdAt ; uint256 lastUpdated ; bool verified ; mapping ( string => string ) attributes ; } mapping ( address => IdentityProfile ) public profiles ; mapping ( bytes32 => address ) public keyToIdentity ; mapping ( address => bytes32 []) public identityKeys ; event IdentityCreated ( address indexed identity , string name ); event IdentityUpdated ( address indexed identity , string attribute , string value ); event IdentityVerified ( address indexed identity , address indexed verifier ); event KeyLinked ( address indexed identity , bytes32 indexed key , uint256 purpose ); constructor ( address _keyManager ) { keyManager = IERC734 ( _keyManager ); } function createIdentity ( string memory name , string memory email , string memory organization ) external { require ( profiles [ msg.sender ]. createdAt == 0 , \"Identity already exists\" ); IdentityProfile storage profile = profiles [ msg.sender ]; profile . name = name ; profile . email = email ; profile . organization = organization ; profile . createdAt = block.timestamp ; profile . lastUpdated = block.timestamp ; profile . verified = false ; // Link primary key bytes32 primaryKey = keccak256 ( abi . encodePacked ( msg.sender )); keyToIdentity [ primaryKey ] = msg.sender ; identityKeys [ msg.sender ]. push ( primaryKey ); emit IdentityCreated ( msg.sender , name ); emit KeyLinked ( msg.sender , primaryKey , 1 ); // MANAGEMENT_KEY } function updateAttribute ( string memory attribute , string memory value ) external { require ( profiles [ msg.sender ]. createdAt > 0 , \"Identity does not exist\" ); profiles [ msg.sender ]. attributes [ attribute ] = value ; profiles [ msg.sender ]. lastUpdated = block.timestamp ; emit IdentityUpdated ( msg.sender , attribute , value ); } function linkKey ( bytes32 key , uint256 purpose ) external { require ( profiles [ msg.sender ]. createdAt > 0 , \"Identity does not exist\" ); require ( keyToIdentity [ key ] == address ( 0 ), \"Key already linked\" ); keyToIdentity [ key ] = msg.sender ; identityKeys [ msg.sender ]. push ( key ); emit KeyLinked ( msg.sender , key , purpose ); } function verifyIdentity ( address identity ) external onlyVerifier { require ( profiles [ identity ]. createdAt > 0 , \"Identity does not exist\" ); profiles [ identity ]. verified = true ; profiles [ identity ]. lastUpdated = block.timestamp ; emit IdentityVerified ( identity , msg.sender ); } function getIdentityProfile ( address identity ) external view returns ( string memory name , string memory email , string memory organization , uint256 createdAt , uint256 lastUpdated , bool verified , uint256 keyCount ) { IdentityProfile storage profile = profiles [ identity ]; name = profile . name ; email = profile . email ; organization = profile . organization ; createdAt = profile . createdAt ; lastUpdated = profile . lastUpdated ; verified = profile . verified ; keyCount = identityKeys [ identity ]. length ; } function getAttribute ( address identity , string memory attribute ) external view returns ( string memory ) { return profiles [ identity ]. attributes [ attribute ]; } function getIdentityKeys ( address identity ) external view returns ( bytes32 [] memory ) { return identityKeys [ identity ]; } function resolveKeyToIdentity ( bytes32 key ) external view returns ( address ) { return keyToIdentity [ key ]; } modifier onlyVerifier () { // Implementation would check for verifier role _ ; } }","title":"Decentralized Identity Provider"},{"location":"smart-contracts/interfaces/ierc734/#events","text":"","title":"Events"},{"location":"smart-contracts/interfaces/ierc734/#key-management-events","text":"event KeyAdded ( bytes32 indexed key , // Key identifier uint256 indexed purpose , // Key purpose uint256 indexed keyType // Key type ); event KeyRemoved ( bytes32 indexed key , // Key identifier uint256 indexed purpose , // Key purpose uint256 indexed keyType // Key type );","title":"Key Management Events"},{"location":"smart-contracts/interfaces/ierc734/#execution-management-events","text":"event ExecutionRequested ( uint256 indexed executionId , // Execution identifier address indexed to , // Target address uint256 indexed value , // ETH value bytes data // Call data ); event Executed ( uint256 indexed executionId , // Execution identifier address indexed to , // Target address uint256 indexed value , // ETH value bytes data // Call data ); event ExecutionFailed ( uint256 indexed executionId , // Execution identifier address indexed to , // Target address uint256 indexed value , // ETH value bytes data // Call data ); event Approved ( uint256 indexed executionId , // Execution identifier bool approved // Approval status );","title":"Execution Management Events"},{"location":"smart-contracts/interfaces/ierc734/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/ierc734/#key-management-security","text":"Secure key generation and storage Prevention of key reuse across purposes Protection against key compromise Secure key rotation procedures","title":"Key Management Security"},{"location":"smart-contracts/interfaces/ierc734/#access-control","text":"Proper validation of key purposes and types Prevention of unauthorized key additions/removals Protection of management keys Secure execution approval mechanisms","title":"Access Control"},{"location":"smart-contracts/interfaces/ierc734/#multi-signature-security","text":"Threshold signature validation Prevention of replay attacks Secure nonce management Protection against front-running","title":"Multi-Signature Security"},{"location":"smart-contracts/interfaces/ierc734/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/interfaces/ierc734/#efficient-operations","text":"Batch key operations where possible Optimized storage layout for key data Minimal external calls in view functions Efficient event emission patterns","title":"Efficient Operations"},{"location":"smart-contracts/interfaces/ierc734/#storage-optimization","text":"Packed storage structures for key data Efficient mapping usage for key lookups Optimized array operations for key lists Cached calculations for frequently accessed data","title":"Storage Optimization"},{"location":"smart-contracts/interfaces/ierc734/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/interfaces/ierc734/#common-errors","text":"Unauthorized key management operations Invalid key purposes or types Non-existent keys or executions Insufficient approvals for execution Key already exists or doesn't exist","title":"Common Errors"},{"location":"smart-contracts/interfaces/ierc734/#best-practices","text":"Validate caller permissions before operations Check key existence before modifications Verify execution requirements before approval Handle edge cases gracefully Provide clear error messages for debugging","title":"Best Practices"},{"location":"smart-contracts/interfaces/ierc734/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/interfaces/ierc734/#unit-tests","text":"Interface compliance verification Key management function testing Execution approval and execution testing Event emission verification Access control validation","title":"Unit Tests"},{"location":"smart-contracts/interfaces/ierc734/#integration-tests","text":"Multi-signature workflow testing Identity provider integration Access control system integration Cross-contract key validation Security scenario testing","title":"Integration Tests"},{"location":"smart-contracts/interfaces/ierc734/#related-documentation","text":"IERC735 - Claim Holder interface for identity claims IdentityRegistryFacet - Identity registry implementation TrustedIssuersRegistryFacet - Trusted issuer management Identity System Guide - Implementation guide for identity management Multi-Signature Guide - Multi-signature implementation patterns This interface defines the Key Manager standard (ERC-734) for decentralized identity management within the Gemforce platform, enabling secure multi-key management, role-based access control, and multi-signature transaction execution.","title":"Related Documentation"},{"location":"smart-contracts/interfaces/ierc735/","text":"IERC735 Interface \u00b6 Overview \u00b6 The IERC735 interface defines the Claim Holder standard for decentralized identity management within the Gemforce platform. This interface implements the ERC-735 standard for managing identity claims, enabling attestations, verifications, and credential management through cryptographically signed claims from trusted issuers. Key Features \u00b6 Identity Claims Management : Add, modify, and remove identity claims Cryptographic Verification : Support for multiple signature schemes Trusted Issuer System : Claims issued by verified and trusted entities Topic-Based Organization : Claims categorized by topics (KYC, credentials, etc.) URI-Based Metadata : Support for off-chain claim data and documentation Event Tracking : Comprehensive event emission for claim lifecycle operations Interface Definition \u00b6 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.16 ; interface IERC735 { // Events event ClaimRequested ( uint256 indexed claimRequestId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ); event ClaimAdded ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ); event ClaimRemoved ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ); event ClaimChanged ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ); // Core Functions function getClaim ( bytes32 _claimId ) external returns ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ); function getClaimIdsByTopic ( uint256 _topic ) external returns ( bytes32 [] memory claimIds ); function addClaim ( uint256 _topic , uint256 _scheme , address _issuer , bytes memory _signature , bytes memory _data , string memory _uri ) external returns ( uint256 claimRequestId ); function changeClaim ( bytes32 _claimId , uint256 _topic , uint256 _scheme , address _issuer , bytes memory _signature , bytes memory _data , string memory _uri ) external returns ( bool success ); function removeClaim ( bytes32 _claimId ) external returns ( bool success ); } Claim Topic Constants \u00b6 // Standard claim topics as defined in ERC-735 uint256 public constant BIOMETRIC_TOPIC = 1 ; // Biometric verification uint256 public constant RESIDENCE_TOPIC = 2 ; // Proof of residence uint256 public constant REGISTRY_TOPIC = 3 ; // Registry inclusion uint256 public constant PROFILE_TOPIC = 4 ; // Profile information uint256 public constant CONTRACT_TOPIC = 5 ; // Contract interaction uint256 public constant KYC_TOPIC = 10001 ; // Know Your Customer uint256 public constant AML_TOPIC = 10002 ; // Anti-Money Laundering uint256 public constant ACCREDITED_INVESTOR_TOPIC = 10003 ; // Accredited investor status uint256 public constant PROFESSIONAL_TOPIC = 10004 ; // Professional credentials Signature Scheme Constants \u00b6 // Standard signature schemes uint256 public constant ECDSA_SCHEME = 1 ; // ECDSA signature uint256 public constant RSA_SCHEME = 2 ; // RSA signature uint256 public constant CONTRACT_SCHEME = 3 ; // Contract-based verification uint256 public constant MULTISIG_SCHEME = 4 ; // Multi-signature scheme Core Functions \u00b6 Claim Management \u00b6 addClaim() \u00b6 function addClaim ( uint256 _topic , uint256 _scheme , address _issuer , bytes memory _signature , bytes memory _data , string memory _uri ) external returns ( uint256 claimRequestId ) Purpose : Add a new identity claim to the claim holder. Parameters : - _topic (uint256): The claim topic identifier (KYC, AML, etc.) - _scheme (uint256): The signature scheme used for verification - _issuer (address): The address of the claim issuer - _signature (bytes): The cryptographic signature of the claim - _data (bytes): The claim data payload - _uri (string): URI pointing to additional claim metadata Returns : - claimRequestId (uint256): Unique identifier for the claim request Requirements : - Issuer must be authorized for the claim topic - Signature must be valid for the claim data - Claim topic must be supported - Caller must have appropriate permissions Events Emitted : - ClaimRequested initially when claim is submitted - ClaimAdded when claim is approved and added Example Usage : // Add a KYC claim from a trusted issuer uint256 topic = KYC_TOPIC ; uint256 scheme = ECDSA_SCHEME ; address issuer = 0x742d35Cc6634C0532925a3b8D4C9db96590c6C8C ; bytes memory signature = abi . encodePacked ( r , s , v ); // ECDSA signature components bytes memory data = abi . encode ( \"John Doe\" , \"US\" , block.timestamp ); string memory uri = \"https://kyc-provider.com/claims/12345\" ; uint256 requestId = IERC735 ( identityContract ). addClaim ( topic , scheme , issuer , signature , data , uri ); console . log ( \"KYC claim request ID:\" , requestId ); changeClaim() \u00b6 function changeClaim ( bytes32 _claimId , uint256 _topic , uint256 _scheme , address _issuer , bytes memory _signature , bytes memory _data , string memory _uri ) external returns ( bool success ) Purpose : Modify an existing identity claim. Parameters : - _claimId (bytes32): The unique identifier of the claim to modify - _topic (uint256): The updated claim topic - _scheme (uint256): The updated signature scheme - _issuer (address): The updated issuer address - _signature (bytes): The updated cryptographic signature - _data (bytes): The updated claim data - _uri (string): The updated metadata URI Returns : Boolean indicating success of the operation Requirements : - Claim must exist - Caller must have permission to modify the claim - New signature must be valid - Issuer must be authorized for the topic Events Emitted : - ClaimChanged with old and new claim details Example Usage : // Update an existing KYC claim with new information bytes32 claimId = 0x1234567890abcdef ...; uint256 topic = KYC_TOPIC ; uint256 scheme = ECDSA_SCHEME ; address issuer = 0x742d35Cc6634C0532925a3b8D4C9db96590c6C8C ; bytes memory newSignature = abi . encodePacked ( r , s , v ); bytes memory newData = abi . encode ( \"John Doe\" , \"US\" , block.timestamp , \"updated\" ); string memory newUri = \"https://kyc-provider.com/claims/12345-updated\" ; bool success = IERC735 ( identityContract ). changeClaim ( claimId , topic , scheme , issuer , newSignature , newData , newUri ); console . log ( \"Claim update success:\" , success ); removeClaim() \u00b6 function removeClaim ( bytes32 _claimId ) external returns ( bool success ) Purpose : Remove an identity claim from the claim holder. Parameters : - _claimId (bytes32): The unique identifier of the claim to remove Returns : Boolean indicating success of the operation Requirements : - Claim must exist - Caller must have permission to remove the claim - Some claims may be required and cannot be removed Events Emitted : - ClaimRemoved with claim details Example Usage : // Remove an expired or invalid claim bytes32 claimId = 0x1234567890abcdef ...; bool success = IERC735 ( identityContract ). removeClaim ( claimId ); console . log ( \"Claim removal success:\" , success ); Query Functions \u00b6 Claim Information \u00b6 getClaim() \u00b6 function getClaim ( bytes32 _claimId ) external returns ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ) Purpose : Retrieve detailed information about a specific claim. Parameters : - _claimId (bytes32): The unique identifier of the claim to query Returns : - topic (uint256): The claim topic identifier - scheme (uint256): The signature scheme used - issuer (address): The address of the claim issuer - signature (bytes): The cryptographic signature - data (bytes): The claim data payload - uri (string): The metadata URI Example Usage : // Get detailed claim information bytes32 claimId = 0x1234567890abcdef ...; ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ) = IERC735 ( identityContract ). getClaim ( claimId ); console . log ( \"Claim topic:\" , topic ); console . log ( \"Claim issuer:\" , issuer ); console . log ( \"Claim URI:\" , uri ); getClaimIdsByTopic() \u00b6 function getClaimIdsByTopic ( uint256 _topic ) external returns ( bytes32 [] memory claimIds ) Purpose : Get all claim IDs associated with a specific topic. Parameters : - _topic (uint256): The topic to query claims for Returns : Array of claim IDs for the specified topic Example Usage : // Get all KYC claims for an identity uint256 topic = KYC_TOPIC ; bytes32 [] memory kycClaims = IERC735 ( identityContract ). getClaimIdsByTopic ( topic ); console . log ( \"KYC claims count:\" , kycClaims . length ); for ( uint256 i = 0 ; i < kycClaims . length ; i ++ ) { console . log ( \"KYC claim ID:\" , kycClaims [ i ]); } Integration Examples \u00b6 KYC/AML Verification System \u00b6 // KYC/AML verification system using ERC-735 claims contract KYCAMLVerification { IERC735 public claimHolder ; struct VerificationRequirement { uint256 [] requiredTopics ; address [] trustedIssuers ; uint256 minValidityPeriod ; bool active ; } mapping ( bytes32 => VerificationRequirement ) public verificationLevels ; mapping ( address => mapping ( uint256 => bool )) public issuerTopicAuthorization ; mapping ( bytes32 => uint256 ) public claimExpirationTime ; event VerificationLevelCreated ( bytes32 indexed levelId , uint256 [] requiredTopics ); event IssuerAuthorized ( address indexed issuer , uint256 indexed topic , bool authorized ); event IdentityVerified ( address indexed identity , bytes32 indexed levelId , uint256 timestamp ); event VerificationFailed ( address indexed identity , bytes32 indexed levelId , string reason ); constructor ( address _claimHolder ) { claimHolder = IERC735 ( _claimHolder ); } function createVerificationLevel ( bytes32 levelId , uint256 [] memory requiredTopics , address [] memory trustedIssuers , uint256 minValidityPeriod ) external onlyAdmin { verificationLevels [ levelId ] = VerificationRequirement ({ requiredTopics : requiredTopics , trustedIssuers : trustedIssuers , minValidityPeriod : minValidityPeriod , active : true }); emit VerificationLevelCreated ( levelId , requiredTopics ); } function authorizeIssuerForTopic ( address issuer , uint256 topic , bool authorized ) external onlyAdmin { issuerTopicAuthorization [ issuer ][ topic ] = authorized ; emit IssuerAuthorized ( issuer , topic , authorized ); } function verifyIdentity ( address identity , bytes32 levelId ) external returns ( bool verified ) { VerificationRequirement memory requirement = verificationLevels [ levelId ]; require ( requirement . active , \"Verification level not active\" ); // Check each required topic for ( uint256 i = 0 ; i < requirement . requiredTopics . length ; i ++ ) { uint256 topic = requirement . requiredTopics [ i ]; bytes32 [] memory claimIds = claimHolder . getClaimIdsByTopic ( topic ); if ( claimIds . length == 0 ) { emit VerificationFailed ( identity , levelId , \"Missing required claim topic\" ); return false ; } bool validClaimFound = false ; for ( uint256 j = 0 ; j < claimIds . length ; j ++ ) { if ( _isClaimValid ( claimIds [ j ], requirement )) { validClaimFound = true ; break ; } } if ( ! validClaimFound ) { emit VerificationFailed ( identity , levelId , \"No valid claim found for topic\" ); return false ; } } emit IdentityVerified ( identity , levelId , block.timestamp ); return true ; } function _isClaimValid ( bytes32 claimId , VerificationRequirement memory requirement ) internal returns ( bool ) { ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ) = claimHolder . getClaim ( claimId ); // Check if issuer is authorized for this topic if ( ! issuerTopicAuthorization [ issuer ][ topic ]) { return false ; } // Check if claim is not expired uint256 expirationTime = claimExpirationTime [ claimId ]; if ( expirationTime > 0 && block.timestamp > expirationTime ) { return false ; } // Verify signature (simplified - would implement full signature verification) if ( signature . length == 0 ) { return false ; } return true ; } function getVerificationStatus ( address identity , bytes32 levelId ) external view returns ( bool canVerify , uint256 [] memory missingTopics , uint256 [] memory expiredClaims ) { VerificationRequirement memory requirement = verificationLevels [ levelId ]; uint256 [] memory missing = new uint256 []( requirement . requiredTopics . length ); uint256 [] memory expired = new uint256 []( requirement . requiredTopics . length ); uint256 missingCount = 0 ; uint256 expiredCount = 0 ; canVerify = true ; for ( uint256 i = 0 ; i < requirement . requiredTopics . length ; i ++ ) { uint256 topic = requirement . requiredTopics [ i ]; bytes32 [] memory claimIds = claimHolder . getClaimIdsByTopic ( topic ); if ( claimIds . length == 0 ) { missing [ missingCount ++ ] = topic ; canVerify = false ; } else { bool hasValidClaim = false ; for ( uint256 j = 0 ; j < claimIds . length ; j ++ ) { uint256 expirationTime = claimExpirationTime [ claimIds [ j ]]; if ( expirationTime == 0 || block.timestamp <= expirationTime ) { hasValidClaim = true ; break ; } } if ( ! hasValidClaim ) { expired [ expiredCount ++ ] = topic ; canVerify = false ; } } } // Resize arrays to actual counts missingTopics = new uint256 []( missingCount ); expiredClaims = new uint256 []( expiredCount ); for ( uint256 i = 0 ; i < missingCount ; i ++ ) { missingTopics [ i ] = missing [ i ]; } for ( uint256 i = 0 ; i < expiredCount ; i ++ ) { expiredClaims [ i ] = expired [ i ]; } } modifier onlyAdmin () { // Implementation would check for admin role _ ; } } Professional Credentials System \u00b6 // Professional credentials and certification system contract ProfessionalCredentials { IERC735 public claimHolder ; struct Credential { string name ; string description ; uint256 topic ; address issuingAuthority ; uint256 validityPeriod ; bool requiresRenewal ; uint256 renewalPeriod ; } struct IssuedCredential { bytes32 credentialId ; address holder ; uint256 issuedAt ; uint256 expiresAt ; bool active ; bytes32 claimId ; } mapping ( bytes32 => Credential ) public credentials ; mapping ( bytes32 => IssuedCredential ) public issuedCredentials ; mapping ( address => bytes32 []) public holderCredentials ; mapping ( address => bool ) public authorizedIssuers ; event CredentialDefined ( bytes32 indexed credentialId , string name , uint256 topic ); event CredentialIssued ( bytes32 indexed credentialId , address indexed holder , bytes32 claimId ); event CredentialRevoked ( bytes32 indexed credentialId , address indexed holder , string reason ); event CredentialRenewed ( bytes32 indexed credentialId , address indexed holder , uint256 newExpirationTime ); constructor ( address _claimHolder ) { claimHolder = IERC735 ( _claimHolder ); } function defineCredential ( bytes32 credentialId , string memory name , string memory description , uint256 topic , address issuingAuthority , uint256 validityPeriod , bool requiresRenewal , uint256 renewalPeriod ) external onlyAdmin { credentials [ credentialId ] = Credential ({ name : name , description : description , topic : topic , issuingAuthority : issuingAuthority , validityPeriod : validityPeriod , requiresRenewal : requiresRenewal , renewalPeriod : renewalPeriod }); authorizedIssuers [ issuingAuthority ] = true ; emit CredentialDefined ( credentialId , name , topic ); } function issueCredential ( bytes32 credentialId , address holder , bytes memory credentialData , bytes memory signature , string memory uri ) external onlyAuthorizedIssuer ( credentialId ) { Credential memory credential = credentials [ credentialId ]; require ( bytes ( credential . name ). length > 0 , \"Credential not defined\" ); uint256 expirationTime = credential . validityPeriod > 0 ? block.timestamp + credential . validityPeriod : 0 ; // Add claim to the identity uint256 claimRequestId = claimHolder . addClaim ( credential . topic , 1 , // ECDSA scheme msg.sender , signature , credentialData , uri ); bytes32 issuedCredentialId = keccak256 ( abi . encodePacked ( credentialId , holder , block.timestamp )); bytes32 claimId = bytes32 ( claimRequestId ); // Simplified mapping issuedCredentials [ issuedCredentialId ] = IssuedCredential ({ credentialId : credentialId , holder : holder , issuedAt : block.timestamp , expiresAt : expirationTime , active : true , claimId : claimId }); holderCredentials [ holder ]. push ( issuedCredentialId ); emit CredentialIssued ( credentialId , holder , claimId ); } function revokeCredential ( bytes32 issuedCredentialId , string memory reason ) external { IssuedCredential storage issued = issuedCredentials [ issuedCredentialId ]; require ( issued . active , \"Credential not active\" ); Credential memory credential = credentials [ issued . credentialId ]; require ( msg.sender == credential . issuingAuthority || msg.sender == issued . holder , \"Not authorized to revoke\" ); issued . active = false ; // Remove the claim from the identity claimHolder . removeClaim ( issued . claimId ); emit CredentialRevoked ( issued . credentialId , issued . holder , reason ); } function renewCredential ( bytes32 issuedCredentialId , bytes memory newCredentialData , bytes memory newSignature , string memory newUri ) external { IssuedCredential storage issued = issuedCredentials [ issuedCredentialId ]; require ( issued . active , \"Credential not active\" ); Credential memory credential = credentials [ issued . credentialId ]; require ( credential . requiresRenewal , \"Credential does not support renewal\" ); require ( msg.sender == credential . issuingAuthority , \"Not authorized to renew\" ); uint256 newExpirationTime = credential . validityPeriod > 0 ? block.timestamp + credential . validityPeriod : 0 ; // Update the claim claimHolder . changeClaim ( issued . claimId , credential . topic , 1 , // ECDSA scheme msg.sender , newSignature , newCredentialData , newUri ); issued . expiresAt = newExpirationTime ; emit CredentialRenewed ( issued . credentialId , issued . holder , newExpirationTime ); } function getHolderCredentials ( address holder ) external view returns ( bytes32 [] memory credentialIds , bool [] memory activeStatus , uint256 [] memory expirationTimes ) { bytes32 [] memory holderCreds = holderCredentials [ holder ]; credentialIds = new bytes32 []( holderCreds . length ); activeStatus = new bool []( holderCreds . length ); expirationTimes = new uint256 []( holderCreds . length ); for ( uint256 i = 0 ; i < holderCreds . length ; i ++ ) { IssuedCredential memory issued = issuedCredentials [ holderCreds [ i ]]; credentialIds [ i ] = issued . credentialId ; activeStatus [ i ] = issued . active && ( issued . expiresAt == 0 || block.timestamp <= issued . expiresAt ); expirationTimes [ i ] = issued . expiresAt ; } } function verifyCredential ( address holder , bytes32 credentialId ) external view returns ( bool valid , uint256 expirationTime ) { bytes32 [] memory holderCreds = holderCredentials [ holder ]; for ( uint256 i = 0 ; i < holderCreds . length ; i ++ ) { IssuedCredential memory issued = issuedCredentials [ holderCreds [ i ]]; if ( issued . credentialId == credentialId && issued . active ) { valid = issued . expiresAt == 0 || block.timestamp <= issued . expiresAt ; expirationTime = issued . expiresAt ; return ( valid , expirationTime ); } } return ( false , 0 ); } modifier onlyAdmin () { // Implementation would check for admin role _ ; } modifier onlyAuthorizedIssuer ( bytes32 credentialId ) { Credential memory credential = credentials [ credentialId ]; require ( msg.sender == credential . issuingAuthority , \"Not authorized issuer\" ); _ ; } } Decentralized Identity Verification \u00b6 // Comprehensive identity verification system contract DecentralizedIdentityVerification { IERC735 public claimHolder ; struct IdentityProfile { address owner ; uint256 createdAt ; uint256 lastUpdated ; uint256 verificationLevel ; bool active ; mapping ( uint256 => bytes32 []) topicClaims ; } struct VerificationChallenge { address challenger ; bytes32 claimId ; string reason ; uint256 createdAt ; uint256 deadline ; bool resolved ; bool upheld ; } mapping ( address => IdentityProfile ) public identityProfiles ; mapping ( bytes32 => VerificationChallenge ) public challenges ; mapping ( uint256 => uint256 ) public topicWeights ; mapping ( address => bool ) public verificationOracles ; uint256 public challengePeriod = 7 days ; uint256 public constant MAX_VERIFICATION_LEVEL = 100 ; event IdentityProfileCreated ( address indexed identity , uint256 timestamp ); event ClaimVerified ( address indexed identity , bytes32 indexed claimId , address indexed verifier ); event ClaimChallenged ( bytes32 indexed challengeId , bytes32 indexed claimId , address challenger ); event ChallengeResolved ( bytes32 indexed challengeId , bool upheld , address resolver ); event VerificationLevelUpdated ( address indexed identity , uint256 oldLevel , uint256 newLevel ); constructor ( address _claimHolder ) { claimHolder = IERC735 ( _claimHolder ); // Set default topic weights topicWeights [ KYC_TOPIC ] = 30 ; topicWeights [ AML_TOPIC ] = 25 ; topicWeights [ ACCREDITED_INVESTOR_TOPIC ] = 20 ; topicWeights [ PROFESSIONAL_TOPIC ] = 15 ; topicWeights [ BIOMETRIC_TOPIC ] = 10 ; } function createIdentityProfile () external { require ( identityProfiles [ msg.sender ]. owner == address ( 0 ), \"Profile already exists\" ); IdentityProfile storage profile = identityProfiles [ msg.sender ]; profile . owner = msg.sender ; profile . createdAt = block.timestamp ; profile . lastUpdated = block.timestamp ; profile . verificationLevel = 0 ; profile . active = true ; emit IdentityProfileCreated ( msg.sender , block.timestamp ); } function updateVerificationLevel ( address identity ) external { IdentityProfile storage profile = identityProfiles [ identity ]; require ( profile . active , \"Identity profile not active\" ); uint256 totalWeight = 0 ; uint256 achievedWeight = 0 ; // Calculate verification level based on claims for ( uint256 topic = 1 ; topic <= 10004 ; topic ++ ) { uint256 weight = topicWeights [ topic ]; if ( weight > 0 ) { totalWeight += weight ; bytes32 [] memory claimIds = claimHolder . getClaimIdsByTopic ( topic ); if ( claimIds . length > 0 ) { // Check if any claim for this topic is valid for ( uint256 i = 0 ; i < claimIds . length ; i ++ ) { if ( _isClaimValid ( claimIds [ i ])) { achievedWeight += weight ; break ; } } } } } uint256 oldLevel = profile . verificationLevel ; uint256 newLevel = totalWeight > 0 ? ( achievedWeight * MAX_VERIFICATION_LEVEL ) / totalWeight : 0 ; profile . verificationLevel = newLevel ; profile . lastUpdated = block.timestamp ; emit VerificationLevelUpdated ( identity , oldLevel , newLevel ); } function challengeClaim ( bytes32 claimId , string memory reason ) external returns ( bytes32 challengeId ) { challengeId = keccak256 ( abi . encodePacked ( claimId , msg.sender , block.timestamp )); challenges [ challengeId ] = VerificationChallenge ({ challenger : msg.sender , claimId : claimId , reason : reason , createdAt : block.timestamp , deadline : block.timestamp + challengePeriod , resolved : false , upheld : false }); emit ClaimChallenged ( challengeId , claimId , msg.sender ); } function resolveChallenge ( bytes32 challengeId , bool upholdChallenge ) external onlyVerificationOracle { VerificationChallenge storage challenge = challenges [ challengeId ]; require ( ! challenge . resolved , \"Challenge already resolved\" ); require ( block.timestamp <= challenge . deadline , \"Challenge deadline passed\" ); challenge . resolved = true ; challenge . upheld = upholdChallenge ; if ( upholdChallenge ) { // Remove the challenged claim claimHolder . removeClaim ( challenge . claimId ); } emit ChallengeResolved ( challengeId , upholdChallenge , msg.sender ); } function _isClaimValid ( bytes32 claimId ) internal returns ( bool ) { ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ) = claimHolder . getClaim ( claimId ); // Basic validation - in practice would include signature verification return signature . length > 0 && issuer != address ( 0 ); } function getIdentityVerificationStatus ( address identity ) external view returns ( uint256 verificationLevel , uint256 claimCount , uint256 lastUpdated , bool active ) { IdentityProfile storage profile = identityProfiles [ identity ]; verificationLevel = profile . verificationLevel ; lastUpdated = profile . lastUpdated ; active = profile . active ; // Count total claims across all topics claimCount = 0 ; for ( uint256 topic = 1 ; topic <= 10004 ; topic ++ ) { bytes32 [] memory claimIds = claimHolder . getClaimIdsByTopic ( topic ); claimCount += claimIds . length ; } } function setTopicWeight ( uint256 topic , uint256 weight ) external onlyAdmin { topicWeights [ topic ] = weight ; } function setVerificationOracle ( address oracle , bool authorized ) external onlyAdmin { verification Oracles [ oracle ] = authorized ; } modifier onlyAdmin () { // Implementation would check for admin role _ ; } modifier onlyVerificationOracle () { require ( verificationOracles [ msg.sender ], \"Not authorized verification oracle\" ); _ ; } } Events \u00b6 Claim Lifecycle Events \u00b6 event ClaimRequested ( uint256 indexed claimRequestId , // Unique request identifier uint256 indexed topic , // Claim topic uint256 scheme , // Signature scheme address indexed issuer , // Claim issuer bytes signature , // Cryptographic signature bytes data , // Claim data string uri // Metadata URI ); event ClaimAdded ( bytes32 indexed claimId , // Unique claim identifier uint256 indexed topic , // Claim topic uint256 scheme , // Signature scheme address indexed issuer , // Claim issuer bytes signature , // Cryptographic signature bytes data , // Claim data string uri // Metadata URI ); event ClaimRemoved ( bytes32 indexed claimId , // Unique claim identifier uint256 indexed topic , // Claim topic uint256 scheme , // Signature scheme address indexed issuer , // Claim issuer bytes signature , // Cryptographic signature bytes data , // Claim data string uri // Metadata URI ); event ClaimChanged ( bytes32 indexed claimId , // Unique claim identifier uint256 indexed topic , // Claim topic uint256 scheme , // Signature scheme address indexed issuer , // Claim issuer bytes signature , // Cryptographic signature bytes data , // Claim data string uri // Metadata URI ); Identity Registry Integration \u00b6 The IERC735 interface works closely with the Identity Registry system: /* How IdentityRegistry works: 1. User creates an Identity contract 2. User calls IdentityRegistry.addIdentity(address _identity, IIdentity identityData) 3. IdentityRegistry emits IdentityAdded(address indexed _address, IIdentity identity) 4. IdentityRegistry emits ClaimAdded(address indexed identity, uint256 indexed claimTopic, bytes claim) 5. IdentityRegistry emits WalletLinked(address indexed walletAddress, bytes32 indexed onchainID) */ Security Considerations \u00b6 Claim Verification Security \u00b6 Cryptographic signature validation for all claims Issuer authorization verification before accepting claims Protection against claim replay attacks Secure claim data storage and retrieval Access Control \u00b6 Proper validation of claim modification permissions Protection of sensitive claim data Secure issuer authorization mechanisms Prevention of unauthorized claim removal Data Integrity \u00b6 Immutable claim history and audit trails Protection against claim tampering Secure off-chain data references via URIs Validation of claim data consistency Gas Optimization \u00b6 Efficient Operations \u00b6 Batch claim operations where possible Optimized storage layout for claim data Minimal external calls in view functions Efficient event emission patterns Storage Optimization \u00b6 Packed storage structures for claim metadata Efficient mapping usage for claim lookups Optimized array operations for topic queries Cached calculations for frequently accessed data Error Handling \u00b6 Common Errors \u00b6 Unauthorized claim operations Invalid claim signatures or data Non-existent claims or topics Expired or revoked claims Issuer authorization failures Best Practices \u00b6 Validate claim signatures before processing Check issuer authorization for claim topics Verify claim existence before modifications Handle signature verification failures gracefully Provide clear error messages for debugging Testing Considerations \u00b6 Unit Tests \u00b6 Interface compliance verification Claim management function testing Signature verification testing Event emission verification Access control validation Integration Tests \u00b6 Identity registry integration KYC/AML workflow testing Professional credentials system integration Cross-contract claim validation Security scenario testing Related Documentation \u00b6 IERC734 - Key Manager interface for identity key management IdentityRegistryFacet - Identity registry implementation TrustedIssuersRegistryFacet - Trusted issuer management Identity System Guide - Implementation guide for identity management KYC/AML Integration Guide - KYC/AML implementation patterns This interface defines the Claim Holder standard (ERC-735) for decentralized identity management within the Gemforce platform, enabling secure management of identity claims, attestations, and verifications through cryptographically signed claims from trusted issuers.","title":"IERC735"},{"location":"smart-contracts/interfaces/ierc735/#ierc735-interface","text":"","title":"IERC735 Interface"},{"location":"smart-contracts/interfaces/ierc735/#overview","text":"The IERC735 interface defines the Claim Holder standard for decentralized identity management within the Gemforce platform. This interface implements the ERC-735 standard for managing identity claims, enabling attestations, verifications, and credential management through cryptographically signed claims from trusted issuers.","title":"Overview"},{"location":"smart-contracts/interfaces/ierc735/#key-features","text":"Identity Claims Management : Add, modify, and remove identity claims Cryptographic Verification : Support for multiple signature schemes Trusted Issuer System : Claims issued by verified and trusted entities Topic-Based Organization : Claims categorized by topics (KYC, credentials, etc.) URI-Based Metadata : Support for off-chain claim data and documentation Event Tracking : Comprehensive event emission for claim lifecycle operations","title":"Key Features"},{"location":"smart-contracts/interfaces/ierc735/#interface-definition","text":"// SPDX-License-Identifier: MIT pragma solidity ^ 0.8.16 ; interface IERC735 { // Events event ClaimRequested ( uint256 indexed claimRequestId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ); event ClaimAdded ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ); event ClaimRemoved ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ); event ClaimChanged ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ); // Core Functions function getClaim ( bytes32 _claimId ) external returns ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ); function getClaimIdsByTopic ( uint256 _topic ) external returns ( bytes32 [] memory claimIds ); function addClaim ( uint256 _topic , uint256 _scheme , address _issuer , bytes memory _signature , bytes memory _data , string memory _uri ) external returns ( uint256 claimRequestId ); function changeClaim ( bytes32 _claimId , uint256 _topic , uint256 _scheme , address _issuer , bytes memory _signature , bytes memory _data , string memory _uri ) external returns ( bool success ); function removeClaim ( bytes32 _claimId ) external returns ( bool success ); }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/ierc735/#claim-topic-constants","text":"// Standard claim topics as defined in ERC-735 uint256 public constant BIOMETRIC_TOPIC = 1 ; // Biometric verification uint256 public constant RESIDENCE_TOPIC = 2 ; // Proof of residence uint256 public constant REGISTRY_TOPIC = 3 ; // Registry inclusion uint256 public constant PROFILE_TOPIC = 4 ; // Profile information uint256 public constant CONTRACT_TOPIC = 5 ; // Contract interaction uint256 public constant KYC_TOPIC = 10001 ; // Know Your Customer uint256 public constant AML_TOPIC = 10002 ; // Anti-Money Laundering uint256 public constant ACCREDITED_INVESTOR_TOPIC = 10003 ; // Accredited investor status uint256 public constant PROFESSIONAL_TOPIC = 10004 ; // Professional credentials","title":"Claim Topic Constants"},{"location":"smart-contracts/interfaces/ierc735/#signature-scheme-constants","text":"// Standard signature schemes uint256 public constant ECDSA_SCHEME = 1 ; // ECDSA signature uint256 public constant RSA_SCHEME = 2 ; // RSA signature uint256 public constant CONTRACT_SCHEME = 3 ; // Contract-based verification uint256 public constant MULTISIG_SCHEME = 4 ; // Multi-signature scheme","title":"Signature Scheme Constants"},{"location":"smart-contracts/interfaces/ierc735/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/ierc735/#claim-management","text":"","title":"Claim Management"},{"location":"smart-contracts/interfaces/ierc735/#addclaim","text":"function addClaim ( uint256 _topic , uint256 _scheme , address _issuer , bytes memory _signature , bytes memory _data , string memory _uri ) external returns ( uint256 claimRequestId ) Purpose : Add a new identity claim to the claim holder. Parameters : - _topic (uint256): The claim topic identifier (KYC, AML, etc.) - _scheme (uint256): The signature scheme used for verification - _issuer (address): The address of the claim issuer - _signature (bytes): The cryptographic signature of the claim - _data (bytes): The claim data payload - _uri (string): URI pointing to additional claim metadata Returns : - claimRequestId (uint256): Unique identifier for the claim request Requirements : - Issuer must be authorized for the claim topic - Signature must be valid for the claim data - Claim topic must be supported - Caller must have appropriate permissions Events Emitted : - ClaimRequested initially when claim is submitted - ClaimAdded when claim is approved and added Example Usage : // Add a KYC claim from a trusted issuer uint256 topic = KYC_TOPIC ; uint256 scheme = ECDSA_SCHEME ; address issuer = 0x742d35Cc6634C0532925a3b8D4C9db96590c6C8C ; bytes memory signature = abi . encodePacked ( r , s , v ); // ECDSA signature components bytes memory data = abi . encode ( \"John Doe\" , \"US\" , block.timestamp ); string memory uri = \"https://kyc-provider.com/claims/12345\" ; uint256 requestId = IERC735 ( identityContract ). addClaim ( topic , scheme , issuer , signature , data , uri ); console . log ( \"KYC claim request ID:\" , requestId );","title":"addClaim()"},{"location":"smart-contracts/interfaces/ierc735/#changeclaim","text":"function changeClaim ( bytes32 _claimId , uint256 _topic , uint256 _scheme , address _issuer , bytes memory _signature , bytes memory _data , string memory _uri ) external returns ( bool success ) Purpose : Modify an existing identity claim. Parameters : - _claimId (bytes32): The unique identifier of the claim to modify - _topic (uint256): The updated claim topic - _scheme (uint256): The updated signature scheme - _issuer (address): The updated issuer address - _signature (bytes): The updated cryptographic signature - _data (bytes): The updated claim data - _uri (string): The updated metadata URI Returns : Boolean indicating success of the operation Requirements : - Claim must exist - Caller must have permission to modify the claim - New signature must be valid - Issuer must be authorized for the topic Events Emitted : - ClaimChanged with old and new claim details Example Usage : // Update an existing KYC claim with new information bytes32 claimId = 0x1234567890abcdef ...; uint256 topic = KYC_TOPIC ; uint256 scheme = ECDSA_SCHEME ; address issuer = 0x742d35Cc6634C0532925a3b8D4C9db96590c6C8C ; bytes memory newSignature = abi . encodePacked ( r , s , v ); bytes memory newData = abi . encode ( \"John Doe\" , \"US\" , block.timestamp , \"updated\" ); string memory newUri = \"https://kyc-provider.com/claims/12345-updated\" ; bool success = IERC735 ( identityContract ). changeClaim ( claimId , topic , scheme , issuer , newSignature , newData , newUri ); console . log ( \"Claim update success:\" , success );","title":"changeClaim()"},{"location":"smart-contracts/interfaces/ierc735/#removeclaim","text":"function removeClaim ( bytes32 _claimId ) external returns ( bool success ) Purpose : Remove an identity claim from the claim holder. Parameters : - _claimId (bytes32): The unique identifier of the claim to remove Returns : Boolean indicating success of the operation Requirements : - Claim must exist - Caller must have permission to remove the claim - Some claims may be required and cannot be removed Events Emitted : - ClaimRemoved with claim details Example Usage : // Remove an expired or invalid claim bytes32 claimId = 0x1234567890abcdef ...; bool success = IERC735 ( identityContract ). removeClaim ( claimId ); console . log ( \"Claim removal success:\" , success );","title":"removeClaim()"},{"location":"smart-contracts/interfaces/ierc735/#query-functions","text":"","title":"Query Functions"},{"location":"smart-contracts/interfaces/ierc735/#claim-information","text":"","title":"Claim Information"},{"location":"smart-contracts/interfaces/ierc735/#getclaim","text":"function getClaim ( bytes32 _claimId ) external returns ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ) Purpose : Retrieve detailed information about a specific claim. Parameters : - _claimId (bytes32): The unique identifier of the claim to query Returns : - topic (uint256): The claim topic identifier - scheme (uint256): The signature scheme used - issuer (address): The address of the claim issuer - signature (bytes): The cryptographic signature - data (bytes): The claim data payload - uri (string): The metadata URI Example Usage : // Get detailed claim information bytes32 claimId = 0x1234567890abcdef ...; ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ) = IERC735 ( identityContract ). getClaim ( claimId ); console . log ( \"Claim topic:\" , topic ); console . log ( \"Claim issuer:\" , issuer ); console . log ( \"Claim URI:\" , uri );","title":"getClaim()"},{"location":"smart-contracts/interfaces/ierc735/#getclaimidsbytopic","text":"function getClaimIdsByTopic ( uint256 _topic ) external returns ( bytes32 [] memory claimIds ) Purpose : Get all claim IDs associated with a specific topic. Parameters : - _topic (uint256): The topic to query claims for Returns : Array of claim IDs for the specified topic Example Usage : // Get all KYC claims for an identity uint256 topic = KYC_TOPIC ; bytes32 [] memory kycClaims = IERC735 ( identityContract ). getClaimIdsByTopic ( topic ); console . log ( \"KYC claims count:\" , kycClaims . length ); for ( uint256 i = 0 ; i < kycClaims . length ; i ++ ) { console . log ( \"KYC claim ID:\" , kycClaims [ i ]); }","title":"getClaimIdsByTopic()"},{"location":"smart-contracts/interfaces/ierc735/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/ierc735/#kycaml-verification-system","text":"// KYC/AML verification system using ERC-735 claims contract KYCAMLVerification { IERC735 public claimHolder ; struct VerificationRequirement { uint256 [] requiredTopics ; address [] trustedIssuers ; uint256 minValidityPeriod ; bool active ; } mapping ( bytes32 => VerificationRequirement ) public verificationLevels ; mapping ( address => mapping ( uint256 => bool )) public issuerTopicAuthorization ; mapping ( bytes32 => uint256 ) public claimExpirationTime ; event VerificationLevelCreated ( bytes32 indexed levelId , uint256 [] requiredTopics ); event IssuerAuthorized ( address indexed issuer , uint256 indexed topic , bool authorized ); event IdentityVerified ( address indexed identity , bytes32 indexed levelId , uint256 timestamp ); event VerificationFailed ( address indexed identity , bytes32 indexed levelId , string reason ); constructor ( address _claimHolder ) { claimHolder = IERC735 ( _claimHolder ); } function createVerificationLevel ( bytes32 levelId , uint256 [] memory requiredTopics , address [] memory trustedIssuers , uint256 minValidityPeriod ) external onlyAdmin { verificationLevels [ levelId ] = VerificationRequirement ({ requiredTopics : requiredTopics , trustedIssuers : trustedIssuers , minValidityPeriod : minValidityPeriod , active : true }); emit VerificationLevelCreated ( levelId , requiredTopics ); } function authorizeIssuerForTopic ( address issuer , uint256 topic , bool authorized ) external onlyAdmin { issuerTopicAuthorization [ issuer ][ topic ] = authorized ; emit IssuerAuthorized ( issuer , topic , authorized ); } function verifyIdentity ( address identity , bytes32 levelId ) external returns ( bool verified ) { VerificationRequirement memory requirement = verificationLevels [ levelId ]; require ( requirement . active , \"Verification level not active\" ); // Check each required topic for ( uint256 i = 0 ; i < requirement . requiredTopics . length ; i ++ ) { uint256 topic = requirement . requiredTopics [ i ]; bytes32 [] memory claimIds = claimHolder . getClaimIdsByTopic ( topic ); if ( claimIds . length == 0 ) { emit VerificationFailed ( identity , levelId , \"Missing required claim topic\" ); return false ; } bool validClaimFound = false ; for ( uint256 j = 0 ; j < claimIds . length ; j ++ ) { if ( _isClaimValid ( claimIds [ j ], requirement )) { validClaimFound = true ; break ; } } if ( ! validClaimFound ) { emit VerificationFailed ( identity , levelId , \"No valid claim found for topic\" ); return false ; } } emit IdentityVerified ( identity , levelId , block.timestamp ); return true ; } function _isClaimValid ( bytes32 claimId , VerificationRequirement memory requirement ) internal returns ( bool ) { ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ) = claimHolder . getClaim ( claimId ); // Check if issuer is authorized for this topic if ( ! issuerTopicAuthorization [ issuer ][ topic ]) { return false ; } // Check if claim is not expired uint256 expirationTime = claimExpirationTime [ claimId ]; if ( expirationTime > 0 && block.timestamp > expirationTime ) { return false ; } // Verify signature (simplified - would implement full signature verification) if ( signature . length == 0 ) { return false ; } return true ; } function getVerificationStatus ( address identity , bytes32 levelId ) external view returns ( bool canVerify , uint256 [] memory missingTopics , uint256 [] memory expiredClaims ) { VerificationRequirement memory requirement = verificationLevels [ levelId ]; uint256 [] memory missing = new uint256 []( requirement . requiredTopics . length ); uint256 [] memory expired = new uint256 []( requirement . requiredTopics . length ); uint256 missingCount = 0 ; uint256 expiredCount = 0 ; canVerify = true ; for ( uint256 i = 0 ; i < requirement . requiredTopics . length ; i ++ ) { uint256 topic = requirement . requiredTopics [ i ]; bytes32 [] memory claimIds = claimHolder . getClaimIdsByTopic ( topic ); if ( claimIds . length == 0 ) { missing [ missingCount ++ ] = topic ; canVerify = false ; } else { bool hasValidClaim = false ; for ( uint256 j = 0 ; j < claimIds . length ; j ++ ) { uint256 expirationTime = claimExpirationTime [ claimIds [ j ]]; if ( expirationTime == 0 || block.timestamp <= expirationTime ) { hasValidClaim = true ; break ; } } if ( ! hasValidClaim ) { expired [ expiredCount ++ ] = topic ; canVerify = false ; } } } // Resize arrays to actual counts missingTopics = new uint256 []( missingCount ); expiredClaims = new uint256 []( expiredCount ); for ( uint256 i = 0 ; i < missingCount ; i ++ ) { missingTopics [ i ] = missing [ i ]; } for ( uint256 i = 0 ; i < expiredCount ; i ++ ) { expiredClaims [ i ] = expired [ i ]; } } modifier onlyAdmin () { // Implementation would check for admin role _ ; } }","title":"KYC/AML Verification System"},{"location":"smart-contracts/interfaces/ierc735/#professional-credentials-system","text":"// Professional credentials and certification system contract ProfessionalCredentials { IERC735 public claimHolder ; struct Credential { string name ; string description ; uint256 topic ; address issuingAuthority ; uint256 validityPeriod ; bool requiresRenewal ; uint256 renewalPeriod ; } struct IssuedCredential { bytes32 credentialId ; address holder ; uint256 issuedAt ; uint256 expiresAt ; bool active ; bytes32 claimId ; } mapping ( bytes32 => Credential ) public credentials ; mapping ( bytes32 => IssuedCredential ) public issuedCredentials ; mapping ( address => bytes32 []) public holderCredentials ; mapping ( address => bool ) public authorizedIssuers ; event CredentialDefined ( bytes32 indexed credentialId , string name , uint256 topic ); event CredentialIssued ( bytes32 indexed credentialId , address indexed holder , bytes32 claimId ); event CredentialRevoked ( bytes32 indexed credentialId , address indexed holder , string reason ); event CredentialRenewed ( bytes32 indexed credentialId , address indexed holder , uint256 newExpirationTime ); constructor ( address _claimHolder ) { claimHolder = IERC735 ( _claimHolder ); } function defineCredential ( bytes32 credentialId , string memory name , string memory description , uint256 topic , address issuingAuthority , uint256 validityPeriod , bool requiresRenewal , uint256 renewalPeriod ) external onlyAdmin { credentials [ credentialId ] = Credential ({ name : name , description : description , topic : topic , issuingAuthority : issuingAuthority , validityPeriod : validityPeriod , requiresRenewal : requiresRenewal , renewalPeriod : renewalPeriod }); authorizedIssuers [ issuingAuthority ] = true ; emit CredentialDefined ( credentialId , name , topic ); } function issueCredential ( bytes32 credentialId , address holder , bytes memory credentialData , bytes memory signature , string memory uri ) external onlyAuthorizedIssuer ( credentialId ) { Credential memory credential = credentials [ credentialId ]; require ( bytes ( credential . name ). length > 0 , \"Credential not defined\" ); uint256 expirationTime = credential . validityPeriod > 0 ? block.timestamp + credential . validityPeriod : 0 ; // Add claim to the identity uint256 claimRequestId = claimHolder . addClaim ( credential . topic , 1 , // ECDSA scheme msg.sender , signature , credentialData , uri ); bytes32 issuedCredentialId = keccak256 ( abi . encodePacked ( credentialId , holder , block.timestamp )); bytes32 claimId = bytes32 ( claimRequestId ); // Simplified mapping issuedCredentials [ issuedCredentialId ] = IssuedCredential ({ credentialId : credentialId , holder : holder , issuedAt : block.timestamp , expiresAt : expirationTime , active : true , claimId : claimId }); holderCredentials [ holder ]. push ( issuedCredentialId ); emit CredentialIssued ( credentialId , holder , claimId ); } function revokeCredential ( bytes32 issuedCredentialId , string memory reason ) external { IssuedCredential storage issued = issuedCredentials [ issuedCredentialId ]; require ( issued . active , \"Credential not active\" ); Credential memory credential = credentials [ issued . credentialId ]; require ( msg.sender == credential . issuingAuthority || msg.sender == issued . holder , \"Not authorized to revoke\" ); issued . active = false ; // Remove the claim from the identity claimHolder . removeClaim ( issued . claimId ); emit CredentialRevoked ( issued . credentialId , issued . holder , reason ); } function renewCredential ( bytes32 issuedCredentialId , bytes memory newCredentialData , bytes memory newSignature , string memory newUri ) external { IssuedCredential storage issued = issuedCredentials [ issuedCredentialId ]; require ( issued . active , \"Credential not active\" ); Credential memory credential = credentials [ issued . credentialId ]; require ( credential . requiresRenewal , \"Credential does not support renewal\" ); require ( msg.sender == credential . issuingAuthority , \"Not authorized to renew\" ); uint256 newExpirationTime = credential . validityPeriod > 0 ? block.timestamp + credential . validityPeriod : 0 ; // Update the claim claimHolder . changeClaim ( issued . claimId , credential . topic , 1 , // ECDSA scheme msg.sender , newSignature , newCredentialData , newUri ); issued . expiresAt = newExpirationTime ; emit CredentialRenewed ( issued . credentialId , issued . holder , newExpirationTime ); } function getHolderCredentials ( address holder ) external view returns ( bytes32 [] memory credentialIds , bool [] memory activeStatus , uint256 [] memory expirationTimes ) { bytes32 [] memory holderCreds = holderCredentials [ holder ]; credentialIds = new bytes32 []( holderCreds . length ); activeStatus = new bool []( holderCreds . length ); expirationTimes = new uint256 []( holderCreds . length ); for ( uint256 i = 0 ; i < holderCreds . length ; i ++ ) { IssuedCredential memory issued = issuedCredentials [ holderCreds [ i ]]; credentialIds [ i ] = issued . credentialId ; activeStatus [ i ] = issued . active && ( issued . expiresAt == 0 || block.timestamp <= issued . expiresAt ); expirationTimes [ i ] = issued . expiresAt ; } } function verifyCredential ( address holder , bytes32 credentialId ) external view returns ( bool valid , uint256 expirationTime ) { bytes32 [] memory holderCreds = holderCredentials [ holder ]; for ( uint256 i = 0 ; i < holderCreds . length ; i ++ ) { IssuedCredential memory issued = issuedCredentials [ holderCreds [ i ]]; if ( issued . credentialId == credentialId && issued . active ) { valid = issued . expiresAt == 0 || block.timestamp <= issued . expiresAt ; expirationTime = issued . expiresAt ; return ( valid , expirationTime ); } } return ( false , 0 ); } modifier onlyAdmin () { // Implementation would check for admin role _ ; } modifier onlyAuthorizedIssuer ( bytes32 credentialId ) { Credential memory credential = credentials [ credentialId ]; require ( msg.sender == credential . issuingAuthority , \"Not authorized issuer\" ); _ ; } }","title":"Professional Credentials System"},{"location":"smart-contracts/interfaces/ierc735/#decentralized-identity-verification","text":"// Comprehensive identity verification system contract DecentralizedIdentityVerification { IERC735 public claimHolder ; struct IdentityProfile { address owner ; uint256 createdAt ; uint256 lastUpdated ; uint256 verificationLevel ; bool active ; mapping ( uint256 => bytes32 []) topicClaims ; } struct VerificationChallenge { address challenger ; bytes32 claimId ; string reason ; uint256 createdAt ; uint256 deadline ; bool resolved ; bool upheld ; } mapping ( address => IdentityProfile ) public identityProfiles ; mapping ( bytes32 => VerificationChallenge ) public challenges ; mapping ( uint256 => uint256 ) public topicWeights ; mapping ( address => bool ) public verificationOracles ; uint256 public challengePeriod = 7 days ; uint256 public constant MAX_VERIFICATION_LEVEL = 100 ; event IdentityProfileCreated ( address indexed identity , uint256 timestamp ); event ClaimVerified ( address indexed identity , bytes32 indexed claimId , address indexed verifier ); event ClaimChallenged ( bytes32 indexed challengeId , bytes32 indexed claimId , address challenger ); event ChallengeResolved ( bytes32 indexed challengeId , bool upheld , address resolver ); event VerificationLevelUpdated ( address indexed identity , uint256 oldLevel , uint256 newLevel ); constructor ( address _claimHolder ) { claimHolder = IERC735 ( _claimHolder ); // Set default topic weights topicWeights [ KYC_TOPIC ] = 30 ; topicWeights [ AML_TOPIC ] = 25 ; topicWeights [ ACCREDITED_INVESTOR_TOPIC ] = 20 ; topicWeights [ PROFESSIONAL_TOPIC ] = 15 ; topicWeights [ BIOMETRIC_TOPIC ] = 10 ; } function createIdentityProfile () external { require ( identityProfiles [ msg.sender ]. owner == address ( 0 ), \"Profile already exists\" ); IdentityProfile storage profile = identityProfiles [ msg.sender ]; profile . owner = msg.sender ; profile . createdAt = block.timestamp ; profile . lastUpdated = block.timestamp ; profile . verificationLevel = 0 ; profile . active = true ; emit IdentityProfileCreated ( msg.sender , block.timestamp ); } function updateVerificationLevel ( address identity ) external { IdentityProfile storage profile = identityProfiles [ identity ]; require ( profile . active , \"Identity profile not active\" ); uint256 totalWeight = 0 ; uint256 achievedWeight = 0 ; // Calculate verification level based on claims for ( uint256 topic = 1 ; topic <= 10004 ; topic ++ ) { uint256 weight = topicWeights [ topic ]; if ( weight > 0 ) { totalWeight += weight ; bytes32 [] memory claimIds = claimHolder . getClaimIdsByTopic ( topic ); if ( claimIds . length > 0 ) { // Check if any claim for this topic is valid for ( uint256 i = 0 ; i < claimIds . length ; i ++ ) { if ( _isClaimValid ( claimIds [ i ])) { achievedWeight += weight ; break ; } } } } } uint256 oldLevel = profile . verificationLevel ; uint256 newLevel = totalWeight > 0 ? ( achievedWeight * MAX_VERIFICATION_LEVEL ) / totalWeight : 0 ; profile . verificationLevel = newLevel ; profile . lastUpdated = block.timestamp ; emit VerificationLevelUpdated ( identity , oldLevel , newLevel ); } function challengeClaim ( bytes32 claimId , string memory reason ) external returns ( bytes32 challengeId ) { challengeId = keccak256 ( abi . encodePacked ( claimId , msg.sender , block.timestamp )); challenges [ challengeId ] = VerificationChallenge ({ challenger : msg.sender , claimId : claimId , reason : reason , createdAt : block.timestamp , deadline : block.timestamp + challengePeriod , resolved : false , upheld : false }); emit ClaimChallenged ( challengeId , claimId , msg.sender ); } function resolveChallenge ( bytes32 challengeId , bool upholdChallenge ) external onlyVerificationOracle { VerificationChallenge storage challenge = challenges [ challengeId ]; require ( ! challenge . resolved , \"Challenge already resolved\" ); require ( block.timestamp <= challenge . deadline , \"Challenge deadline passed\" ); challenge . resolved = true ; challenge . upheld = upholdChallenge ; if ( upholdChallenge ) { // Remove the challenged claim claimHolder . removeClaim ( challenge . claimId ); } emit ChallengeResolved ( challengeId , upholdChallenge , msg.sender ); } function _isClaimValid ( bytes32 claimId ) internal returns ( bool ) { ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ) = claimHolder . getClaim ( claimId ); // Basic validation - in practice would include signature verification return signature . length > 0 && issuer != address ( 0 ); } function getIdentityVerificationStatus ( address identity ) external view returns ( uint256 verificationLevel , uint256 claimCount , uint256 lastUpdated , bool active ) { IdentityProfile storage profile = identityProfiles [ identity ]; verificationLevel = profile . verificationLevel ; lastUpdated = profile . lastUpdated ; active = profile . active ; // Count total claims across all topics claimCount = 0 ; for ( uint256 topic = 1 ; topic <= 10004 ; topic ++ ) { bytes32 [] memory claimIds = claimHolder . getClaimIdsByTopic ( topic ); claimCount += claimIds . length ; } } function setTopicWeight ( uint256 topic , uint256 weight ) external onlyAdmin { topicWeights [ topic ] = weight ; } function setVerificationOracle ( address oracle , bool authorized ) external onlyAdmin { verification Oracles [ oracle ] = authorized ; } modifier onlyAdmin () { // Implementation would check for admin role _ ; } modifier onlyVerificationOracle () { require ( verificationOracles [ msg.sender ], \"Not authorized verification oracle\" ); _ ; } }","title":"Decentralized Identity Verification"},{"location":"smart-contracts/interfaces/ierc735/#events","text":"","title":"Events"},{"location":"smart-contracts/interfaces/ierc735/#claim-lifecycle-events","text":"event ClaimRequested ( uint256 indexed claimRequestId , // Unique request identifier uint256 indexed topic , // Claim topic uint256 scheme , // Signature scheme address indexed issuer , // Claim issuer bytes signature , // Cryptographic signature bytes data , // Claim data string uri // Metadata URI ); event ClaimAdded ( bytes32 indexed claimId , // Unique claim identifier uint256 indexed topic , // Claim topic uint256 scheme , // Signature scheme address indexed issuer , // Claim issuer bytes signature , // Cryptographic signature bytes data , // Claim data string uri // Metadata URI ); event ClaimRemoved ( bytes32 indexed claimId , // Unique claim identifier uint256 indexed topic , // Claim topic uint256 scheme , // Signature scheme address indexed issuer , // Claim issuer bytes signature , // Cryptographic signature bytes data , // Claim data string uri // Metadata URI ); event ClaimChanged ( bytes32 indexed claimId , // Unique claim identifier uint256 indexed topic , // Claim topic uint256 scheme , // Signature scheme address indexed issuer , // Claim issuer bytes signature , // Cryptographic signature bytes data , // Claim data string uri // Metadata URI );","title":"Claim Lifecycle Events"},{"location":"smart-contracts/interfaces/ierc735/#identity-registry-integration","text":"The IERC735 interface works closely with the Identity Registry system: /* How IdentityRegistry works: 1. User creates an Identity contract 2. User calls IdentityRegistry.addIdentity(address _identity, IIdentity identityData) 3. IdentityRegistry emits IdentityAdded(address indexed _address, IIdentity identity) 4. IdentityRegistry emits ClaimAdded(address indexed identity, uint256 indexed claimTopic, bytes claim) 5. IdentityRegistry emits WalletLinked(address indexed walletAddress, bytes32 indexed onchainID) */","title":"Identity Registry Integration"},{"location":"smart-contracts/interfaces/ierc735/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/ierc735/#claim-verification-security","text":"Cryptographic signature validation for all claims Issuer authorization verification before accepting claims Protection against claim replay attacks Secure claim data storage and retrieval","title":"Claim Verification Security"},{"location":"smart-contracts/interfaces/ierc735/#access-control","text":"Proper validation of claim modification permissions Protection of sensitive claim data Secure issuer authorization mechanisms Prevention of unauthorized claim removal","title":"Access Control"},{"location":"smart-contracts/interfaces/ierc735/#data-integrity","text":"Immutable claim history and audit trails Protection against claim tampering Secure off-chain data references via URIs Validation of claim data consistency","title":"Data Integrity"},{"location":"smart-contracts/interfaces/ierc735/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/interfaces/ierc735/#efficient-operations","text":"Batch claim operations where possible Optimized storage layout for claim data Minimal external calls in view functions Efficient event emission patterns","title":"Efficient Operations"},{"location":"smart-contracts/interfaces/ierc735/#storage-optimization","text":"Packed storage structures for claim metadata Efficient mapping usage for claim lookups Optimized array operations for topic queries Cached calculations for frequently accessed data","title":"Storage Optimization"},{"location":"smart-contracts/interfaces/ierc735/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/interfaces/ierc735/#common-errors","text":"Unauthorized claim operations Invalid claim signatures or data Non-existent claims or topics Expired or revoked claims Issuer authorization failures","title":"Common Errors"},{"location":"smart-contracts/interfaces/ierc735/#best-practices","text":"Validate claim signatures before processing Check issuer authorization for claim topics Verify claim existence before modifications Handle signature verification failures gracefully Provide clear error messages for debugging","title":"Best Practices"},{"location":"smart-contracts/interfaces/ierc735/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/interfaces/ierc735/#unit-tests","text":"Interface compliance verification Claim management function testing Signature verification testing Event emission verification Access control validation","title":"Unit Tests"},{"location":"smart-contracts/interfaces/ierc735/#integration-tests","text":"Identity registry integration KYC/AML workflow testing Professional credentials system integration Cross-contract claim validation Security scenario testing","title":"Integration Tests"},{"location":"smart-contracts/interfaces/ierc735/#related-documentation","text":"IERC734 - Key Manager interface for identity key management IdentityRegistryFacet - Identity registry implementation TrustedIssuersRegistryFacet - Trusted issuer management Identity System Guide - Implementation guide for identity management KYC/AML Integration Guide - KYC/AML implementation patterns This interface defines the Claim Holder standard (ERC-735) for decentralized identity management within the Gemforce platform, enabling secure management of identity claims, attestations, and verifications through cryptographically signed claims from trusted issuers.","title":"Related Documentation"},{"location":"smart-contracts/interfaces/ifee-distributor/","text":"IFeeDistributor Interface \u00b6 The IFeeDistributor interface defines the standard for smart contracts responsible for distributing collected fees or revenues to multiple recipients based on predefined percentages or shares. This is a critical component for managing revenue sharing in various decentralized applications within the Gemforce ecosystem. Overview \u00b6 IFeeDistributor provides: Configurable Shares : Define distribution percentages for multiple recipients. Automated Distribution : Functions to trigger and manage fee distribution. Recipient Management : Add, update, and remove recipients with their shares. Event Logging : Comprehensive event tracking for all distribution activities. Key Features \u00b6 Distribution Management \u00b6 Manual Trigger : Allow authorized parties to initiate distribution. Automated Trigger (Optional) : Can be integrated with external mechanisms for time-based or volume-based distribution. Share Calculation : Accurately calculate each recipient's share. Recipient and Share Management \u00b6 Add Recipient : Onboard new recipients with their respective shares. Update Share : Adjust existing recipient shares. Remove Recipient : Remove recipients from the distribution list. Fund Handling \u00b6 Multi-Token Support : Can be designed to distribute various ERC20 tokens or native currency (ETH). Residual Handling : Mechanisms to manage any remaining dust or undistributed funds. Interface Definition \u00b6 interface IFeeDistributor { // Events event FundsReceived ( address indexed token , uint256 amount , address indexed sender ); event FeesDistributed ( address indexed token , uint256 totalAmount , uint256 leftOverAmount , address indexed distributor ); event RecipientAdded ( address indexed recipient , uint256 share , address indexed manager ); event RecipientUpdated ( address indexed recipient , uint256 oldShare , uint256 newShare , address indexed manager ); event RecipientRemoved ( address indexed recipient , uint256 share , address indexed manager ); event FeeCollectorUpdated ( address indexed oldCollector , address indexed newCollector ); // Structs struct Recipient { address addr ; uint256 share ; // Basis points (e.g., 100 = 1%) uint256 lastDistributedAmount ; // Amount last sent to this recipient } // Core Functions function distributeFees ( address token ) external returns ( uint256 distributedAmount ); function updateRecipient ( address recipientAddr , uint256 newShare ) external ; function addRecipient ( address recipientAddr , uint256 share ) external ; function removeRecipient ( address recipientAddr ) external ; function setFeeCollector ( address collector ) external ; // View Functions function getTotalShare () external view returns ( uint256 ); function getRecipientShare ( address recipientAddr ) external view returns ( uint256 ); function getRecipientCount () external view returns ( uint256 ); function getRecipientAddress ( uint256 index ) external view returns ( address ); function getFeeCollector () external view returns ( address ); function getBalance ( address token ) external view returns ( uint256 ); function getRecipientDetails ( address recipientAddr ) external view returns ( Recipient memory ); } Core Functions \u00b6 distributeFees() \u00b6 Initiates the distribution of collected fees for a specific token to all registered recipients based on their shares. Parameters: - token : The address of the ERC20 token to distribute. If address(0) is used, it refers to the native blockchain currency (e.g., ETH). Returns: - uint256 : The total amount of the token that was successfully distributed. Usage: // Distribute ETH feeDistributor . distributeFees ( address ( 0 )); // Distribute DAI (ERC20 token) feeDistributor . distributeFees ( DAI_TOKEN_ADDRESS ); addRecipient() \u00b6 Adds a new address to the list of fee recipients with a specified share. Shares are typically defined in basis points (e.g., 100 = 1%). Parameters: - recipientAddr : The address of the new recipient. - share : The share percentage of the recipient in basis points. Access Control: - Typically restricted to the contract owner or an authorized feeCollector . updateRecipient() \u00b6 Updates the share percentage of an existing recipient. Parameters: - recipientAddr : The address of the recipient whose share is to be updated. - newShare : The new share percentage for the recipient. removeRecipient() \u00b6 Removes an address from the list of fee recipients. Parameters: - recipientAddr : The address of the recipient to be removed. Implementation Example \u00b6 Basic FeeDistributor Contract \u00b6 import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; import \"@openzeppelin/contracts/utils/math/SafeMath.sol\" ; contract FeeDistributor is IFeeDistributor , Ownable { using SafeMath for uint256 ; uint256 public constant TOTAL_BASIS_POINTS = 10000 ; // 100% // Mapping from recipient address to their share (in basis points) mapping ( address => uint256 ) private _recipientShares ; // Array to maintain order and iterate over recipients address [] private _recipients ; // Total sum of all recipient shares uint256 private _totalShares ; address private _feeCollector ; constructor () { _feeCollector = msg.sender ; } modifier onlyFeeCollector () { require ( msg.sender == _feeCollector , \"Only fee collector can call this function\" ); _ ; } receive () external payable { emit FundsReceived ( address ( 0 ), msg.value , msg.sender ); } // Handles ERC20 transfers directly to the contract function onERC20Received ( address , uint256 amount ) external returns ( bool ) { emit FundsReceived ( msg.sender , amount , tx.origin ); // Assume msg.sender is the ERC20 token contract return true ; } function distributeFees ( address token ) external override returns ( uint256 distributedAmount ) { require ( _recipients . length > 0 , \"No recipients to distribute to\" ); require ( _totalShares <= TOTAL_BASIS_POINTS , \"Invalid total shares configuration\" ); uint256 contractBalance ; if ( token == address ( 0 )) { contractBalance = address ( this ). balance ; } else { contractBalance = IERC20 ( token ). balanceOf ( address ( this )); } require ( contractBalance > 0 , \"No funds to distribute\" ); distributedAmount = 0 ; uint256 remainingAmount = contractBalance ; for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { address recipientAddr = _recipients [ i ]; uint256 share = _recipientShares [ recipientAddr ]; // Calculate amount for current recipient uint256 amountToSend = contractBalance . mul ( share ). div ( TOTAL_BASIS_POINTS ); if ( amountToSend > 0 ) { if ( token == address ( 0 )) { // Send ETH payable ( recipientAddr ). transfer ( amountToSend ); } else { // Send ERC20 IERC20 ( token ). transfer ( recipientAddr , amountToSend ); } distributedAmount = distributedAmount . add ( amountToSend ); remainingAmount = remainingAmount . sub ( amountToSend ); } } emit FeesDistributed ( token , distributedAmount , remainingAmount , msg.sender ); } function addRecipient ( address recipientAddr , uint256 share ) external override onlyFeeCollector { require ( recipientAddr != address ( 0 ), \"Cannot add zero address\" ); require ( _recipientShares [ recipientAddr ] == 0 , \"Recipient already exists\" ); require ( _totalShares . add ( share ) <= TOTAL_BASIS_POINTS , \"Total shares exceed 100%\" ); _recipientShares [ recipientAddr ] = share ; _recipients . push ( recipientAddr ); _totalShares = _totalShares . add ( share ); emit RecipientAdded ( recipientAddr , share , msg.sender ); } function updateRecipient ( address recipientAddr , uint256 newShare ) external override onlyFeeCollector { require ( recipientAddr != address ( 0 ), \"Cannot update zero address\" ); require ( _recipientShares [ recipientAddr ] != 0 , \"Recipient does not exist\" ); uint256 oldShare = _recipientShares [ recipientAddr ]; require ( _totalShares . sub ( oldShare ). add ( newShare ) <= TOTAL_BASIS_POINTS , \"Total shares exceed 100%\" ); _recipientShares [ recipientAddr ] = newShare ; _totalShares = _totalShares . sub ( oldShare ). add ( newShare ); emit RecipientUpdated ( recipientAddr , oldShare , newShare , msg.sender ); } function removeRecipient ( address recipientAddr ) external override onlyFeeCollector { require ( recipientAddr != address ( 0 ), \"Cannot remove zero address\" ); uint256 shareToRemove = _recipientShares [ recipientAddr ]; require ( shareToRemove > 0 , \"Recipient does not exist\" ); delete _recipientShares [ recipientAddr ]; _totalShares = _totalShares . sub ( shareToRemove ); // Remove from dynamic array by swapping with last element and popping for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { if ( _recipients [ i ] == recipientAddr ) { _recipients [ i ] = _recipients [ _recipients . length - 1 ]; _recipients . pop (); break ; } } emit RecipientRemoved ( recipientAddr , shareToRemove , msg.sender ); } function setFeeCollector ( address collector ) external override onlyOwner { require ( collector != address ( 0 ), \"New fee collector cannot be the zero address\" ); emit FeeCollectorUpdated ( _feeCollector , collector ); _feeCollector = collector ; } function getTotalShare () external view override returns ( uint256 ) { return _totalShares ; } function getRecipientShare ( address recipientAddr ) external view override returns ( uint256 ) { return _recipientShares [ recipientAddr ]; } function getRecipientCount () external view override returns ( uint256 ) { return _recipients . length ; } function getRecipientAddress ( uint256 index ) external view override returns ( address ) { require ( index < _recipients . length , \"Index out of bounds\" ); return _recipients [ index ]; } function getFeeCollector () external view override returns ( address ) { return _feeCollector ; } function getBalance ( address token ) external view override returns ( uint256 ) { if ( token == address ( 0 )) { return address ( this ). balance ; } else { return IERC20 ( token ). balanceOf ( address ( this )); } } function getRecipientDetails ( address recipientAddr ) external view override returns ( Recipient memory ) { return Recipient ({ addr : recipientAddr , share : _recipientShares [ recipientAddr ], lastDistributedAmount : 0 // This would require more complex state tracking }); } } Security Considerations \u00b6 Access Control \u00b6 onlyOwner : Critical administrative functions (like changing the fee collector) should be restricted to the contract owner. onlyFeeCollector : Functions modifying recipient lists or shares should be restricted to an authorized fee collector role. Fund Handling \u00b6 Reentrancy : Implement reentrancy guards for distributeFees if external calls are made that could re-enter the contract (though direct token transfers are less prone to this). Exact Amounts : Ensure precise calculations to avoid sending unintended amounts or leaving dust. Using SafeMath is crucial. Eth/Token Differences : Correctly handle native currency (ETH) transfers vs. ERC20 token transfers. Dust Management : Consider a mechanism to handle small remaining amounts (dust) if total shares don't perfectly sum up to TOTAL_BASIS_POINTS or if precision issues arise. Configuration \u00b6 Share Validation : Prevent total shares from exceeding TOTAL_BASIS_POINTS (100%) to avoid potential over-distribution. Zero Address Checks : Always validate non-zero addresses for recipients and collectors. Best Practices \u00b6 Shares Configuration \u00b6 Basis Points : Use basis points (e.g., 10,000 for 100%) for share representation to avoid floating-point errors common in Solidity. Sum to 100% : Ensure that the sum of all recipient shares equals TOTAL_BASIS_POINTS to guarantee full distribution and no residual funds left in the contract (unless intentional). Modularity \u00b6 Separation of Concerns : Keep fee distribution logic separate from other core application logic. Upgradeable : Design the contract to be upgradeable if shares or recipients might change frequently or if new distribution logic is anticipated. Gas Efficiency \u00b6 Array Iteration : Be mindful of gas costs for iterating over a large number of recipients; large arrays can become expensive. Consider a pull-based mechanism for recipients to claim their funds if recipient count is very high. Integration Examples \u00b6 Frontend Integration (React/Web3Modal) \u00b6 import { ethers } from 'ethers' ; import feeDistributorABI from './FeeDistributor.json' ; // ABI of the FeeDistributor contract const FEE_DISTRIBUTOR_ADDRESS = \"0x...\" ; // Deploy address of your FeeDistributor contract const getProvider = () => new ethers . providers . Web3Provider ( window . ethereum ); const getSigner = () => getProvider (). getSigner (); const getFeeDistributorContract = () => new ethers . Contract ( FEE_DISTRIBUTOR_ADDRESS , feeDistributorABI , getSigner ()); async function handleDistributeFees ( tokenAddress : string ) { try { const feeDistributor = getFeeDistributorContract (); const tx = await feeDistributor . distributeFees ( tokenAddress ); await tx . wait (); alert ( \"Fees distributed successfully!\" ); } catch ( error ) { console . error ( \"Error distributing fees:\" , error ); alert ( \"Failed to distribute fees.\" ); } } async function handleAddRecipient ( recipientAddress : string , share : number ) { try { const feeDistributor = getFeeDistributorContract (); // Assuming share is in basis points, e.g., 2500 for 25% const tx = await feeDistributor . addRecipient ( recipientAddress , share ); await tx . wait (); alert ( \"Recipient added successfully!\" ); } catch ( error ) { console . error ( \"Error adding recipient:\" , error ); alert ( \"Failed to add recipient.\" ); } } // Example usage in a React component // <button onClick={() => handleDistributeFees(\"0x0000000000000000000000000000000000000000\")}>Distribute ETH Fees</button> // <button onClick={() => handleAddRecipient(\"0xRecipientAddress\", 1000)}>Add 10% Recipient</button> Backend Integration (Node.js/Ethers.js) \u00b6 const { ethers } = require ( \"ethers\" ); const FeeDistributorABI = require ( \"./FeeDistributor.json\" ). abi ; const provider = new ethers . JsonRpcProvider ( \"YOUR_RPC_URL\" ); const wallet = new ethers . Wallet ( \"YOUR_PRIVATE_KEY\" , provider ); const feeDistributorAddress = \"0x...\" ; // Your deployed FeeDistributor contract address const feeDistributorContract = new ethers . Contract ( feeDistributorAddress , FeeDistributorABI , wallet ); async function performFeeDistribution ( tokenAddress ) { try { console . log ( `Initiating fee distribution for ${ tokenAddress === ethers . ZeroAddress ? \"ETH\" : \"ERC20 token\" } ...` ); const tx = await feeDistributorContract . distributeFees ( tokenAddress ); await tx . wait (); console . log ( `Distribution transaction successful: ${ tx . hash } ` ); } catch ( error ) { console . error ( \"Error during fee distribution:\" , error ); throw error ; } } async function addNewRecipient ( address , share ) { try { console . log ( `Adding new recipient ${ address } with share ${ share } ...` ); const tx = await feeDistributorContract . addRecipient ( address , share ); await tx . wait (); console . log ( `Recipient added transaction successful: ${ tx . hash } ` ); } catch ( error ) { console . error ( \"Error adding new recipient:\" , error ); throw error ; } } // Example usage // performFeeDistribution(ethers.ZeroAddress); // Distribute ETH // addNewRecipient(\"0xNewRecipientAddress\", 500); // Add a recipient with 5% share Related Documentation \u00b6 Fee Distributor Library ERC20 Standard Ownable Contract Safemath Library Standards Compliance \u00b6 ERC20 : Compatible with ERC20 tokens for distribution. Ownable : Utilizes OpenZeppelin's Ownable for administrative access control.","title":"IFeeDistributor"},{"location":"smart-contracts/interfaces/ifee-distributor/#ifeedistributor-interface","text":"The IFeeDistributor interface defines the standard for smart contracts responsible for distributing collected fees or revenues to multiple recipients based on predefined percentages or shares. This is a critical component for managing revenue sharing in various decentralized applications within the Gemforce ecosystem.","title":"IFeeDistributor Interface"},{"location":"smart-contracts/interfaces/ifee-distributor/#overview","text":"IFeeDistributor provides: Configurable Shares : Define distribution percentages for multiple recipients. Automated Distribution : Functions to trigger and manage fee distribution. Recipient Management : Add, update, and remove recipients with their shares. Event Logging : Comprehensive event tracking for all distribution activities.","title":"Overview"},{"location":"smart-contracts/interfaces/ifee-distributor/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/ifee-distributor/#distribution-management","text":"Manual Trigger : Allow authorized parties to initiate distribution. Automated Trigger (Optional) : Can be integrated with external mechanisms for time-based or volume-based distribution. Share Calculation : Accurately calculate each recipient's share.","title":"Distribution Management"},{"location":"smart-contracts/interfaces/ifee-distributor/#recipient-and-share-management","text":"Add Recipient : Onboard new recipients with their respective shares. Update Share : Adjust existing recipient shares. Remove Recipient : Remove recipients from the distribution list.","title":"Recipient and Share Management"},{"location":"smart-contracts/interfaces/ifee-distributor/#fund-handling","text":"Multi-Token Support : Can be designed to distribute various ERC20 tokens or native currency (ETH). Residual Handling : Mechanisms to manage any remaining dust or undistributed funds.","title":"Fund Handling"},{"location":"smart-contracts/interfaces/ifee-distributor/#interface-definition","text":"interface IFeeDistributor { // Events event FundsReceived ( address indexed token , uint256 amount , address indexed sender ); event FeesDistributed ( address indexed token , uint256 totalAmount , uint256 leftOverAmount , address indexed distributor ); event RecipientAdded ( address indexed recipient , uint256 share , address indexed manager ); event RecipientUpdated ( address indexed recipient , uint256 oldShare , uint256 newShare , address indexed manager ); event RecipientRemoved ( address indexed recipient , uint256 share , address indexed manager ); event FeeCollectorUpdated ( address indexed oldCollector , address indexed newCollector ); // Structs struct Recipient { address addr ; uint256 share ; // Basis points (e.g., 100 = 1%) uint256 lastDistributedAmount ; // Amount last sent to this recipient } // Core Functions function distributeFees ( address token ) external returns ( uint256 distributedAmount ); function updateRecipient ( address recipientAddr , uint256 newShare ) external ; function addRecipient ( address recipientAddr , uint256 share ) external ; function removeRecipient ( address recipientAddr ) external ; function setFeeCollector ( address collector ) external ; // View Functions function getTotalShare () external view returns ( uint256 ); function getRecipientShare ( address recipientAddr ) external view returns ( uint256 ); function getRecipientCount () external view returns ( uint256 ); function getRecipientAddress ( uint256 index ) external view returns ( address ); function getFeeCollector () external view returns ( address ); function getBalance ( address token ) external view returns ( uint256 ); function getRecipientDetails ( address recipientAddr ) external view returns ( Recipient memory ); }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/ifee-distributor/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/ifee-distributor/#distributefees","text":"Initiates the distribution of collected fees for a specific token to all registered recipients based on their shares. Parameters: - token : The address of the ERC20 token to distribute. If address(0) is used, it refers to the native blockchain currency (e.g., ETH). Returns: - uint256 : The total amount of the token that was successfully distributed. Usage: // Distribute ETH feeDistributor . distributeFees ( address ( 0 )); // Distribute DAI (ERC20 token) feeDistributor . distributeFees ( DAI_TOKEN_ADDRESS );","title":"distributeFees()"},{"location":"smart-contracts/interfaces/ifee-distributor/#addrecipient","text":"Adds a new address to the list of fee recipients with a specified share. Shares are typically defined in basis points (e.g., 100 = 1%). Parameters: - recipientAddr : The address of the new recipient. - share : The share percentage of the recipient in basis points. Access Control: - Typically restricted to the contract owner or an authorized feeCollector .","title":"addRecipient()"},{"location":"smart-contracts/interfaces/ifee-distributor/#updaterecipient","text":"Updates the share percentage of an existing recipient. Parameters: - recipientAddr : The address of the recipient whose share is to be updated. - newShare : The new share percentage for the recipient.","title":"updateRecipient()"},{"location":"smart-contracts/interfaces/ifee-distributor/#removerecipient","text":"Removes an address from the list of fee recipients. Parameters: - recipientAddr : The address of the recipient to be removed.","title":"removeRecipient()"},{"location":"smart-contracts/interfaces/ifee-distributor/#implementation-example","text":"","title":"Implementation Example"},{"location":"smart-contracts/interfaces/ifee-distributor/#basic-feedistributor-contract","text":"import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; import \"@openzeppelin/contracts/utils/math/SafeMath.sol\" ; contract FeeDistributor is IFeeDistributor , Ownable { using SafeMath for uint256 ; uint256 public constant TOTAL_BASIS_POINTS = 10000 ; // 100% // Mapping from recipient address to their share (in basis points) mapping ( address => uint256 ) private _recipientShares ; // Array to maintain order and iterate over recipients address [] private _recipients ; // Total sum of all recipient shares uint256 private _totalShares ; address private _feeCollector ; constructor () { _feeCollector = msg.sender ; } modifier onlyFeeCollector () { require ( msg.sender == _feeCollector , \"Only fee collector can call this function\" ); _ ; } receive () external payable { emit FundsReceived ( address ( 0 ), msg.value , msg.sender ); } // Handles ERC20 transfers directly to the contract function onERC20Received ( address , uint256 amount ) external returns ( bool ) { emit FundsReceived ( msg.sender , amount , tx.origin ); // Assume msg.sender is the ERC20 token contract return true ; } function distributeFees ( address token ) external override returns ( uint256 distributedAmount ) { require ( _recipients . length > 0 , \"No recipients to distribute to\" ); require ( _totalShares <= TOTAL_BASIS_POINTS , \"Invalid total shares configuration\" ); uint256 contractBalance ; if ( token == address ( 0 )) { contractBalance = address ( this ). balance ; } else { contractBalance = IERC20 ( token ). balanceOf ( address ( this )); } require ( contractBalance > 0 , \"No funds to distribute\" ); distributedAmount = 0 ; uint256 remainingAmount = contractBalance ; for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { address recipientAddr = _recipients [ i ]; uint256 share = _recipientShares [ recipientAddr ]; // Calculate amount for current recipient uint256 amountToSend = contractBalance . mul ( share ). div ( TOTAL_BASIS_POINTS ); if ( amountToSend > 0 ) { if ( token == address ( 0 )) { // Send ETH payable ( recipientAddr ). transfer ( amountToSend ); } else { // Send ERC20 IERC20 ( token ). transfer ( recipientAddr , amountToSend ); } distributedAmount = distributedAmount . add ( amountToSend ); remainingAmount = remainingAmount . sub ( amountToSend ); } } emit FeesDistributed ( token , distributedAmount , remainingAmount , msg.sender ); } function addRecipient ( address recipientAddr , uint256 share ) external override onlyFeeCollector { require ( recipientAddr != address ( 0 ), \"Cannot add zero address\" ); require ( _recipientShares [ recipientAddr ] == 0 , \"Recipient already exists\" ); require ( _totalShares . add ( share ) <= TOTAL_BASIS_POINTS , \"Total shares exceed 100%\" ); _recipientShares [ recipientAddr ] = share ; _recipients . push ( recipientAddr ); _totalShares = _totalShares . add ( share ); emit RecipientAdded ( recipientAddr , share , msg.sender ); } function updateRecipient ( address recipientAddr , uint256 newShare ) external override onlyFeeCollector { require ( recipientAddr != address ( 0 ), \"Cannot update zero address\" ); require ( _recipientShares [ recipientAddr ] != 0 , \"Recipient does not exist\" ); uint256 oldShare = _recipientShares [ recipientAddr ]; require ( _totalShares . sub ( oldShare ). add ( newShare ) <= TOTAL_BASIS_POINTS , \"Total shares exceed 100%\" ); _recipientShares [ recipientAddr ] = newShare ; _totalShares = _totalShares . sub ( oldShare ). add ( newShare ); emit RecipientUpdated ( recipientAddr , oldShare , newShare , msg.sender ); } function removeRecipient ( address recipientAddr ) external override onlyFeeCollector { require ( recipientAddr != address ( 0 ), \"Cannot remove zero address\" ); uint256 shareToRemove = _recipientShares [ recipientAddr ]; require ( shareToRemove > 0 , \"Recipient does not exist\" ); delete _recipientShares [ recipientAddr ]; _totalShares = _totalShares . sub ( shareToRemove ); // Remove from dynamic array by swapping with last element and popping for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { if ( _recipients [ i ] == recipientAddr ) { _recipients [ i ] = _recipients [ _recipients . length - 1 ]; _recipients . pop (); break ; } } emit RecipientRemoved ( recipientAddr , shareToRemove , msg.sender ); } function setFeeCollector ( address collector ) external override onlyOwner { require ( collector != address ( 0 ), \"New fee collector cannot be the zero address\" ); emit FeeCollectorUpdated ( _feeCollector , collector ); _feeCollector = collector ; } function getTotalShare () external view override returns ( uint256 ) { return _totalShares ; } function getRecipientShare ( address recipientAddr ) external view override returns ( uint256 ) { return _recipientShares [ recipientAddr ]; } function getRecipientCount () external view override returns ( uint256 ) { return _recipients . length ; } function getRecipientAddress ( uint256 index ) external view override returns ( address ) { require ( index < _recipients . length , \"Index out of bounds\" ); return _recipients [ index ]; } function getFeeCollector () external view override returns ( address ) { return _feeCollector ; } function getBalance ( address token ) external view override returns ( uint256 ) { if ( token == address ( 0 )) { return address ( this ). balance ; } else { return IERC20 ( token ). balanceOf ( address ( this )); } } function getRecipientDetails ( address recipientAddr ) external view override returns ( Recipient memory ) { return Recipient ({ addr : recipientAddr , share : _recipientShares [ recipientAddr ], lastDistributedAmount : 0 // This would require more complex state tracking }); } }","title":"Basic FeeDistributor Contract"},{"location":"smart-contracts/interfaces/ifee-distributor/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/ifee-distributor/#access-control","text":"onlyOwner : Critical administrative functions (like changing the fee collector) should be restricted to the contract owner. onlyFeeCollector : Functions modifying recipient lists or shares should be restricted to an authorized fee collector role.","title":"Access Control"},{"location":"smart-contracts/interfaces/ifee-distributor/#fund-handling_1","text":"Reentrancy : Implement reentrancy guards for distributeFees if external calls are made that could re-enter the contract (though direct token transfers are less prone to this). Exact Amounts : Ensure precise calculations to avoid sending unintended amounts or leaving dust. Using SafeMath is crucial. Eth/Token Differences : Correctly handle native currency (ETH) transfers vs. ERC20 token transfers. Dust Management : Consider a mechanism to handle small remaining amounts (dust) if total shares don't perfectly sum up to TOTAL_BASIS_POINTS or if precision issues arise.","title":"Fund Handling"},{"location":"smart-contracts/interfaces/ifee-distributor/#configuration","text":"Share Validation : Prevent total shares from exceeding TOTAL_BASIS_POINTS (100%) to avoid potential over-distribution. Zero Address Checks : Always validate non-zero addresses for recipients and collectors.","title":"Configuration"},{"location":"smart-contracts/interfaces/ifee-distributor/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/interfaces/ifee-distributor/#shares-configuration","text":"Basis Points : Use basis points (e.g., 10,000 for 100%) for share representation to avoid floating-point errors common in Solidity. Sum to 100% : Ensure that the sum of all recipient shares equals TOTAL_BASIS_POINTS to guarantee full distribution and no residual funds left in the contract (unless intentional).","title":"Shares Configuration"},{"location":"smart-contracts/interfaces/ifee-distributor/#modularity","text":"Separation of Concerns : Keep fee distribution logic separate from other core application logic. Upgradeable : Design the contract to be upgradeable if shares or recipients might change frequently or if new distribution logic is anticipated.","title":"Modularity"},{"location":"smart-contracts/interfaces/ifee-distributor/#gas-efficiency","text":"Array Iteration : Be mindful of gas costs for iterating over a large number of recipients; large arrays can become expensive. Consider a pull-based mechanism for recipients to claim their funds if recipient count is very high.","title":"Gas Efficiency"},{"location":"smart-contracts/interfaces/ifee-distributor/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/ifee-distributor/#frontend-integration-reactweb3modal","text":"import { ethers } from 'ethers' ; import feeDistributorABI from './FeeDistributor.json' ; // ABI of the FeeDistributor contract const FEE_DISTRIBUTOR_ADDRESS = \"0x...\" ; // Deploy address of your FeeDistributor contract const getProvider = () => new ethers . providers . Web3Provider ( window . ethereum ); const getSigner = () => getProvider (). getSigner (); const getFeeDistributorContract = () => new ethers . Contract ( FEE_DISTRIBUTOR_ADDRESS , feeDistributorABI , getSigner ()); async function handleDistributeFees ( tokenAddress : string ) { try { const feeDistributor = getFeeDistributorContract (); const tx = await feeDistributor . distributeFees ( tokenAddress ); await tx . wait (); alert ( \"Fees distributed successfully!\" ); } catch ( error ) { console . error ( \"Error distributing fees:\" , error ); alert ( \"Failed to distribute fees.\" ); } } async function handleAddRecipient ( recipientAddress : string , share : number ) { try { const feeDistributor = getFeeDistributorContract (); // Assuming share is in basis points, e.g., 2500 for 25% const tx = await feeDistributor . addRecipient ( recipientAddress , share ); await tx . wait (); alert ( \"Recipient added successfully!\" ); } catch ( error ) { console . error ( \"Error adding recipient:\" , error ); alert ( \"Failed to add recipient.\" ); } } // Example usage in a React component // <button onClick={() => handleDistributeFees(\"0x0000000000000000000000000000000000000000\")}>Distribute ETH Fees</button> // <button onClick={() => handleAddRecipient(\"0xRecipientAddress\", 1000)}>Add 10% Recipient</button>","title":"Frontend Integration (React/Web3Modal)"},{"location":"smart-contracts/interfaces/ifee-distributor/#backend-integration-nodejsethersjs","text":"const { ethers } = require ( \"ethers\" ); const FeeDistributorABI = require ( \"./FeeDistributor.json\" ). abi ; const provider = new ethers . JsonRpcProvider ( \"YOUR_RPC_URL\" ); const wallet = new ethers . Wallet ( \"YOUR_PRIVATE_KEY\" , provider ); const feeDistributorAddress = \"0x...\" ; // Your deployed FeeDistributor contract address const feeDistributorContract = new ethers . Contract ( feeDistributorAddress , FeeDistributorABI , wallet ); async function performFeeDistribution ( tokenAddress ) { try { console . log ( `Initiating fee distribution for ${ tokenAddress === ethers . ZeroAddress ? \"ETH\" : \"ERC20 token\" } ...` ); const tx = await feeDistributorContract . distributeFees ( tokenAddress ); await tx . wait (); console . log ( `Distribution transaction successful: ${ tx . hash } ` ); } catch ( error ) { console . error ( \"Error during fee distribution:\" , error ); throw error ; } } async function addNewRecipient ( address , share ) { try { console . log ( `Adding new recipient ${ address } with share ${ share } ...` ); const tx = await feeDistributorContract . addRecipient ( address , share ); await tx . wait (); console . log ( `Recipient added transaction successful: ${ tx . hash } ` ); } catch ( error ) { console . error ( \"Error adding new recipient:\" , error ); throw error ; } } // Example usage // performFeeDistribution(ethers.ZeroAddress); // Distribute ETH // addNewRecipient(\"0xNewRecipientAddress\", 500); // Add a recipient with 5% share","title":"Backend Integration (Node.js/Ethers.js)"},{"location":"smart-contracts/interfaces/ifee-distributor/#related-documentation","text":"Fee Distributor Library ERC20 Standard Ownable Contract Safemath Library","title":"Related Documentation"},{"location":"smart-contracts/interfaces/ifee-distributor/#standards-compliance","text":"ERC20 : Compatible with ERC20 tokens for distribution. Ownable : Utilizes OpenZeppelin's Ownable for administrative access control.","title":"Standards Compliance"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/","text":"IGemforceMinterFacet Interface \u00b6 The IGemforceMinterFacet interface defines the standard functions for a minter facet within a Gemforce Diamond contract, specifically designed for minting and managing Gemforce-specific NFTs. This facet integrates with the core tokenization and attribute management systems of the Gemforce platform. Overview \u00b6 IGemforceMinterFacet provides: NFT Minting : Functions to create new NFTs with specified metadata and attributes. Supply Management : Control over total supply, minted supply, and unique identifiers. Attribute Integration : Seamless integration with the platform's attribute system. Royalty/Fee Handling : Mechanisms to define and collect royalties or minting fees. Event Tracking : Comprehensive event logging for all minting operations. Key Features \u00b6 Minting Operations \u00b6 Single Mint : Mint one NFT at a time. Batch Mint : Mint multiple NFTs in a single transaction for efficiency. Custom Metadata : Attach custom metadata and attributes during minting. Pre-minting Hooks : Support for pre-minting validation or logic. Supply and Identifier Management \u00b6 Token ID Generation : Strategies for unique token ID generation. Supply Tracking : Keep track of total minted NFTs. Provenance : Record minter and minting timestamp. Royalty and Fee Mechanisms \u00b6 Configurable Royalties : Define royalty percentages and recipients. Minting Fees : Charge fees for minting operations. Fee Distribution : Integration with fee distribution mechanisms. Interface Definition \u00b6 interface IGemforceMinterFacet { // Events event GemforceMinted ( address indexed minter , uint256 indexed tokenId , uint256 indexed quantity , address indexed receiver , bytes metadataURI , bytes attributes ); event GemforceBatchMinted ( address indexed minter , uint256 [] tokenIds , uint256 [] quantities , address indexed receiver , bytes metadataURI , bytes attributes ); event MintFeeSet ( address indexed token , uint256 amount ); event RoyaltyInfoSet ( address indexed receiver , uint96 feeNumerator ); event BaseURIUpdated ( string newBaseURI ); // Structs struct MintConfig { uint256 initialSupply ; uint256 pricePerUnit ; address paymentToken ; // Address of ERC20 token for payment, or address(0) for native currency uint256 maxSupply ; bool isPausable ; bool isBridgeable ; string name ; string symbol ; string baseURI ; string contractURI ; bytes extraData ; // For custom metadata or specific minting logic } struct MintBatchParams { uint256 [] quantities ; address receiver ; bytes attributesData ; bytes metadataURI ; } // Core Minting Functions function mint ( address receiver , uint256 quantity , bytes attributesData , bytes metadataURI ) external payable returns ( uint256 newTokenId ); function mintBatch ( MintBatchParams [] calldata mintParams ) external payable ; // Configuration Functions function setMintFee ( address paymentToken , uint256 amount ) external ; function setRoyaltyInfo ( address receiver , uint96 feeNumerator ) external ; function setBaseURI ( string memory newBaseURI ) external ; function setContractURI ( string memory newContractURI ) external ; function setMaxSupply ( uint256 newMaxSupply ) external ; // View Functions function getMintFee ( address paymentToken ) external view returns ( uint256 ); function getRoyaltyInfo ( uint256 tokenId , uint256 salePrice ) external view returns ( address receiver , uint256 royaltyAmount ); function getBaseURI () external view returns ( string memory ); function getContractURI () external view returns ( string memory ); function getMaxSupply () external view returns ( uint256 ); function getTotalMintedSupply () external view returns ( uint256 ); function isPaused () external view returns ( bool ); } Core Functions \u00b6 mint() \u00b6 Mints a single or a specified quantity of new Gemforce NFTs to a designated receiver. Parameters: - receiver : The address to receive the minted NFTs. - quantity : The number of NFTs to mint. - attributesData : Bytes array containing encoded attribute data for the NFTs. - metadataURI : URI pointing to off-chain metadata (e.g., JSON file). Behavior: - Handles payment of minting fees, if configured. - Increments the total minted supply. Usage: // Mint 1 NFT to a specific address with attributes and metadata URI gemforceMinter . mint ( recipientAddress , 1 , abi . encodePacked ( \"color\" , \"red\" , \"size\" , \"L\" ), \"ipfs://example.com/metadata/1.json\" ); // Mint 5 NFTs (if applicable) gemforceMinter . mint ( recipientAddress , 5 , abi . encodePacked ( \"series\" , \"A\" ), \"ipfs://example.com/metadata/series_a.json\" ); mintBatch() \u00b6 Mints multiple batches of NFTs in a single transaction. Each element in mintParams represents a separate minting operation with its own quantity, receiver, attributes, and metadata. Parameters: - mintParams : An array of MintBatchParams structs, each detailing a batch minting request. Usage: IGemforceMinterFacet . MintBatchParams [] memory batches = new IGemforceMinterFacet . MintBatchParams []( 2 ); batches [ 0 ] = IGemforceMinterFacet . MintBatchParams ({ quantities : 10 , receiver : user1 , attributesData : abi . encodePacked ( \"tier\" , \"gold\" ), metadataURI : \"ipfs://gold.json\" }); batches [ 1 ] = IGemforceMinterFacet . MintBatchParams ({ quantities : 5 , receiver : user2 , attributesData : abi . encodePacked ( \"tier\" , \"silver\" ), metadataURI : \"ipfs://silver.json\" }); gemforceMinter . mintBatch ( batches ); setMintFee() \u00b6 Sets the minting fee for a specific payment token. Parameters: - paymentToken : The address of the ERC20 token to be used for fee payment, or address(0) for native currency (ETH). - amount : The amount of the specified paymentToken required per mint. setRoyaltyInfo() \u00b6 Sets the royalty information for the NFTs minted by this facet. Parameters: - receiver : The address that will receive the royalties. - feeNumerator : A fraction (numerator) used to calculate the royalty amount from the sale price, compatible with EIP-2981. Implementation Example \u00b6 import \"@openzeppelin/contracts/token/ERC721/IERC721.sol\" ; import \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\" ; import \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\" ; import \"@openzeppelin/contracts/token/common/ERC2981.sol\" ; import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/utils/Context.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; // Assuming LibDiamond and AttributeLib are available through the Diamond interface IDiamond { function owner () external view returns ( address ); function addFunction ( address functionToCall , bytes4 _selector ) external ; function removeFunction ( bytes4 _selector ) external ; } library AttributeLib { function setAttributes ( uint256 tokenId , bytes calldata data ) internal ; // other attribute-related functions } contract GemforceMinterFacet is IGemforceMinterFacet , ERC2981 , Ownable { using Counters for Counters . Counter ; Counters . Counter private _tokenIdCounter ; string private _baseURI ; string private _contractURI ; uint256 private _maxSupply ; uint256 private _totalMintedSupply ; mapping ( address => uint256 ) private _mintFees ; // paymentToken => feeAmount address private _royaltyReceiver ; uint96 private _royaltyFeeNumerator ; // ERC165 support bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd ; bytes4 private constant _INTERFACE_ID_ERC721ENUMERABLE = 0x780e9d63 ; bytes4 private constant _INTERFACE_ID_ERC721METADATA = 0x5b5e139f ; constructor ( uint256 maxSupply_ , string memory baseURI_ , string memory contractURI_ ) { _maxSupply = maxSupply_ ; _baseURI = baseURI_ ; _contractURI = contractURI_ ; // _setOwner(msg.sender); // In a diamond, owner is typically set by OwnershipFacet } // This needs to be hooked up to the ERC721 token's _mint function (e.g. from ERC721Facet) // For demonstration, we simulate the mint function _safeMint ( address to , uint256 tokenId ) internal { require ( _totalMintedSupply < _maxSupply , \"Supply limit reached\" ); // In a real diamond, this would call into an ERC721Facet or similar // For now, we increment the counter and minted supply _tokenIdCounter . increment (); _totalMintedSupply ++ ; // emit Transfer(address(0), to, tokenId); // Simulate ERC721 Transfer event } function mint ( address receiver , uint256 quantity , bytes attributesData , bytes metadataURI ) external payable override returns ( uint256 newTokenId ) { require ( receiver != address ( 0 ), \"Receiver cannot be zero address\" ); require ( quantity > 0 , \"Quantity must be greater than 0\" ); require ( _totalMintedSupply + quantity <= _maxSupply , \"Exceeds max supply\" ); // Handle mint fees uint256 requiredFee = _mintFees [ address ( 0 )] * quantity ; // For native currency if ( requiredFee > 0 ) { require ( msg.value >= requiredFee , \"Insufficient ETH for mint fee\" ); // Transfer excess ETH back if ( msg.value > requiredFee ) { payable ( msg.sender ). transfer ( msg.value - requiredFee ); } // Transfer fee to owner/fee collector (assuming owner is fee collector) payable ( owner ()). transfer ( requiredFee ); } // For ERC20 fee, it would be an ERC20.transferFrom call before minting newTokenId = _tokenIdCounter . current (); for ( uint256 i = 0 ; i < quantity ; i ++ ) { _safeMint ( receiver , newTokenId + i ); AttributeLib . setAttributes ( newTokenId + i , attributesData ); // Integrate with attribute system // Associated metadataURI could be stored or linked } emit GemforceMinted ( msg.sender , newTokenId , quantity , receiver , metadataURI , attributesData ); } function mintBatch ( MintBatchParams [] calldata mintParams ) external payable override { uint256 totalQuantity = 0 ; uint256 totalEthFee = 0 ; for ( uint256 i = 0 ; i < mintParams . length ; i ++ ) { require ( mintParams [ i ]. quantities > 0 , \"Quantity must be greater than 0\" ); require ( mintParams [ i ]. receiver != address ( 0 ), \"Receiver cannot be zero address\" ); totalQuantity += mintParams [ i ]. quantities ; totalEthFee += _mintFees [ address ( 0 )] * mintParams [ i ]. quantities ; } require ( _totalMintedSupply + totalQuantity <= _maxSupply , \"Exceeds max supply for batch mint\" ); if ( totalEthFee > 0 ) { require ( msg.value >= totalEthFee , \"Insufficient ETH for batch mint fee\" ); // Transfer excess ETH back if any if ( msg.value > totalEthFee ) { payable ( msg.sender ). transfer ( msg.value - totalEthFee ); } payable ( owner ()). transfer ( totalEthFee ); // Transfer total fee } for ( uint256 i = 0 ; i < mintParams . length ; i ++ ) { uint256 currentTokenId = _tokenIdCounter . current (); for ( uint256 j = 0 ; j < mintParams [ i ]. quantities ; j ++ ) { _safeMint ( mintParams [ i ]. receiver , currentTokenId + j ); AttributeLib . setAttributes ( currentTokenId + j , mintParams [ i ]. attributesData ); } emit GemforceBatchMinted ( msg.sender , _getTokenIdsFromRange ( currentTokenId , mintParams [ i ]. quantities ), new uint256 []( 0 ), // quantities for each token, if different mintParams [ i ]. receiver , mintParams [ i ]. metadataURI , mintParams [ i ]. attributesData ); } } function _getTokenIdsFromRange ( uint256 startTokenId , uint256 count ) internal pure returns ( uint256 [] memory ) { uint256 [] memory tokenIds = new uint256 []( count ); for ( uint256 i = 0 ; i < count ; i ++ ) { tokenIds [ i ] = startTokenId + i ; } return tokenIds ; } function setMintFee ( address paymentToken , uint256 amount ) external override onlyOwner { _mintFees [ paymentToken ] = amount ; emit MintFeeSet ( paymentToken , amount ); } function getMintFee ( address paymentToken ) external view override returns ( uint256 ) { return _mintFees [ paymentToken ]; } function setRoyaltyInfo ( address receiver , uint96 feeNumerator ) external override onlyOwner { _royaltyReceiver = receiver ; _royaltyFeeNumerator = feeNumerator ; emit RoyaltyInfoSet ( receiver , feeNumerator ); _setDefaultRoyalty ( receiver , feeNumerator ); // Sets default for ERC2981 } // Override the ERC2981 royaltyInfo to always use the contract-wide settings function royaltyInfo ( uint256 _tokenId , uint256 _salePrice ) public view override returns ( address receiver , uint256 royaltyAmount ) { return ( _royaltyReceiver , _salePrice * _royaltyFeeNumerator / ERC2981_DENOMINATOR ); } function getBaseURI () external view override returns ( string memory ) { return _baseURI ; } function setBaseURI ( string memory newBaseURI ) external override onlyOwner { _baseURI = newBaseURI ; emit BaseURIUpdated ( newBaseURI ); } function getContractURI () external view override returns ( string memory ) { return _contractURI ; } function setContractURI ( string memory newContractURI ) external override onlyOwner { _contractURI = newContractURI ; } function getMaxSupply () external view override returns ( uint256 ) { return _maxSupply ; } function setMaxSupply ( uint256 newMaxSupply ) external override onlyOwner { require ( newMaxSupply >= _totalMintedSupply , \"New max supply cannot be less than minted supply\" ); _maxSupply = newMaxSupply ; } function getTotalMintedSupply () external view override returns ( uint256 ) { return _totalMintedSupply ; } function isPaused () external view override returns ( bool ) { // This would typically involve a Pausable contract or similar logic return false ; } // ERC165 support function supportsInterface ( bytes4 interfaceId ) public view virtual override ( ERC2981 , Context ) returns ( bool ) { return interfaceId == type ( IGemforceMinterFacet ). interfaceId || interfaceId == _INTERFACE_ID_ERC721 || // Placeholder, assuming underlying ERC721 interfaceId == _INTERFACE_ID_ERC721METADATA || interfaceId == _INTERFACE_ID_ERC721ENUMERABLE || super . supportsInterface ( interfaceId ); } } Security Considerations \u00b6 Access Control \u00b6 Owner Privileges : Crucial functions like setMintFee , setRoyaltyInfo , setBaseURI , and setMaxSupply must be restricted to the contract owner or an authorized administrator. Diamond Integration : Ensure that the facet's access control aligns with the overall Diamond contract's ownership and access management. Supply Management \u00b6 Max Supply Enforcement : Rigorous checks to prevent minting beyond the maxSupply . Token ID Uniqueness : Ensure that minted token IDs are unique and avoid collisions. Re-entrancy : While low risk for simple minting, complex payment or external calls within mint operations should implement re-entrancy guards. Fee Handling \u00b6 Eth/Token Distinction : Correctly handle native currency (ETH) payments versus ERC20 token payments, ensuring proper msg.value checks and transferFrom calls. Overpayment/Underpayment : Implement mechanisms to refund overpayments or revert if underpaid. Best Practices \u00b6 Metadata and Attributes \u00b6 URI Standards : Adhere to established standards (e.g., EIP-1577 for ERC721Metadata or contractURI for collection-level metadata) for off-chain metadata. On-chain Attributes : Utilize a dedicated attribute system (like AttributeLib ) for on-chain verifiable traits, ensuring data integrity. Efficiency \u00b6 Batch Operations : Provide batch minting functionality ( mintBatch ) to reduce transaction costs for users minting multiple NFTs. Gas Optimization : Optimize internal logic to minimize gas consumption, especially for frequently called functions. Modularity \u00b6 Facet Separation : Ensure functions related to minting are encapsulated within this facet, adhering to the Diamond Standard's principle of modularity. Upgradeability : Design the facet to be easily upgradeable or replaceable within the Diamond structure. Integration Examples \u00b6 Frontend Integration (TypeScript via Ethers.js) \u00b6 import { ethers , Contract } from 'ethers' ; import MinterFacetABI from './GemforceMinterFacet.json' ; // ABI for the IGemforceMinterFacet const MINTER_FACET_ADDRESS = \"0x...\" ; // Address of the deployed MinterFacet within the Diamond const DIAMOND_ADDRESS = \"0x...\" ; // Address of the Diamond contract itself // Assuming provider from WalletConnect, Metamask, etc. const getSigner = () => new ethers . providers . Web3Provider ( window . ethereum ). getSigner (); const getMinterFacet = () => new Contract ( MINTER_FACET_ADDRESS , MinterFacetABI , getSigner ()); interface MintParams { receiver : string ; quantity : number ; attributesData : string ; // Hex string for bytes metadataURI : string ; value? : ethers.BigNumberish ; // For ETH payment } async function handleMintNFT ( params : MintParams ) { try { const minterFacet = getMinterFacet (); const tx = await minterFacet . mint ( params . receiver , params . quantity , ethers . utils . arrayify ( params . attributesData ), // Convert hex string to bytes array ethers . utils . toUtf8Bytes ( params . metadataURI ), // Convert string to bytes array { value : params.value } ); await tx . wait (); alert ( \"NFT minted successfully!\" ); console . log ( \"Mint Transaction Hash:\" , tx . hash ); } catch ( error ) { console . error ( \"Error minting NFT:\" , error ); alert ( \"Failed to mint NFT. Check console for details.\" ); } } async function handleSetMintFee ( paymentTokenAddress : string , amount : ethers.BigNumberish ) { try { const minterFacet = getMinterFacet (); const tx = await minterFacet . setMintFee ( paymentTokenAddress , amount ); await tx . wait (); alert ( \"Mint fee updated.\" ); } catch ( error ) { console . error ( \"Error setting mint fee:\" , error ); alert ( \"Failed to set mint fee.\" ); } } Backend Integration (Node.js/Web3.js for off-chain minting trigger) \u00b6 const Web3 = require ( 'web3' ); const GemforceMinterFacetABI = require ( './GemforceMinterFacet.json' ). abi ; const web3 = new Web3 ( 'YOUR_ETHEREUM_RPC_URL' ); const minterFacetAddress = '0x...' ; // Address of your deployed minter facet const adminPrivateKey = 'YOUR_ADMIN_PRIVATE_KEY' ; // Private key of the account authorized to mint const minterFacetContract = new web3 . eth . Contract ( GemforceMinterFacetABI , minterFacetAddress ); const adminAccount = web3 . eth . accounts . privateKeyToAccount ( adminPrivateKey ); web3 . eth . accounts . wallet . add ( adminAccount ); async function triggerMint ( receiverAddress , quantity , attributesDataHex , metadataURI ) { try { console . log ( `Triggering mint for ${ quantity } NFTs to ${ receiverAddress } ...` ); const tx = minterFacetContract . methods . mint ( receiverAddress , quantity , web3 . utils . hexToBytes ( attributesDataHex ), web3 . utils . hexToBytes ( web3 . utils . utf8ToHex ( metadataURI )) ); const gas = await tx . estimateGas ({ from : adminAccount . address }); const receipt = await tx . send ({ from : adminAccount . address , gas : gas }); console . log ( 'Mint transaction sent:' , receipt . transactionHash ); return receipt ; } catch ( error ) { console . error ( 'Error triggering mint:' , error ); throw error ; } } // Example usage // triggerMint(\"0xUserWalletAddress\", 1, \"0xabcdef123456\", \"https://api.example.com/nft/1\"); Related Documentation \u00b6 Diamond Standard Overview Attribute Library Fee Distributor Library EIP-2981 NFT Royalty Standard ERC721 Standard Standards Compliance \u00b6 EIP-2535 : Designed as a facet for the Diamond Standard. EIP-2981 : Implements the NFT Royalty Standard for royalty distribution. ERC721 : Provides minting functionality for ERC721-compatible NFTs (assumes an underlying ERC721 facet for actual token management). ERC165 : Supports interface detection.","title":"IGemforceMinterFacet"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#igemforceminterfacet-interface","text":"The IGemforceMinterFacet interface defines the standard functions for a minter facet within a Gemforce Diamond contract, specifically designed for minting and managing Gemforce-specific NFTs. This facet integrates with the core tokenization and attribute management systems of the Gemforce platform.","title":"IGemforceMinterFacet Interface"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#overview","text":"IGemforceMinterFacet provides: NFT Minting : Functions to create new NFTs with specified metadata and attributes. Supply Management : Control over total supply, minted supply, and unique identifiers. Attribute Integration : Seamless integration with the platform's attribute system. Royalty/Fee Handling : Mechanisms to define and collect royalties or minting fees. Event Tracking : Comprehensive event logging for all minting operations.","title":"Overview"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#minting-operations","text":"Single Mint : Mint one NFT at a time. Batch Mint : Mint multiple NFTs in a single transaction for efficiency. Custom Metadata : Attach custom metadata and attributes during minting. Pre-minting Hooks : Support for pre-minting validation or logic.","title":"Minting Operations"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#supply-and-identifier-management","text":"Token ID Generation : Strategies for unique token ID generation. Supply Tracking : Keep track of total minted NFTs. Provenance : Record minter and minting timestamp.","title":"Supply and Identifier Management"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#royalty-and-fee-mechanisms","text":"Configurable Royalties : Define royalty percentages and recipients. Minting Fees : Charge fees for minting operations. Fee Distribution : Integration with fee distribution mechanisms.","title":"Royalty and Fee Mechanisms"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#interface-definition","text":"interface IGemforceMinterFacet { // Events event GemforceMinted ( address indexed minter , uint256 indexed tokenId , uint256 indexed quantity , address indexed receiver , bytes metadataURI , bytes attributes ); event GemforceBatchMinted ( address indexed minter , uint256 [] tokenIds , uint256 [] quantities , address indexed receiver , bytes metadataURI , bytes attributes ); event MintFeeSet ( address indexed token , uint256 amount ); event RoyaltyInfoSet ( address indexed receiver , uint96 feeNumerator ); event BaseURIUpdated ( string newBaseURI ); // Structs struct MintConfig { uint256 initialSupply ; uint256 pricePerUnit ; address paymentToken ; // Address of ERC20 token for payment, or address(0) for native currency uint256 maxSupply ; bool isPausable ; bool isBridgeable ; string name ; string symbol ; string baseURI ; string contractURI ; bytes extraData ; // For custom metadata or specific minting logic } struct MintBatchParams { uint256 [] quantities ; address receiver ; bytes attributesData ; bytes metadataURI ; } // Core Minting Functions function mint ( address receiver , uint256 quantity , bytes attributesData , bytes metadataURI ) external payable returns ( uint256 newTokenId ); function mintBatch ( MintBatchParams [] calldata mintParams ) external payable ; // Configuration Functions function setMintFee ( address paymentToken , uint256 amount ) external ; function setRoyaltyInfo ( address receiver , uint96 feeNumerator ) external ; function setBaseURI ( string memory newBaseURI ) external ; function setContractURI ( string memory newContractURI ) external ; function setMaxSupply ( uint256 newMaxSupply ) external ; // View Functions function getMintFee ( address paymentToken ) external view returns ( uint256 ); function getRoyaltyInfo ( uint256 tokenId , uint256 salePrice ) external view returns ( address receiver , uint256 royaltyAmount ); function getBaseURI () external view returns ( string memory ); function getContractURI () external view returns ( string memory ); function getMaxSupply () external view returns ( uint256 ); function getTotalMintedSupply () external view returns ( uint256 ); function isPaused () external view returns ( bool ); }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#mint","text":"Mints a single or a specified quantity of new Gemforce NFTs to a designated receiver. Parameters: - receiver : The address to receive the minted NFTs. - quantity : The number of NFTs to mint. - attributesData : Bytes array containing encoded attribute data for the NFTs. - metadataURI : URI pointing to off-chain metadata (e.g., JSON file). Behavior: - Handles payment of minting fees, if configured. - Increments the total minted supply. Usage: // Mint 1 NFT to a specific address with attributes and metadata URI gemforceMinter . mint ( recipientAddress , 1 , abi . encodePacked ( \"color\" , \"red\" , \"size\" , \"L\" ), \"ipfs://example.com/metadata/1.json\" ); // Mint 5 NFTs (if applicable) gemforceMinter . mint ( recipientAddress , 5 , abi . encodePacked ( \"series\" , \"A\" ), \"ipfs://example.com/metadata/series_a.json\" );","title":"mint()"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#mintbatch","text":"Mints multiple batches of NFTs in a single transaction. Each element in mintParams represents a separate minting operation with its own quantity, receiver, attributes, and metadata. Parameters: - mintParams : An array of MintBatchParams structs, each detailing a batch minting request. Usage: IGemforceMinterFacet . MintBatchParams [] memory batches = new IGemforceMinterFacet . MintBatchParams []( 2 ); batches [ 0 ] = IGemforceMinterFacet . MintBatchParams ({ quantities : 10 , receiver : user1 , attributesData : abi . encodePacked ( \"tier\" , \"gold\" ), metadataURI : \"ipfs://gold.json\" }); batches [ 1 ] = IGemforceMinterFacet . MintBatchParams ({ quantities : 5 , receiver : user2 , attributesData : abi . encodePacked ( \"tier\" , \"silver\" ), metadataURI : \"ipfs://silver.json\" }); gemforceMinter . mintBatch ( batches );","title":"mintBatch()"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#setmintfee","text":"Sets the minting fee for a specific payment token. Parameters: - paymentToken : The address of the ERC20 token to be used for fee payment, or address(0) for native currency (ETH). - amount : The amount of the specified paymentToken required per mint.","title":"setMintFee()"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#setroyaltyinfo","text":"Sets the royalty information for the NFTs minted by this facet. Parameters: - receiver : The address that will receive the royalties. - feeNumerator : A fraction (numerator) used to calculate the royalty amount from the sale price, compatible with EIP-2981.","title":"setRoyaltyInfo()"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#implementation-example","text":"import \"@openzeppelin/contracts/token/ERC721/IERC721.sol\" ; import \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\" ; import \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\" ; import \"@openzeppelin/contracts/token/common/ERC2981.sol\" ; import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/utils/Context.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; // Assuming LibDiamond and AttributeLib are available through the Diamond interface IDiamond { function owner () external view returns ( address ); function addFunction ( address functionToCall , bytes4 _selector ) external ; function removeFunction ( bytes4 _selector ) external ; } library AttributeLib { function setAttributes ( uint256 tokenId , bytes calldata data ) internal ; // other attribute-related functions } contract GemforceMinterFacet is IGemforceMinterFacet , ERC2981 , Ownable { using Counters for Counters . Counter ; Counters . Counter private _tokenIdCounter ; string private _baseURI ; string private _contractURI ; uint256 private _maxSupply ; uint256 private _totalMintedSupply ; mapping ( address => uint256 ) private _mintFees ; // paymentToken => feeAmount address private _royaltyReceiver ; uint96 private _royaltyFeeNumerator ; // ERC165 support bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd ; bytes4 private constant _INTERFACE_ID_ERC721ENUMERABLE = 0x780e9d63 ; bytes4 private constant _INTERFACE_ID_ERC721METADATA = 0x5b5e139f ; constructor ( uint256 maxSupply_ , string memory baseURI_ , string memory contractURI_ ) { _maxSupply = maxSupply_ ; _baseURI = baseURI_ ; _contractURI = contractURI_ ; // _setOwner(msg.sender); // In a diamond, owner is typically set by OwnershipFacet } // This needs to be hooked up to the ERC721 token's _mint function (e.g. from ERC721Facet) // For demonstration, we simulate the mint function _safeMint ( address to , uint256 tokenId ) internal { require ( _totalMintedSupply < _maxSupply , \"Supply limit reached\" ); // In a real diamond, this would call into an ERC721Facet or similar // For now, we increment the counter and minted supply _tokenIdCounter . increment (); _totalMintedSupply ++ ; // emit Transfer(address(0), to, tokenId); // Simulate ERC721 Transfer event } function mint ( address receiver , uint256 quantity , bytes attributesData , bytes metadataURI ) external payable override returns ( uint256 newTokenId ) { require ( receiver != address ( 0 ), \"Receiver cannot be zero address\" ); require ( quantity > 0 , \"Quantity must be greater than 0\" ); require ( _totalMintedSupply + quantity <= _maxSupply , \"Exceeds max supply\" ); // Handle mint fees uint256 requiredFee = _mintFees [ address ( 0 )] * quantity ; // For native currency if ( requiredFee > 0 ) { require ( msg.value >= requiredFee , \"Insufficient ETH for mint fee\" ); // Transfer excess ETH back if ( msg.value > requiredFee ) { payable ( msg.sender ). transfer ( msg.value - requiredFee ); } // Transfer fee to owner/fee collector (assuming owner is fee collector) payable ( owner ()). transfer ( requiredFee ); } // For ERC20 fee, it would be an ERC20.transferFrom call before minting newTokenId = _tokenIdCounter . current (); for ( uint256 i = 0 ; i < quantity ; i ++ ) { _safeMint ( receiver , newTokenId + i ); AttributeLib . setAttributes ( newTokenId + i , attributesData ); // Integrate with attribute system // Associated metadataURI could be stored or linked } emit GemforceMinted ( msg.sender , newTokenId , quantity , receiver , metadataURI , attributesData ); } function mintBatch ( MintBatchParams [] calldata mintParams ) external payable override { uint256 totalQuantity = 0 ; uint256 totalEthFee = 0 ; for ( uint256 i = 0 ; i < mintParams . length ; i ++ ) { require ( mintParams [ i ]. quantities > 0 , \"Quantity must be greater than 0\" ); require ( mintParams [ i ]. receiver != address ( 0 ), \"Receiver cannot be zero address\" ); totalQuantity += mintParams [ i ]. quantities ; totalEthFee += _mintFees [ address ( 0 )] * mintParams [ i ]. quantities ; } require ( _totalMintedSupply + totalQuantity <= _maxSupply , \"Exceeds max supply for batch mint\" ); if ( totalEthFee > 0 ) { require ( msg.value >= totalEthFee , \"Insufficient ETH for batch mint fee\" ); // Transfer excess ETH back if any if ( msg.value > totalEthFee ) { payable ( msg.sender ). transfer ( msg.value - totalEthFee ); } payable ( owner ()). transfer ( totalEthFee ); // Transfer total fee } for ( uint256 i = 0 ; i < mintParams . length ; i ++ ) { uint256 currentTokenId = _tokenIdCounter . current (); for ( uint256 j = 0 ; j < mintParams [ i ]. quantities ; j ++ ) { _safeMint ( mintParams [ i ]. receiver , currentTokenId + j ); AttributeLib . setAttributes ( currentTokenId + j , mintParams [ i ]. attributesData ); } emit GemforceBatchMinted ( msg.sender , _getTokenIdsFromRange ( currentTokenId , mintParams [ i ]. quantities ), new uint256 []( 0 ), // quantities for each token, if different mintParams [ i ]. receiver , mintParams [ i ]. metadataURI , mintParams [ i ]. attributesData ); } } function _getTokenIdsFromRange ( uint256 startTokenId , uint256 count ) internal pure returns ( uint256 [] memory ) { uint256 [] memory tokenIds = new uint256 []( count ); for ( uint256 i = 0 ; i < count ; i ++ ) { tokenIds [ i ] = startTokenId + i ; } return tokenIds ; } function setMintFee ( address paymentToken , uint256 amount ) external override onlyOwner { _mintFees [ paymentToken ] = amount ; emit MintFeeSet ( paymentToken , amount ); } function getMintFee ( address paymentToken ) external view override returns ( uint256 ) { return _mintFees [ paymentToken ]; } function setRoyaltyInfo ( address receiver , uint96 feeNumerator ) external override onlyOwner { _royaltyReceiver = receiver ; _royaltyFeeNumerator = feeNumerator ; emit RoyaltyInfoSet ( receiver , feeNumerator ); _setDefaultRoyalty ( receiver , feeNumerator ); // Sets default for ERC2981 } // Override the ERC2981 royaltyInfo to always use the contract-wide settings function royaltyInfo ( uint256 _tokenId , uint256 _salePrice ) public view override returns ( address receiver , uint256 royaltyAmount ) { return ( _royaltyReceiver , _salePrice * _royaltyFeeNumerator / ERC2981_DENOMINATOR ); } function getBaseURI () external view override returns ( string memory ) { return _baseURI ; } function setBaseURI ( string memory newBaseURI ) external override onlyOwner { _baseURI = newBaseURI ; emit BaseURIUpdated ( newBaseURI ); } function getContractURI () external view override returns ( string memory ) { return _contractURI ; } function setContractURI ( string memory newContractURI ) external override onlyOwner { _contractURI = newContractURI ; } function getMaxSupply () external view override returns ( uint256 ) { return _maxSupply ; } function setMaxSupply ( uint256 newMaxSupply ) external override onlyOwner { require ( newMaxSupply >= _totalMintedSupply , \"New max supply cannot be less than minted supply\" ); _maxSupply = newMaxSupply ; } function getTotalMintedSupply () external view override returns ( uint256 ) { return _totalMintedSupply ; } function isPaused () external view override returns ( bool ) { // This would typically involve a Pausable contract or similar logic return false ; } // ERC165 support function supportsInterface ( bytes4 interfaceId ) public view virtual override ( ERC2981 , Context ) returns ( bool ) { return interfaceId == type ( IGemforceMinterFacet ). interfaceId || interfaceId == _INTERFACE_ID_ERC721 || // Placeholder, assuming underlying ERC721 interfaceId == _INTERFACE_ID_ERC721METADATA || interfaceId == _INTERFACE_ID_ERC721ENUMERABLE || super . supportsInterface ( interfaceId ); } }","title":"Implementation Example"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#access-control","text":"Owner Privileges : Crucial functions like setMintFee , setRoyaltyInfo , setBaseURI , and setMaxSupply must be restricted to the contract owner or an authorized administrator. Diamond Integration : Ensure that the facet's access control aligns with the overall Diamond contract's ownership and access management.","title":"Access Control"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#supply-management","text":"Max Supply Enforcement : Rigorous checks to prevent minting beyond the maxSupply . Token ID Uniqueness : Ensure that minted token IDs are unique and avoid collisions. Re-entrancy : While low risk for simple minting, complex payment or external calls within mint operations should implement re-entrancy guards.","title":"Supply Management"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#fee-handling","text":"Eth/Token Distinction : Correctly handle native currency (ETH) payments versus ERC20 token payments, ensuring proper msg.value checks and transferFrom calls. Overpayment/Underpayment : Implement mechanisms to refund overpayments or revert if underpaid.","title":"Fee Handling"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#metadata-and-attributes","text":"URI Standards : Adhere to established standards (e.g., EIP-1577 for ERC721Metadata or contractURI for collection-level metadata) for off-chain metadata. On-chain Attributes : Utilize a dedicated attribute system (like AttributeLib ) for on-chain verifiable traits, ensuring data integrity.","title":"Metadata and Attributes"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#efficiency","text":"Batch Operations : Provide batch minting functionality ( mintBatch ) to reduce transaction costs for users minting multiple NFTs. Gas Optimization : Optimize internal logic to minimize gas consumption, especially for frequently called functions.","title":"Efficiency"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#modularity","text":"Facet Separation : Ensure functions related to minting are encapsulated within this facet, adhering to the Diamond Standard's principle of modularity. Upgradeability : Design the facet to be easily upgradeable or replaceable within the Diamond structure.","title":"Modularity"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#frontend-integration-typescript-via-ethersjs","text":"import { ethers , Contract } from 'ethers' ; import MinterFacetABI from './GemforceMinterFacet.json' ; // ABI for the IGemforceMinterFacet const MINTER_FACET_ADDRESS = \"0x...\" ; // Address of the deployed MinterFacet within the Diamond const DIAMOND_ADDRESS = \"0x...\" ; // Address of the Diamond contract itself // Assuming provider from WalletConnect, Metamask, etc. const getSigner = () => new ethers . providers . Web3Provider ( window . ethereum ). getSigner (); const getMinterFacet = () => new Contract ( MINTER_FACET_ADDRESS , MinterFacetABI , getSigner ()); interface MintParams { receiver : string ; quantity : number ; attributesData : string ; // Hex string for bytes metadataURI : string ; value? : ethers.BigNumberish ; // For ETH payment } async function handleMintNFT ( params : MintParams ) { try { const minterFacet = getMinterFacet (); const tx = await minterFacet . mint ( params . receiver , params . quantity , ethers . utils . arrayify ( params . attributesData ), // Convert hex string to bytes array ethers . utils . toUtf8Bytes ( params . metadataURI ), // Convert string to bytes array { value : params.value } ); await tx . wait (); alert ( \"NFT minted successfully!\" ); console . log ( \"Mint Transaction Hash:\" , tx . hash ); } catch ( error ) { console . error ( \"Error minting NFT:\" , error ); alert ( \"Failed to mint NFT. Check console for details.\" ); } } async function handleSetMintFee ( paymentTokenAddress : string , amount : ethers.BigNumberish ) { try { const minterFacet = getMinterFacet (); const tx = await minterFacet . setMintFee ( paymentTokenAddress , amount ); await tx . wait (); alert ( \"Mint fee updated.\" ); } catch ( error ) { console . error ( \"Error setting mint fee:\" , error ); alert ( \"Failed to set mint fee.\" ); } }","title":"Frontend Integration (TypeScript via Ethers.js)"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#backend-integration-nodejsweb3js-for-off-chain-minting-trigger","text":"const Web3 = require ( 'web3' ); const GemforceMinterFacetABI = require ( './GemforceMinterFacet.json' ). abi ; const web3 = new Web3 ( 'YOUR_ETHEREUM_RPC_URL' ); const minterFacetAddress = '0x...' ; // Address of your deployed minter facet const adminPrivateKey = 'YOUR_ADMIN_PRIVATE_KEY' ; // Private key of the account authorized to mint const minterFacetContract = new web3 . eth . Contract ( GemforceMinterFacetABI , minterFacetAddress ); const adminAccount = web3 . eth . accounts . privateKeyToAccount ( adminPrivateKey ); web3 . eth . accounts . wallet . add ( adminAccount ); async function triggerMint ( receiverAddress , quantity , attributesDataHex , metadataURI ) { try { console . log ( `Triggering mint for ${ quantity } NFTs to ${ receiverAddress } ...` ); const tx = minterFacetContract . methods . mint ( receiverAddress , quantity , web3 . utils . hexToBytes ( attributesDataHex ), web3 . utils . hexToBytes ( web3 . utils . utf8ToHex ( metadataURI )) ); const gas = await tx . estimateGas ({ from : adminAccount . address }); const receipt = await tx . send ({ from : adminAccount . address , gas : gas }); console . log ( 'Mint transaction sent:' , receipt . transactionHash ); return receipt ; } catch ( error ) { console . error ( 'Error triggering mint:' , error ); throw error ; } } // Example usage // triggerMint(\"0xUserWalletAddress\", 1, \"0xabcdef123456\", \"https://api.example.com/nft/1\");","title":"Backend Integration (Node.js/Web3.js for off-chain minting trigger)"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#related-documentation","text":"Diamond Standard Overview Attribute Library Fee Distributor Library EIP-2981 NFT Royalty Standard ERC721 Standard","title":"Related Documentation"},{"location":"smart-contracts/interfaces/igemforce-minter-facet/#standards-compliance","text":"EIP-2535 : Designed as a facet for the Diamond Standard. EIP-2981 : Implements the NFT Royalty Standard for royalty distribution. ERC721 : Provides minting functionality for ERC721-compatible NFTs (assumes an underlying ERC721 facet for actual token management). ERC165 : Supports interface detection.","title":"Standards Compliance"},{"location":"smart-contracts/interfaces/iidentity-registry/","text":"IIdentityRegistry Interface \u00b6 The IIdentityRegistry interface defines the standard for a registry of identity contracts within the Gemforce ecosystem. This registry acts as a central lookup and management system for various identity contracts, allowing for consistent identity resolution and verification across the platform. Overview \u00b6 IIdentityRegistry provides: Identity Resolution : A method to query and retrieve registered identity contract addresses. Registration Management : Functions to add, update, and remove identity entries in the registry. Status Tracking : Keep track of the status (e.g., active, suspended) of registered identities. Event Logging : Comprehensive event tracking for all registry operations. Key Features \u00b6 Identity Registration & Query \u00b6 Register Identity : Link an identity contract address to a user or entity. Query Identity : Retrieve an identity contract address associated with a given identifier. Batch Registration : Register multiple identities efficiently. Status and Access Control \u00b6 Identity Status : Manage and query the active status of registered identities. Ownership/Admin Control : Restrict registration and modification functions to authorized entities. Verification Levels : Potentially integrate with identity verification levels. Decentralized Identifiers (DIDs) Compatibility (Conceptual) \u00b6 Can be designed to store DID-like identifiers or map to them for broader interoperability. Interface Definition \u00b6 interface IIdentityRegistry { // Events event IdentityRegistered ( bytes32 indexed identityHash , address indexed identityAddress , address indexed registrant , string metadataURI ); event IdentityUpdated ( bytes32 indexed identityHash , address indexed identityAddress , address indexed updater , string oldMetadataURI , string newMetadataURI ); event IdentityRemoved ( bytes32 indexed identityHash , address indexed identityAddress , address indexed remover ); event IdentityStatusChanged ( bytes32 indexed identityHash , address indexed identityAddress , bool newStatus , address indexed changer ); // Structs struct IdentityEntry { address identityAddress ; address registrant ; string metadataURI ; bool active ; uint256 registeredAt ; uint256 lastUpdated ; } // Core Functions function registerIdentity ( address _identityAddress , string calldata _metadataURI ) external returns ( bytes32 identityHash ); function registerIdentities ( address [] calldata _identityAddresses , string [] calldata _metadataURIs ) external returns ( bytes32 [] memory identityHashes ); function updateIdentity ( bytes32 _identityHash , string calldata _newMetadataURI ) external ; function removeIdentity ( bytes32 _identityHash ) external ; function setIdentityStatus ( bytes32 _identityHash , bool _newStatus ) external ; // View Functions function getIdentityAddress ( bytes32 _identityHash ) external view returns ( address ); function getIdentityEntry ( bytes32 _identityHash ) external view returns ( IdentityEntry memory ); function isIdentityActive ( bytes32 _identityHash ) external view returns ( bool ); function getIdentityHash ( address _identityAddress ) external view returns ( bytes32 ); // Reverse lookup for the hash function getRegisteredIdentityCount () external view returns ( uint256 ); function getIdentityHashByIndex ( uint256 index ) external view returns ( bytes32 ); } Core Functions \u00b6 registerIdentity() \u00b6 Registers a new identity contract address with an associated metadata URI. A unique identityHash is generated for lookup. Parameters: - _identityAddress : The address of the identity smart contract to register. - _metadataURI : A URI pointing to additional off-chain metadata about the identity. Returns: - bytes32 : A unique hash that identifies this registered identity. Usage: // Register a new identity contract bytes32 myIdentityHash = identityRegistry . registerIdentity ( _newlyDeployedIdentityAddress , \"ipfs://my-identity-meta.json\" ); getIdentityAddress() \u00b6 Retrieves the identity contract address associated with a given identityHash . Parameters: - _identityHash : The unique hash of the registered identity. Returns: - address : The address of the registered identity contract. Returns address(0) if not found. setIdentityStatus() \u00b6 Changes the active status of a registered identity. This can be used to suspend or reactivate an identity. Parameters: - _identityHash : The hash of the identity whose status is to be changed. - _newStatus : true for active, false for suspended. Implementation Example \u00b6 import \"@openzeppelin/contracts/access/Ownable.sol\" ; contract IdentityRegistry is IIdentityRegistry , Ownable { // Mapping from identity hash to its entry details mapping ( bytes32 => IdentityEntry ) private _identityEntries ; // Mapping from identity address to its hash for reverse lookup mapping ( address => bytes32 ) private _identityAddressToHash ; // Counter for total registered identities (and to generate unique hashes if needed) uint256 private _registeredIdentityCount ; // Array to store all hashes for enumeration bytes32 [] private _allIdentityHashes ; constructor () { // Owner is set to deployer by default due to Ownable } function registerIdentity ( address _identityAddress , string calldata _metadataURI ) external override onlyOwner returns ( bytes32 identityHash ) { require ( _identityAddress != address ( 0 ), \"Identity address cannot be zero\" ); require ( _identityAddressToHash [ _identityAddress ] == bytes32 ( 0 ), \"Identity already registered\" ); identityHash = keccak256 ( abi . encodePacked ( _identityAddress , block.timestamp , msg.sender )); // Generate unique hash _identityEntries [ identityHash ] = IdentityEntry ({ identityAddress : _identityAddress , registrant : msg.sender , metadataURI : _metadataURI , active : true , registeredAt : block.timestamp , lastUpdated : block.timestamp }); _identityAddressToHash [ _identityAddress ] = identityHash ; _registeredIdentityCount ++ ; _allIdentityHashes . push ( identityHash ); emit IdentityRegistered ( identityHash , _identityAddress , msg.sender , _metadataURI ); } function registerIdentities ( address [] calldata _identityAddresses , string [] calldata _metadataURIs ) external override onlyOwner returns ( bytes32 [] memory identityHashes ) { require ( _identityAddresses . length == _metadataURIs . length , \"Array length mismatch\" ); identityHashes = new bytes32 []( _identityAddresses . length ); for ( uint256 i = 0 ; i < _identityAddresses . length ; i ++ ) { identityHashes [ i ] = registerIdentity ( _identityAddresses [ i ], _metadataURIs [ i ]); } } function updateIdentity ( bytes32 _identityHash , string calldata _newMetadataURI ) external override onlyOwner { IdentityEntry storage entry = _identityEntries [ _identityHash ]; require ( entry . identityAddress != address ( 0 ), \"Identity hash not found\" ); string memory oldMetadataURI = entry . metadataURI ; entry . metadataURI = _newMetadataURI ; entry . lastUpdated = block.timestamp ; emit IdentityUpdated ( _identityHash , entry . identityAddress , msg.sender , oldMetadataURI , _newMetadataURI ); } function removeIdentity ( bytes32 _identityHash ) external override onlyOwner { IdentityEntry storage entry = _identityEntries [ _identityHash ]; require ( entry . identityAddress != address ( 0 ), \"Identity hash not found\" ); address removedAddress = entry . identityAddress ; delete _identityAddressToHash [ removedAddress ]; delete _identityEntries [ _identityHash ]; // Clear storage for the hash _registeredIdentityCount -- ; // Remove from dynamic array, maintain order is not necessary for ( uint256 i = 0 ; i < _allIdentityHashes . length ; i ++ ) { if ( _allIdentityHashes [ i ] == _identityHash ) { _allIdentityHashes [ i ] = _allIdentityHashes [ _allIdentityHashes . length - 1 ]; // Swap with last _allIdentityHashes . pop (); // Pop last element break ; } } emit IdentityRemoved ( _identityHash , removedAddress , msg.sender ); } function setIdentityStatus ( bytes32 _identityHash , bool _newStatus ) external override onlyOwner { IdentityEntry storage entry = _identityEntries [ _identityHash ]; require ( entry . identityAddress != address ( 0 ), \"Identity hash not found\" ); require ( entry . active != _newStatus , \"Status is already the same\" ); entry . active = _newStatus ; entry . lastUpdated = block.timestamp ; emit IdentityStatusChanged ( _identityHash , entry . identityAddress , _newStatus , msg.sender ); } function getIdentityAddress ( bytes32 _identityHash ) external view override returns ( address ) { return _identityEntries [ _identityHash ]. identityAddress ; } function getIdentityEntry ( bytes32 _identityHash ) external view override returns ( IdentityEntry memory ) { return _identityEntries [ _identityHash ]; } function isIdentityActive ( bytes32 _identityHash ) external view override returns ( bool ) { return _identityEntries [ _identityHash ]. active ; } function getIdentityHash ( address _identityAddress ) external view override returns ( bytes32 ) { return _identityAddressToHash [ _identityAddress ]; } function getRegisteredIdentityCount () external view override returns ( uint256 ) { return _registeredIdentityCount ; } function getIdentityHashByIndex ( uint256 index ) external view override returns ( bytes32 ) { require ( index < _allIdentityHashes . length , \"Index out of bounds\" ); return _allIdentityHashes [ index ]; } } Security Considerations \u00b6 Access Control \u00b6 onlyOwner : All functions that modify the registry ( registerIdentity , updateIdentity , removeIdentity , setIdentityStatus ) are restricted to the contract owner to maintain integrity and prevent unauthorized modifications. Role-Based Access Control : For more complex scenarios, consider implementing a role-based access control (RBAC) system instead of a single owner. Data Integrity \u00b6 Zero Address Check : Prevent registration of address(0) as an identity. Duplicate Registration : Ensure that an identity address can only be registered once. Hash Collisions : While keccak256 is highly collision-resistant, rely on the generated hash to be unique within the contract's scope, not solely on external inputs. Gas Efficiency \u00b6 Array Iteration : removeIdentity iterates through _allIdentityHashes to remove an element. For a very large number of identities, this operation could become gas-expensive. Consider alternative data structures or a flag-based removal if enumeration isn't strictly necessary or if the number of removals is high. Best Practices \u00b6 Identity Hashing \u00b6 Deterministic Hashing : The identityHash generated by the contract (e.g., using keccak256(abi.encodePacked(_identityAddress, block.timestamp, msg.sender)) ) should include entropy to make it unique and hard to guess, while still allowing for a unique identifier for each registered identity. Events \u00b6 Comprehensive Events : Emit events for all state-changing operations to enable off-chain indexing and monitoring. Modularity \u00b6 Separation of Concerns : The registry focuses solely on mapping identifiers to identity contracts. Specific identity logic (e.g., claims, keys) should reside within the IIdentity contracts linked by this registry. Integration Examples \u00b6 Frontend Integration (TypeScript via Ethers.js) \u00b6 import { ethers , Contract } from 'ethers' ; import IdentityRegistryABI from './IdentityRegistry.json' ; // ABI of the IIdentityRegistry const REGISTRY_ADDRESS = \"0x...\" ; // Your deployed IdentityRegistry contract address const getSigner = () => new ethers . providers . Web3Provider ( window . ethereum ). getSigner (); const getIdentityRegistryContract = () => new Contract ( REGISTRY_ADDRESS , IdentityRegistryABI , getSigner ()); async function registerNewIdentity ( identityAddress : string , metadataURI : string ) : Promise < string > { try { const registry = getIdentityRegistryContract (); const tx = await registry . registerIdentity ( identityAddress , metadataURI ); const receipt = await tx . wait (); const event = receipt . events ? . find (( e : any ) => e . event === 'IdentityRegistered' ); return event ? . args ? . identityHash ; } catch ( error ) { console . error ( \"Error registering identity:\" , error ); throw error ; } } async function getIdentityAddressByHash ( identityHash : string ) : Promise < string > { try { const registry = getIdentityRegistryContract (); const address = await registry . getIdentityAddress ( identityHash ); return address ; } catch ( error ) { console . error ( \"Error getting identity address:\" , error ); throw error ; } } async function checkIdentityStatus ( identityHash : string ) : Promise < boolean > { try { const registry = getIdentityRegistryContract (); const isActive = await registry . isIdentityActive ( identityHash ); return isActive ; } catch ( error ) { console . error ( \"Error checking identity status:\" , error ); throw error ; } } // Example usage // const newIdHash = await registerNewIdentity(\"0xIdentityContractAddress\", \"http://my.identity/profile.json\"); // const retrievedAddress = await getIdentityAddressByHash(newIdHash); // const status = await checkIdentityStatus(newIdHash); Backend Integration (Node.js for a centralized identity service) \u00b6 const Web3 = require ( 'web3' ); const IdentityRegistryABI = require ( './IdentityRegistry.json' ). abi ; const web3 = new Web3 ( 'YOUR_ETHEREUM_RPC_URL' ); const registryAddress = '0x...' ; // Address of your deployed IdentityRegistry contract const ownerPrivateKey = 'YOUR_CONTRACT_OWNER_PRIVATE_KEY' ; // Private key of the contract owner const identityRegistryContract = new web3 . eth . Contract ( IdentityRegistryABI , registryAddress ); const ownerAccount = web3 . eth . accounts . privateKeyToAccount ( ownerPrivateKey ); web3 . eth . accounts . wallet . add ( ownerAccount ); async function registerNewIdentityBackend ( identityAddress , metadataURI ) { try { console . log ( `Registering identity ${ identityAddress } with URI ${ metadataURI } ...` ); const tx = identityRegistryContract . methods . registerIdentity ( identityAddress , metadataURI ); const gasLimit = await tx . estimateGas ({ from : ownerAccount . address }); const receipt = await tx . send ({ from : ownerAccount . address , gas : gasLimit }); console . log ( `Identity registered. Transaction hash: ${ receipt . transactionHash } ` ); // Extract identity hash from event logs if necessary return receipt ; } catch ( error ) { console . error ( \"Backend: Error registering identity:\" , error ); throw error ; } } async function suspendIdentityBackend ( identityHash ) { try { console . log ( `Suspending identity with hash ${ identityHash } ...` ); const tx = identityRegistryContract . methods . setIdentityStatus ( identityHash , false ); const gasLimit = await tx . estimateGas ({ from : ownerAccount . address }); const receipt = await tx . send ({ from : ownerAccount . address , gas : gasLimit }); console . log ( `Identity suspended. Transaction hash: ${ receipt . transactionHash } ` ); return receipt ; } catch ( error ) { console . error ( \"Backend: Error suspending identity:\" , error ); throw error ; } } // Example usage // registerNewIdentityBackend(\"0xAnotherIdentityContract\", \"https://api.example.com/identity/2\"); // suspendIdentityBackend(\"0xabcdef1234567890...\"); // Use a previously obtained identity hash Related Documentation \u00b6 IIdentity Interface Identity Factory Ownable Contract Decentralized Identifiers (DIDs) (External) Standards Compliance \u00b6 Ownable : Utilizes OpenZeppelin's Ownable for administrative access control.","title":"IIdentityRegistry"},{"location":"smart-contracts/interfaces/iidentity-registry/#iidentityregistry-interface","text":"The IIdentityRegistry interface defines the standard for a registry of identity contracts within the Gemforce ecosystem. This registry acts as a central lookup and management system for various identity contracts, allowing for consistent identity resolution and verification across the platform.","title":"IIdentityRegistry Interface"},{"location":"smart-contracts/interfaces/iidentity-registry/#overview","text":"IIdentityRegistry provides: Identity Resolution : A method to query and retrieve registered identity contract addresses. Registration Management : Functions to add, update, and remove identity entries in the registry. Status Tracking : Keep track of the status (e.g., active, suspended) of registered identities. Event Logging : Comprehensive event tracking for all registry operations.","title":"Overview"},{"location":"smart-contracts/interfaces/iidentity-registry/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/iidentity-registry/#identity-registration-query","text":"Register Identity : Link an identity contract address to a user or entity. Query Identity : Retrieve an identity contract address associated with a given identifier. Batch Registration : Register multiple identities efficiently.","title":"Identity Registration &amp; Query"},{"location":"smart-contracts/interfaces/iidentity-registry/#status-and-access-control","text":"Identity Status : Manage and query the active status of registered identities. Ownership/Admin Control : Restrict registration and modification functions to authorized entities. Verification Levels : Potentially integrate with identity verification levels.","title":"Status and Access Control"},{"location":"smart-contracts/interfaces/iidentity-registry/#decentralized-identifiers-dids-compatibility-conceptual","text":"Can be designed to store DID-like identifiers or map to them for broader interoperability.","title":"Decentralized Identifiers (DIDs) Compatibility (Conceptual)"},{"location":"smart-contracts/interfaces/iidentity-registry/#interface-definition","text":"interface IIdentityRegistry { // Events event IdentityRegistered ( bytes32 indexed identityHash , address indexed identityAddress , address indexed registrant , string metadataURI ); event IdentityUpdated ( bytes32 indexed identityHash , address indexed identityAddress , address indexed updater , string oldMetadataURI , string newMetadataURI ); event IdentityRemoved ( bytes32 indexed identityHash , address indexed identityAddress , address indexed remover ); event IdentityStatusChanged ( bytes32 indexed identityHash , address indexed identityAddress , bool newStatus , address indexed changer ); // Structs struct IdentityEntry { address identityAddress ; address registrant ; string metadataURI ; bool active ; uint256 registeredAt ; uint256 lastUpdated ; } // Core Functions function registerIdentity ( address _identityAddress , string calldata _metadataURI ) external returns ( bytes32 identityHash ); function registerIdentities ( address [] calldata _identityAddresses , string [] calldata _metadataURIs ) external returns ( bytes32 [] memory identityHashes ); function updateIdentity ( bytes32 _identityHash , string calldata _newMetadataURI ) external ; function removeIdentity ( bytes32 _identityHash ) external ; function setIdentityStatus ( bytes32 _identityHash , bool _newStatus ) external ; // View Functions function getIdentityAddress ( bytes32 _identityHash ) external view returns ( address ); function getIdentityEntry ( bytes32 _identityHash ) external view returns ( IdentityEntry memory ); function isIdentityActive ( bytes32 _identityHash ) external view returns ( bool ); function getIdentityHash ( address _identityAddress ) external view returns ( bytes32 ); // Reverse lookup for the hash function getRegisteredIdentityCount () external view returns ( uint256 ); function getIdentityHashByIndex ( uint256 index ) external view returns ( bytes32 ); }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/iidentity-registry/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/iidentity-registry/#registeridentity","text":"Registers a new identity contract address with an associated metadata URI. A unique identityHash is generated for lookup. Parameters: - _identityAddress : The address of the identity smart contract to register. - _metadataURI : A URI pointing to additional off-chain metadata about the identity. Returns: - bytes32 : A unique hash that identifies this registered identity. Usage: // Register a new identity contract bytes32 myIdentityHash = identityRegistry . registerIdentity ( _newlyDeployedIdentityAddress , \"ipfs://my-identity-meta.json\" );","title":"registerIdentity()"},{"location":"smart-contracts/interfaces/iidentity-registry/#getidentityaddress","text":"Retrieves the identity contract address associated with a given identityHash . Parameters: - _identityHash : The unique hash of the registered identity. Returns: - address : The address of the registered identity contract. Returns address(0) if not found.","title":"getIdentityAddress()"},{"location":"smart-contracts/interfaces/iidentity-registry/#setidentitystatus","text":"Changes the active status of a registered identity. This can be used to suspend or reactivate an identity. Parameters: - _identityHash : The hash of the identity whose status is to be changed. - _newStatus : true for active, false for suspended.","title":"setIdentityStatus()"},{"location":"smart-contracts/interfaces/iidentity-registry/#implementation-example","text":"import \"@openzeppelin/contracts/access/Ownable.sol\" ; contract IdentityRegistry is IIdentityRegistry , Ownable { // Mapping from identity hash to its entry details mapping ( bytes32 => IdentityEntry ) private _identityEntries ; // Mapping from identity address to its hash for reverse lookup mapping ( address => bytes32 ) private _identityAddressToHash ; // Counter for total registered identities (and to generate unique hashes if needed) uint256 private _registeredIdentityCount ; // Array to store all hashes for enumeration bytes32 [] private _allIdentityHashes ; constructor () { // Owner is set to deployer by default due to Ownable } function registerIdentity ( address _identityAddress , string calldata _metadataURI ) external override onlyOwner returns ( bytes32 identityHash ) { require ( _identityAddress != address ( 0 ), \"Identity address cannot be zero\" ); require ( _identityAddressToHash [ _identityAddress ] == bytes32 ( 0 ), \"Identity already registered\" ); identityHash = keccak256 ( abi . encodePacked ( _identityAddress , block.timestamp , msg.sender )); // Generate unique hash _identityEntries [ identityHash ] = IdentityEntry ({ identityAddress : _identityAddress , registrant : msg.sender , metadataURI : _metadataURI , active : true , registeredAt : block.timestamp , lastUpdated : block.timestamp }); _identityAddressToHash [ _identityAddress ] = identityHash ; _registeredIdentityCount ++ ; _allIdentityHashes . push ( identityHash ); emit IdentityRegistered ( identityHash , _identityAddress , msg.sender , _metadataURI ); } function registerIdentities ( address [] calldata _identityAddresses , string [] calldata _metadataURIs ) external override onlyOwner returns ( bytes32 [] memory identityHashes ) { require ( _identityAddresses . length == _metadataURIs . length , \"Array length mismatch\" ); identityHashes = new bytes32 []( _identityAddresses . length ); for ( uint256 i = 0 ; i < _identityAddresses . length ; i ++ ) { identityHashes [ i ] = registerIdentity ( _identityAddresses [ i ], _metadataURIs [ i ]); } } function updateIdentity ( bytes32 _identityHash , string calldata _newMetadataURI ) external override onlyOwner { IdentityEntry storage entry = _identityEntries [ _identityHash ]; require ( entry . identityAddress != address ( 0 ), \"Identity hash not found\" ); string memory oldMetadataURI = entry . metadataURI ; entry . metadataURI = _newMetadataURI ; entry . lastUpdated = block.timestamp ; emit IdentityUpdated ( _identityHash , entry . identityAddress , msg.sender , oldMetadataURI , _newMetadataURI ); } function removeIdentity ( bytes32 _identityHash ) external override onlyOwner { IdentityEntry storage entry = _identityEntries [ _identityHash ]; require ( entry . identityAddress != address ( 0 ), \"Identity hash not found\" ); address removedAddress = entry . identityAddress ; delete _identityAddressToHash [ removedAddress ]; delete _identityEntries [ _identityHash ]; // Clear storage for the hash _registeredIdentityCount -- ; // Remove from dynamic array, maintain order is not necessary for ( uint256 i = 0 ; i < _allIdentityHashes . length ; i ++ ) { if ( _allIdentityHashes [ i ] == _identityHash ) { _allIdentityHashes [ i ] = _allIdentityHashes [ _allIdentityHashes . length - 1 ]; // Swap with last _allIdentityHashes . pop (); // Pop last element break ; } } emit IdentityRemoved ( _identityHash , removedAddress , msg.sender ); } function setIdentityStatus ( bytes32 _identityHash , bool _newStatus ) external override onlyOwner { IdentityEntry storage entry = _identityEntries [ _identityHash ]; require ( entry . identityAddress != address ( 0 ), \"Identity hash not found\" ); require ( entry . active != _newStatus , \"Status is already the same\" ); entry . active = _newStatus ; entry . lastUpdated = block.timestamp ; emit IdentityStatusChanged ( _identityHash , entry . identityAddress , _newStatus , msg.sender ); } function getIdentityAddress ( bytes32 _identityHash ) external view override returns ( address ) { return _identityEntries [ _identityHash ]. identityAddress ; } function getIdentityEntry ( bytes32 _identityHash ) external view override returns ( IdentityEntry memory ) { return _identityEntries [ _identityHash ]; } function isIdentityActive ( bytes32 _identityHash ) external view override returns ( bool ) { return _identityEntries [ _identityHash ]. active ; } function getIdentityHash ( address _identityAddress ) external view override returns ( bytes32 ) { return _identityAddressToHash [ _identityAddress ]; } function getRegisteredIdentityCount () external view override returns ( uint256 ) { return _registeredIdentityCount ; } function getIdentityHashByIndex ( uint256 index ) external view override returns ( bytes32 ) { require ( index < _allIdentityHashes . length , \"Index out of bounds\" ); return _allIdentityHashes [ index ]; } }","title":"Implementation Example"},{"location":"smart-contracts/interfaces/iidentity-registry/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/iidentity-registry/#access-control","text":"onlyOwner : All functions that modify the registry ( registerIdentity , updateIdentity , removeIdentity , setIdentityStatus ) are restricted to the contract owner to maintain integrity and prevent unauthorized modifications. Role-Based Access Control : For more complex scenarios, consider implementing a role-based access control (RBAC) system instead of a single owner.","title":"Access Control"},{"location":"smart-contracts/interfaces/iidentity-registry/#data-integrity","text":"Zero Address Check : Prevent registration of address(0) as an identity. Duplicate Registration : Ensure that an identity address can only be registered once. Hash Collisions : While keccak256 is highly collision-resistant, rely on the generated hash to be unique within the contract's scope, not solely on external inputs.","title":"Data Integrity"},{"location":"smart-contracts/interfaces/iidentity-registry/#gas-efficiency","text":"Array Iteration : removeIdentity iterates through _allIdentityHashes to remove an element. For a very large number of identities, this operation could become gas-expensive. Consider alternative data structures or a flag-based removal if enumeration isn't strictly necessary or if the number of removals is high.","title":"Gas Efficiency"},{"location":"smart-contracts/interfaces/iidentity-registry/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/interfaces/iidentity-registry/#identity-hashing","text":"Deterministic Hashing : The identityHash generated by the contract (e.g., using keccak256(abi.encodePacked(_identityAddress, block.timestamp, msg.sender)) ) should include entropy to make it unique and hard to guess, while still allowing for a unique identifier for each registered identity.","title":"Identity Hashing"},{"location":"smart-contracts/interfaces/iidentity-registry/#events","text":"Comprehensive Events : Emit events for all state-changing operations to enable off-chain indexing and monitoring.","title":"Events"},{"location":"smart-contracts/interfaces/iidentity-registry/#modularity","text":"Separation of Concerns : The registry focuses solely on mapping identifiers to identity contracts. Specific identity logic (e.g., claims, keys) should reside within the IIdentity contracts linked by this registry.","title":"Modularity"},{"location":"smart-contracts/interfaces/iidentity-registry/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/iidentity-registry/#frontend-integration-typescript-via-ethersjs","text":"import { ethers , Contract } from 'ethers' ; import IdentityRegistryABI from './IdentityRegistry.json' ; // ABI of the IIdentityRegistry const REGISTRY_ADDRESS = \"0x...\" ; // Your deployed IdentityRegistry contract address const getSigner = () => new ethers . providers . Web3Provider ( window . ethereum ). getSigner (); const getIdentityRegistryContract = () => new Contract ( REGISTRY_ADDRESS , IdentityRegistryABI , getSigner ()); async function registerNewIdentity ( identityAddress : string , metadataURI : string ) : Promise < string > { try { const registry = getIdentityRegistryContract (); const tx = await registry . registerIdentity ( identityAddress , metadataURI ); const receipt = await tx . wait (); const event = receipt . events ? . find (( e : any ) => e . event === 'IdentityRegistered' ); return event ? . args ? . identityHash ; } catch ( error ) { console . error ( \"Error registering identity:\" , error ); throw error ; } } async function getIdentityAddressByHash ( identityHash : string ) : Promise < string > { try { const registry = getIdentityRegistryContract (); const address = await registry . getIdentityAddress ( identityHash ); return address ; } catch ( error ) { console . error ( \"Error getting identity address:\" , error ); throw error ; } } async function checkIdentityStatus ( identityHash : string ) : Promise < boolean > { try { const registry = getIdentityRegistryContract (); const isActive = await registry . isIdentityActive ( identityHash ); return isActive ; } catch ( error ) { console . error ( \"Error checking identity status:\" , error ); throw error ; } } // Example usage // const newIdHash = await registerNewIdentity(\"0xIdentityContractAddress\", \"http://my.identity/profile.json\"); // const retrievedAddress = await getIdentityAddressByHash(newIdHash); // const status = await checkIdentityStatus(newIdHash);","title":"Frontend Integration (TypeScript via Ethers.js)"},{"location":"smart-contracts/interfaces/iidentity-registry/#backend-integration-nodejs-for-a-centralized-identity-service","text":"const Web3 = require ( 'web3' ); const IdentityRegistryABI = require ( './IdentityRegistry.json' ). abi ; const web3 = new Web3 ( 'YOUR_ETHEREUM_RPC_URL' ); const registryAddress = '0x...' ; // Address of your deployed IdentityRegistry contract const ownerPrivateKey = 'YOUR_CONTRACT_OWNER_PRIVATE_KEY' ; // Private key of the contract owner const identityRegistryContract = new web3 . eth . Contract ( IdentityRegistryABI , registryAddress ); const ownerAccount = web3 . eth . accounts . privateKeyToAccount ( ownerPrivateKey ); web3 . eth . accounts . wallet . add ( ownerAccount ); async function registerNewIdentityBackend ( identityAddress , metadataURI ) { try { console . log ( `Registering identity ${ identityAddress } with URI ${ metadataURI } ...` ); const tx = identityRegistryContract . methods . registerIdentity ( identityAddress , metadataURI ); const gasLimit = await tx . estimateGas ({ from : ownerAccount . address }); const receipt = await tx . send ({ from : ownerAccount . address , gas : gasLimit }); console . log ( `Identity registered. Transaction hash: ${ receipt . transactionHash } ` ); // Extract identity hash from event logs if necessary return receipt ; } catch ( error ) { console . error ( \"Backend: Error registering identity:\" , error ); throw error ; } } async function suspendIdentityBackend ( identityHash ) { try { console . log ( `Suspending identity with hash ${ identityHash } ...` ); const tx = identityRegistryContract . methods . setIdentityStatus ( identityHash , false ); const gasLimit = await tx . estimateGas ({ from : ownerAccount . address }); const receipt = await tx . send ({ from : ownerAccount . address , gas : gasLimit }); console . log ( `Identity suspended. Transaction hash: ${ receipt . transactionHash } ` ); return receipt ; } catch ( error ) { console . error ( \"Backend: Error suspending identity:\" , error ); throw error ; } } // Example usage // registerNewIdentityBackend(\"0xAnotherIdentityContract\", \"https://api.example.com/identity/2\"); // suspendIdentityBackend(\"0xabcdef1234567890...\"); // Use a previously obtained identity hash","title":"Backend Integration (Node.js for a centralized identity service)"},{"location":"smart-contracts/interfaces/iidentity-registry/#related-documentation","text":"IIdentity Interface Identity Factory Ownable Contract Decentralized Identifiers (DIDs) (External)","title":"Related Documentation"},{"location":"smart-contracts/interfaces/iidentity-registry/#standards-compliance","text":"Ownable : Utilizes OpenZeppelin's Ownable for administrative access control.","title":"Standards Compliance"},{"location":"smart-contracts/interfaces/iidentity/","text":"IIdentity Interface \u00b6 The IIdentity interface defines the standard for identity management contracts in the Gemforce ecosystem. It provides a comprehensive framework for managing digital identities, key management, claims verification, and identity attestations based on ERC734 and ERC735 standards. Overview \u00b6 IIdentity provides: Key Management : Secure management of cryptographic keys Claims System : Verifiable claims and attestations Identity Verification : Multi-level identity verification Access Control : Role-based access control for identity operations Interoperability : Standard interface for identity interactions Key Features \u00b6 Key Management \u00b6 Multi-Key Support : Support for multiple key types and purposes Key Rotation : Secure key rotation and revocation Hierarchical Keys : Support for key hierarchies and delegation Recovery Mechanisms : Account recovery through trusted keys Claims and Attestations \u00b6 Verifiable Claims : Create and verify identity claims Third-Party Attestations : Support for external attestations Claim Revocation : Revoke invalid or expired claims Proof Generation : Generate cryptographic proofs for claims Identity Operations \u00b6 Identity Creation : Create new identity contracts Profile Management : Manage identity profiles and metadata Verification Levels : Support multiple verification levels Compliance : Support for regulatory compliance requirements Interface Definition \u00b6 interface IIdentity { // Events event KeyAdded ( bytes32 indexed key , uint256 indexed purpose , uint256 indexed keyType ); event KeyRemoved ( bytes32 indexed key , uint256 indexed purpose , uint256 indexed keyType ); event ClaimAdded ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ); event ClaimRemoved ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer ); event ClaimChanged ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ); event IdentityVerified ( address indexed identity , uint256 indexed level , address indexed verifier ); event IdentityRevoked ( address indexed identity , address indexed revoker , string reason ); // Enums enum KeyPurpose { MANAGEMENT , // 1 ACTION , // 2 CLAIM , // 3 ENCRYPTION // 4 } enum KeyType { ECDSA , // 1 RSA , // 2 AES // 3 } enum VerificationLevel { NONE , // 0 BASIC , // 1 ENHANCED , // 2 PREMIUM // 3 } // Structs struct Key { uint256 purpose ; uint256 keyType ; bytes32 key ; bool active ; uint256 addedAt ; uint256 revokedAt ; } struct Claim { uint256 topic ; uint256 scheme ; address issuer ; bytes signature ; bytes data ; string uri ; bool valid ; uint256 issuedAt ; uint256 expiresAt ; } struct IdentityProfile { string name ; string email ; string country ; uint256 verificationLevel ; bool active ; uint256 createdAt ; uint256 updatedAt ; } struct VerificationRequest { address identity ; uint256 requestedLevel ; address verifier ; bytes evidence ; uint256 requestedAt ; uint256 expiresAt ; bool processed ; } // Key Management Functions function addKey ( bytes32 _key , uint256 _purpose , uint256 _keyType ) external returns ( bool success ); function removeKey ( bytes32 _key , uint256 _purpose ) external returns ( bool success ); function getKey ( bytes32 _key ) external view returns ( uint256 purpose , uint256 keyType , bytes32 key , bool active ); function getKeysByPurpose ( uint256 _purpose ) external view returns ( bytes32 [] memory keys ); function keyHasPurpose ( bytes32 _key , uint256 _purpose ) external view returns ( bool exists ); // Claim Management Functions function addClaim ( uint256 _topic , uint256 _scheme , address _issuer , bytes calldata _signature , bytes calldata _data , string calldata _uri ) external returns ( bytes32 claimRequestId ); function removeClaim ( bytes32 _claimId ) external returns ( bool success ); function getClaim ( bytes32 _claimId ) external view returns ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ); function getClaimIdsByTopic ( uint256 _topic ) external view returns ( bytes32 [] memory claimIds ); function getClaimsByTopic ( uint256 _topic ) external view returns ( Claim [] memory claims ); // Identity Management Functions function createIdentity ( address _owner , IdentityProfile calldata _profile ) external returns ( address identity ); function updateProfile ( IdentityProfile calldata _profile ) external ; function getProfile () external view returns ( IdentityProfile memory profile ); function requestVerification ( uint256 _level , bytes calldata _evidence ) external returns ( bytes32 requestId ); function processVerification ( bytes32 _requestId , bool _approved , string calldata _reason ) external ; function getVerificationLevel () external view returns ( uint256 level ); function isVerified ( uint256 _level ) external view returns ( bool verified ); // Utility Functions function execute ( address _to , uint256 _value , bytes calldata _data ) external returns ( uint256 executionId ); function approve ( uint256 _id , bool _approve ) external returns ( bool success ); function isValidSignature ( bytes32 _hash , bytes calldata _signature ) external view returns ( bytes4 magicValue ); // Query Functions function owner () external view returns ( address ); function isOwner ( address _addr ) external view returns ( bool ); function getExecutionNonce () external view returns ( uint256 ); function getClaimCount () external view returns ( uint256 ); function getKeyCount () external view returns ( uint256 ); function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ); } Core Functions \u00b6 addKey() \u00b6 Adds a new key to the identity with specified purpose and type. Parameters: - _key : The key identifier (keccak256 hash of the key) - _purpose : The purpose of the key (MANAGEMENT, ACTION, CLAIM, ENCRYPTION) - _keyType : The type of key (ECDSA, RSA, AES) Returns: - bool : Success status Usage: bytes32 keyHash = keccak256 ( abi . encodePacked ( publicKey )); bool success = identity . addKey ( keyHash , uint256 ( IIdentity . KeyPurpose . MANAGEMENT ), uint256 ( IIdentity . KeyType . ECDSA ) ); addClaim() \u00b6 Adds a new claim to the identity. Parameters: - _topic : The claim topic identifier - _scheme : The signature scheme used - _issuer : The address of the claim issuer - _signature : The claim signature - _data : The claim data - _uri : URI for additional claim information Returns: - bytes32 : Claim request ID createIdentity() \u00b6 Creates a new identity contract for a user. Parameters: - _owner : The owner address of the identity - _profile : Initial identity profile information Returns: - address : Address of the created identity contract requestVerification() \u00b6 Requests identity verification at a specific level. Parameters: - _level : Requested verification level - _evidence : Supporting evidence for verification Returns: - bytes32 : Verification request ID Implementation Example \u00b6 Basic Identity Contract \u00b6 contract Identity is IIdentity , ERC165 { using ECDSA for bytes32 ; // Storage mapping ( bytes32 => Key ) private keys ; mapping ( uint256 => bytes32 []) private keysByPurpose ; mapping ( bytes32 => Claim ) private claims ; mapping ( uint256 => bytes32 []) private claimsByTopic ; IdentityProfile private profile ; address private _owner ; uint256 private executionNonce ; uint256 private verificationLevel ; // Modifiers modifier onlyOwner () { require ( msg.sender == _owner , \"Not owner\" ); _ ; } modifier onlyManagementKey () { require ( keyHasPurpose ( keccak256 ( abi . encodePacked ( msg.sender )), 1 ), \"No management key\" ); _ ; } constructor ( address owner , IdentityProfile memory _profile ) { _owner = owner ; profile = _profile ; // Add owner as management key bytes32 ownerKey = keccak256 ( abi . encodePacked ( owner )); _addKey ( ownerKey , 1 , 1 ); // MANAGEMENT, ECDSA emit IdentityVerified ( address ( this ), 0 , address ( 0 )); } function addKey ( bytes32 _key , uint256 _purpose , uint256 _keyType ) external override onlyManagementKey returns ( bool success ) { return _addKey ( _key , _purpose , _keyType ); } function _addKey ( bytes32 _key , uint256 _purpose , uint256 _keyType ) internal returns ( bool success ) { require ( _key != bytes32 ( 0 ), \"Invalid key\" ); require ( _purpose >= 1 && _purpose <= 4 , \"Invalid purpose\" ); require ( _keyType >= 1 && _keyType <= 3 , \"Invalid key type\" ); Key storage key = keys [ _key ]; require ( ! key . active , \"Key already exists\" ); key . purpose = _purpose ; key . keyType = _keyType ; key . key = _key ; key . active = true ; key . addedAt = block.timestamp ; keysByPurpose [ _purpose ]. push ( _key ); emit KeyAdded ( _key , _purpose , _keyType ); return true ; } function removeKey ( bytes32 _key , uint256 _purpose ) external override onlyManagementKey returns ( bool success ) { Key storage key = keys [ _key ]; require ( key . active , \"Key not found\" ); require ( key . purpose == _purpose , \"Purpose mismatch\" ); key . active = false ; key . revokedAt = block.timestamp ; // Remove from purpose array _removeFromArray ( keysByPurpose [ _purpose ], _key ); emit KeyRemoved ( _key , _purpose , key . keyType ); return true ; } function addClaim ( uint256 _topic , uint256 _scheme , address _issuer , bytes calldata _signature , bytes calldata _data , string calldata _uri ) external override returns ( bytes32 claimRequestId ) { require ( _issuer != address ( 0 ), \"Invalid issuer\" ); claimRequestId = keccak256 ( abi . encodePacked ( _topic , _scheme , _issuer , _data , block.timestamp ) ); Claim storage claim = claims [ claimRequestId ]; require ( claim . issuedAt == 0 , \"Claim already exists\" ); claim . topic = _topic ; claim . scheme = _scheme ; claim . issuer = _issuer ; claim . signature = _signature ; claim . data = _data ; claim . uri = _uri ; claim . valid = true ; claim . issuedAt = block.timestamp ; claim . expiresAt = block.timestamp + 365 days ; // Default 1 year claimsByTopic [ _topic ]. push ( claimRequestId ); emit ClaimAdded ( claimRequestId , _topic , _scheme , _issuer , _signature , _data , _uri ); } function requestVerification ( uint256 _level , bytes calldata _evidence ) external override returns ( bytes32 requestId ) { require ( _level > verificationLevel , \"Level not higher\" ); require ( _level <= 3 , \"Invalid level\" ); requestId = keccak256 ( abi . encodePacked ( address ( this ), _level , _evidence , block.timestamp ) ); // Emit event for off-chain processing emit IdentityVerified ( address ( this ), _level , msg.sender ); return requestId ; } function processVerification ( bytes32 _requestId , bool _approved , string calldata _reason ) external override { // Only authorized verifiers can process require ( isAuthorizedVerifier ( msg.sender ), \"Not authorized verifier\" ); if ( _approved ) { // Update verification level based on request // Implementation depends on specific verification logic verificationLevel = getRequestedLevel ( _requestId ); emit IdentityVerified ( address ( this ), verificationLevel , msg.sender ); } else { emit IdentityRevoked ( address ( this ), msg.sender , _reason ); } } function execute ( address _to , uint256 _value , bytes calldata _data ) external override returns ( uint256 executionId ) { require ( keyHasPurpose ( keccak256 ( abi . encodePacked ( msg.sender )), 2 ) || keyHasPurpose ( keccak256 ( abi . encodePacked ( msg.sender )), 1 ), \"No execution permission\" ); executionId = executionNonce ++ ; ( bool success , ) = _to . call { value : _value }( _data ); require ( success , \"Execution failed\" ); return executionId ; } function isValidSignature ( bytes32 _hash , bytes calldata _signature ) external view override returns ( bytes4 magicValue ) { address signer = _hash . recover ( _signature ); bytes32 signerKey = keccak256 ( abi . encodePacked ( signer )); if ( keyHasPurpose ( signerKey , 1 ) || keyHasPurpose ( signerKey , 2 )) { return 0x1626ba7e ; // EIP-1271 magic value } return 0xffffffff ; } // View functions function getKey ( bytes32 _key ) external view override returns ( uint256 purpose , uint256 keyType , bytes32 key , bool active ) { Key storage k = keys [ _key ]; return ( k . purpose , k . keyType , k . key , k . active ); } function keyHasPurpose ( bytes32 _key , uint256 _purpose ) public view override returns ( bool exists ) { Key storage key = keys [ _key ]; return key . active && key . purpose == _purpose ; } function getClaim ( bytes32 _claimId ) external view override returns ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ) { Claim storage claim = claims [ _claimId ]; return ( claim . topic , claim . scheme , claim . issuer , claim . signature , claim . data , claim . uri ); } function getProfile () external view override returns ( IdentityProfile memory ) { return profile ; } function getVerificationLevel () external view override returns ( uint256 level ) { return verificationLevel ; } function isVerified ( uint256 _level ) external view override returns ( bool verified ) { return verificationLevel >= _level ; } function owner () external view override returns ( address ) { return _owner ; } function isOwner ( address _addr ) external view override returns ( bool ) { return _addr == _owner ; } function supportsInterface ( bytes4 interfaceId ) public view virtual override returns ( bool ) { return interfaceId == type ( IIdentity ). interfaceId || super . supportsInterface ( interfaceId ); } } Advanced Identity Features \u00b6 contract AdvancedIdentity is Identity { // Multi-signature support mapping ( bytes32 => mapping ( address => bool )) public approvals ; mapping ( bytes32 => uint256 ) public approvalCount ; mapping ( bytes32 => uint256 ) public requiredApprovals ; // Delegation support mapping ( address => mapping ( uint256 => bool )) public delegations ; mapping ( address => uint256 ) public delegationExpiry ; // Recovery mechanisms mapping ( address => bool ) public recoveryKeys ; uint256 public recoveryThreshold ; mapping ( bytes32 => uint256 ) public recoveryVotes ; function addMultiSigKey ( bytes32 _key , uint256 _purpose , uint256 _keyType , uint256 _requiredApprovals ) external onlyManagementKey { _addKey ( _key , _purpose , _keyType ); requiredApprovals [ _key ] = _requiredApprovals ; } function executeWithApproval ( address _to , uint256 _value , bytes calldata _data , bytes32 _executionId ) external returns ( bool success ) { bytes32 signerKey = keccak256 ( abi . encodePacked ( msg.sender )); require ( keyHasPurpose ( signerKey , 2 ), \"No action key\" ); approvals [ _executionId ][ msg.sender ] = true ; approvalCount [ _executionId ] ++ ; if ( approvalCount [ _executionId ] >= requiredApprovals [ signerKey ]) { ( success , ) = _to . call { value : _value }( _data ); delete approvals [ _executionId ]; delete approvalCount [ _executionId ]; } return success ; } function delegateKey ( address _delegate , uint256 _purpose , uint256 _duration ) external onlyManagementKey { delegations [ _delegate ][ _purpose ] = true ; delegationExpiry [ _delegate ] = block.timestamp + _duration ; } function revokeDelegation ( address _delegate ) external onlyManagementKey { delete delegations [ _delegate ][ 1 ]; delete delegations [ _delegate ][ 2 ]; delete delegationExpiry [ _delegate ]; } function addRecoveryKey ( address _recoveryKey ) external onlyOwner { recoveryKeys [ _recoveryKey ] = true ; } function initiateRecovery ( address _newOwner ) external { require ( recoveryKeys [ msg.sender ], \"Not recovery key\" ); bytes32 recoveryId = keccak256 ( abi . encodePacked ( _newOwner , block.timestamp )); recoveryVotes [ recoveryId ] ++ ; if ( recoveryVotes [ recoveryId ] >= recoveryThreshold ) { _owner = _newOwner ; // Add new owner as management key bytes32 newOwnerKey = keccak256 ( abi . encodePacked ( _newOwner )); _addKey ( newOwnerKey , 1 , 1 ); } } } Verification Levels \u00b6 Level 0: None \u00b6 Requirements : Basic identity creation Capabilities : Basic key management and claims Restrictions : Limited transaction amounts Level 1: Basic \u00b6 Requirements : Email verification, basic KYC Capabilities : Standard operations, moderate transaction limits Verification : Automated verification process Level 2: Enhanced \u00b6 Requirements : Document verification, address proof Capabilities : Higher transaction limits, advanced features Verification : Manual review process Level 3: Premium \u00b6 Requirements : Full KYC/AML compliance, biometric verification Capabilities : Unlimited operations, institutional features Verification : Comprehensive compliance review Security Considerations \u00b6 Key Management Security \u00b6 Key Rotation : Regular key rotation policies Multi-Signature : Multi-signature requirements for critical operations Recovery Mechanisms : Secure account recovery procedures Key Validation : Validate key formats and cryptographic properties Claim Verification \u00b6 Issuer Validation : Verify claim issuer authenticity Signature Verification : Validate claim signatures Expiration Handling : Handle claim expiration properly Revocation Checks : Check for claim revocations Access Control \u00b6 Permission Validation : Validate permissions for all operations Delegation Security : Secure delegation mechanisms Audit Trails : Comprehensive audit logging Rate Limiting : Prevent abuse through rate limiting Best Practices \u00b6 Identity Design \u00b6 Minimal Data : Store minimal personal data on-chain Privacy Protection : Implement privacy-preserving mechanisms Interoperability : Design for cross-platform compatibility Upgradability : Plan for identity contract upgrades Key Management \u00b6 Key Diversity : Use different keys for different purposes Secure Storage : Implement secure key storage mechanisms Regular Rotation : Establish key rotation schedules Backup Procedures : Implement secure backup procedures Verification Process \u00b6 Graduated Verification : Implement graduated verification levels Evidence Validation : Thoroughly validate verification evidence Compliance : Ensure regulatory compliance User Experience : Balance security with user experience Integration Examples \u00b6 Frontend Integration \u00b6 class IdentityService { private contract : Contract ; constructor ( address : string , provider : Provider ) { this . contract = new Contract ( address , IDENTITY_ABI , provider ); } async createIdentity ( profile : IdentityProfile ) : Promise < string > { const tx = await this . contract . createIdentity ( await this . provider . getSigner (). getAddress (), profile ); const receipt = await tx . wait (); return receipt . contractAddress ; } async addKey ( key : string , purpose : KeyPurpose , keyType : KeyType ) : Promise < void > { const keyHash = ethers . utils . keccak256 ( ethers . utils . toUtf8Bytes ( key )); await this . contract . addKey ( keyHash , purpose , keyType ); } async addClaim ( claim : ClaimData ) : Promise < string > { const tx = await this . contract . addClaim ( claim . topic , claim . scheme , claim . issuer , claim . signature , claim . data , claim . uri ); const receipt = await tx . wait (); return receipt . events [ 0 ]. args . claimRequestId ; } async requestVerification ( level : number , evidence : string ) : Promise < string > { const tx = await this . contract . requestVerification ( level , ethers . utils . toUtf8Bytes ( evidence ) ); const receipt = await tx . wait (); return receipt . events [ 0 ]. args . requestId ; } async getVerificationLevel () : Promise < number > { return await this . contract . getVerificationLevel (); } } Backend Integration \u00b6 class IdentityManager { constructor ( web3 , contractAddress ) { this . web3 = web3 ; this . contract = new web3 . eth . Contract ( IDENTITY_ABI , contractAddress ); } async processVerificationRequest ( requestId , approved , reason ) { const accounts = await this . web3 . eth . getAccounts (); return await this . contract . methods . processVerification ( requestId , approved , reason ) . send ({ from : accounts [ 0 ] }); } async validateClaim ( claimId ) { const claim = await this . contract . methods . getClaim ( claimId ). call (); // Validate claim signature const messageHash = this . web3 . utils . keccak256 ( claim . data ); const recoveredAddress = this . web3 . eth . accounts . recover ( messageHash , claim . signature ); return recoveredAddress . toLowerCase () === claim . issuer . toLowerCase (); } async getIdentityProfile ( identityAddress ) { const identityContract = new this . web3 . eth . Contract ( IDENTITY_ABI , identityAddress ); return await identityContract . methods . getProfile (). call (); } } Related Documentation \u00b6 ERC734 Key Manager ERC735 Claim Holder Identity Factory Identity Registry Verification Guide Key Management Guide Standards Compliance \u00b6 ERC734 : Key Manager standard implementation ERC735 : Claim Holder standard implementation ERC165 : Interface detection standard ERC1271 : Signature validation standard EIP-712 : Typed structured data hashing and signing","title":"IIdentity"},{"location":"smart-contracts/interfaces/iidentity/#iidentity-interface","text":"The IIdentity interface defines the standard for identity management contracts in the Gemforce ecosystem. It provides a comprehensive framework for managing digital identities, key management, claims verification, and identity attestations based on ERC734 and ERC735 standards.","title":"IIdentity Interface"},{"location":"smart-contracts/interfaces/iidentity/#overview","text":"IIdentity provides: Key Management : Secure management of cryptographic keys Claims System : Verifiable claims and attestations Identity Verification : Multi-level identity verification Access Control : Role-based access control for identity operations Interoperability : Standard interface for identity interactions","title":"Overview"},{"location":"smart-contracts/interfaces/iidentity/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/iidentity/#key-management","text":"Multi-Key Support : Support for multiple key types and purposes Key Rotation : Secure key rotation and revocation Hierarchical Keys : Support for key hierarchies and delegation Recovery Mechanisms : Account recovery through trusted keys","title":"Key Management"},{"location":"smart-contracts/interfaces/iidentity/#claims-and-attestations","text":"Verifiable Claims : Create and verify identity claims Third-Party Attestations : Support for external attestations Claim Revocation : Revoke invalid or expired claims Proof Generation : Generate cryptographic proofs for claims","title":"Claims and Attestations"},{"location":"smart-contracts/interfaces/iidentity/#identity-operations","text":"Identity Creation : Create new identity contracts Profile Management : Manage identity profiles and metadata Verification Levels : Support multiple verification levels Compliance : Support for regulatory compliance requirements","title":"Identity Operations"},{"location":"smart-contracts/interfaces/iidentity/#interface-definition","text":"interface IIdentity { // Events event KeyAdded ( bytes32 indexed key , uint256 indexed purpose , uint256 indexed keyType ); event KeyRemoved ( bytes32 indexed key , uint256 indexed purpose , uint256 indexed keyType ); event ClaimAdded ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ); event ClaimRemoved ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer ); event ClaimChanged ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ); event IdentityVerified ( address indexed identity , uint256 indexed level , address indexed verifier ); event IdentityRevoked ( address indexed identity , address indexed revoker , string reason ); // Enums enum KeyPurpose { MANAGEMENT , // 1 ACTION , // 2 CLAIM , // 3 ENCRYPTION // 4 } enum KeyType { ECDSA , // 1 RSA , // 2 AES // 3 } enum VerificationLevel { NONE , // 0 BASIC , // 1 ENHANCED , // 2 PREMIUM // 3 } // Structs struct Key { uint256 purpose ; uint256 keyType ; bytes32 key ; bool active ; uint256 addedAt ; uint256 revokedAt ; } struct Claim { uint256 topic ; uint256 scheme ; address issuer ; bytes signature ; bytes data ; string uri ; bool valid ; uint256 issuedAt ; uint256 expiresAt ; } struct IdentityProfile { string name ; string email ; string country ; uint256 verificationLevel ; bool active ; uint256 createdAt ; uint256 updatedAt ; } struct VerificationRequest { address identity ; uint256 requestedLevel ; address verifier ; bytes evidence ; uint256 requestedAt ; uint256 expiresAt ; bool processed ; } // Key Management Functions function addKey ( bytes32 _key , uint256 _purpose , uint256 _keyType ) external returns ( bool success ); function removeKey ( bytes32 _key , uint256 _purpose ) external returns ( bool success ); function getKey ( bytes32 _key ) external view returns ( uint256 purpose , uint256 keyType , bytes32 key , bool active ); function getKeysByPurpose ( uint256 _purpose ) external view returns ( bytes32 [] memory keys ); function keyHasPurpose ( bytes32 _key , uint256 _purpose ) external view returns ( bool exists ); // Claim Management Functions function addClaim ( uint256 _topic , uint256 _scheme , address _issuer , bytes calldata _signature , bytes calldata _data , string calldata _uri ) external returns ( bytes32 claimRequestId ); function removeClaim ( bytes32 _claimId ) external returns ( bool success ); function getClaim ( bytes32 _claimId ) external view returns ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ); function getClaimIdsByTopic ( uint256 _topic ) external view returns ( bytes32 [] memory claimIds ); function getClaimsByTopic ( uint256 _topic ) external view returns ( Claim [] memory claims ); // Identity Management Functions function createIdentity ( address _owner , IdentityProfile calldata _profile ) external returns ( address identity ); function updateProfile ( IdentityProfile calldata _profile ) external ; function getProfile () external view returns ( IdentityProfile memory profile ); function requestVerification ( uint256 _level , bytes calldata _evidence ) external returns ( bytes32 requestId ); function processVerification ( bytes32 _requestId , bool _approved , string calldata _reason ) external ; function getVerificationLevel () external view returns ( uint256 level ); function isVerified ( uint256 _level ) external view returns ( bool verified ); // Utility Functions function execute ( address _to , uint256 _value , bytes calldata _data ) external returns ( uint256 executionId ); function approve ( uint256 _id , bool _approve ) external returns ( bool success ); function isValidSignature ( bytes32 _hash , bytes calldata _signature ) external view returns ( bytes4 magicValue ); // Query Functions function owner () external view returns ( address ); function isOwner ( address _addr ) external view returns ( bool ); function getExecutionNonce () external view returns ( uint256 ); function getClaimCount () external view returns ( uint256 ); function getKeyCount () external view returns ( uint256 ); function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ); }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/iidentity/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/iidentity/#addkey","text":"Adds a new key to the identity with specified purpose and type. Parameters: - _key : The key identifier (keccak256 hash of the key) - _purpose : The purpose of the key (MANAGEMENT, ACTION, CLAIM, ENCRYPTION) - _keyType : The type of key (ECDSA, RSA, AES) Returns: - bool : Success status Usage: bytes32 keyHash = keccak256 ( abi . encodePacked ( publicKey )); bool success = identity . addKey ( keyHash , uint256 ( IIdentity . KeyPurpose . MANAGEMENT ), uint256 ( IIdentity . KeyType . ECDSA ) );","title":"addKey()"},{"location":"smart-contracts/interfaces/iidentity/#addclaim","text":"Adds a new claim to the identity. Parameters: - _topic : The claim topic identifier - _scheme : The signature scheme used - _issuer : The address of the claim issuer - _signature : The claim signature - _data : The claim data - _uri : URI for additional claim information Returns: - bytes32 : Claim request ID","title":"addClaim()"},{"location":"smart-contracts/interfaces/iidentity/#createidentity","text":"Creates a new identity contract for a user. Parameters: - _owner : The owner address of the identity - _profile : Initial identity profile information Returns: - address : Address of the created identity contract","title":"createIdentity()"},{"location":"smart-contracts/interfaces/iidentity/#requestverification","text":"Requests identity verification at a specific level. Parameters: - _level : Requested verification level - _evidence : Supporting evidence for verification Returns: - bytes32 : Verification request ID","title":"requestVerification()"},{"location":"smart-contracts/interfaces/iidentity/#implementation-example","text":"","title":"Implementation Example"},{"location":"smart-contracts/interfaces/iidentity/#basic-identity-contract","text":"contract Identity is IIdentity , ERC165 { using ECDSA for bytes32 ; // Storage mapping ( bytes32 => Key ) private keys ; mapping ( uint256 => bytes32 []) private keysByPurpose ; mapping ( bytes32 => Claim ) private claims ; mapping ( uint256 => bytes32 []) private claimsByTopic ; IdentityProfile private profile ; address private _owner ; uint256 private executionNonce ; uint256 private verificationLevel ; // Modifiers modifier onlyOwner () { require ( msg.sender == _owner , \"Not owner\" ); _ ; } modifier onlyManagementKey () { require ( keyHasPurpose ( keccak256 ( abi . encodePacked ( msg.sender )), 1 ), \"No management key\" ); _ ; } constructor ( address owner , IdentityProfile memory _profile ) { _owner = owner ; profile = _profile ; // Add owner as management key bytes32 ownerKey = keccak256 ( abi . encodePacked ( owner )); _addKey ( ownerKey , 1 , 1 ); // MANAGEMENT, ECDSA emit IdentityVerified ( address ( this ), 0 , address ( 0 )); } function addKey ( bytes32 _key , uint256 _purpose , uint256 _keyType ) external override onlyManagementKey returns ( bool success ) { return _addKey ( _key , _purpose , _keyType ); } function _addKey ( bytes32 _key , uint256 _purpose , uint256 _keyType ) internal returns ( bool success ) { require ( _key != bytes32 ( 0 ), \"Invalid key\" ); require ( _purpose >= 1 && _purpose <= 4 , \"Invalid purpose\" ); require ( _keyType >= 1 && _keyType <= 3 , \"Invalid key type\" ); Key storage key = keys [ _key ]; require ( ! key . active , \"Key already exists\" ); key . purpose = _purpose ; key . keyType = _keyType ; key . key = _key ; key . active = true ; key . addedAt = block.timestamp ; keysByPurpose [ _purpose ]. push ( _key ); emit KeyAdded ( _key , _purpose , _keyType ); return true ; } function removeKey ( bytes32 _key , uint256 _purpose ) external override onlyManagementKey returns ( bool success ) { Key storage key = keys [ _key ]; require ( key . active , \"Key not found\" ); require ( key . purpose == _purpose , \"Purpose mismatch\" ); key . active = false ; key . revokedAt = block.timestamp ; // Remove from purpose array _removeFromArray ( keysByPurpose [ _purpose ], _key ); emit KeyRemoved ( _key , _purpose , key . keyType ); return true ; } function addClaim ( uint256 _topic , uint256 _scheme , address _issuer , bytes calldata _signature , bytes calldata _data , string calldata _uri ) external override returns ( bytes32 claimRequestId ) { require ( _issuer != address ( 0 ), \"Invalid issuer\" ); claimRequestId = keccak256 ( abi . encodePacked ( _topic , _scheme , _issuer , _data , block.timestamp ) ); Claim storage claim = claims [ claimRequestId ]; require ( claim . issuedAt == 0 , \"Claim already exists\" ); claim . topic = _topic ; claim . scheme = _scheme ; claim . issuer = _issuer ; claim . signature = _signature ; claim . data = _data ; claim . uri = _uri ; claim . valid = true ; claim . issuedAt = block.timestamp ; claim . expiresAt = block.timestamp + 365 days ; // Default 1 year claimsByTopic [ _topic ]. push ( claimRequestId ); emit ClaimAdded ( claimRequestId , _topic , _scheme , _issuer , _signature , _data , _uri ); } function requestVerification ( uint256 _level , bytes calldata _evidence ) external override returns ( bytes32 requestId ) { require ( _level > verificationLevel , \"Level not higher\" ); require ( _level <= 3 , \"Invalid level\" ); requestId = keccak256 ( abi . encodePacked ( address ( this ), _level , _evidence , block.timestamp ) ); // Emit event for off-chain processing emit IdentityVerified ( address ( this ), _level , msg.sender ); return requestId ; } function processVerification ( bytes32 _requestId , bool _approved , string calldata _reason ) external override { // Only authorized verifiers can process require ( isAuthorizedVerifier ( msg.sender ), \"Not authorized verifier\" ); if ( _approved ) { // Update verification level based on request // Implementation depends on specific verification logic verificationLevel = getRequestedLevel ( _requestId ); emit IdentityVerified ( address ( this ), verificationLevel , msg.sender ); } else { emit IdentityRevoked ( address ( this ), msg.sender , _reason ); } } function execute ( address _to , uint256 _value , bytes calldata _data ) external override returns ( uint256 executionId ) { require ( keyHasPurpose ( keccak256 ( abi . encodePacked ( msg.sender )), 2 ) || keyHasPurpose ( keccak256 ( abi . encodePacked ( msg.sender )), 1 ), \"No execution permission\" ); executionId = executionNonce ++ ; ( bool success , ) = _to . call { value : _value }( _data ); require ( success , \"Execution failed\" ); return executionId ; } function isValidSignature ( bytes32 _hash , bytes calldata _signature ) external view override returns ( bytes4 magicValue ) { address signer = _hash . recover ( _signature ); bytes32 signerKey = keccak256 ( abi . encodePacked ( signer )); if ( keyHasPurpose ( signerKey , 1 ) || keyHasPurpose ( signerKey , 2 )) { return 0x1626ba7e ; // EIP-1271 magic value } return 0xffffffff ; } // View functions function getKey ( bytes32 _key ) external view override returns ( uint256 purpose , uint256 keyType , bytes32 key , bool active ) { Key storage k = keys [ _key ]; return ( k . purpose , k . keyType , k . key , k . active ); } function keyHasPurpose ( bytes32 _key , uint256 _purpose ) public view override returns ( bool exists ) { Key storage key = keys [ _key ]; return key . active && key . purpose == _purpose ; } function getClaim ( bytes32 _claimId ) external view override returns ( uint256 topic , uint256 scheme , address issuer , bytes memory signature , bytes memory data , string memory uri ) { Claim storage claim = claims [ _claimId ]; return ( claim . topic , claim . scheme , claim . issuer , claim . signature , claim . data , claim . uri ); } function getProfile () external view override returns ( IdentityProfile memory ) { return profile ; } function getVerificationLevel () external view override returns ( uint256 level ) { return verificationLevel ; } function isVerified ( uint256 _level ) external view override returns ( bool verified ) { return verificationLevel >= _level ; } function owner () external view override returns ( address ) { return _owner ; } function isOwner ( address _addr ) external view override returns ( bool ) { return _addr == _owner ; } function supportsInterface ( bytes4 interfaceId ) public view virtual override returns ( bool ) { return interfaceId == type ( IIdentity ). interfaceId || super . supportsInterface ( interfaceId ); } }","title":"Basic Identity Contract"},{"location":"smart-contracts/interfaces/iidentity/#advanced-identity-features","text":"contract AdvancedIdentity is Identity { // Multi-signature support mapping ( bytes32 => mapping ( address => bool )) public approvals ; mapping ( bytes32 => uint256 ) public approvalCount ; mapping ( bytes32 => uint256 ) public requiredApprovals ; // Delegation support mapping ( address => mapping ( uint256 => bool )) public delegations ; mapping ( address => uint256 ) public delegationExpiry ; // Recovery mechanisms mapping ( address => bool ) public recoveryKeys ; uint256 public recoveryThreshold ; mapping ( bytes32 => uint256 ) public recoveryVotes ; function addMultiSigKey ( bytes32 _key , uint256 _purpose , uint256 _keyType , uint256 _requiredApprovals ) external onlyManagementKey { _addKey ( _key , _purpose , _keyType ); requiredApprovals [ _key ] = _requiredApprovals ; } function executeWithApproval ( address _to , uint256 _value , bytes calldata _data , bytes32 _executionId ) external returns ( bool success ) { bytes32 signerKey = keccak256 ( abi . encodePacked ( msg.sender )); require ( keyHasPurpose ( signerKey , 2 ), \"No action key\" ); approvals [ _executionId ][ msg.sender ] = true ; approvalCount [ _executionId ] ++ ; if ( approvalCount [ _executionId ] >= requiredApprovals [ signerKey ]) { ( success , ) = _to . call { value : _value }( _data ); delete approvals [ _executionId ]; delete approvalCount [ _executionId ]; } return success ; } function delegateKey ( address _delegate , uint256 _purpose , uint256 _duration ) external onlyManagementKey { delegations [ _delegate ][ _purpose ] = true ; delegationExpiry [ _delegate ] = block.timestamp + _duration ; } function revokeDelegation ( address _delegate ) external onlyManagementKey { delete delegations [ _delegate ][ 1 ]; delete delegations [ _delegate ][ 2 ]; delete delegationExpiry [ _delegate ]; } function addRecoveryKey ( address _recoveryKey ) external onlyOwner { recoveryKeys [ _recoveryKey ] = true ; } function initiateRecovery ( address _newOwner ) external { require ( recoveryKeys [ msg.sender ], \"Not recovery key\" ); bytes32 recoveryId = keccak256 ( abi . encodePacked ( _newOwner , block.timestamp )); recoveryVotes [ recoveryId ] ++ ; if ( recoveryVotes [ recoveryId ] >= recoveryThreshold ) { _owner = _newOwner ; // Add new owner as management key bytes32 newOwnerKey = keccak256 ( abi . encodePacked ( _newOwner )); _addKey ( newOwnerKey , 1 , 1 ); } } }","title":"Advanced Identity Features"},{"location":"smart-contracts/interfaces/iidentity/#verification-levels","text":"","title":"Verification Levels"},{"location":"smart-contracts/interfaces/iidentity/#level-0-none","text":"Requirements : Basic identity creation Capabilities : Basic key management and claims Restrictions : Limited transaction amounts","title":"Level 0: None"},{"location":"smart-contracts/interfaces/iidentity/#level-1-basic","text":"Requirements : Email verification, basic KYC Capabilities : Standard operations, moderate transaction limits Verification : Automated verification process","title":"Level 1: Basic"},{"location":"smart-contracts/interfaces/iidentity/#level-2-enhanced","text":"Requirements : Document verification, address proof Capabilities : Higher transaction limits, advanced features Verification : Manual review process","title":"Level 2: Enhanced"},{"location":"smart-contracts/interfaces/iidentity/#level-3-premium","text":"Requirements : Full KYC/AML compliance, biometric verification Capabilities : Unlimited operations, institutional features Verification : Comprehensive compliance review","title":"Level 3: Premium"},{"location":"smart-contracts/interfaces/iidentity/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/iidentity/#key-management-security","text":"Key Rotation : Regular key rotation policies Multi-Signature : Multi-signature requirements for critical operations Recovery Mechanisms : Secure account recovery procedures Key Validation : Validate key formats and cryptographic properties","title":"Key Management Security"},{"location":"smart-contracts/interfaces/iidentity/#claim-verification","text":"Issuer Validation : Verify claim issuer authenticity Signature Verification : Validate claim signatures Expiration Handling : Handle claim expiration properly Revocation Checks : Check for claim revocations","title":"Claim Verification"},{"location":"smart-contracts/interfaces/iidentity/#access-control","text":"Permission Validation : Validate permissions for all operations Delegation Security : Secure delegation mechanisms Audit Trails : Comprehensive audit logging Rate Limiting : Prevent abuse through rate limiting","title":"Access Control"},{"location":"smart-contracts/interfaces/iidentity/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/interfaces/iidentity/#identity-design","text":"Minimal Data : Store minimal personal data on-chain Privacy Protection : Implement privacy-preserving mechanisms Interoperability : Design for cross-platform compatibility Upgradability : Plan for identity contract upgrades","title":"Identity Design"},{"location":"smart-contracts/interfaces/iidentity/#key-management_1","text":"Key Diversity : Use different keys for different purposes Secure Storage : Implement secure key storage mechanisms Regular Rotation : Establish key rotation schedules Backup Procedures : Implement secure backup procedures","title":"Key Management"},{"location":"smart-contracts/interfaces/iidentity/#verification-process","text":"Graduated Verification : Implement graduated verification levels Evidence Validation : Thoroughly validate verification evidence Compliance : Ensure regulatory compliance User Experience : Balance security with user experience","title":"Verification Process"},{"location":"smart-contracts/interfaces/iidentity/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/iidentity/#frontend-integration","text":"class IdentityService { private contract : Contract ; constructor ( address : string , provider : Provider ) { this . contract = new Contract ( address , IDENTITY_ABI , provider ); } async createIdentity ( profile : IdentityProfile ) : Promise < string > { const tx = await this . contract . createIdentity ( await this . provider . getSigner (). getAddress (), profile ); const receipt = await tx . wait (); return receipt . contractAddress ; } async addKey ( key : string , purpose : KeyPurpose , keyType : KeyType ) : Promise < void > { const keyHash = ethers . utils . keccak256 ( ethers . utils . toUtf8Bytes ( key )); await this . contract . addKey ( keyHash , purpose , keyType ); } async addClaim ( claim : ClaimData ) : Promise < string > { const tx = await this . contract . addClaim ( claim . topic , claim . scheme , claim . issuer , claim . signature , claim . data , claim . uri ); const receipt = await tx . wait (); return receipt . events [ 0 ]. args . claimRequestId ; } async requestVerification ( level : number , evidence : string ) : Promise < string > { const tx = await this . contract . requestVerification ( level , ethers . utils . toUtf8Bytes ( evidence ) ); const receipt = await tx . wait (); return receipt . events [ 0 ]. args . requestId ; } async getVerificationLevel () : Promise < number > { return await this . contract . getVerificationLevel (); } }","title":"Frontend Integration"},{"location":"smart-contracts/interfaces/iidentity/#backend-integration","text":"class IdentityManager { constructor ( web3 , contractAddress ) { this . web3 = web3 ; this . contract = new web3 . eth . Contract ( IDENTITY_ABI , contractAddress ); } async processVerificationRequest ( requestId , approved , reason ) { const accounts = await this . web3 . eth . getAccounts (); return await this . contract . methods . processVerification ( requestId , approved , reason ) . send ({ from : accounts [ 0 ] }); } async validateClaim ( claimId ) { const claim = await this . contract . methods . getClaim ( claimId ). call (); // Validate claim signature const messageHash = this . web3 . utils . keccak256 ( claim . data ); const recoveredAddress = this . web3 . eth . accounts . recover ( messageHash , claim . signature ); return recoveredAddress . toLowerCase () === claim . issuer . toLowerCase (); } async getIdentityProfile ( identityAddress ) { const identityContract = new this . web3 . eth . Contract ( IDENTITY_ABI , identityAddress ); return await identityContract . methods . getProfile (). call (); } }","title":"Backend Integration"},{"location":"smart-contracts/interfaces/iidentity/#related-documentation","text":"ERC734 Key Manager ERC735 Claim Holder Identity Factory Identity Registry Verification Guide Key Management Guide","title":"Related Documentation"},{"location":"smart-contracts/interfaces/iidentity/#standards-compliance","text":"ERC734 : Key Manager standard implementation ERC735 : Claim Holder standard implementation ERC165 : Interface detection standard ERC1271 : Signature validation standard EIP-712 : Typed structured data hashing and signing","title":"Standards Compliance"},{"location":"smart-contracts/interfaces/imarketplace/","text":"IMarketplace Interface \u00b6 Overview \u00b6 The IMarketplace.sol defines the core interface for NFT marketplace functionality within the Gemforce platform. This interface establishes the standard contract for marketplace operations including listing, purchasing, delisting, and fee management for NFT trading. Interface Details \u00b6 Interface Name : IMarketplace License : MIT Solidity Version : ^0.8.4 Key Features \u00b6 \ud83d\udd39 NFT Trading Operations \u00b6 List NFTs for sale with flexible pricing Purchase NFTs with multiple payment methods Delist items from the marketplace Transfer management for NFT custody \ud83d\udd39 Fee Management System \u00b6 Configurable fee receivers and percentages Parts-per-million fee calculation Multiple fee recipient support Transparent fee distribution \ud83d\udd39 Multi-Token Payment Support \u00b6 ETH payments for NFT purchases ERC20 token payment options Flexible payment token configuration Secure payment processing \ud83d\udd39 Comprehensive Item Management \u00b6 Detailed item metadata tracking Seller and owner management Sale status tracking Item discovery and querying Core Data Structures \u00b6 FeeReceiver \u00b6 struct FeeReceiver { address payable receiver ; // Address that will receive the fee uint256 sharePerMillion ; // Fee share in parts per million } Purpose : Defines fee distribution configuration for marketplace transactions. Fields : - receiver : Address that will receive the fee payment - sharePerMillion : Fee percentage in parts per million (e.g., 10,000 = 1%) Fee Calculation : - 1% fee : sharePerMillion = 10,000 - 0.5% fee : sharePerMillion = 5,000 - 2.5% fee : sharePerMillion = 25,000 - Maximum precision : Up to 0.0001% (1 part per million) Usage Example : // Configure marketplace fees FeeReceiver [] memory feeReceivers = new FeeReceiver []( 2 ); // Platform fee: 2.5% feeReceivers [ 0 ] = FeeReceiver ({ receiver : payable ( platformAddress ), sharePerMillion : 25000 }); // Creator royalty: 5% feeReceivers [ 1 ] = FeeReceiver ({ receiver : payable ( creatorAddress ), sharePerMillion : 50000 }); MarketItem \u00b6 struct MarketItem { address nftContract ; // NFT contract address uint256 tokenId ; // Token ID within the NFT contract address seller ; // Address of the seller address owner ; // Current owner of the NFT uint256 price ; // Sale price bool sold ; // Whether the item has been sold address receiver ; // Address to receive sale proceeds address paymentToken ; // Token contract for payment (address(0) for ETH) } Purpose : Comprehensive data structure representing an NFT listing in the marketplace. Fields : - nftContract : Address of the NFT contract containing the token - tokenId : Unique identifier of the NFT within its contract - seller : Address of the account that listed the item for sale - owner : Current owner of the NFT (may differ from seller) - price : Sale price in the specified payment token - sold : Boolean indicating if the item has been purchased - receiver : Address that will receive the sale proceeds - paymentToken : Address of the ERC20 token for payment (zero address for ETH) Usage Example : // Create marketplace listing MarketItem memory item = MarketItem ({ nftContract : nftContractAddress , tokenId : 123 , seller : msg.sender , owner : msg.sender , price : 1 ether , sold : false , receiver : msg.sender , paymentToken : address ( 0 ) // ETH payment }); Core Interface Functions \u00b6 Listing Functions \u00b6 listItem() \u00b6 function listItem ( address nftContract , address payable receiver , uint256 tokenId , uint256 price , bool transferNFT , address paymentToken ) external payable Purpose : Lists an NFT for sale on the marketplace with specified parameters. Parameters : - nftContract (address): Address of the NFT contract - receiver (address payable): Address to receive sale proceeds - tokenId (uint256): ID of the token to list - price (uint256): Sale price in the specified payment token - transferNFT (bool): Whether to transfer NFT to marketplace custody - paymentToken (address): Token for payment (zero address for ETH) Access Control : Public (with ownership validation) Process : 1. Validates caller owns the NFT or has approval 2. Optionally transfers NFT to marketplace custody 3. Creates marketplace listing with specified parameters 4. Emits Listings event with complete item details 5. Returns item ID for future reference Events : Listings(nftContract, tokenId, seller, receiver, owner, price, sold, paymentToken) Example Usage : // List NFT for sale with ETH payment address nftContract = 0x1234567890123456789012345678901234567890 ; uint256 tokenId = 123 ; uint256 price = 1 ether ; // First approve marketplace to transfer NFT IERC721 ( nftContract ). approve ( marketplaceAddress , tokenId ); // List the item IMarketplace ( marketplace ). listItem ( nftContract , payable ( msg.sender ), // Receive proceeds tokenId , price , true , // Transfer NFT to marketplace address ( 0 ) // ETH payment ); console . log ( \"NFT listed for sale at\" , price , \"ETH\" ); Payment Token Options : // List with USDC payment address usdcToken = 0xA0b86a33E6441e6e80A7181a02d0d25e8E687770 ; uint256 usdcPrice = 1000 * 10 ** 6 ; // 1000 USDC IMarketplace ( marketplace ). listItem ( nftContract , payable ( msg.sender ), tokenId , usdcPrice , true , usdcToken ); delistItem() \u00b6 function delistItem ( address nftContract , uint256 itemId ) external Purpose : Removes an NFT listing from the marketplace. Parameters : - nftContract (address): Address of the NFT contract - itemId (uint256): ID of the marketplace item to delist Access Control : Seller or authorized party only Process : 1. Validates caller has permission to delist 2. Removes item from active marketplace listings 3. Returns NFT to seller if in marketplace custody 4. Updates item status to delisted 5. Emits Delisted event Events : Delisted(itemId) Example Usage : // Delist an NFT from the marketplace uint256 itemId = 456 ; address nftContract = 0x1234567890123456789012345678901234567890 ; IMarketplace ( marketplace ). delistItem ( nftContract , itemId ); console . log ( \"Item\" , itemId , \"delisted from marketplace\" ); Purchase Functions \u00b6 purchaseItem() \u00b6 function purchaseItem ( address nftContract , uint256 itemId ) external payable Purpose : Purchases an NFT from the marketplace. Parameters : - nftContract (address): Address of the NFT contract - itemId (uint256): ID of the marketplace item to purchase Access Control : Public (with payment validation) Process : 1. Validates item is available for purchase 2. Processes payment according to item's payment token 3. Calculates and distributes fees to configured receivers 4. Transfers remaining proceeds to seller/receiver 5. Transfers NFT to buyer 6. Updates item status to sold 7. Emits Sales event Events : Sales(tokenAddress, tokenId, owner) Example Usage : // Purchase NFT with ETH uint256 itemId = 456 ; address nftContract = 0x1234567890123456789012345678901234567890 ; // Get item details first MarketItem memory item = IMarketplace ( marketplace ). fetchItem ( nftContract , itemId ); require ( ! item . sold , \"Item already sold\" ); // Purchase with ETH IMarketplace ( marketplace ). purchaseItem { value : item . price }( nftContract , itemId ); console . log ( \"NFT purchased for\" , item . price , \"ETH\" ); ERC20 Token Purchase : // Purchase NFT with ERC20 token MarketItem memory item = IMarketplace ( marketplace ). fetchItem ( nftContract , itemId ); if ( item . paymentToken != address ( 0 )) { // Approve token transfer first IERC20 ( item . paymentToken ). approve ( marketplaceAddress , item . price ); // Purchase (no ETH value needed) IMarketplace ( marketplace ). purchaseItem ( nftContract , itemId ); } Query Functions \u00b6 fetchItems() \u00b6 function fetchItems () external view returns ( MarketItem [] memory ) Purpose : Retrieves all active marketplace listings. Returns : - MarketItem[] : Array of all marketplace items Example Usage : // Get all marketplace listings MarketItem [] memory allItems = IMarketplace ( marketplace ). fetchItems (); console . log ( \"Total marketplace items:\" , allItems . length ); for ( uint256 i = 0 ; i < allItems . length ; i ++ ) { MarketItem memory item = allItems [ i ]; if ( ! item . sold ) { console . log ( \"Available NFT:\" , item . nftContract , \"Token ID:\" , item . tokenId , \"Price:\" , item . price ); } } fetchItem() \u00b6 function fetchItem ( address nftContract , uint256 tokenId ) external view returns ( MarketItem memory ) Purpose : Retrieves details for a specific NFT listing. Parameters : - nftContract (address): Address of the NFT contract - tokenId (uint256): ID of the token Returns : - MarketItem : Complete item details Example Usage : // Get specific item details address nftContract = 0x1234567890123456789012345678901234567890 ; uint256 tokenId = 123 ; MarketItem memory item = IMarketplace ( marketplace ). fetchItem ( nftContract , tokenId ); if ( item . nftContract != address ( 0 )) { console . log ( \"Item found:\" ); console . log ( \"- Seller:\" , item . seller ); console . log ( \"- Price:\" , item . price ); console . log ( \"- Sold:\" , item . sold ); console . log ( \"- Payment Token:\" , item . paymentToken ); } else { console . log ( \"Item not found in marketplace\" ); } getMarketplaceFeeReceivers() \u00b6 function getMarketplaceFeeReceivers () external view returns ( FeeReceiver [] memory ) Purpose : Returns the current fee configuration for marketplace transactions. Returns : - FeeReceiver[] : Array of fee receiver configurations Example Usage : // Check marketplace fee structure FeeReceiver [] memory feeReceivers = IMarketplace ( marketplace ). getMarketplaceFeeReceivers (); console . log ( \"Marketplace fee structure:\" ); uint256 totalFeePerMillion = 0 ; for ( uint256 i = 0 ; i < feeReceivers . length ; i ++ ) { FeeReceiver memory fee = feeReceivers [ i ]; uint256 feePercentage = fee . sharePerMillion / 10000 ; // Convert to basis points console . log ( \"- Receiver:\" , fee . receiver ); console . log ( \"- Fee:\" , feePercentage / 100 , \".\" , feePercentage % 100 , \"%\" ); totalFeePerMillion += fee . sharePerMillion ; } console . log ( \"Total marketplace fee:\" , totalFeePerMillion / 10000 / 100 , \".\" , ( totalFeePerMillion / 10000 ) % 100 , \"%\" ); Integration Examples \u00b6 Complete Marketplace Integration \u00b6 // Comprehensive marketplace integration example contract NFTMarketplaceIntegration { IMarketplace public marketplace ; struct ListingInfo { uint256 itemId ; uint256 listingTime ; uint256 views ; bool featured ; } mapping ( address => mapping ( uint256 => ListingInfo )) public listingInfo ; mapping ( address => uint256 []) public userListings ; event ItemListed ( address indexed nftContract , uint256 indexed tokenId , address indexed seller , uint256 price ); event ItemPurchased ( address indexed nftContract , uint256 indexed tokenId , address indexed buyer , uint256 price ); event ItemDelisted ( address indexed nftContract , uint256 indexed tokenId , address indexed seller ); constructor ( address _marketplace ) { marketplace = IMarketplace ( _marketplace ); } function listNFTForSale ( address nftContract , uint256 tokenId , uint256 price , address paymentToken , bool featured ) external { // Verify ownership require ( IERC721 ( nftContract ). ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); // List on marketplace marketplace . listItem ( nftContract , payable ( msg.sender ), tokenId , price , true , // Transfer to marketplace paymentToken ); // Track listing info listingInfo [ nftContract ][ tokenId ] = ListingInfo ({ itemId : tokenId , // Simplified - would get actual item ID listingTime : block.timestamp , views : 0 , featured : featured }); userListings [ msg.sender ]. push ( tokenId ); emit ItemListed ( nftContract , tokenId , msg.sender , price ); } function purchaseNFT ( address nftContract , uint256 tokenId ) external payable { // Get item details MarketItem memory item = marketplace . fetchItem ( nftContract , tokenId ); require ( ! item . sold , \"Item already sold\" ); require ( item . nftContract != address ( 0 ), \"Item not found\" ); // Handle payment if ( item . paymentToken == address ( 0 )) { // ETH payment require ( msg.value >= item . price , \"Insufficient ETH\" ); marketplace . purchaseItem { value : item . price }( nftContract , tokenId ); // Refund excess ETH if ( msg.value > item . price ) { payable ( msg.sender ). transfer ( msg.value - item . price ); } } else { // ERC20 payment require ( msg.value == 0 , \"Do not send ETH for token payments\" ); // Transfer tokens to this contract first, then to marketplace IERC20 ( item . paymentToken ). transferFrom ( msg.sender , address ( this ), item . price ); IERC20 ( item . paymentToken ). approve ( address ( marketplace ), item . price ); marketplace . purchaseItem ( nftContract , tokenId ); } emit ItemPurchased ( nftContract , tokenId , msg.sender , item . price ); } function delistNFT ( address nftContract , uint256 tokenId ) external { // Verify seller MarketItem memory item = marketplace . fetchItem ( nftContract , tokenId ); require ( item . seller == msg.sender , \"Not the seller\" ); require ( ! item . sold , \"Item already sold\" ); // Delist from marketplace marketplace . delistItem ( nftContract , tokenId ); // Clean up tracking delete listingInfo [ nftContract ][ tokenId ]; _removeFromUserListings ( msg.sender , tokenId ); emit ItemDelisted ( nftContract , tokenId , msg.sender ); } function getMarketplaceOverview () external view returns ( uint256 totalListings , uint256 totalSold , uint256 averagePrice , FeeReceiver [] memory feeStructure ) { MarketItem [] memory allItems = marketplace . fetchItems (); totalListings = allItems . length ; uint256 totalValue = 0 ; for ( uint256 i = 0 ; i < allItems . length ; i ++ ) { if ( allItems [ i ]. sold ) { totalSold ++ ; } totalValue += allItems [ i ]. price ; } if ( totalListings > 0 ) { averagePrice = totalValue / totalListings ; } feeStructure = marketplace . getMarketplaceFeeReceivers (); } function getUserListings ( address user ) external view returns ( uint256 [] memory tokenIds , MarketItem [] memory items ) { uint256 [] memory userTokenIds = userListings [ user ]; tokenIds = new uint256 []( userTokenIds . length ); items = new MarketItem []( userTokenIds . length ); for ( uint256 i = 0 ; i < userTokenIds . length ; i ++ ) { tokenIds [ i ] = userTokenIds [ i ]; // Would need to track NFT contract addresses for complete implementation } } function _removeFromUserListings ( address user , uint256 tokenId ) internal { uint256 [] storage listings = userListings [ user ]; for ( uint256 i = 0 ; i < listings . length ; i ++ ) { if ( listings [ i ] == tokenId ) { listings [ i ] = listings [ listings . length - 1 ]; listings . pop (); break ; } } } } Marketplace Analytics System \u00b6 // Analytics and reporting for marketplace activity contract MarketplaceAnalytics { IMarketplace public marketplace ; struct SalesData { uint256 totalSales ; uint256 totalVolume ; uint256 averagePrice ; uint256 uniqueBuyers ; uint256 uniqueSellers ; } struct CollectionStats { address nftContract ; uint256 totalListings ; uint256 totalSales ; uint256 totalVolume ; uint256 floorPrice ; uint256 averagePrice ; } mapping ( address => SalesData ) public collectionSales ; mapping ( address => mapping ( uint256 => uint256 )) public dailyVolume ; mapping ( address => bool ) public trackedBuyers ; mapping ( address => bool ) public trackedSellers ; event SaleRecorded ( address indexed nftContract , uint256 indexed tokenId , uint256 price , address buyer , address seller ); event NewCollection ( address indexed nftContract ); function recordSale ( address nftContract , uint256 tokenId , uint256 price , address buyer , address seller ) external onlyAuthorized { SalesData storage data = collectionSales [ nftContract ]; // Update sales data data . totalSales ++ ; data . totalVolume += price ; data . averagePrice = data . totalVolume / data . totalSales ; // Track unique participants if ( ! trackedBuyers [ buyer ]) { trackedBuyers [ buyer ] = true ; data . uniqueBuyers ++ ; } if ( ! trackedSellers [ seller ]) { trackedSellers [ seller ] = true ; data . uniqueSellers ++ ; } // Update daily volume uint256 today = block.timestamp / 1 days ; dailyVolume [ nftContract ][ today ] += price ; emit SaleRecorded ( nftContract , tokenId , price , buyer , seller ); } function getCollectionStats ( address nftContract ) external view returns ( CollectionStats memory ) { MarketItem [] memory allItems = marketplace . fetchItems (); SalesData memory salesData = collectionSales [ nftContract ]; uint256 totalListings = 0 ; uint256 floorPrice = type ( uint256 ). max ; uint256 totalListingValue = 0 ; // Analyze current listings for ( uint256 i = 0 ; i < allItems . length ; i ++ ) { if ( allItems [ i ]. nftContract == nftContract && ! allItems [ i ]. sold ) { totalListings ++ ; totalListingValue += allItems [ i ]. price ; if ( allItems [ i ]. price < floorPrice ) { floorPrice = allItems [ i ]. price ; } } } if ( floorPrice == type ( uint256 ). max ) { floorPrice = 0 ; } return CollectionStats ({ nftContract : nftContract , totalListings : totalListings , totalSales : salesData . totalSales , totalVolume : salesData . totalVolume , floorPrice : floorPrice , averagePrice : salesData . averagePrice }); } function getDailyVolume ( address nftContract , uint256 daysBack ) external view returns ( uint256 [] memory dates , uint256 [] memory volumes ) { dates = new uint256 []( daysBack ); volumes = new uint256 []( daysBack ); uint256 today = block.timestamp / 1 days ; for ( uint256 i = 0 ; i < daysBack ; i ++ ) { uint256 date = today - i ; dates [ i ] = date ; volumes [ i ] = dailyVolume [ nftContract ][ date ]; } } function getTopCollections ( uint256 limit ) external view returns ( address [] memory ) { // Simplified implementation - would need more sophisticated sorting address [] memory collections = new address []( limit ); // Implementation would sort by volume or other metrics return collections ; } } Fee Management System \u00b6 // Advanced fee management for marketplace contract MarketplaceFeeManager { struct FeeConfig { FeeReceiver [] receivers ; uint256 totalFeePerMillion ; bool active ; uint256 lastUpdated ; } mapping ( address => FeeConfig ) public collectionFees ; FeeConfig public defaultFees ; event FeeConfigUpdated ( address indexed collection , FeeReceiver [] receivers ); event FeeDistributed ( address indexed collection , uint256 totalAmount , address [] receivers , uint256 [] amounts ); function setDefaultFees ( FeeReceiver [] memory receivers ) external onlyOwner { _validateFeeReceivers ( receivers ); delete defaultFees . receivers ; uint256 totalFee = 0 ; for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { defaultFees . receivers . push ( receivers [ i ]); totalFee += receivers [ i ]. sharePerMillion ; } defaultFees . totalFeePerMillion = totalFee ; defaultFees . active = true ; defaultFees . lastUpdated = block.timestamp ; emit FeeConfigUpdated ( address ( 0 ), receivers ); } function setCollectionFees ( address collection , FeeReceiver [] memory receivers ) external onlyOwner { _validateFeeReceivers ( receivers ); delete collectionFees [ collection ]. receivers ; uint256 totalFee = 0 ; for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { collectionFees [ collection ]. receivers . push ( receivers [ i ]); totalFee += receivers [ i ]. sharePerMillion ; } collectionFees [ collection ]. totalFeePerMillion = totalFee ; collectionFees [ collection ]. active = true ; collectionFees [ collection ]. lastUpdated = block.timestamp ; emit FeeConfigUpdated ( collection , receivers ); } function calculateFees ( address collection , uint256 salePrice ) external view returns ( address [] memory receivers , uint256 [] memory amounts , uint256 totalFees ) { FeeConfig memory config = collectionFees [ collection ]. active ? collectionFees [ collection ] : defaultFees ; receivers = new address []( config . receivers . length ); amounts = new uint256 []( config . receivers . length ); for ( uint256 i = 0 ; i < config . receivers . length ; i ++ ) { receivers [ i ] = config . receivers [ i ]. receiver ; amounts [ i ] = ( salePrice * config . receivers [ i ]. sharePerMillion ) / 1000000 ; totalFees += amounts [ i ]; } } function distributeFees ( address collection , uint256 salePrice , address paymentToken ) external payable onlyAuthorized { ( address [] memory receivers , uint256 [] memory amounts , uint256 totalFees ) = this . calculateFees ( collection , salePrice ); if ( paymentToken == address ( 0 )) { // ETH distribution require ( msg.value >= totalFees , \"Insufficient ETH for fees\" ); for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { payable ( receivers [ i ]). transfer ( amounts [ i ]); } } else { // ERC20 distribution for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { IERC20 ( paymentToken ). transferFrom ( msg.sender , receivers [ i ], amounts [ i ]); } } emit FeeDistributed ( collection , totalFees , receivers , amounts ); } function _validateFeeReceivers ( FeeReceiver [] memory receivers ) internal pure { require ( receivers . length > 0 , \"No fee receivers provided\" ); uint256 totalFee = 0 ; for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { require ( receivers [ i ]. receiver != address ( 0 ), \"Invalid receiver address\" ); require ( receivers [ i ]. sharePerMillion > 0 , \"Invalid fee share\" ); totalFee += receivers [ i ]. sharePerMillion ; } require ( totalFee <= 100000 , \"Total fees exceed 10%\" ); // Max 10% total fees } } Events \u00b6 Listing Events \u00b6 event Listings ( address indexed nftContract , uint256 indexed tokenId , address seller , address receiver , address owner , uint256 price , bool sold , address paymentToken ); event Delisted ( uint256 indexed itemId ); Trading Events \u00b6 event Sales ( address indexed tokenAddress , uint256 indexed tokenId , address indexed owner ); event Bids ( uint256 indexed itemId , address bidder , uint256 amount ); Security Considerations \u00b6 Access Control \u00b6 Ownership verification for listing and delisting Payment validation for purchases Fee receiver address validation Proper authorization for administrative functions Payment Security \u00b6 Secure ETH and ERC20 token handling Proper fee calculation and distribution Protection against reentrancy attacks Validation of payment amounts NFT Security \u00b6 Ownership verification before listing Secure NFT transfer mechanisms Protection against unauthorized transfers Proper custody management Gas Optimization \u00b6 Efficient Operations \u00b6 Batch operations where possible Optimized storage layout for MarketItem Minimal external calls Efficient fee calculations Query Optimization \u00b6 Efficient item retrieval patterns Optimized array operations Minimal storage reads Cached calculations where appropriate Testing Considerations \u00b6 Unit Tests \u00b6 Interface compliance verification Data structure validation Function behavior testing Event emission verification Integration Tests \u00b6 End-to-end marketplace workflows Payment processing scenarios Fee distribution testing Multi-token payment testing Related Documentation \u00b6 MarketplaceFacet - Marketplace implementation FeeDistributorFacet - Fee management ERC721 Standard - NFT standard ERC20 Standard - Token standard Marketplace Guide - Implementation guide This interface defines the core contract for NFT marketplace functionality within the Gemforce platform, providing standardized trading operations with flexible payment and fee management.","title":"IMarketplace"},{"location":"smart-contracts/interfaces/imarketplace/#imarketplace-interface","text":"","title":"IMarketplace Interface"},{"location":"smart-contracts/interfaces/imarketplace/#overview","text":"The IMarketplace.sol defines the core interface for NFT marketplace functionality within the Gemforce platform. This interface establishes the standard contract for marketplace operations including listing, purchasing, delisting, and fee management for NFT trading.","title":"Overview"},{"location":"smart-contracts/interfaces/imarketplace/#interface-details","text":"Interface Name : IMarketplace License : MIT Solidity Version : ^0.8.4","title":"Interface Details"},{"location":"smart-contracts/interfaces/imarketplace/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/imarketplace/#nft-trading-operations","text":"List NFTs for sale with flexible pricing Purchase NFTs with multiple payment methods Delist items from the marketplace Transfer management for NFT custody","title":"\ud83d\udd39 NFT Trading Operations"},{"location":"smart-contracts/interfaces/imarketplace/#fee-management-system","text":"Configurable fee receivers and percentages Parts-per-million fee calculation Multiple fee recipient support Transparent fee distribution","title":"\ud83d\udd39 Fee Management System"},{"location":"smart-contracts/interfaces/imarketplace/#multi-token-payment-support","text":"ETH payments for NFT purchases ERC20 token payment options Flexible payment token configuration Secure payment processing","title":"\ud83d\udd39 Multi-Token Payment Support"},{"location":"smart-contracts/interfaces/imarketplace/#comprehensive-item-management","text":"Detailed item metadata tracking Seller and owner management Sale status tracking Item discovery and querying","title":"\ud83d\udd39 Comprehensive Item Management"},{"location":"smart-contracts/interfaces/imarketplace/#core-data-structures","text":"","title":"Core Data Structures"},{"location":"smart-contracts/interfaces/imarketplace/#feereceiver","text":"struct FeeReceiver { address payable receiver ; // Address that will receive the fee uint256 sharePerMillion ; // Fee share in parts per million } Purpose : Defines fee distribution configuration for marketplace transactions. Fields : - receiver : Address that will receive the fee payment - sharePerMillion : Fee percentage in parts per million (e.g., 10,000 = 1%) Fee Calculation : - 1% fee : sharePerMillion = 10,000 - 0.5% fee : sharePerMillion = 5,000 - 2.5% fee : sharePerMillion = 25,000 - Maximum precision : Up to 0.0001% (1 part per million) Usage Example : // Configure marketplace fees FeeReceiver [] memory feeReceivers = new FeeReceiver []( 2 ); // Platform fee: 2.5% feeReceivers [ 0 ] = FeeReceiver ({ receiver : payable ( platformAddress ), sharePerMillion : 25000 }); // Creator royalty: 5% feeReceivers [ 1 ] = FeeReceiver ({ receiver : payable ( creatorAddress ), sharePerMillion : 50000 });","title":"FeeReceiver"},{"location":"smart-contracts/interfaces/imarketplace/#marketitem","text":"struct MarketItem { address nftContract ; // NFT contract address uint256 tokenId ; // Token ID within the NFT contract address seller ; // Address of the seller address owner ; // Current owner of the NFT uint256 price ; // Sale price bool sold ; // Whether the item has been sold address receiver ; // Address to receive sale proceeds address paymentToken ; // Token contract for payment (address(0) for ETH) } Purpose : Comprehensive data structure representing an NFT listing in the marketplace. Fields : - nftContract : Address of the NFT contract containing the token - tokenId : Unique identifier of the NFT within its contract - seller : Address of the account that listed the item for sale - owner : Current owner of the NFT (may differ from seller) - price : Sale price in the specified payment token - sold : Boolean indicating if the item has been purchased - receiver : Address that will receive the sale proceeds - paymentToken : Address of the ERC20 token for payment (zero address for ETH) Usage Example : // Create marketplace listing MarketItem memory item = MarketItem ({ nftContract : nftContractAddress , tokenId : 123 , seller : msg.sender , owner : msg.sender , price : 1 ether , sold : false , receiver : msg.sender , paymentToken : address ( 0 ) // ETH payment });","title":"MarketItem"},{"location":"smart-contracts/interfaces/imarketplace/#core-interface-functions","text":"","title":"Core Interface Functions"},{"location":"smart-contracts/interfaces/imarketplace/#listing-functions","text":"","title":"Listing Functions"},{"location":"smart-contracts/interfaces/imarketplace/#listitem","text":"function listItem ( address nftContract , address payable receiver , uint256 tokenId , uint256 price , bool transferNFT , address paymentToken ) external payable Purpose : Lists an NFT for sale on the marketplace with specified parameters. Parameters : - nftContract (address): Address of the NFT contract - receiver (address payable): Address to receive sale proceeds - tokenId (uint256): ID of the token to list - price (uint256): Sale price in the specified payment token - transferNFT (bool): Whether to transfer NFT to marketplace custody - paymentToken (address): Token for payment (zero address for ETH) Access Control : Public (with ownership validation) Process : 1. Validates caller owns the NFT or has approval 2. Optionally transfers NFT to marketplace custody 3. Creates marketplace listing with specified parameters 4. Emits Listings event with complete item details 5. Returns item ID for future reference Events : Listings(nftContract, tokenId, seller, receiver, owner, price, sold, paymentToken) Example Usage : // List NFT for sale with ETH payment address nftContract = 0x1234567890123456789012345678901234567890 ; uint256 tokenId = 123 ; uint256 price = 1 ether ; // First approve marketplace to transfer NFT IERC721 ( nftContract ). approve ( marketplaceAddress , tokenId ); // List the item IMarketplace ( marketplace ). listItem ( nftContract , payable ( msg.sender ), // Receive proceeds tokenId , price , true , // Transfer NFT to marketplace address ( 0 ) // ETH payment ); console . log ( \"NFT listed for sale at\" , price , \"ETH\" ); Payment Token Options : // List with USDC payment address usdcToken = 0xA0b86a33E6441e6e80A7181a02d0d25e8E687770 ; uint256 usdcPrice = 1000 * 10 ** 6 ; // 1000 USDC IMarketplace ( marketplace ). listItem ( nftContract , payable ( msg.sender ), tokenId , usdcPrice , true , usdcToken );","title":"listItem()"},{"location":"smart-contracts/interfaces/imarketplace/#delistitem","text":"function delistItem ( address nftContract , uint256 itemId ) external Purpose : Removes an NFT listing from the marketplace. Parameters : - nftContract (address): Address of the NFT contract - itemId (uint256): ID of the marketplace item to delist Access Control : Seller or authorized party only Process : 1. Validates caller has permission to delist 2. Removes item from active marketplace listings 3. Returns NFT to seller if in marketplace custody 4. Updates item status to delisted 5. Emits Delisted event Events : Delisted(itemId) Example Usage : // Delist an NFT from the marketplace uint256 itemId = 456 ; address nftContract = 0x1234567890123456789012345678901234567890 ; IMarketplace ( marketplace ). delistItem ( nftContract , itemId ); console . log ( \"Item\" , itemId , \"delisted from marketplace\" );","title":"delistItem()"},{"location":"smart-contracts/interfaces/imarketplace/#purchase-functions","text":"","title":"Purchase Functions"},{"location":"smart-contracts/interfaces/imarketplace/#purchaseitem","text":"function purchaseItem ( address nftContract , uint256 itemId ) external payable Purpose : Purchases an NFT from the marketplace. Parameters : - nftContract (address): Address of the NFT contract - itemId (uint256): ID of the marketplace item to purchase Access Control : Public (with payment validation) Process : 1. Validates item is available for purchase 2. Processes payment according to item's payment token 3. Calculates and distributes fees to configured receivers 4. Transfers remaining proceeds to seller/receiver 5. Transfers NFT to buyer 6. Updates item status to sold 7. Emits Sales event Events : Sales(tokenAddress, tokenId, owner) Example Usage : // Purchase NFT with ETH uint256 itemId = 456 ; address nftContract = 0x1234567890123456789012345678901234567890 ; // Get item details first MarketItem memory item = IMarketplace ( marketplace ). fetchItem ( nftContract , itemId ); require ( ! item . sold , \"Item already sold\" ); // Purchase with ETH IMarketplace ( marketplace ). purchaseItem { value : item . price }( nftContract , itemId ); console . log ( \"NFT purchased for\" , item . price , \"ETH\" ); ERC20 Token Purchase : // Purchase NFT with ERC20 token MarketItem memory item = IMarketplace ( marketplace ). fetchItem ( nftContract , itemId ); if ( item . paymentToken != address ( 0 )) { // Approve token transfer first IERC20 ( item . paymentToken ). approve ( marketplaceAddress , item . price ); // Purchase (no ETH value needed) IMarketplace ( marketplace ). purchaseItem ( nftContract , itemId ); }","title":"purchaseItem()"},{"location":"smart-contracts/interfaces/imarketplace/#query-functions","text":"","title":"Query Functions"},{"location":"smart-contracts/interfaces/imarketplace/#fetchitems","text":"function fetchItems () external view returns ( MarketItem [] memory ) Purpose : Retrieves all active marketplace listings. Returns : - MarketItem[] : Array of all marketplace items Example Usage : // Get all marketplace listings MarketItem [] memory allItems = IMarketplace ( marketplace ). fetchItems (); console . log ( \"Total marketplace items:\" , allItems . length ); for ( uint256 i = 0 ; i < allItems . length ; i ++ ) { MarketItem memory item = allItems [ i ]; if ( ! item . sold ) { console . log ( \"Available NFT:\" , item . nftContract , \"Token ID:\" , item . tokenId , \"Price:\" , item . price ); } }","title":"fetchItems()"},{"location":"smart-contracts/interfaces/imarketplace/#fetchitem","text":"function fetchItem ( address nftContract , uint256 tokenId ) external view returns ( MarketItem memory ) Purpose : Retrieves details for a specific NFT listing. Parameters : - nftContract (address): Address of the NFT contract - tokenId (uint256): ID of the token Returns : - MarketItem : Complete item details Example Usage : // Get specific item details address nftContract = 0x1234567890123456789012345678901234567890 ; uint256 tokenId = 123 ; MarketItem memory item = IMarketplace ( marketplace ). fetchItem ( nftContract , tokenId ); if ( item . nftContract != address ( 0 )) { console . log ( \"Item found:\" ); console . log ( \"- Seller:\" , item . seller ); console . log ( \"- Price:\" , item . price ); console . log ( \"- Sold:\" , item . sold ); console . log ( \"- Payment Token:\" , item . paymentToken ); } else { console . log ( \"Item not found in marketplace\" ); }","title":"fetchItem()"},{"location":"smart-contracts/interfaces/imarketplace/#getmarketplacefeereceivers","text":"function getMarketplaceFeeReceivers () external view returns ( FeeReceiver [] memory ) Purpose : Returns the current fee configuration for marketplace transactions. Returns : - FeeReceiver[] : Array of fee receiver configurations Example Usage : // Check marketplace fee structure FeeReceiver [] memory feeReceivers = IMarketplace ( marketplace ). getMarketplaceFeeReceivers (); console . log ( \"Marketplace fee structure:\" ); uint256 totalFeePerMillion = 0 ; for ( uint256 i = 0 ; i < feeReceivers . length ; i ++ ) { FeeReceiver memory fee = feeReceivers [ i ]; uint256 feePercentage = fee . sharePerMillion / 10000 ; // Convert to basis points console . log ( \"- Receiver:\" , fee . receiver ); console . log ( \"- Fee:\" , feePercentage / 100 , \".\" , feePercentage % 100 , \"%\" ); totalFeePerMillion += fee . sharePerMillion ; } console . log ( \"Total marketplace fee:\" , totalFeePerMillion / 10000 / 100 , \".\" , ( totalFeePerMillion / 10000 ) % 100 , \"%\" );","title":"getMarketplaceFeeReceivers()"},{"location":"smart-contracts/interfaces/imarketplace/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/imarketplace/#complete-marketplace-integration","text":"// Comprehensive marketplace integration example contract NFTMarketplaceIntegration { IMarketplace public marketplace ; struct ListingInfo { uint256 itemId ; uint256 listingTime ; uint256 views ; bool featured ; } mapping ( address => mapping ( uint256 => ListingInfo )) public listingInfo ; mapping ( address => uint256 []) public userListings ; event ItemListed ( address indexed nftContract , uint256 indexed tokenId , address indexed seller , uint256 price ); event ItemPurchased ( address indexed nftContract , uint256 indexed tokenId , address indexed buyer , uint256 price ); event ItemDelisted ( address indexed nftContract , uint256 indexed tokenId , address indexed seller ); constructor ( address _marketplace ) { marketplace = IMarketplace ( _marketplace ); } function listNFTForSale ( address nftContract , uint256 tokenId , uint256 price , address paymentToken , bool featured ) external { // Verify ownership require ( IERC721 ( nftContract ). ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); // List on marketplace marketplace . listItem ( nftContract , payable ( msg.sender ), tokenId , price , true , // Transfer to marketplace paymentToken ); // Track listing info listingInfo [ nftContract ][ tokenId ] = ListingInfo ({ itemId : tokenId , // Simplified - would get actual item ID listingTime : block.timestamp , views : 0 , featured : featured }); userListings [ msg.sender ]. push ( tokenId ); emit ItemListed ( nftContract , tokenId , msg.sender , price ); } function purchaseNFT ( address nftContract , uint256 tokenId ) external payable { // Get item details MarketItem memory item = marketplace . fetchItem ( nftContract , tokenId ); require ( ! item . sold , \"Item already sold\" ); require ( item . nftContract != address ( 0 ), \"Item not found\" ); // Handle payment if ( item . paymentToken == address ( 0 )) { // ETH payment require ( msg.value >= item . price , \"Insufficient ETH\" ); marketplace . purchaseItem { value : item . price }( nftContract , tokenId ); // Refund excess ETH if ( msg.value > item . price ) { payable ( msg.sender ). transfer ( msg.value - item . price ); } } else { // ERC20 payment require ( msg.value == 0 , \"Do not send ETH for token payments\" ); // Transfer tokens to this contract first, then to marketplace IERC20 ( item . paymentToken ). transferFrom ( msg.sender , address ( this ), item . price ); IERC20 ( item . paymentToken ). approve ( address ( marketplace ), item . price ); marketplace . purchaseItem ( nftContract , tokenId ); } emit ItemPurchased ( nftContract , tokenId , msg.sender , item . price ); } function delistNFT ( address nftContract , uint256 tokenId ) external { // Verify seller MarketItem memory item = marketplace . fetchItem ( nftContract , tokenId ); require ( item . seller == msg.sender , \"Not the seller\" ); require ( ! item . sold , \"Item already sold\" ); // Delist from marketplace marketplace . delistItem ( nftContract , tokenId ); // Clean up tracking delete listingInfo [ nftContract ][ tokenId ]; _removeFromUserListings ( msg.sender , tokenId ); emit ItemDelisted ( nftContract , tokenId , msg.sender ); } function getMarketplaceOverview () external view returns ( uint256 totalListings , uint256 totalSold , uint256 averagePrice , FeeReceiver [] memory feeStructure ) { MarketItem [] memory allItems = marketplace . fetchItems (); totalListings = allItems . length ; uint256 totalValue = 0 ; for ( uint256 i = 0 ; i < allItems . length ; i ++ ) { if ( allItems [ i ]. sold ) { totalSold ++ ; } totalValue += allItems [ i ]. price ; } if ( totalListings > 0 ) { averagePrice = totalValue / totalListings ; } feeStructure = marketplace . getMarketplaceFeeReceivers (); } function getUserListings ( address user ) external view returns ( uint256 [] memory tokenIds , MarketItem [] memory items ) { uint256 [] memory userTokenIds = userListings [ user ]; tokenIds = new uint256 []( userTokenIds . length ); items = new MarketItem []( userTokenIds . length ); for ( uint256 i = 0 ; i < userTokenIds . length ; i ++ ) { tokenIds [ i ] = userTokenIds [ i ]; // Would need to track NFT contract addresses for complete implementation } } function _removeFromUserListings ( address user , uint256 tokenId ) internal { uint256 [] storage listings = userListings [ user ]; for ( uint256 i = 0 ; i < listings . length ; i ++ ) { if ( listings [ i ] == tokenId ) { listings [ i ] = listings [ listings . length - 1 ]; listings . pop (); break ; } } } }","title":"Complete Marketplace Integration"},{"location":"smart-contracts/interfaces/imarketplace/#marketplace-analytics-system","text":"// Analytics and reporting for marketplace activity contract MarketplaceAnalytics { IMarketplace public marketplace ; struct SalesData { uint256 totalSales ; uint256 totalVolume ; uint256 averagePrice ; uint256 uniqueBuyers ; uint256 uniqueSellers ; } struct CollectionStats { address nftContract ; uint256 totalListings ; uint256 totalSales ; uint256 totalVolume ; uint256 floorPrice ; uint256 averagePrice ; } mapping ( address => SalesData ) public collectionSales ; mapping ( address => mapping ( uint256 => uint256 )) public dailyVolume ; mapping ( address => bool ) public trackedBuyers ; mapping ( address => bool ) public trackedSellers ; event SaleRecorded ( address indexed nftContract , uint256 indexed tokenId , uint256 price , address buyer , address seller ); event NewCollection ( address indexed nftContract ); function recordSale ( address nftContract , uint256 tokenId , uint256 price , address buyer , address seller ) external onlyAuthorized { SalesData storage data = collectionSales [ nftContract ]; // Update sales data data . totalSales ++ ; data . totalVolume += price ; data . averagePrice = data . totalVolume / data . totalSales ; // Track unique participants if ( ! trackedBuyers [ buyer ]) { trackedBuyers [ buyer ] = true ; data . uniqueBuyers ++ ; } if ( ! trackedSellers [ seller ]) { trackedSellers [ seller ] = true ; data . uniqueSellers ++ ; } // Update daily volume uint256 today = block.timestamp / 1 days ; dailyVolume [ nftContract ][ today ] += price ; emit SaleRecorded ( nftContract , tokenId , price , buyer , seller ); } function getCollectionStats ( address nftContract ) external view returns ( CollectionStats memory ) { MarketItem [] memory allItems = marketplace . fetchItems (); SalesData memory salesData = collectionSales [ nftContract ]; uint256 totalListings = 0 ; uint256 floorPrice = type ( uint256 ). max ; uint256 totalListingValue = 0 ; // Analyze current listings for ( uint256 i = 0 ; i < allItems . length ; i ++ ) { if ( allItems [ i ]. nftContract == nftContract && ! allItems [ i ]. sold ) { totalListings ++ ; totalListingValue += allItems [ i ]. price ; if ( allItems [ i ]. price < floorPrice ) { floorPrice = allItems [ i ]. price ; } } } if ( floorPrice == type ( uint256 ). max ) { floorPrice = 0 ; } return CollectionStats ({ nftContract : nftContract , totalListings : totalListings , totalSales : salesData . totalSales , totalVolume : salesData . totalVolume , floorPrice : floorPrice , averagePrice : salesData . averagePrice }); } function getDailyVolume ( address nftContract , uint256 daysBack ) external view returns ( uint256 [] memory dates , uint256 [] memory volumes ) { dates = new uint256 []( daysBack ); volumes = new uint256 []( daysBack ); uint256 today = block.timestamp / 1 days ; for ( uint256 i = 0 ; i < daysBack ; i ++ ) { uint256 date = today - i ; dates [ i ] = date ; volumes [ i ] = dailyVolume [ nftContract ][ date ]; } } function getTopCollections ( uint256 limit ) external view returns ( address [] memory ) { // Simplified implementation - would need more sophisticated sorting address [] memory collections = new address []( limit ); // Implementation would sort by volume or other metrics return collections ; } }","title":"Marketplace Analytics System"},{"location":"smart-contracts/interfaces/imarketplace/#fee-management-system_1","text":"// Advanced fee management for marketplace contract MarketplaceFeeManager { struct FeeConfig { FeeReceiver [] receivers ; uint256 totalFeePerMillion ; bool active ; uint256 lastUpdated ; } mapping ( address => FeeConfig ) public collectionFees ; FeeConfig public defaultFees ; event FeeConfigUpdated ( address indexed collection , FeeReceiver [] receivers ); event FeeDistributed ( address indexed collection , uint256 totalAmount , address [] receivers , uint256 [] amounts ); function setDefaultFees ( FeeReceiver [] memory receivers ) external onlyOwner { _validateFeeReceivers ( receivers ); delete defaultFees . receivers ; uint256 totalFee = 0 ; for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { defaultFees . receivers . push ( receivers [ i ]); totalFee += receivers [ i ]. sharePerMillion ; } defaultFees . totalFeePerMillion = totalFee ; defaultFees . active = true ; defaultFees . lastUpdated = block.timestamp ; emit FeeConfigUpdated ( address ( 0 ), receivers ); } function setCollectionFees ( address collection , FeeReceiver [] memory receivers ) external onlyOwner { _validateFeeReceivers ( receivers ); delete collectionFees [ collection ]. receivers ; uint256 totalFee = 0 ; for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { collectionFees [ collection ]. receivers . push ( receivers [ i ]); totalFee += receivers [ i ]. sharePerMillion ; } collectionFees [ collection ]. totalFeePerMillion = totalFee ; collectionFees [ collection ]. active = true ; collectionFees [ collection ]. lastUpdated = block.timestamp ; emit FeeConfigUpdated ( collection , receivers ); } function calculateFees ( address collection , uint256 salePrice ) external view returns ( address [] memory receivers , uint256 [] memory amounts , uint256 totalFees ) { FeeConfig memory config = collectionFees [ collection ]. active ? collectionFees [ collection ] : defaultFees ; receivers = new address []( config . receivers . length ); amounts = new uint256 []( config . receivers . length ); for ( uint256 i = 0 ; i < config . receivers . length ; i ++ ) { receivers [ i ] = config . receivers [ i ]. receiver ; amounts [ i ] = ( salePrice * config . receivers [ i ]. sharePerMillion ) / 1000000 ; totalFees += amounts [ i ]; } } function distributeFees ( address collection , uint256 salePrice , address paymentToken ) external payable onlyAuthorized { ( address [] memory receivers , uint256 [] memory amounts , uint256 totalFees ) = this . calculateFees ( collection , salePrice ); if ( paymentToken == address ( 0 )) { // ETH distribution require ( msg.value >= totalFees , \"Insufficient ETH for fees\" ); for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { payable ( receivers [ i ]). transfer ( amounts [ i ]); } } else { // ERC20 distribution for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { IERC20 ( paymentToken ). transferFrom ( msg.sender , receivers [ i ], amounts [ i ]); } } emit FeeDistributed ( collection , totalFees , receivers , amounts ); } function _validateFeeReceivers ( FeeReceiver [] memory receivers ) internal pure { require ( receivers . length > 0 , \"No fee receivers provided\" ); uint256 totalFee = 0 ; for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { require ( receivers [ i ]. receiver != address ( 0 ), \"Invalid receiver address\" ); require ( receivers [ i ]. sharePerMillion > 0 , \"Invalid fee share\" ); totalFee += receivers [ i ]. sharePerMillion ; } require ( totalFee <= 100000 , \"Total fees exceed 10%\" ); // Max 10% total fees } }","title":"Fee Management System"},{"location":"smart-contracts/interfaces/imarketplace/#events","text":"","title":"Events"},{"location":"smart-contracts/interfaces/imarketplace/#listing-events","text":"event Listings ( address indexed nftContract , uint256 indexed tokenId , address seller , address receiver , address owner , uint256 price , bool sold , address paymentToken ); event Delisted ( uint256 indexed itemId );","title":"Listing Events"},{"location":"smart-contracts/interfaces/imarketplace/#trading-events","text":"event Sales ( address indexed tokenAddress , uint256 indexed tokenId , address indexed owner ); event Bids ( uint256 indexed itemId , address bidder , uint256 amount );","title":"Trading Events"},{"location":"smart-contracts/interfaces/imarketplace/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/imarketplace/#access-control","text":"Ownership verification for listing and delisting Payment validation for purchases Fee receiver address validation Proper authorization for administrative functions","title":"Access Control"},{"location":"smart-contracts/interfaces/imarketplace/#payment-security","text":"Secure ETH and ERC20 token handling Proper fee calculation and distribution Protection against reentrancy attacks Validation of payment amounts","title":"Payment Security"},{"location":"smart-contracts/interfaces/imarketplace/#nft-security","text":"Ownership verification before listing Secure NFT transfer mechanisms Protection against unauthorized transfers Proper custody management","title":"NFT Security"},{"location":"smart-contracts/interfaces/imarketplace/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/interfaces/imarketplace/#efficient-operations","text":"Batch operations where possible Optimized storage layout for MarketItem Minimal external calls Efficient fee calculations","title":"Efficient Operations"},{"location":"smart-contracts/interfaces/imarketplace/#query-optimization","text":"Efficient item retrieval patterns Optimized array operations Minimal storage reads Cached calculations where appropriate","title":"Query Optimization"},{"location":"smart-contracts/interfaces/imarketplace/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/interfaces/imarketplace/#unit-tests","text":"Interface compliance verification Data structure validation Function behavior testing Event emission verification","title":"Unit Tests"},{"location":"smart-contracts/interfaces/imarketplace/#integration-tests","text":"End-to-end marketplace workflows Payment processing scenarios Fee distribution testing Multi-token payment testing","title":"Integration Tests"},{"location":"smart-contracts/interfaces/imarketplace/#related-documentation","text":"MarketplaceFacet - Marketplace implementation FeeDistributorFacet - Fee management ERC721 Standard - NFT standard ERC20 Standard - Token standard Marketplace Guide - Implementation guide This interface defines the core contract for NFT marketplace functionality within the Gemforce platform, providing standardized trading operations with flexible payment and fee management.","title":"Related Documentation"},{"location":"smart-contracts/interfaces/imultisale/","text":"IMultiSale Interface \u00b6 The IMultiSale interface defines the standard for smart contracts that enable multi-token sales, supporting various token types (ERC20, ERC721, ERC1155) and flexible payment methods. This interface is crucial for implementing diverse sale mechanisms within the Gemforce ecosystem, such as presales, public sales, and Dutch auctions. Overview \u00b6 IMultiSale provides: Token Flexibility : Supports ERC20, ERC721, and ERC1155 tokens. Payment Versatility : Configurable payment tokens and currencies. Sale Lifecycle Management : Functions for starting, pausing, and ending sales. Participation Control : Mechanisms for whitelisting and setting purchase limits. Event Tracking : Comprehensive event logging for sale activities. Key Features \u00b6 Sale Management \u00b6 Start/Pause/End : Control the lifecycle of sales Configuration : Set sale parameters like price, duration, limits Fund Collection : Manage primary and secondary payment collection Purchase Mechanics \u00b6 Direct Purchase : Standard buy function Batch Purchase : Purchase multiple items or tokens at once Dynamic Pricing : Support for variable pricing models (e.g., fixed, exponential, inverse logarithmic) Refunds : Mechanism for handling failed purchases or refunds Whitelisting and Access Control \u00b6 Whitelist Management : Add and remove addresses from whitelists Purchase Limits : Set maximum purchase quantities per address Role-Based Access : Define roles for managing sale configurations Interface Definition \u00b6 interface IMultiSale { // Events event SaleStarted ( bytes32 indexed saleId , address indexed seller , uint256 startTime , uint256 endTime ); event SalePaused ( bytes32 indexed saleId ); event SaleEnded ( bytes32 indexed saleId ); event Purchase ( bytes32 indexed saleId , address indexed buyer , address indexed token , uint256 indexed tokenId , uint256 amount , uint256 pricePaid , address paymentToken ); event PaymentCollected ( bytes32 indexed saleId , address indexed payee , address paymentToken , uint256 amount ); event WhitelistUpdated ( bytes32 indexed saleId , address indexed addr , bool whitelisted ); event SaleConfigUpdated ( bytes32 indexed saleId ); // Enums enum SaleState { NOT_STARTED , ACTIVE , PAUSED , ENDED } enum TokenType { ERC20 , ERC721 , ERC1155 } // Structs struct SaleConfig { address seller ; address saleTokenAddress ; TokenType saleTokenType ; uint256 saleTokenId ; // For ERC721/ERC1155, 0 for ERC20 uint256 totalAmount ; // For ERC20/ERC1155, total NFTs for ERC721 uint256 price ; // Base price or starting price address paymentTokenAddress ; uint256 startTime ; uint256 endTime ; uint256 maxPurchasePerAddress ; bool isWhitelistedSale ; address initialReceiver ; // Where initial payment goes, often a treasury uint256 initialPaymentAmount ; // Amount to collect initially uint256 feePercentage ; // Percentage fee for the platform address feeReceiver ; // Address to receive fees string name ; string description ; bytes data ; // Additional data for specific sale types (e.g., pricing curves) } struct SaleDetails { SaleConfig config ; SaleState state ; uint256 amountSold ; uint256 totalRevenue ; uint256 collectedPayment ; address [] buyers ; mapping ( address => uint256 ) purchasedAmount ; mapping ( address => bool ) whitelisted ; } // Sale Management Functions function createSale ( SaleConfig calldata config ) external returns ( bytes32 saleId ); function startSale ( bytes32 saleId ) external ; function pauseSale ( bytes32 saleId ) external ; function endSale ( bytes32 saleId ) external ; function updateSaleConfig ( bytes32 saleId , SaleConfig calldata newConfig ) external ; // Purchase Functions function buy ( bytes32 saleId , uint256 amount ) external payable ; function buyBatch ( bytes32 saleId , uint256 [] calldata amounts ) external payable ; function refund ( bytes32 saleId , uint256 amount ) external ; // Whitelist Functions function addToWhitelist ( bytes32 saleId , address [] calldata addrs ) external ; function removeFromWhitelist ( bytes32 saleId , address [] calldata addrs ) external ; function isWhitelisted ( bytes32 saleId , address addr ) external view returns ( bool ); // Query Functions function getSaleConfig ( bytes32 saleId ) external view returns ( SaleConfig memory ); function getSaleState ( bytes32 saleId ) external view returns ( SaleState ); function getAmountSold ( bytes32 saleId ) external view returns ( uint256 ); function getTotalRevenue ( bytes32 saleId ) external view returns ( uint256 ); function getPurchasedAmount ( bytes32 saleId , address buyer ) external view returns ( uint256 ); function getAllActiveSales () external view returns ( bytes32 [] memory ); function getSalesBySeller ( address seller ) external view returns ( bytes32 [] memory ); function getSalesByPaymentToken ( address paymentToken ) external view returns ( bytes32 [] memory ); function getCurrentPrice ( bytes32 saleId ) external view returns ( uint256 ); // Payment Collection Functions function sweepFunds ( bytes32 saleId , address receiver ) external ; function collectFees ( bytes32 saleId , address feeReceiver ) external ; } Core Functions \u00b6 createSale() \u00b6 Initializes and creates a new multi-token sale with the specified configuration. Parameters: - config : A SaleConfig struct containing all parameters for the sale. Returns: - bytes32 : A unique identifier for the created sale ( saleId ). Usage: IMultiSale . SaleConfig memory saleConfig = IMultiSale . SaleConfig ({ seller : msg.sender , saleTokenAddress : address ( nftContract ), saleTokenType : IMultiSale . TokenType . ERC721 , saleTokenId : 0 , // Not applicable for ERC721 general sale totalAmount : 100 , price : 1 ether , // Price per NFT paymentTokenAddress : address ( 0 ), // ETH startTime : block.timestamp + 1 hours , endTime : block.timestamp + 2 hours , maxPurchasePerAddress : 5 , isWhitelistedSale : false , initialReceiver : treasury , initialPaymentAmount : 0 , feePercentage : 500 , // 5% feeReceiver : platformFeeRecipient , name : \"My NFT Sale\" , description : \"A limited edition NFT collection.\" , data : \"\" }); bytes32 mySaleId = multiSaleContract . createSale ( saleConfig ); buy() \u00b6 Allows a buyer to purchase amount of tokens/NFTs from an active sale. Parameters: - saleId : The ID of the sale. - amount : The quantity of tokens/NFTs to purchase. Behavior: - Requires msg.value to match the calculated total price if payable ETH is used. - Transfers the sale tokens to the buyer and collects payment. - Updates amountSold and totalRevenue . addToWhitelist() \u00b6 Adds multiple addresses to the whitelist for a specific sale. Only applicable for whitelisted sales. Parameters: - saleId : The ID of the sale. - addrs : An array of addresses to add to the whitelist. Implementation Example \u00b6 Basic MultiSale Contract \u00b6 contract MultiSale is IMultiSale { // Storage mapping ( bytes32 => SaleDetails ) public sales ; mapping ( address => bytes32 []) public salesBySeller ; mapping ( bytes32 => address => uint256 ) private _purchasedAmount ; // Keep track of amounts bytes32 [] private _allSales ; // Dependencies (example simplified, in real scenario these would be injected) IERC20 private _erc20 ; IERC721 private _erc721 ; IERC1155 private _erc1155 ; constructor ( address erc20Addr , address erc721Addr , address erc1155Addr ) { _erc20 = IERC20 ( erc20Addr ); _erc721 = IERC721 ( erc721Addr ); _erc1155 = IERC1155 ( erc1155Addr ); } function createSale ( SaleConfig calldata config ) external returns ( bytes32 saleId ) { saleId = keccak256 ( abi . encodePacked ( block.timestamp , config . seller )); require ( sales [ saleId ]. config . seller == address ( 0 ), \"Sale ID collision\" ); // Basic validation require ( config . totalAmount > 0 , \"Total amount must be greater than 0\" ); require ( config . price > 0 , \"Price must be greater than 0\" ); require ( config . endTime > config . startTime , \"End time must be after start time\" ); require ( config . initialReceiver != address ( 0 ), \"Initial receiver cannot be zero address\" ); // Initialize SaleDetails sales [ saleId ]. config = config ; sales [ saleId ]. state = SaleState . NOT_STARTED ; sales [ saleId ]. amountSold = 0 ; sales [ saleId ]. totalRevenue = 0 ; sales [ saleId ]. collectedPayment = 0 ; sales [ saleId ]. config . seller = msg.sender ; // Ensure seller is creation caller salesBySeller [ msg.sender ]. push ( saleId ); _allSales . push ( saleId ); emit SaleConfigUpdated ( saleId ); } function startSale ( bytes32 saleId ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Caller not seller\" ); require ( sale . state == SaleState . NOT_STARTED || sale . state == SaleState . PAUSED , \"Sale not in votable state\" ); require ( block.timestamp >= sale . config . startTime , \"Sale has not started yet\" ); require ( block.timestamp <= sale . config . endTime , \"Sale has already ended\" ); sale . state = SaleState . ACTIVE ; emit SaleStarted ( saleId , msg.sender , sale . config . startTime , sale . config . endTime ); } function pauseSale ( bytes32 saleId ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Caller not seller\" ); require ( sale . state == SaleState . ACTIVE , \"Sale not active\" ); sale . state = SaleState . PAUSED ; emit SalePaused ( saleId ); } function endSale ( bytes32 saleId ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender || block.timestamp > sale . config . endTime , \"Caller not seller or sale not ended\" ); require ( sale . state == SaleState . ACTIVE || sale . state == SaleState . PAUSED , \"Sale already ended or not started\" ); sale . state = SaleState . ENDED ; emit SaleEnded ( saleId ); } function buy ( bytes32 saleId , uint256 amount ) external payable { SaleDetails storage sale = sales [ saleId ]; require ( sale . state == SaleState . ACTIVE , \"Sale not active\" ); require ( sale . amountSold + amount <= sale . config . totalAmount , \"Exceeds total available\" ); require ( amount > 0 , \"Amount must be greater than 0\" ); if ( sale . config . isWhitelistedSale ) { require ( sale . whitelisted [ msg.sender ], \"Not whitelisted\" ); } require ( _purchasedAmount [ saleId ][ msg.sender ] + amount <= sale . config . maxPurchasePerAddress , \"Exceeds max purchase per address\" ); uint256 currentPrice = getCurrentPrice ( saleId ); // Supports dynamic pricing uint256 totalPrice = currentPrice * amount ; if ( sale . config . paymentTokenAddress == address ( 0 )) { // ETH payment require ( msg.value == totalPrice , \"Incorrect ETH amount sent\" ); } else { // ERC20 payment require ( msg.value == 0 , \"Do not send ETH for ERC20 payment\" ); IERC20 ( sale . config . paymentTokenAddress ). transferFrom ( msg.sender , address ( this ), totalPrice ); } // Transfer sale tokens _transferSaleTokens ( saleId , msg.sender , amount ); sale . amountSold += amount ; sale . totalRevenue += totalPrice ; _purchasedAmount [ saleId ][ msg.sender ] += amount ; bool buyerFound = false ; for ( uint i = 0 ; i < sale . buyers . length ; i ++ ) { if ( sale . buyers [ i ] == msg.sender ) { buyerFound = true ; break ; } } if ( ! buyerFound ) { sale . buyers . push ( msg.sender ); } emit Purchase ( saleId , msg.sender , sale . config . saleTokenAddress , sale . config . saleTokenId , amount , totalPrice , sale . config . paymentTokenAddress ); } function _transferSaleTokens ( bytes32 saleId , address buyer , uint256 amount ) internal { SaleConfig storage config = sales [ saleId ]. config ; if ( config . saleTokenType == TokenType . ERC20 ) { _erc20 . transfer ( buyer , amount ); // from MultiSale contract's balance } else if ( config . saleTokenType == TokenType . ERC721 ) { for ( uint256 i = 0 ; i < amount ; i ++ ) { // Assuming saleTokenId is the starting ID or a way to select NFTs _erc721 . transferFrom ( address ( this ), buyer , config . saleTokenId + sales [ saleId ]. amountSold + i ); } } else if ( config . saleTokenType == TokenType . ERC1155 ) { _erc1155 . safeTransferFrom ( address ( this ), buyer , config . saleTokenId , amount , \"\" ); } } function addToWhitelist ( bytes32 saleId , address [] calldata addrs ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Caller not seller\" ); require ( sale . config . isWhitelistedSale , \"Not a whitelisted sale\" ); for ( uint256 i = 0 ; i < addrs . length ; i ++ ) { require ( addrs [ i ] != address ( 0 ), \"Cannot whitelist zero address\" ); sale . whitelisted [ addrs [ i ]] = true ; emit WhitelistUpdated ( saleId , addrs [ i ], true ); } } // Example of a simple getCurrentPrice, could be replaced by an external VariablePriceLib function getCurrentPrice ( bytes32 saleId ) public view returns ( uint256 ) { return sales [ saleId ]. config . price ; } function getSaleConfig ( bytes32 saleId ) external view returns ( SaleConfig memory ) { return sales [ saleId ]. config ; } function getSaleState ( bytes32 saleId ) external view returns ( SaleState ) { return sales [ saleId ]. state ; } function getAmountSold ( bytes32 saleId ) external view returns ( uint256 ) { return sales [ saleId ]. amountSold ; } function getTotalRevenue ( bytes32 saleId ) external view returns ( uint256 ) { return sales [ saleId ]. totalRevenue ; } function getPurchasedAmount ( bytes32 saleId , address buyer ) external view returns ( uint256 ) { return _purchasedAmount [ saleId ][ buyer ]; } function getAllActiveSales () external view returns ( bytes32 [] memory ) { bytes32 [] memory activeSales ; uint256 count = 0 ; for ( uint i = 0 ; i < _allSales . length ; i ++ ) { if ( sales [ _allSales [ i ]]. state == SaleState . ACTIVE ) { count ++ ; } } activeSales = new bytes32 []( count ); uint256 j = 0 ; for ( uint i = 0 ; i < _allSales . length ; i ++ ) { if ( sales [ _allSales [ i ]]. state == SaleState . ACTIVE ) { activeSales [ j ] = _allSales [ i ]; j ++ ; } } return activeSales ; } function getSalesBySeller ( address seller ) external view returns ( bytes32 [] memory ) { return salesBySeller [ seller ]; } function getSalesByPaymentToken ( address paymentToken ) external view returns ( bytes32 [] memory ) { bytes32 [] memory salesList ; uint256 count = 0 ; for ( uint i = 0 ; i < _allSales . length ; i ++ ) { if ( sales [ _allSales [ i ]]. config . paymentTokenAddress == paymentToken ) { count ++ ; } } salesList = new bytes32 []( count ); uint256 j = 0 ; for ( uint i = 0 ; i < _allSales . length ; i ++ ) { if ( sales [ _allSales [ i ]]. config . paymentTokenAddress == paymentToken ) { salesList [ j ] = _allSales [ i ]; j ++ ; } } return salesList ; } function refund ( bytes32 saleId , uint256 amount ) external { // Implement refund logic: check if refund is allowed, transfer funds back // This is a simplified example. Real-world would involve more checks. SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Only seller can refund\" ); require ( sale . state == SaleState . ENDED , \"Sale must be ended to refund\" ); // Further logic to identify who to refund and how much // For demonstration, let's assume it's a direct refund mechanism. // Requires a way to track individual buyer payments which isn't fully detailed in this basic interface. // E.g., if a purchase failed midway or for return policies. if ( sale . config . paymentTokenAddress == address ( 0 )) { payable ( msg.sender ). transfer ( amount ); } else { IERC20 ( sale . config . paymentTokenAddress ). transfer ( msg.sender , amount ); } } function sweepFunds ( bytes32 saleId , address receiver ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Caller not seller\" ); require ( sale . state == SaleState . ENDED , \"Sale must be ended\" ); uint256 balance = ( sale . config . paymentTokenAddress == address ( 0 )) ? address ( this ). balance : IERC20 ( sale . config . paymentTokenAddress ). balanceOf ( address ( this )); require ( balance > 0 , \"No funds to sweep\" ); uint256 amountToSweep = balance - ( balance * sale . config . feePercentage / 10000 ); // Exclude fees if ( sale . config . paymentTokenAddress == address ( 0 )) { payable ( receiver ). transfer ( amountToSweep ); } else { IERC20 ( sale . config . paymentTokenAddress ). transfer ( receiver , amountToSweep ); } sale . collectedPayment += amountToSweep ; emit PaymentCollected ( saleId , receiver , sale . config . paymentTokenAddress , amountToSweep ); } function collectFees ( bytes32 saleId , address feeReceiver ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Caller not seller\" ); require ( sale . state == SaleState . ENDED , \"Sale must be ended to collect fees\" ); uint256 totalCollected = ( sale . config . paymentTokenAddress == address ( 0 )) ? address ( this ). balance : IERC20 ( sale . config . paymentTokenAddress ). balanceOf ( address ( this )); uint256 feeAmount = totalCollected * sale . config . feePercentage / 10000 ; if ( feeAmount > 0 ) { if ( sale . config . paymentTokenAddress == address ( 0 )) { payable ( feeReceiver ). transfer ( feeAmount ); } else { IERC20 ( sale . config . paymentTokenAddress ). transfer ( feeReceiver , feeAmount ); } emit PaymentCollected ( saleId , feeReceiver , sale . config . paymentTokenAddress , feeAmount ); } } function updateSaleConfig ( bytes32 saleId , SaleConfig calldata newConfig ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Caller not seller\" ); require ( sale . state == SaleState . NOT_STARTED || sale . state == SaleState . PAUSED , \"Can only update config when not active\" ); // Implement logic to update only allowed fields to prevent abuse sale . config = newConfig ; // For simplicity, replacing whole config. In real scenario, selective updates. emit SaleConfigUpdated ( saleId ); } } Security Considerations \u00b6 Access Control \u00b6 Seller Privileges : Ensure only the designated seller can manage sale lifecycle. Whitelist Management : Restrict whitelist updates to authorized roles. Fund Control : Implement secure mechanisms for fund collection and fee distribution. Fund Safety \u00b6 Reentrancy Protection : Use reentrancy guards on all critical transfer functions. Input Validation : Strict validation of amount , price , and addresses . Token Handling : Proper handling of ERC20, ERC721, and ERC1155 transfers. Sale Integrity \u00b6 State Checks : Verify sale state ( ACTIVE , PAUSED , ENDED ) before transactions. Price Consistency : Ensure pricing logic is robust and tamper-proof. Overflow/Underflow : Protect against integer overflows/underflows in calculations. Best Practices \u00b6 Sale Configuration \u00b6 Clear Parameters : Define unambiguous sale parameters. Flexible Pricing : Support various pricing models (fixed, dynamic). Refund Policy : Implement clear and transparent refund mechanisms. Token Management \u00b6 Approve Before Transfer : For ERC20, ensure the MultiSale contract has sufficient allowance. Safe ERC721/ERC1155 Transfers : Use safeTransferFrom to prevent token loss. Ownership Transfer : Ensure sale tokens are transferred to the contract prior to sale. Monitoring and Events \u00b6 Comprehensive Events : Emit events for all significant actions (purchase, start, end, whitelist). Off-chain Indexing : Use events for off-chain indexing and analytics. Integration Examples \u00b6 Frontend Integration (TypeScript) \u00b6 import { ethers , Contract } from 'ethers' ; import MultiSaleABI from './MultiSale.json' ; interface SaleConfig { seller : string ; saleTokenAddress : string ; saleTokenType : number ; // Enum: 0=ERC20, 1=ERC721, 2=ERC1155 saleTokenId : number ; totalAmount : number ; price : number ; paymentTokenAddress : string ; startTime : number ; endTime : number ; maxPurchasePerAddress : number ; isWhitelistedSale : boolean ; initialReceiver : string ; initialPaymentAmount : number ; feePercentage : number ; feeReceiver : string ; name : string ; description : string ; data : string ; } class MultiSaleService { private contract : Contract ; constructor ( contractAddress : string , signer : ethers.Signer ) { this . contract = new Contract ( contractAddress , MultiSaleABI , signer ); } async createNewSale ( config : SaleConfig ) : Promise < string > { const tx = await this . contract . createSale ( config ); const receipt = await tx . wait (); const event = receipt . events ? . find (( e : any ) => e . event === 'SaleConfigUpdated' ); return event ? . args ? . saleId ; } async startSale ( saleId : string ) : Promise < void > { const tx = await this . contract . startSale ( saleId ); await tx . wait (); } async buyTokens ( saleId : string , amount : number , value : ethers.BigNumberish = 0 ) : Promise < void > { const tx = await this . contract . buy ( saleId , amount , { value }); await tx . wait (); } async getSaleDetails ( saleId : string ) : Promise < any > { return await this . contract . getSaleConfig ( saleId ); } async checkWhitelist ( saleId : string , address : string ) : Promise < boolean > { return await this . contract . isWhitelisted ( saleId , address ); } } Backend Integration (Node.js with web3.js) \u00b6 const Web3 = require ( 'web3' ); const MultiSaleABI = require ( './MultiSale.json' ). abi ; class MultiSaleBackend { constructor ( providerUrl , multiSaleContractAddress ) { this . web3 = new Web3 ( providerUrl ); this . multiSaleContract = new this . web3 . eth . Contract ( MultiSaleABI , multiSaleContractAddress ); } async addAddressesToWhitelist ( privateKey , saleId , addresses ) { const account = this . web3 . eth . accounts . privateKeyToAccount ( privateKey ); this . web3 . eth . accounts . wallet . add ( account ); const gasEstimate = await this . multiSaleContract . methods . addToWhitelist ( saleId , addresses ). estimateGas ({ from : account . address }); const tx = await this . multiSaleContract . methods . addToWhitelist ( saleId , addresses ). send ({ from : account . address , gas : gasEstimate }); console . log ( `Whitelist updated for sale ${ saleId } : ${ tx . transactionHash } ` ); return tx ; } async getActiveSales () { return await this . multiSaleContract . methods . getAllActiveSales (). call (); } async handlePurchaseWebhook ( saleId , buyerAddress , amount , pricePaid , paymentToken ) { console . log ( `Processing purchase for sale: ${ saleId } ` ); console . log ( `Buyer: ${ buyerAddress } , Amount: ${ amount } , Price: ${ pricePaid } , Payment Token: ${ paymentToken } ` ); // Here you would integrate with your backend systems, e.g., // update internal databases, trigger notifications, etc. } } Related Documentation \u00b6 Variable Price Library ERC20 Standard ERC721 Standard ERC1155 Standard Fee Distributor Library Deployment Guide Standards Compliance \u00b6 ERC20 : Tokens used for payment or sale. ERC721 : NFTs used for sale. ERC1155 : Multi-tokens used for sale. EIP-165 : Interface detection standard (implicitly used by calling IERC* functions).","title":"IMultiSale"},{"location":"smart-contracts/interfaces/imultisale/#imultisale-interface","text":"The IMultiSale interface defines the standard for smart contracts that enable multi-token sales, supporting various token types (ERC20, ERC721, ERC1155) and flexible payment methods. This interface is crucial for implementing diverse sale mechanisms within the Gemforce ecosystem, such as presales, public sales, and Dutch auctions.","title":"IMultiSale Interface"},{"location":"smart-contracts/interfaces/imultisale/#overview","text":"IMultiSale provides: Token Flexibility : Supports ERC20, ERC721, and ERC1155 tokens. Payment Versatility : Configurable payment tokens and currencies. Sale Lifecycle Management : Functions for starting, pausing, and ending sales. Participation Control : Mechanisms for whitelisting and setting purchase limits. Event Tracking : Comprehensive event logging for sale activities.","title":"Overview"},{"location":"smart-contracts/interfaces/imultisale/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/imultisale/#sale-management","text":"Start/Pause/End : Control the lifecycle of sales Configuration : Set sale parameters like price, duration, limits Fund Collection : Manage primary and secondary payment collection","title":"Sale Management"},{"location":"smart-contracts/interfaces/imultisale/#purchase-mechanics","text":"Direct Purchase : Standard buy function Batch Purchase : Purchase multiple items or tokens at once Dynamic Pricing : Support for variable pricing models (e.g., fixed, exponential, inverse logarithmic) Refunds : Mechanism for handling failed purchases or refunds","title":"Purchase Mechanics"},{"location":"smart-contracts/interfaces/imultisale/#whitelisting-and-access-control","text":"Whitelist Management : Add and remove addresses from whitelists Purchase Limits : Set maximum purchase quantities per address Role-Based Access : Define roles for managing sale configurations","title":"Whitelisting and Access Control"},{"location":"smart-contracts/interfaces/imultisale/#interface-definition","text":"interface IMultiSale { // Events event SaleStarted ( bytes32 indexed saleId , address indexed seller , uint256 startTime , uint256 endTime ); event SalePaused ( bytes32 indexed saleId ); event SaleEnded ( bytes32 indexed saleId ); event Purchase ( bytes32 indexed saleId , address indexed buyer , address indexed token , uint256 indexed tokenId , uint256 amount , uint256 pricePaid , address paymentToken ); event PaymentCollected ( bytes32 indexed saleId , address indexed payee , address paymentToken , uint256 amount ); event WhitelistUpdated ( bytes32 indexed saleId , address indexed addr , bool whitelisted ); event SaleConfigUpdated ( bytes32 indexed saleId ); // Enums enum SaleState { NOT_STARTED , ACTIVE , PAUSED , ENDED } enum TokenType { ERC20 , ERC721 , ERC1155 } // Structs struct SaleConfig { address seller ; address saleTokenAddress ; TokenType saleTokenType ; uint256 saleTokenId ; // For ERC721/ERC1155, 0 for ERC20 uint256 totalAmount ; // For ERC20/ERC1155, total NFTs for ERC721 uint256 price ; // Base price or starting price address paymentTokenAddress ; uint256 startTime ; uint256 endTime ; uint256 maxPurchasePerAddress ; bool isWhitelistedSale ; address initialReceiver ; // Where initial payment goes, often a treasury uint256 initialPaymentAmount ; // Amount to collect initially uint256 feePercentage ; // Percentage fee for the platform address feeReceiver ; // Address to receive fees string name ; string description ; bytes data ; // Additional data for specific sale types (e.g., pricing curves) } struct SaleDetails { SaleConfig config ; SaleState state ; uint256 amountSold ; uint256 totalRevenue ; uint256 collectedPayment ; address [] buyers ; mapping ( address => uint256 ) purchasedAmount ; mapping ( address => bool ) whitelisted ; } // Sale Management Functions function createSale ( SaleConfig calldata config ) external returns ( bytes32 saleId ); function startSale ( bytes32 saleId ) external ; function pauseSale ( bytes32 saleId ) external ; function endSale ( bytes32 saleId ) external ; function updateSaleConfig ( bytes32 saleId , SaleConfig calldata newConfig ) external ; // Purchase Functions function buy ( bytes32 saleId , uint256 amount ) external payable ; function buyBatch ( bytes32 saleId , uint256 [] calldata amounts ) external payable ; function refund ( bytes32 saleId , uint256 amount ) external ; // Whitelist Functions function addToWhitelist ( bytes32 saleId , address [] calldata addrs ) external ; function removeFromWhitelist ( bytes32 saleId , address [] calldata addrs ) external ; function isWhitelisted ( bytes32 saleId , address addr ) external view returns ( bool ); // Query Functions function getSaleConfig ( bytes32 saleId ) external view returns ( SaleConfig memory ); function getSaleState ( bytes32 saleId ) external view returns ( SaleState ); function getAmountSold ( bytes32 saleId ) external view returns ( uint256 ); function getTotalRevenue ( bytes32 saleId ) external view returns ( uint256 ); function getPurchasedAmount ( bytes32 saleId , address buyer ) external view returns ( uint256 ); function getAllActiveSales () external view returns ( bytes32 [] memory ); function getSalesBySeller ( address seller ) external view returns ( bytes32 [] memory ); function getSalesByPaymentToken ( address paymentToken ) external view returns ( bytes32 [] memory ); function getCurrentPrice ( bytes32 saleId ) external view returns ( uint256 ); // Payment Collection Functions function sweepFunds ( bytes32 saleId , address receiver ) external ; function collectFees ( bytes32 saleId , address feeReceiver ) external ; }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/imultisale/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/imultisale/#createsale","text":"Initializes and creates a new multi-token sale with the specified configuration. Parameters: - config : A SaleConfig struct containing all parameters for the sale. Returns: - bytes32 : A unique identifier for the created sale ( saleId ). Usage: IMultiSale . SaleConfig memory saleConfig = IMultiSale . SaleConfig ({ seller : msg.sender , saleTokenAddress : address ( nftContract ), saleTokenType : IMultiSale . TokenType . ERC721 , saleTokenId : 0 , // Not applicable for ERC721 general sale totalAmount : 100 , price : 1 ether , // Price per NFT paymentTokenAddress : address ( 0 ), // ETH startTime : block.timestamp + 1 hours , endTime : block.timestamp + 2 hours , maxPurchasePerAddress : 5 , isWhitelistedSale : false , initialReceiver : treasury , initialPaymentAmount : 0 , feePercentage : 500 , // 5% feeReceiver : platformFeeRecipient , name : \"My NFT Sale\" , description : \"A limited edition NFT collection.\" , data : \"\" }); bytes32 mySaleId = multiSaleContract . createSale ( saleConfig );","title":"createSale()"},{"location":"smart-contracts/interfaces/imultisale/#buy","text":"Allows a buyer to purchase amount of tokens/NFTs from an active sale. Parameters: - saleId : The ID of the sale. - amount : The quantity of tokens/NFTs to purchase. Behavior: - Requires msg.value to match the calculated total price if payable ETH is used. - Transfers the sale tokens to the buyer and collects payment. - Updates amountSold and totalRevenue .","title":"buy()"},{"location":"smart-contracts/interfaces/imultisale/#addtowhitelist","text":"Adds multiple addresses to the whitelist for a specific sale. Only applicable for whitelisted sales. Parameters: - saleId : The ID of the sale. - addrs : An array of addresses to add to the whitelist.","title":"addToWhitelist()"},{"location":"smart-contracts/interfaces/imultisale/#implementation-example","text":"","title":"Implementation Example"},{"location":"smart-contracts/interfaces/imultisale/#basic-multisale-contract","text":"contract MultiSale is IMultiSale { // Storage mapping ( bytes32 => SaleDetails ) public sales ; mapping ( address => bytes32 []) public salesBySeller ; mapping ( bytes32 => address => uint256 ) private _purchasedAmount ; // Keep track of amounts bytes32 [] private _allSales ; // Dependencies (example simplified, in real scenario these would be injected) IERC20 private _erc20 ; IERC721 private _erc721 ; IERC1155 private _erc1155 ; constructor ( address erc20Addr , address erc721Addr , address erc1155Addr ) { _erc20 = IERC20 ( erc20Addr ); _erc721 = IERC721 ( erc721Addr ); _erc1155 = IERC1155 ( erc1155Addr ); } function createSale ( SaleConfig calldata config ) external returns ( bytes32 saleId ) { saleId = keccak256 ( abi . encodePacked ( block.timestamp , config . seller )); require ( sales [ saleId ]. config . seller == address ( 0 ), \"Sale ID collision\" ); // Basic validation require ( config . totalAmount > 0 , \"Total amount must be greater than 0\" ); require ( config . price > 0 , \"Price must be greater than 0\" ); require ( config . endTime > config . startTime , \"End time must be after start time\" ); require ( config . initialReceiver != address ( 0 ), \"Initial receiver cannot be zero address\" ); // Initialize SaleDetails sales [ saleId ]. config = config ; sales [ saleId ]. state = SaleState . NOT_STARTED ; sales [ saleId ]. amountSold = 0 ; sales [ saleId ]. totalRevenue = 0 ; sales [ saleId ]. collectedPayment = 0 ; sales [ saleId ]. config . seller = msg.sender ; // Ensure seller is creation caller salesBySeller [ msg.sender ]. push ( saleId ); _allSales . push ( saleId ); emit SaleConfigUpdated ( saleId ); } function startSale ( bytes32 saleId ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Caller not seller\" ); require ( sale . state == SaleState . NOT_STARTED || sale . state == SaleState . PAUSED , \"Sale not in votable state\" ); require ( block.timestamp >= sale . config . startTime , \"Sale has not started yet\" ); require ( block.timestamp <= sale . config . endTime , \"Sale has already ended\" ); sale . state = SaleState . ACTIVE ; emit SaleStarted ( saleId , msg.sender , sale . config . startTime , sale . config . endTime ); } function pauseSale ( bytes32 saleId ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Caller not seller\" ); require ( sale . state == SaleState . ACTIVE , \"Sale not active\" ); sale . state = SaleState . PAUSED ; emit SalePaused ( saleId ); } function endSale ( bytes32 saleId ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender || block.timestamp > sale . config . endTime , \"Caller not seller or sale not ended\" ); require ( sale . state == SaleState . ACTIVE || sale . state == SaleState . PAUSED , \"Sale already ended or not started\" ); sale . state = SaleState . ENDED ; emit SaleEnded ( saleId ); } function buy ( bytes32 saleId , uint256 amount ) external payable { SaleDetails storage sale = sales [ saleId ]; require ( sale . state == SaleState . ACTIVE , \"Sale not active\" ); require ( sale . amountSold + amount <= sale . config . totalAmount , \"Exceeds total available\" ); require ( amount > 0 , \"Amount must be greater than 0\" ); if ( sale . config . isWhitelistedSale ) { require ( sale . whitelisted [ msg.sender ], \"Not whitelisted\" ); } require ( _purchasedAmount [ saleId ][ msg.sender ] + amount <= sale . config . maxPurchasePerAddress , \"Exceeds max purchase per address\" ); uint256 currentPrice = getCurrentPrice ( saleId ); // Supports dynamic pricing uint256 totalPrice = currentPrice * amount ; if ( sale . config . paymentTokenAddress == address ( 0 )) { // ETH payment require ( msg.value == totalPrice , \"Incorrect ETH amount sent\" ); } else { // ERC20 payment require ( msg.value == 0 , \"Do not send ETH for ERC20 payment\" ); IERC20 ( sale . config . paymentTokenAddress ). transferFrom ( msg.sender , address ( this ), totalPrice ); } // Transfer sale tokens _transferSaleTokens ( saleId , msg.sender , amount ); sale . amountSold += amount ; sale . totalRevenue += totalPrice ; _purchasedAmount [ saleId ][ msg.sender ] += amount ; bool buyerFound = false ; for ( uint i = 0 ; i < sale . buyers . length ; i ++ ) { if ( sale . buyers [ i ] == msg.sender ) { buyerFound = true ; break ; } } if ( ! buyerFound ) { sale . buyers . push ( msg.sender ); } emit Purchase ( saleId , msg.sender , sale . config . saleTokenAddress , sale . config . saleTokenId , amount , totalPrice , sale . config . paymentTokenAddress ); } function _transferSaleTokens ( bytes32 saleId , address buyer , uint256 amount ) internal { SaleConfig storage config = sales [ saleId ]. config ; if ( config . saleTokenType == TokenType . ERC20 ) { _erc20 . transfer ( buyer , amount ); // from MultiSale contract's balance } else if ( config . saleTokenType == TokenType . ERC721 ) { for ( uint256 i = 0 ; i < amount ; i ++ ) { // Assuming saleTokenId is the starting ID or a way to select NFTs _erc721 . transferFrom ( address ( this ), buyer , config . saleTokenId + sales [ saleId ]. amountSold + i ); } } else if ( config . saleTokenType == TokenType . ERC1155 ) { _erc1155 . safeTransferFrom ( address ( this ), buyer , config . saleTokenId , amount , \"\" ); } } function addToWhitelist ( bytes32 saleId , address [] calldata addrs ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Caller not seller\" ); require ( sale . config . isWhitelistedSale , \"Not a whitelisted sale\" ); for ( uint256 i = 0 ; i < addrs . length ; i ++ ) { require ( addrs [ i ] != address ( 0 ), \"Cannot whitelist zero address\" ); sale . whitelisted [ addrs [ i ]] = true ; emit WhitelistUpdated ( saleId , addrs [ i ], true ); } } // Example of a simple getCurrentPrice, could be replaced by an external VariablePriceLib function getCurrentPrice ( bytes32 saleId ) public view returns ( uint256 ) { return sales [ saleId ]. config . price ; } function getSaleConfig ( bytes32 saleId ) external view returns ( SaleConfig memory ) { return sales [ saleId ]. config ; } function getSaleState ( bytes32 saleId ) external view returns ( SaleState ) { return sales [ saleId ]. state ; } function getAmountSold ( bytes32 saleId ) external view returns ( uint256 ) { return sales [ saleId ]. amountSold ; } function getTotalRevenue ( bytes32 saleId ) external view returns ( uint256 ) { return sales [ saleId ]. totalRevenue ; } function getPurchasedAmount ( bytes32 saleId , address buyer ) external view returns ( uint256 ) { return _purchasedAmount [ saleId ][ buyer ]; } function getAllActiveSales () external view returns ( bytes32 [] memory ) { bytes32 [] memory activeSales ; uint256 count = 0 ; for ( uint i = 0 ; i < _allSales . length ; i ++ ) { if ( sales [ _allSales [ i ]]. state == SaleState . ACTIVE ) { count ++ ; } } activeSales = new bytes32 []( count ); uint256 j = 0 ; for ( uint i = 0 ; i < _allSales . length ; i ++ ) { if ( sales [ _allSales [ i ]]. state == SaleState . ACTIVE ) { activeSales [ j ] = _allSales [ i ]; j ++ ; } } return activeSales ; } function getSalesBySeller ( address seller ) external view returns ( bytes32 [] memory ) { return salesBySeller [ seller ]; } function getSalesByPaymentToken ( address paymentToken ) external view returns ( bytes32 [] memory ) { bytes32 [] memory salesList ; uint256 count = 0 ; for ( uint i = 0 ; i < _allSales . length ; i ++ ) { if ( sales [ _allSales [ i ]]. config . paymentTokenAddress == paymentToken ) { count ++ ; } } salesList = new bytes32 []( count ); uint256 j = 0 ; for ( uint i = 0 ; i < _allSales . length ; i ++ ) { if ( sales [ _allSales [ i ]]. config . paymentTokenAddress == paymentToken ) { salesList [ j ] = _allSales [ i ]; j ++ ; } } return salesList ; } function refund ( bytes32 saleId , uint256 amount ) external { // Implement refund logic: check if refund is allowed, transfer funds back // This is a simplified example. Real-world would involve more checks. SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Only seller can refund\" ); require ( sale . state == SaleState . ENDED , \"Sale must be ended to refund\" ); // Further logic to identify who to refund and how much // For demonstration, let's assume it's a direct refund mechanism. // Requires a way to track individual buyer payments which isn't fully detailed in this basic interface. // E.g., if a purchase failed midway or for return policies. if ( sale . config . paymentTokenAddress == address ( 0 )) { payable ( msg.sender ). transfer ( amount ); } else { IERC20 ( sale . config . paymentTokenAddress ). transfer ( msg.sender , amount ); } } function sweepFunds ( bytes32 saleId , address receiver ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Caller not seller\" ); require ( sale . state == SaleState . ENDED , \"Sale must be ended\" ); uint256 balance = ( sale . config . paymentTokenAddress == address ( 0 )) ? address ( this ). balance : IERC20 ( sale . config . paymentTokenAddress ). balanceOf ( address ( this )); require ( balance > 0 , \"No funds to sweep\" ); uint256 amountToSweep = balance - ( balance * sale . config . feePercentage / 10000 ); // Exclude fees if ( sale . config . paymentTokenAddress == address ( 0 )) { payable ( receiver ). transfer ( amountToSweep ); } else { IERC20 ( sale . config . paymentTokenAddress ). transfer ( receiver , amountToSweep ); } sale . collectedPayment += amountToSweep ; emit PaymentCollected ( saleId , receiver , sale . config . paymentTokenAddress , amountToSweep ); } function collectFees ( bytes32 saleId , address feeReceiver ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Caller not seller\" ); require ( sale . state == SaleState . ENDED , \"Sale must be ended to collect fees\" ); uint256 totalCollected = ( sale . config . paymentTokenAddress == address ( 0 )) ? address ( this ). balance : IERC20 ( sale . config . paymentTokenAddress ). balanceOf ( address ( this )); uint256 feeAmount = totalCollected * sale . config . feePercentage / 10000 ; if ( feeAmount > 0 ) { if ( sale . config . paymentTokenAddress == address ( 0 )) { payable ( feeReceiver ). transfer ( feeAmount ); } else { IERC20 ( sale . config . paymentTokenAddress ). transfer ( feeReceiver , feeAmount ); } emit PaymentCollected ( saleId , feeReceiver , sale . config . paymentTokenAddress , feeAmount ); } } function updateSaleConfig ( bytes32 saleId , SaleConfig calldata newConfig ) external { SaleDetails storage sale = sales [ saleId ]; require ( sale . config . seller == msg.sender , \"Caller not seller\" ); require ( sale . state == SaleState . NOT_STARTED || sale . state == SaleState . PAUSED , \"Can only update config when not active\" ); // Implement logic to update only allowed fields to prevent abuse sale . config = newConfig ; // For simplicity, replacing whole config. In real scenario, selective updates. emit SaleConfigUpdated ( saleId ); } }","title":"Basic MultiSale Contract"},{"location":"smart-contracts/interfaces/imultisale/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/imultisale/#access-control","text":"Seller Privileges : Ensure only the designated seller can manage sale lifecycle. Whitelist Management : Restrict whitelist updates to authorized roles. Fund Control : Implement secure mechanisms for fund collection and fee distribution.","title":"Access Control"},{"location":"smart-contracts/interfaces/imultisale/#fund-safety","text":"Reentrancy Protection : Use reentrancy guards on all critical transfer functions. Input Validation : Strict validation of amount , price , and addresses . Token Handling : Proper handling of ERC20, ERC721, and ERC1155 transfers.","title":"Fund Safety"},{"location":"smart-contracts/interfaces/imultisale/#sale-integrity","text":"State Checks : Verify sale state ( ACTIVE , PAUSED , ENDED ) before transactions. Price Consistency : Ensure pricing logic is robust and tamper-proof. Overflow/Underflow : Protect against integer overflows/underflows in calculations.","title":"Sale Integrity"},{"location":"smart-contracts/interfaces/imultisale/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/interfaces/imultisale/#sale-configuration","text":"Clear Parameters : Define unambiguous sale parameters. Flexible Pricing : Support various pricing models (fixed, dynamic). Refund Policy : Implement clear and transparent refund mechanisms.","title":"Sale Configuration"},{"location":"smart-contracts/interfaces/imultisale/#token-management","text":"Approve Before Transfer : For ERC20, ensure the MultiSale contract has sufficient allowance. Safe ERC721/ERC1155 Transfers : Use safeTransferFrom to prevent token loss. Ownership Transfer : Ensure sale tokens are transferred to the contract prior to sale.","title":"Token Management"},{"location":"smart-contracts/interfaces/imultisale/#monitoring-and-events","text":"Comprehensive Events : Emit events for all significant actions (purchase, start, end, whitelist). Off-chain Indexing : Use events for off-chain indexing and analytics.","title":"Monitoring and Events"},{"location":"smart-contracts/interfaces/imultisale/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/imultisale/#frontend-integration-typescript","text":"import { ethers , Contract } from 'ethers' ; import MultiSaleABI from './MultiSale.json' ; interface SaleConfig { seller : string ; saleTokenAddress : string ; saleTokenType : number ; // Enum: 0=ERC20, 1=ERC721, 2=ERC1155 saleTokenId : number ; totalAmount : number ; price : number ; paymentTokenAddress : string ; startTime : number ; endTime : number ; maxPurchasePerAddress : number ; isWhitelistedSale : boolean ; initialReceiver : string ; initialPaymentAmount : number ; feePercentage : number ; feeReceiver : string ; name : string ; description : string ; data : string ; } class MultiSaleService { private contract : Contract ; constructor ( contractAddress : string , signer : ethers.Signer ) { this . contract = new Contract ( contractAddress , MultiSaleABI , signer ); } async createNewSale ( config : SaleConfig ) : Promise < string > { const tx = await this . contract . createSale ( config ); const receipt = await tx . wait (); const event = receipt . events ? . find (( e : any ) => e . event === 'SaleConfigUpdated' ); return event ? . args ? . saleId ; } async startSale ( saleId : string ) : Promise < void > { const tx = await this . contract . startSale ( saleId ); await tx . wait (); } async buyTokens ( saleId : string , amount : number , value : ethers.BigNumberish = 0 ) : Promise < void > { const tx = await this . contract . buy ( saleId , amount , { value }); await tx . wait (); } async getSaleDetails ( saleId : string ) : Promise < any > { return await this . contract . getSaleConfig ( saleId ); } async checkWhitelist ( saleId : string , address : string ) : Promise < boolean > { return await this . contract . isWhitelisted ( saleId , address ); } }","title":"Frontend Integration (TypeScript)"},{"location":"smart-contracts/interfaces/imultisale/#backend-integration-nodejs-with-web3js","text":"const Web3 = require ( 'web3' ); const MultiSaleABI = require ( './MultiSale.json' ). abi ; class MultiSaleBackend { constructor ( providerUrl , multiSaleContractAddress ) { this . web3 = new Web3 ( providerUrl ); this . multiSaleContract = new this . web3 . eth . Contract ( MultiSaleABI , multiSaleContractAddress ); } async addAddressesToWhitelist ( privateKey , saleId , addresses ) { const account = this . web3 . eth . accounts . privateKeyToAccount ( privateKey ); this . web3 . eth . accounts . wallet . add ( account ); const gasEstimate = await this . multiSaleContract . methods . addToWhitelist ( saleId , addresses ). estimateGas ({ from : account . address }); const tx = await this . multiSaleContract . methods . addToWhitelist ( saleId , addresses ). send ({ from : account . address , gas : gasEstimate }); console . log ( `Whitelist updated for sale ${ saleId } : ${ tx . transactionHash } ` ); return tx ; } async getActiveSales () { return await this . multiSaleContract . methods . getAllActiveSales (). call (); } async handlePurchaseWebhook ( saleId , buyerAddress , amount , pricePaid , paymentToken ) { console . log ( `Processing purchase for sale: ${ saleId } ` ); console . log ( `Buyer: ${ buyerAddress } , Amount: ${ amount } , Price: ${ pricePaid } , Payment Token: ${ paymentToken } ` ); // Here you would integrate with your backend systems, e.g., // update internal databases, trigger notifications, etc. } }","title":"Backend Integration (Node.js with web3.js)"},{"location":"smart-contracts/interfaces/imultisale/#related-documentation","text":"Variable Price Library ERC20 Standard ERC721 Standard ERC1155 Standard Fee Distributor Library Deployment Guide","title":"Related Documentation"},{"location":"smart-contracts/interfaces/imultisale/#standards-compliance","text":"ERC20 : Tokens used for payment or sale. ERC721 : NFTs used for sale. ERC1155 : Multi-tokens used for sale. EIP-165 : Interface detection standard (implicitly used by calling IERC* functions).","title":"Standards Compliance"},{"location":"smart-contracts/interfaces/isvg/","text":"ISVG Interface \u00b6 The ISVG interface defines the standard for smart contracts that generate and manage Scalable Vector Graphics (SVG) on-chain. This interface is crucial for creating dynamic and algorithmically generated NFT art, badges, or other visual assets directly from smart contracts within the Gemforce ecosystem. Overview \u00b6 ISVG provides: SVG Generation : Functions to generate complete SVG strings based on input parameters. Template Management : Mechanisms for managing and combining SVG templates. Render Parameterization : Allow for dynamic data to influence SVG output. Data Encoding : Efficiently encode visual data on-chain. Key Features \u00b6 SVG Rendering \u00b6 renderSVG() : Main function to produce a final SVG string. Dynamic Elements : Support for injecting data (colors, shapes, text, etc.) into templates. Component Assembly : Combine smaller SVG components into a larger scene. Template and Asset Management \u00b6 Store Templates : On-chain storage for SVG fragments or predefined layers. Reference Assets : Ability to reference other on-chain or off-chain assets (e.g., fonts, images encoded as base64). Template Composition : Logic to mix and match predefined SVG elements. Metadata Integration \u00b6 Can be used to generate SVG content that forms the image field in ERC721 metadata URIs. Interface Definition \u00b6 interface ISVG { // Events event SVGGenerated ( uint256 indexed tokenId , string indexed svgType , uint256 indexed version , string svgDataURI ); event TemplateAdded ( string indexed templateName , uint256 indexed version , address indexed creator ); event TemplateUpdated ( string indexed templateName , uint256 indexed version , address indexed updater ); event FragmentAdded ( string indexed fragmentName , uint256 indexed version , address indexed creator ); event FragmentUpdated ( string indexed fragmentName , uint256 indexed version , address indexed updater ); // Structs struct SVGTemplate { string name ; uint256 version ; string content ; // Base SVG structure, often with placeholders bool active ; address creator ; uint256 createdAt ; } struct SVGFragment { string name ; uint256 version ; string content ; // Reusable SVG snippets address creator ; uint256 createdAt ; } // Core SVG Generation Functions function renderSVG ( string calldata templateName , uint256 templateVersion , bytes calldata data ) external view returns ( string memory svgURI ); function getRenderedSVG ( uint256 tokenId ) external view returns ( string memory svgURI ); // Template Management Functions function addTemplate ( string calldata name , uint256 version , string calldata content ) external ; function updateTemplate ( string calldata name , uint256 version , string calldata newContent ) external ; function getTemplate ( string calldata name , uint256 version ) external view returns ( SVGTemplate memory ); function deactivateTemplate ( string calldata name , uint256 version ) external ; // Fragment Management Functions function addFragment ( string calldata name , uint256 version , string calldata content ) external ; function updateFragment ( string calldata name , uint256 version , string calldata newContent ) external ; function getFragment ( string calldata name , uint256 version ) external view returns ( SVGFragment memory ); // View Functions for Listing function getTemplateNames () external view returns ( string [] memory ); function getAvailableVersions ( string calldata templateName ) external view returns ( uint256 [] memory ); function getFragmentNames () external view returns ( string [] memory ); } Core Functions \u00b6 renderSVG() \u00b6 Generates and returns a data URI (typically base64-encoded) containing the complete SVG image. This function takes a template name, version, and dynamic data as input to customize the output. Parameters: - templateName : The name of the SVG template to use. - templateVersion : The version of the template. - data : ABI-encoded bytes containing dynamic parameters (e.g., colors, text, numbers) to be inserted into the SVG template. Returns: - string : A data URI (e.g., data:image/svg+xml;base64,... ) containing the generated SVG. Usage: // Example: Render an SVG for a token, passing color and text details bytes memory renderData = abi . encode ( \"red\" , \"Hello Gemforce!\" , 123 ); string memory svgDataURI = svgContract . renderSVG ( \"CryptoBadge\" , 1 , renderData ); addTemplate() \u00b6 Adds a new SVG template to the contract's storage. Templates are typically base SVG structures with placeholders for dynamic data. Parameters: - name : A unique name for the template. - version : A version number for the template. - content : The raw SVG string content (with placeholders). Access Control: - Typically restricted to the contract owner or an authorized administrator. addFragment() \u00b6 Adds a reusable SVG fragment (e.g., a common icon, a repeating pattern) to the contract's storage. Fragments can be embedded into templates. Parameters: - name : A unique name for the fragment. - version : A version number for the fragment. - content : The raw SVG string content of the fragment. Implementation Example \u00b6 import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/utils/Base64.sol\" ; // Optional: Using StringUtils for more complex string manipulation if not available // import \"./libraries/StringUtils.sol\"; contract SVGGenerator is ISVG , Ownable { // Mapping for SVG templates: name => version => SVGTemplate mapping ( string => mapping ( uint256 => SVGTemplate )) private _templates ; // Mapping for SVG fragments: name => version => SVGFragment mapping ( string => mapping ( uint256 => SVGFragment )) private _fragments ; // To list available templates and fragments string [] private _templateNames ; mapping ( string => uint256 []) private _templateVersions ; string [] private _fragmentNames ; // Assuming a mapping from tokenId to its SVG data URI is maintained elsewhere or generated on the fly per request // This example focuses on the generation logic itself. mapping ( uint256 => string ) private _renderedSVGStorage ; // For getRenderedSVG if needed for persistence constructor () { // Initial setup or placeholders can be added here } function addTemplate ( string calldata name , uint256 version , string calldata content ) external override onlyOwner { require ( bytes ( name ). length > 0 , \"Name cannot be empty\" ); require ( bytes ( content ). length > 0 , \"Content cannot be empty\" ); require ( _templates [ name ][ version ]. creator == address ( 0 ), \"Template already exists\" ); _templates [ name ][ version ] = SVGTemplate ({ name : name , version : version , content : content , active : true , creator : msg.sender , createdAt : block.timestamp }); bool nameExists = false ; for ( uint256 i = 0 ; i < _templateNames . length ; i ++ ){ if ( keccak256 ( abi . encodePacked ( _templateNames [ i ])) == keccak256 ( abi . encodePacked ( name ))){ nameExists = true ; break ; } } if ( ! nameExists ){ _templateNames . push ( name ); } _templateVersions [ name ]. push ( version ); emit TemplateAdded ( name , version , msg.sender ); } function updateTemplate ( string calldata name , uint256 version , string calldata newContent ) external override onlyOwner { SVGTemplate storage templateEntry = _templates [ name ][ version ]; require ( templateEntry . creator != address ( 0 ), \"Template not found\" ); require ( bytes ( newContent ). length > 0 , \"Content cannot be empty\" ); templateEntry . content = newContent ; templateEntry . lastUpdated = block.timestamp ; // Assuming a 'lastUpdated' field in struct emit TemplateUpdated ( name , version , msg.sender ); } function deactivateTemplate ( string calldata name , uint256 version ) external override onlyOwner { SVGTemplate storage templateEntry = _templates [ name ][ version ]; require ( templateEntry . creator != address ( 0 ), \"Template not found\" ); require ( templateEntry . active == true , \"Template already inactive\" ); templateEntry . active = false ; // Optionally remove from _templateVersions or _templateNames if no active versions remain } function getTemplate ( string calldata name , uint256 version ) external view override returns ( SVGTemplate memory ) { SVGTemplate memory templateEntry = _templates [ name ][ version ]; require ( templateEntry . creator != address ( 0 ), \"Template not found\" ); return templateEntry ; } function addFragment ( string calldata name , uint256 version , string calldata content ) external override onlyOwner { require ( bytes ( name ). length > 0 , \"Name cannot be empty\" ); require ( bytes ( content ). length > 0 , \"Content cannot be empty\" ); require ( _fragments [ name ][ version ]. creator == address ( 0 ), \"Fragment already exists\" ); _fragments [ name ][ version ] = SVGFragment ({ name : name , version : version , content : content , creator : msg.sender , createdAt : block.timestamp }); bool nameExists = false ; for ( uint256 i = 0 ; i < _fragmentNames . length ; i ++ ){ if ( keccak256 ( abi . encodePacked ( _fragmentNames [ i ])) == keccak256 ( abi . encodePacked ( name ))){ nameExists = true ; break ; } } if ( ! nameExists ){ _fragmentNames . push ( name ); } emit FragmentAdded ( name , version , msg.sender ); } function updateFragment ( string calldata name , uint256 version , string calldata newContent ) external override onlyOwner { SVGFragment storage fragmentEntry = _fragments [ name ][ version ]; require ( fragmentEntry . creator != address ( 0 ), \"Fragment not found\" ); require ( bytes ( newContent ). length > 0 , \"Content cannot be empty\" ); fragmentEntry . content = newContent ; // Assuming a 'lastUpdated' field exists emit FragmentUpdated ( name , version , msg.sender ); } function getFragment ( string calldata name , uint256 version ) external view override returns ( SVGFragment memory ) { SVGFragment memory fragmentEntry = _fragments [ name ][ version ]; require ( fragmentEntry . creator != address ( 0 ), \"Fragment not found\" ); return fragmentEntry ; } function renderSVG ( string calldata templateName , uint256 templateVersion , bytes calldata data ) external view override returns ( string memory svgURI ) { SVGTemplate memory template = _templates [ templateName ][ templateVersion ]; require ( template . creator != address ( 0 ), \"Template not found\" ); require ( template . active == true , \"Template inactive\" ); string memory svgContent = template . content ; // Basic example of data integration. A more robust solution would need a templating engine // or more structured data parsing. This part highly depends on expected 'data' format. // For demonstration, let's assume 'data' is simply a string to be inserted. // A more advanced approach would use a dedicated string utility library for replaceAll. // Example: if data is abi.encode(color, text, number) ( string memory color , string memory text , uint256 number ) = abi . decode ( data , ( string , string , uint256 )); svgContent = _replacePlaceholder ( svgContent , \"[[COLOR]]\" , color ); svgContent = _replacePlaceholder ( svgContent , \"[[TEXT]]\" , text ); svgContent = _replacePlaceholder ( svgContent , \"[[NUMBER]]\" , _uint256ToString ( number )); // Example: Inject fragments string memory fragment1Content = _fragments [ \"star_icon\" ][ 1 ]. content ; // Assuming fragment exists svgContent = _replacePlaceholder ( svgContent , \"[[STAR_ICON]]\" , fragment1Content ); // Construct data URI bytes memory rawSvgBytes = bytes ( svgContent ); string memory base64Encoded = Base64 . encode ( rawSvgBytes ); svgURI = string ( abi . encodePacked ( \"data:image/svg+xml;base64,\" , base64Encoded )); // Emit event, potentially storing tokenId and linking SVG for future retrieval // emit SVGGenerated(_tokenId, templateName, templateVersion, svgURI); } function getRenderedSVG ( uint256 tokenId ) external view override returns ( string memory svgURI ) { // This function would typically retrieve from a mapping if SVGs were stored persistently // For this example, assuming it's dynamic or a dummy. // If the intention is to store, _renderedSVGStorage[tokenId] would be used. return _renderedSVGStorage [ tokenId ]; } function getTemplateNames () external view override returns ( string [] memory ) { return _templateNames ; } function getAvailableVersions ( string calldata templateName ) external view override returns ( uint256 [] memory ) { return _templateVersions [ templateName ]; } function getFragmentNames () external view override returns ( string [] memory ) { return _fragmentNames ; } // --- Internal String Utility Functions (Simplified for example) --- function _replacePlaceholder ( string memory source , string memory placeholder , string memory replacement ) internal pure returns ( string memory ) { // This is a very basic string replace. For production, consider a robust StringUtils lib. bytes memory sourceBytes = bytes ( source ); bytes memory placeholderBytes = bytes ( placeholder ); bytes memory replacementBytes = bytes ( replacement ); uint265 i = 0 ; uint256 j = 0 ; bytes memory result = new bytes ( sourceBytes . length ); // Max possible size while ( i < sourceBytes . length ) { bool found = true ; if ( i + placeholderBytes . length <= sourceBytes . length ) { for ( uint256 p = 0 ; p < placeholderBytes . length ; p ++ ) { if ( sourceBytes [ i + p ] != placeholderBytes [ p ]) { found = false ; break ; } } } else { found = false ; } if ( found ) { for ( uint256 r = 0 ; r < replacementBytes . length ; r ++ ) { result [ j ++ ] = replacementBytes [ r ]; } i += placeholderBytes . length ; } else { result [ j ++ ] = sourceBytes [ i ++ ]; } } return string ( result ); } function _uint256ToString ( uint256 _i ) internal pure returns ( string memory _uintAsString ) { if ( _i == 0 ) { return \"0\" ; } uint256 j = _i ; uint256 len ; while ( j != 0 ) { len ++ ; j /= 10 ; } bytes memory bstr = new bytes ( len ); uint256 k = len - 1 ; while ( _i != 0 ) { bstr [ k -- ] = byte ( uint8 ( 48 + _i % 10 )); _i /= 10 ; } return string ( bstr ); } } Security Considerations \u00b6 Access Control \u00b6 onlyOwner : Critical functions for adding, updating, or deactivating SVG templates and fragments must be restricted to the contract owner or an authorized role to prevent malicious or accidental changes to visual assets. Gas Costs \u00b6 String Manipulation : On-chain string concatenation and replacement can be extremely gas-intensive, especially for complex SVGs or frequent rendering. Consider the trade-off between fully on-chain SVG generation and off-chain rendering with on-chain data validation. Base64 Encoding : Base64.encode also consumes significant gas; ensure its usage is justified by the application's needs. Input Validation \u00b6 Data bytes : The data parameter in renderSVG should be carefully parsed and validated to prevent unexpected SVG output or injection vulnerabilities if directly embedded without proper sanitization. Template Content : Validate that template and fragment content doesn't contain malicious scripts or excessive size. Best Practices \u00b6 Off-chain Rendering (Alternative) \u00b6 Hybrid Approach : For high-volume or very complex SVGs, consider storing only the dynamic numerical/text data on-chain and performing the actual SVG rendering in a frontend application or a dedicated off-chain service. The smart contract would then primarily act as a data oracle. Template Design \u00b6 Placeholders : Use clear, consistent placeholders (e.g., [[COLOR]] , {{VARIABLE_NAME}} ) within SVG templates to indicate where dynamic data should be injected. Modular Fragments : Break down complex SVGs into smaller, reusable fragments to promote efficiency and simplify template management. Data URI Length \u00b6 Transaction Limits : Be aware of blockchain transaction size limits if you intend to store or return very large SVG data URIs via events or return values. IPFS/Storage : For large metadata, store the SVG on IPFS or another decentralized storage solution and just provide the hash/URI on-chain. Integration Examples \u00b6 Frontend Integration (React with Ethers.js) \u00b6 import React , { useState , useEffect } from 'react' ; import { ethers , Contract } from 'ethers' ; import SVGABI from './SVGGenerator.json' ; // ABI for the ISVG contract const SVG_GENERATOR_ADDRESS = \"0x...\" ; // Deployed SVG generator contract address interface SVGComponentProps { tokenId : number ; color : string ; text : string ; } const NFTImage : React.FC < SVGComponentProps > = ({ tokenId , color , text }) => { const [ svgDataUri , setSvgDataUri ] = useState < string > ( '' ); const [ loading , setLoading ] = useState < boolean > ( true ); const [ error , setError ] = useState < string | null > ( null ); useEffect (() => { const fetchSVG = async () => { setLoading ( true ); setError ( null ); try { const provider = new ethers . providers . Web3Provider ( window . ethereum ); const svgContract = new Contract ( SVG_GENERATOR_ADDRESS , SVGABI , provider ); // Encode dynamic data const encodedData = ethers . utils . defaultAbiCoder . encode ( [ \"string\" , \"string\" , \"uint256\" ], // Match the abi.decode in contract [ color , text , tokenId ] ); // Call renderSVG specifying a template and version const templateName = \"CryptoBadge\" ; // Example template name const templateVersion = 1 ; // Example template version const uri = await svgContract . renderSVG ( templateName , templateVersion , encodedData ); setSvgDataUri ( uri ); } catch ( err : any ) { console . error ( \"Error fetching SVG:\" , err ); setError ( `Failed to fetch SVG: ${ err . message || err } ` ); } finally { setLoading ( false ); } }; fetchSVG (); }, [ tokenId , color , text ]); if ( loading ) return < div > Loading SVG ... < /div>; if ( error ) return < div > Error : { error } < /div>; return ( < img src = { svgDataUri } alt = { `NFT ${ tokenId } ` } style = {{ width : '300px' , height : '300px' }} /> ); }; export default NFTImage ; Backend Integration (Node.js/Web3.js for off-chain metadata generation) \u00b6 const Web3 = require ( 'web3' ); const SVGGeneratorABI = require ( './SVGGenerator.json' ). abi ; // ABI of ISVG contract const web3 = new Web3 ( 'YOUR_ETHEREUM_RPC_URL' ); const svgGeneratorAddress = '0x...' ; // Deployed SVG generator contract address const svgGeneratorContract = new web3 . eth . Contract ( SVGGeneratorABI , svgGeneratorAddress ); async function generateNFTMetadata ( tokenId , nftAttributes ) { try { console . log ( `Generating SVG for Token ID: ${ tokenId } ` ); const templateName = \"ArtPieceTemplate\" ; const templateVersion = 1 ; // Assuming version 1 for now // ABI encode the attributes const encodedData = web3 . eth . abi . encodeParameters ( [ 'string' , 'uint256' , 'string' ], // Example types: color, rarity, texture [ nftAttributes . color , nftAttributes . rarity , nftAttributes . texture ] ); const svgDataUri = await svgGeneratorContract . methods . renderSVG ( templateName , templateVersion , encodedData ). call (); // Construct ERC721 metadata JSON const metadata = { name : `My NFT # ${ tokenId } ` , description : \"An algorithmically generated NFT from Gemforce.\" , image : svgDataUri , // The generated SVG data URI attributes : [ { trait_type : \"Color\" , value : nftAttributes . color }, { trait_type : \"Rarity\" , value : nftAttributes . rarity }, { trait_type : \"Texture\" , value : nftAttributes . texture } ] }; console . log ( `Metadata for Token ID ${ tokenId } :` , JSON . stringify ( metadata , null , 2 )); return metadata ; } catch ( error ) { console . error ( 'Error generating NFT metadata:' , error ); throw error ; } } // Example Usage // generateNFTMetadata(123, { color: \"blue\", rarity: 5, texture: \"smooth\" }); Related Documentation \u00b6 SVG Templates Library ERC721 Metadata Standard Base64 Encoding (OpenZeppelin's Base64) Data URIs (MDN Web Docs) Standards Compliance \u00b6 ERC721 Metadata : The output can be directly used as the image field for ERC721 token metadata. Ownable : Utilizes OpenZeppelin's Ownable for administrative access control.","title":"ISVG"},{"location":"smart-contracts/interfaces/isvg/#isvg-interface","text":"The ISVG interface defines the standard for smart contracts that generate and manage Scalable Vector Graphics (SVG) on-chain. This interface is crucial for creating dynamic and algorithmically generated NFT art, badges, or other visual assets directly from smart contracts within the Gemforce ecosystem.","title":"ISVG Interface"},{"location":"smart-contracts/interfaces/isvg/#overview","text":"ISVG provides: SVG Generation : Functions to generate complete SVG strings based on input parameters. Template Management : Mechanisms for managing and combining SVG templates. Render Parameterization : Allow for dynamic data to influence SVG output. Data Encoding : Efficiently encode visual data on-chain.","title":"Overview"},{"location":"smart-contracts/interfaces/isvg/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/isvg/#svg-rendering","text":"renderSVG() : Main function to produce a final SVG string. Dynamic Elements : Support for injecting data (colors, shapes, text, etc.) into templates. Component Assembly : Combine smaller SVG components into a larger scene.","title":"SVG Rendering"},{"location":"smart-contracts/interfaces/isvg/#template-and-asset-management","text":"Store Templates : On-chain storage for SVG fragments or predefined layers. Reference Assets : Ability to reference other on-chain or off-chain assets (e.g., fonts, images encoded as base64). Template Composition : Logic to mix and match predefined SVG elements.","title":"Template and Asset Management"},{"location":"smart-contracts/interfaces/isvg/#metadata-integration","text":"Can be used to generate SVG content that forms the image field in ERC721 metadata URIs.","title":"Metadata Integration"},{"location":"smart-contracts/interfaces/isvg/#interface-definition","text":"interface ISVG { // Events event SVGGenerated ( uint256 indexed tokenId , string indexed svgType , uint256 indexed version , string svgDataURI ); event TemplateAdded ( string indexed templateName , uint256 indexed version , address indexed creator ); event TemplateUpdated ( string indexed templateName , uint256 indexed version , address indexed updater ); event FragmentAdded ( string indexed fragmentName , uint256 indexed version , address indexed creator ); event FragmentUpdated ( string indexed fragmentName , uint256 indexed version , address indexed updater ); // Structs struct SVGTemplate { string name ; uint256 version ; string content ; // Base SVG structure, often with placeholders bool active ; address creator ; uint256 createdAt ; } struct SVGFragment { string name ; uint256 version ; string content ; // Reusable SVG snippets address creator ; uint256 createdAt ; } // Core SVG Generation Functions function renderSVG ( string calldata templateName , uint256 templateVersion , bytes calldata data ) external view returns ( string memory svgURI ); function getRenderedSVG ( uint256 tokenId ) external view returns ( string memory svgURI ); // Template Management Functions function addTemplate ( string calldata name , uint256 version , string calldata content ) external ; function updateTemplate ( string calldata name , uint256 version , string calldata newContent ) external ; function getTemplate ( string calldata name , uint256 version ) external view returns ( SVGTemplate memory ); function deactivateTemplate ( string calldata name , uint256 version ) external ; // Fragment Management Functions function addFragment ( string calldata name , uint256 version , string calldata content ) external ; function updateFragment ( string calldata name , uint256 version , string calldata newContent ) external ; function getFragment ( string calldata name , uint256 version ) external view returns ( SVGFragment memory ); // View Functions for Listing function getTemplateNames () external view returns ( string [] memory ); function getAvailableVersions ( string calldata templateName ) external view returns ( uint256 [] memory ); function getFragmentNames () external view returns ( string [] memory ); }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/isvg/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/isvg/#rendersvg","text":"Generates and returns a data URI (typically base64-encoded) containing the complete SVG image. This function takes a template name, version, and dynamic data as input to customize the output. Parameters: - templateName : The name of the SVG template to use. - templateVersion : The version of the template. - data : ABI-encoded bytes containing dynamic parameters (e.g., colors, text, numbers) to be inserted into the SVG template. Returns: - string : A data URI (e.g., data:image/svg+xml;base64,... ) containing the generated SVG. Usage: // Example: Render an SVG for a token, passing color and text details bytes memory renderData = abi . encode ( \"red\" , \"Hello Gemforce!\" , 123 ); string memory svgDataURI = svgContract . renderSVG ( \"CryptoBadge\" , 1 , renderData );","title":"renderSVG()"},{"location":"smart-contracts/interfaces/isvg/#addtemplate","text":"Adds a new SVG template to the contract's storage. Templates are typically base SVG structures with placeholders for dynamic data. Parameters: - name : A unique name for the template. - version : A version number for the template. - content : The raw SVG string content (with placeholders). Access Control: - Typically restricted to the contract owner or an authorized administrator.","title":"addTemplate()"},{"location":"smart-contracts/interfaces/isvg/#addfragment","text":"Adds a reusable SVG fragment (e.g., a common icon, a repeating pattern) to the contract's storage. Fragments can be embedded into templates. Parameters: - name : A unique name for the fragment. - version : A version number for the fragment. - content : The raw SVG string content of the fragment.","title":"addFragment()"},{"location":"smart-contracts/interfaces/isvg/#implementation-example","text":"import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/utils/Base64.sol\" ; // Optional: Using StringUtils for more complex string manipulation if not available // import \"./libraries/StringUtils.sol\"; contract SVGGenerator is ISVG , Ownable { // Mapping for SVG templates: name => version => SVGTemplate mapping ( string => mapping ( uint256 => SVGTemplate )) private _templates ; // Mapping for SVG fragments: name => version => SVGFragment mapping ( string => mapping ( uint256 => SVGFragment )) private _fragments ; // To list available templates and fragments string [] private _templateNames ; mapping ( string => uint256 []) private _templateVersions ; string [] private _fragmentNames ; // Assuming a mapping from tokenId to its SVG data URI is maintained elsewhere or generated on the fly per request // This example focuses on the generation logic itself. mapping ( uint256 => string ) private _renderedSVGStorage ; // For getRenderedSVG if needed for persistence constructor () { // Initial setup or placeholders can be added here } function addTemplate ( string calldata name , uint256 version , string calldata content ) external override onlyOwner { require ( bytes ( name ). length > 0 , \"Name cannot be empty\" ); require ( bytes ( content ). length > 0 , \"Content cannot be empty\" ); require ( _templates [ name ][ version ]. creator == address ( 0 ), \"Template already exists\" ); _templates [ name ][ version ] = SVGTemplate ({ name : name , version : version , content : content , active : true , creator : msg.sender , createdAt : block.timestamp }); bool nameExists = false ; for ( uint256 i = 0 ; i < _templateNames . length ; i ++ ){ if ( keccak256 ( abi . encodePacked ( _templateNames [ i ])) == keccak256 ( abi . encodePacked ( name ))){ nameExists = true ; break ; } } if ( ! nameExists ){ _templateNames . push ( name ); } _templateVersions [ name ]. push ( version ); emit TemplateAdded ( name , version , msg.sender ); } function updateTemplate ( string calldata name , uint256 version , string calldata newContent ) external override onlyOwner { SVGTemplate storage templateEntry = _templates [ name ][ version ]; require ( templateEntry . creator != address ( 0 ), \"Template not found\" ); require ( bytes ( newContent ). length > 0 , \"Content cannot be empty\" ); templateEntry . content = newContent ; templateEntry . lastUpdated = block.timestamp ; // Assuming a 'lastUpdated' field in struct emit TemplateUpdated ( name , version , msg.sender ); } function deactivateTemplate ( string calldata name , uint256 version ) external override onlyOwner { SVGTemplate storage templateEntry = _templates [ name ][ version ]; require ( templateEntry . creator != address ( 0 ), \"Template not found\" ); require ( templateEntry . active == true , \"Template already inactive\" ); templateEntry . active = false ; // Optionally remove from _templateVersions or _templateNames if no active versions remain } function getTemplate ( string calldata name , uint256 version ) external view override returns ( SVGTemplate memory ) { SVGTemplate memory templateEntry = _templates [ name ][ version ]; require ( templateEntry . creator != address ( 0 ), \"Template not found\" ); return templateEntry ; } function addFragment ( string calldata name , uint256 version , string calldata content ) external override onlyOwner { require ( bytes ( name ). length > 0 , \"Name cannot be empty\" ); require ( bytes ( content ). length > 0 , \"Content cannot be empty\" ); require ( _fragments [ name ][ version ]. creator == address ( 0 ), \"Fragment already exists\" ); _fragments [ name ][ version ] = SVGFragment ({ name : name , version : version , content : content , creator : msg.sender , createdAt : block.timestamp }); bool nameExists = false ; for ( uint256 i = 0 ; i < _fragmentNames . length ; i ++ ){ if ( keccak256 ( abi . encodePacked ( _fragmentNames [ i ])) == keccak256 ( abi . encodePacked ( name ))){ nameExists = true ; break ; } } if ( ! nameExists ){ _fragmentNames . push ( name ); } emit FragmentAdded ( name , version , msg.sender ); } function updateFragment ( string calldata name , uint256 version , string calldata newContent ) external override onlyOwner { SVGFragment storage fragmentEntry = _fragments [ name ][ version ]; require ( fragmentEntry . creator != address ( 0 ), \"Fragment not found\" ); require ( bytes ( newContent ). length > 0 , \"Content cannot be empty\" ); fragmentEntry . content = newContent ; // Assuming a 'lastUpdated' field exists emit FragmentUpdated ( name , version , msg.sender ); } function getFragment ( string calldata name , uint256 version ) external view override returns ( SVGFragment memory ) { SVGFragment memory fragmentEntry = _fragments [ name ][ version ]; require ( fragmentEntry . creator != address ( 0 ), \"Fragment not found\" ); return fragmentEntry ; } function renderSVG ( string calldata templateName , uint256 templateVersion , bytes calldata data ) external view override returns ( string memory svgURI ) { SVGTemplate memory template = _templates [ templateName ][ templateVersion ]; require ( template . creator != address ( 0 ), \"Template not found\" ); require ( template . active == true , \"Template inactive\" ); string memory svgContent = template . content ; // Basic example of data integration. A more robust solution would need a templating engine // or more structured data parsing. This part highly depends on expected 'data' format. // For demonstration, let's assume 'data' is simply a string to be inserted. // A more advanced approach would use a dedicated string utility library for replaceAll. // Example: if data is abi.encode(color, text, number) ( string memory color , string memory text , uint256 number ) = abi . decode ( data , ( string , string , uint256 )); svgContent = _replacePlaceholder ( svgContent , \"[[COLOR]]\" , color ); svgContent = _replacePlaceholder ( svgContent , \"[[TEXT]]\" , text ); svgContent = _replacePlaceholder ( svgContent , \"[[NUMBER]]\" , _uint256ToString ( number )); // Example: Inject fragments string memory fragment1Content = _fragments [ \"star_icon\" ][ 1 ]. content ; // Assuming fragment exists svgContent = _replacePlaceholder ( svgContent , \"[[STAR_ICON]]\" , fragment1Content ); // Construct data URI bytes memory rawSvgBytes = bytes ( svgContent ); string memory base64Encoded = Base64 . encode ( rawSvgBytes ); svgURI = string ( abi . encodePacked ( \"data:image/svg+xml;base64,\" , base64Encoded )); // Emit event, potentially storing tokenId and linking SVG for future retrieval // emit SVGGenerated(_tokenId, templateName, templateVersion, svgURI); } function getRenderedSVG ( uint256 tokenId ) external view override returns ( string memory svgURI ) { // This function would typically retrieve from a mapping if SVGs were stored persistently // For this example, assuming it's dynamic or a dummy. // If the intention is to store, _renderedSVGStorage[tokenId] would be used. return _renderedSVGStorage [ tokenId ]; } function getTemplateNames () external view override returns ( string [] memory ) { return _templateNames ; } function getAvailableVersions ( string calldata templateName ) external view override returns ( uint256 [] memory ) { return _templateVersions [ templateName ]; } function getFragmentNames () external view override returns ( string [] memory ) { return _fragmentNames ; } // --- Internal String Utility Functions (Simplified for example) --- function _replacePlaceholder ( string memory source , string memory placeholder , string memory replacement ) internal pure returns ( string memory ) { // This is a very basic string replace. For production, consider a robust StringUtils lib. bytes memory sourceBytes = bytes ( source ); bytes memory placeholderBytes = bytes ( placeholder ); bytes memory replacementBytes = bytes ( replacement ); uint265 i = 0 ; uint256 j = 0 ; bytes memory result = new bytes ( sourceBytes . length ); // Max possible size while ( i < sourceBytes . length ) { bool found = true ; if ( i + placeholderBytes . length <= sourceBytes . length ) { for ( uint256 p = 0 ; p < placeholderBytes . length ; p ++ ) { if ( sourceBytes [ i + p ] != placeholderBytes [ p ]) { found = false ; break ; } } } else { found = false ; } if ( found ) { for ( uint256 r = 0 ; r < replacementBytes . length ; r ++ ) { result [ j ++ ] = replacementBytes [ r ]; } i += placeholderBytes . length ; } else { result [ j ++ ] = sourceBytes [ i ++ ]; } } return string ( result ); } function _uint256ToString ( uint256 _i ) internal pure returns ( string memory _uintAsString ) { if ( _i == 0 ) { return \"0\" ; } uint256 j = _i ; uint256 len ; while ( j != 0 ) { len ++ ; j /= 10 ; } bytes memory bstr = new bytes ( len ); uint256 k = len - 1 ; while ( _i != 0 ) { bstr [ k -- ] = byte ( uint8 ( 48 + _i % 10 )); _i /= 10 ; } return string ( bstr ); } }","title":"Implementation Example"},{"location":"smart-contracts/interfaces/isvg/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/isvg/#access-control","text":"onlyOwner : Critical functions for adding, updating, or deactivating SVG templates and fragments must be restricted to the contract owner or an authorized role to prevent malicious or accidental changes to visual assets.","title":"Access Control"},{"location":"smart-contracts/interfaces/isvg/#gas-costs","text":"String Manipulation : On-chain string concatenation and replacement can be extremely gas-intensive, especially for complex SVGs or frequent rendering. Consider the trade-off between fully on-chain SVG generation and off-chain rendering with on-chain data validation. Base64 Encoding : Base64.encode also consumes significant gas; ensure its usage is justified by the application's needs.","title":"Gas Costs"},{"location":"smart-contracts/interfaces/isvg/#input-validation","text":"Data bytes : The data parameter in renderSVG should be carefully parsed and validated to prevent unexpected SVG output or injection vulnerabilities if directly embedded without proper sanitization. Template Content : Validate that template and fragment content doesn't contain malicious scripts or excessive size.","title":"Input Validation"},{"location":"smart-contracts/interfaces/isvg/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/interfaces/isvg/#off-chain-rendering-alternative","text":"Hybrid Approach : For high-volume or very complex SVGs, consider storing only the dynamic numerical/text data on-chain and performing the actual SVG rendering in a frontend application or a dedicated off-chain service. The smart contract would then primarily act as a data oracle.","title":"Off-chain Rendering (Alternative)"},{"location":"smart-contracts/interfaces/isvg/#template-design","text":"Placeholders : Use clear, consistent placeholders (e.g., [[COLOR]] , {{VARIABLE_NAME}} ) within SVG templates to indicate where dynamic data should be injected. Modular Fragments : Break down complex SVGs into smaller, reusable fragments to promote efficiency and simplify template management.","title":"Template Design"},{"location":"smart-contracts/interfaces/isvg/#data-uri-length","text":"Transaction Limits : Be aware of blockchain transaction size limits if you intend to store or return very large SVG data URIs via events or return values. IPFS/Storage : For large metadata, store the SVG on IPFS or another decentralized storage solution and just provide the hash/URI on-chain.","title":"Data URI Length"},{"location":"smart-contracts/interfaces/isvg/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/isvg/#frontend-integration-react-with-ethersjs","text":"import React , { useState , useEffect } from 'react' ; import { ethers , Contract } from 'ethers' ; import SVGABI from './SVGGenerator.json' ; // ABI for the ISVG contract const SVG_GENERATOR_ADDRESS = \"0x...\" ; // Deployed SVG generator contract address interface SVGComponentProps { tokenId : number ; color : string ; text : string ; } const NFTImage : React.FC < SVGComponentProps > = ({ tokenId , color , text }) => { const [ svgDataUri , setSvgDataUri ] = useState < string > ( '' ); const [ loading , setLoading ] = useState < boolean > ( true ); const [ error , setError ] = useState < string | null > ( null ); useEffect (() => { const fetchSVG = async () => { setLoading ( true ); setError ( null ); try { const provider = new ethers . providers . Web3Provider ( window . ethereum ); const svgContract = new Contract ( SVG_GENERATOR_ADDRESS , SVGABI , provider ); // Encode dynamic data const encodedData = ethers . utils . defaultAbiCoder . encode ( [ \"string\" , \"string\" , \"uint256\" ], // Match the abi.decode in contract [ color , text , tokenId ] ); // Call renderSVG specifying a template and version const templateName = \"CryptoBadge\" ; // Example template name const templateVersion = 1 ; // Example template version const uri = await svgContract . renderSVG ( templateName , templateVersion , encodedData ); setSvgDataUri ( uri ); } catch ( err : any ) { console . error ( \"Error fetching SVG:\" , err ); setError ( `Failed to fetch SVG: ${ err . message || err } ` ); } finally { setLoading ( false ); } }; fetchSVG (); }, [ tokenId , color , text ]); if ( loading ) return < div > Loading SVG ... < /div>; if ( error ) return < div > Error : { error } < /div>; return ( < img src = { svgDataUri } alt = { `NFT ${ tokenId } ` } style = {{ width : '300px' , height : '300px' }} /> ); }; export default NFTImage ;","title":"Frontend Integration (React with Ethers.js)"},{"location":"smart-contracts/interfaces/isvg/#backend-integration-nodejsweb3js-for-off-chain-metadata-generation","text":"const Web3 = require ( 'web3' ); const SVGGeneratorABI = require ( './SVGGenerator.json' ). abi ; // ABI of ISVG contract const web3 = new Web3 ( 'YOUR_ETHEREUM_RPC_URL' ); const svgGeneratorAddress = '0x...' ; // Deployed SVG generator contract address const svgGeneratorContract = new web3 . eth . Contract ( SVGGeneratorABI , svgGeneratorAddress ); async function generateNFTMetadata ( tokenId , nftAttributes ) { try { console . log ( `Generating SVG for Token ID: ${ tokenId } ` ); const templateName = \"ArtPieceTemplate\" ; const templateVersion = 1 ; // Assuming version 1 for now // ABI encode the attributes const encodedData = web3 . eth . abi . encodeParameters ( [ 'string' , 'uint256' , 'string' ], // Example types: color, rarity, texture [ nftAttributes . color , nftAttributes . rarity , nftAttributes . texture ] ); const svgDataUri = await svgGeneratorContract . methods . renderSVG ( templateName , templateVersion , encodedData ). call (); // Construct ERC721 metadata JSON const metadata = { name : `My NFT # ${ tokenId } ` , description : \"An algorithmically generated NFT from Gemforce.\" , image : svgDataUri , // The generated SVG data URI attributes : [ { trait_type : \"Color\" , value : nftAttributes . color }, { trait_type : \"Rarity\" , value : nftAttributes . rarity }, { trait_type : \"Texture\" , value : nftAttributes . texture } ] }; console . log ( `Metadata for Token ID ${ tokenId } :` , JSON . stringify ( metadata , null , 2 )); return metadata ; } catch ( error ) { console . error ( 'Error generating NFT metadata:' , error ); throw error ; } } // Example Usage // generateNFTMetadata(123, { color: \"blue\", rarity: 5, texture: \"smooth\" });","title":"Backend Integration (Node.js/Web3.js for off-chain metadata generation)"},{"location":"smart-contracts/interfaces/isvg/#related-documentation","text":"SVG Templates Library ERC721 Metadata Standard Base64 Encoding (OpenZeppelin's Base64) Data URIs (MDN Web Docs)","title":"Related Documentation"},{"location":"smart-contracts/interfaces/isvg/#standards-compliance","text":"ERC721 Metadata : The output can be directly used as the image field for ERC721 token metadata. Ownable : Utilizes OpenZeppelin's Ownable for administrative access control.","title":"Standards Compliance"},{"location":"smart-contracts/interfaces/itradedeal/","text":"ITradeDeal Interface \u00b6 Overview \u00b6 The ITradeDeal.sol defines the comprehensive interface for trade deal functionality within the Gemforce platform. This interface establishes the standard contract for creating, managing, and operating collateralized trade deals with invoice backing, USDC funding, interest distribution, and participant management. Interface Details \u00b6 Interface Name : ITradeDeal License : MIT Solidity Version : ^0.8.0 Key Features \u00b6 \ud83d\udd39 Trade Deal Lifecycle Management \u00b6 Create and configure trade deals with flexible parameters Activate and deactivate trade deals Update trade deal settings and token addresses Comprehensive status tracking and reporting \ud83d\udd39 Collateral and Funding Operations \u00b6 Invoice deposit and withdrawal as collateral USDC funding with automatic collateral token distribution Funding withdrawal for borrowers Collateral token redemption system \ud83d\udd39 Interest and Fee Management \u00b6 Automated interest calculation and distribution Multi-pool interest allocation Fee distribution to configured receivers Interest token minting and management \ud83d\udd39 Participant and Access Control \u00b6 Participant addition and removal Identity verification through claim topics Role-based access control Participant validation for operations \ud83d\udd39 Repayment and Settlement \u00b6 Flexible repayment processing Partial and full repayment support Automated settlement calculations Repayment tracking and validation Core Functions \u00b6 Trade Deal Management Functions \u00b6 createTradeDeal() \u00b6 function createTradeDeal ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , uint256 [] memory requiredClaimTopics , address collateralAddress , address interestAddress , address usdcAddress , TradeDealLib . OperationMode operationMode ) external returns ( uint256 ) Purpose : Creates a new trade deal with specified configuration parameters. Parameters : - name (string): Human-readable name for the trade deal - symbol (string): Symbol for the trade deal's collateral token - interestRate (uint256): Interest rate in basis points (100 = 1%) - collateralToInterestRatio (uint256): Conversion ratio for collateral to interest tokens - requiredClaimTopics (uint256[]): Array of claim topic IDs required for participation - collateralAddress (address): Address of the collateral token contract - interestAddress (address): Address of the interest token contract - usdcAddress (address): Address of the USDC token contract - operationMode (TradeDealLib.OperationMode): Operation mode for the trade deal Returns : - uint256 : Unique identifier for the newly created trade deal Events : TradeDealCreated(tradeDealId, name, symbol, interestRate, collateralToInterestRatio, active, nftAddress, collateralAddress, interestAddress, usdcAddress, operationMode) Example Usage : // Create a new trade deal for invoice financing string memory dealName = \"Q1 2024 Invoice Financing\" ; string memory dealSymbol = \"Q1IF\" ; uint256 interestRate = 800 ; // 8% annual interest uint256 collateralRatio = 1000000 ; // 1:1 ratio (scaled) uint256 [] memory claimTopics = new uint256 []( 2 ); claimTopics [ 0 ] = 1 ; // KYC verification claimTopics [ 1 ] = 2 ; // Accredited investor uint256 tradeDealId = ITradeDeal ( diamond ). createTradeDeal ( dealName , dealSymbol , interestRate , collateralRatio , claimTopics , collateralTokenAddress , interestTokenAddress , usdcTokenAddress , TradeDealLib . OperationMode . STANDARD ); console . log ( \"Created trade deal with ID:\" , tradeDealId ); updateTradeDeal() \u00b6 function updateTradeDeal ( uint256 tradeDealId , string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , address collateralAddress , address interestAddress , address usdcAddress ) external Purpose : Updates the configuration of an existing trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal to update - name (string): Updated name for the trade deal - symbol (string): Updated symbol for the collateral token - interestRate (uint256): Updated interest rate in basis points - collateralToInterestRatio (uint256): Updated conversion ratio - collateralAddress (address): Updated collateral token address - interestAddress (address): Updated interest token address - usdcAddress (address): Updated USDC token address Events : TradeDealUpdated(tradeDealId, name, symbol, interestRate, collateralToInterestRatio, active, collateralAddress, interestAddress, usdcAddress) Example Usage : // Update trade deal interest rate uint256 tradeDealId = 1 ; uint256 newInterestRate = 750 ; // Reduce to 7.5% ITradeDeal ( diamond ). updateTradeDeal ( tradeDealId , \"Q1 2024 Invoice Financing - Updated\" , \"Q1IF\" , newInterestRate , 1000000 , // Keep same ratio collateralTokenAddress , interestTokenAddress , usdcTokenAddress ); activateTradeDeal() / deactivateTradeDeal() \u00b6 function activateTradeDeal ( uint256 tradeDealId ) external function deactivateTradeDeal ( uint256 tradeDealId ) external Purpose : Activates or deactivates a trade deal for participation and operations. Parameters : - tradeDealId (uint256): ID of the trade deal Events : - TradeDealActivated(tradeDealId) - TradeDealDeactivated(tradeDealId) Example Usage : // Activate trade deal for funding uint256 tradeDealId = 1 ; ITradeDeal ( diamond ). activateTradeDeal ( tradeDealId ); // Later, deactivate when funding complete ITradeDeal ( diamond ). deactivateTradeDeal ( tradeDealId ); Collateral and Funding Functions \u00b6 tdDepositInvoice() / tdWithdrawInvoice() \u00b6 function tdDepositInvoice ( uint256 tradeDealId , uint256 tokenId ) external function tdWithdrawInvoice ( uint256 tradeDealId , uint256 tokenId ) external Purpose : Deposits or withdraws invoice NFTs as collateral for trade deals. Parameters : - tradeDealId (uint256): ID of the trade deal - tokenId (uint256): ID of the invoice NFT Events : - InvoiceDepositedToTradeDeal(tradeDealId, tokenId) - InvoiceWithdrawnFromTradeDeal(tradeDealId, tokenId) Example Usage : // Deposit invoice as collateral uint256 tradeDealId = 1 ; uint256 invoiceTokenId = 123 ; // First approve the diamond to transfer the invoice IERC721 ( invoiceContract ). approve ( diamond , invoiceTokenId ); // Deposit the invoice ITradeDeal ( diamond ). tdDepositInvoice ( tradeDealId , invoiceTokenId ); console . log ( \"Invoice deposited as collateral\" ); // Later withdraw if needed ITradeDeal ( diamond ). tdWithdrawInvoice ( tradeDealId , invoiceTokenId ); tdDepositUSDC() / tdWithdrawUSDC() \u00b6 function tdDepositUSDC ( uint256 tradeDealId , uint256 amount ) external function tdWithdrawUSDC ( uint256 tradeDealId , uint256 amount ) external Purpose : Deposits or withdraws USDC for trade deal funding. Parameters : - tradeDealId (uint256): ID of the trade deal - amount (uint256): Amount of USDC to deposit/withdraw Events : - USDCDepositedToTradeDeal(tradeDealId, amount, depositor) - CollateralTokensDistributed(tradeDealId, recipient, amount) - TradeDealFullyFunded(tradeDealId, fundingTarget) (if applicable) - USDCWithdrawnFromTradeDeal(tradeDealId, amount) Example Usage : // Fund trade deal with USDC uint256 tradeDealId = 1 ; uint256 fundingAmount = 10000 * 10 ** 6 ; // 10,000 USDC // First approve USDC transfer IERC20 ( usdcToken ). approve ( diamond , fundingAmount ); // Deposit USDC and receive collateral tokens ITradeDeal ( diamond ). tdDepositUSDC ( tradeDealId , fundingAmount ); console . log ( \"Deposited USDC and received collateral tokens\" ); withdrawTradeDealFundingForBorrower() \u00b6 function withdrawTradeDealFundingForBorrower ( uint256 tradeDealId , address borrowerAddress ) external Purpose : Allows admin to withdraw funding on behalf of a borrower. Parameters : - tradeDealId (uint256): ID of the trade deal - borrowerAddress (address): Address of the borrower receiving funds Events : TradeDealFundingWithdrawn(tradeDealId, recipient, amount) Example Usage : // Admin withdraws funding for borrower uint256 tradeDealId = 1 ; address borrower = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; ITradeDeal ( diamond ). withdrawTradeDealFundingForBorrower ( tradeDealId , borrower ); console . log ( \"Funding withdrawn for borrower\" ); Interest and Fee Management Functions \u00b6 tdDistributeInterest() \u00b6 function tdDistributeInterest ( uint256 tradeDealId ) external Purpose : Distributes accumulated interest for a trade deal across pools and participants. Parameters : - tradeDealId (uint256): ID of the trade deal Events : InterestDistributedForTradeDeal(tradeDealId, totalInterest, invoicePoolInterest, interestInterest, interestTokensMinted) Example Usage : // Distribute interest for trade deal uint256 tradeDealId = 1 ; ITradeDeal ( diamond ). tdDistributeInterest ( tradeDealId ); console . log ( \"Interest distributed for trade deal\" ); Repayment Functions \u00b6 repayTradeDeal() / repayTradeDealForBorrower() \u00b6 function repayTradeDeal ( uint256 tradeDealId , uint256 amount ) external function repayTradeDealForBorrower ( uint256 tradeDealId , address borrower , uint256 amount ) external Purpose : Processes repayments for trade deals, either by borrower or admin. Parameters : - tradeDealId (uint256): ID of the trade deal - amount (uint256): Amount to repay - borrower (address): Borrower address (for admin repayment) Events : TradeDealRepaid(tradeDealId, repayer, amount, fullyRepaid) Example Usage : // Borrower makes repayment uint256 tradeDealId = 1 ; uint256 repaymentAmount = 5000 * 10 ** 6 ; // 5,000 USDC // First approve USDC transfer IERC20 ( usdcToken ). approve ( diamond , repaymentAmount ); // Make repayment ITradeDeal ( diamond ). repayTradeDeal ( tradeDealId , repaymentAmount ); console . log ( \"Repayment made\" ); redeemCollateralTokens() \u00b6 function redeemCollateralTokens ( uint256 tradeDealId , uint256 collateralAmount ) external Purpose : Redeems collateral tokens for USDC based on current redemption rate. Parameters : - tradeDealId (uint256): ID of the trade deal - collateralAmount (uint256): Amount of collateral tokens to redeem Events : CollateralTokensRedeemed(tradeDealId, redeemer, collateralAmount, usdcAmount) Example Usage : // Redeem collateral tokens for USDC uint256 tradeDealId = 1 ; uint256 collateralToRedeem = 1000 * 10 ** 18 ; // 1,000 collateral tokens ITradeDeal ( diamond ). redeemCollateralTokens ( tradeDealId , collateralToRedeem ); console . log ( \"Collateral tokens redeemed for USDC\" ); Participant Management Functions \u00b6 setTradeDealRequiredClaimTopics() / getTradeDealRequiredClaimTopics() \u00b6 function setTradeDealRequiredClaimTopics ( uint256 tradeDealId , uint256 [] memory claimTopics ) external function getTradeDealRequiredClaimTopics ( uint256 tradeDealId ) external view returns ( uint256 [] memory ) Purpose : Sets or retrieves required identity claim topics for trade deal participation. Parameters : - tradeDealId (uint256): ID of the trade deal - claimTopics (uint256[]): Array of claim topic IDs Events : TradeDealRequiredClaimTopicsSet(tradeDealId, claimTopics) Example Usage : // Set required claim topics uint256 tradeDealId = 1 ; uint256 [] memory requiredClaims = new uint256 []( 3 ); requiredClaims [ 0 ] = 1 ; // KYC verification requiredClaims [ 1 ] = 2 ; // Accredited investor requiredClaims [ 2 ] = 3 ; // Geographic eligibility ITradeDeal ( diamond ). setTradeDealRequiredClaimTopics ( tradeDealId , requiredClaims ); // Get current requirements uint256 [] memory currentClaims = ITradeDeal ( diamond ). getTradeDealRequiredClaimTopics ( tradeDealId ); isTradeDealParticipant() \u00b6 function isTradeDealParticipant ( uint256 tradeDealId , address user ) external view returns ( bool ) Purpose : Checks if an address is a verified participant in a trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal - user (address): Address to check Returns : - bool : True if user is a verified participant Example Usage : // Check if user is a participant uint256 tradeDealId = 1 ; address user = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; bool isParticipant = ITradeDeal ( diamond ). isTradeDealParticipant ( tradeDealId , user ); if ( isParticipant ) { console . log ( \"User is verified participant\" ); } else { console . log ( \"User is not a participant\" ); } Query Functions \u00b6 getTradeDealInfo() \u00b6 function getTradeDealInfo ( uint256 tradeDealId ) external view returns ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , TradeDealLib . OperationMode operationMode ) Purpose : Retrieves basic information about a trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal Returns : Trade deal configuration details Example Usage : // Get trade deal information uint256 tradeDealId = 1 ; ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralRatio , bool active , TradeDealLib . OperationMode mode ) = ITradeDeal ( diamond ). getTradeDealInfo ( tradeDealId ); console . log ( \"Trade Deal:\" , name ); console . log ( \"Interest Rate:\" , interestRate , \"basis points\" ); console . log ( \"Active:\" , active ); getTradeDealFullStatus() \u00b6 function getTradeDealFullStatus ( uint256 tradeDealId ) external view returns ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) Purpose : Retrieves comprehensive status information for a trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal Returns : Complete financial and operational status Example Usage : // Get complete trade deal status uint256 tradeDealId = 1 ; ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = ITradeDeal ( diamond ). getTradeDealFullStatus ( tradeDealId ); console . log ( \"Funding Target:\" , fundingTarget ); console . log ( \"Current Balance:\" , currentBalance ); console . log ( \"Is Funded:\" , isFunded ); console . log ( \"Total Debt:\" , totalDebt ); console . log ( \"Repaid Amount:\" , repaidAmount ); console . log ( \"Is Fully Repaid:\" , isRepaid ); getAllTradeDealIds() \u00b6 function getAllTradeDealIds () external view returns ( uint256 [] memory ) Purpose : Returns all trade deal IDs in the system. Returns : Array of trade deal IDs Example Usage : // Get all trade deal IDs uint256 [] memory allDeals = ITradeDeal ( diamond ). getAllTradeDealIds (); console . log ( \"Total trade deals:\" , allDeals . length ); for ( uint256 i = 0 ; i < allDeals . length ; i ++ ) { console . log ( \"Trade Deal ID:\" , allDeals [ i ]); } Status Check Functions \u00b6 isTradeDealFunded() / isTradeDealRepaid() \u00b6 function isTradeDealFunded ( uint256 tradeDealId ) external view returns ( bool ) function isTradeDealRepaid ( uint256 tradeDealId ) external view returns ( bool ) Purpose : Quick status checks for funding and repayment status. Parameters : - tradeDealId (uint256): ID of the trade deal Returns : Boolean status Example Usage : // Check trade deal status uint256 tradeDealId = 1 ; bool isFunded = ITradeDeal ( diamond ). isTradeDealFunded ( tradeDealId ); bool isRepaid = ITradeDeal ( diamond ). isTradeDealRepaid ( tradeDealId ); console . log ( \"Trade Deal Funded:\" , isFunded ); console . log ( \"Trade Deal Repaid:\" , isRepaid ); Integration Examples \u00b6 Complete Trade Deal Workflow \u00b6 // Comprehensive trade deal integration example contract TradeDealWorkflow { ITradeDeal public tradeDeal ; struct WorkflowState { uint256 tradeDealId ; uint256 phase ; // 0: Created, 1: Funded, 2: Active, 3: Repaid uint256 totalFunding ; uint256 totalRepaid ; address [] participants ; } mapping ( uint256 => WorkflowState ) public workflows ; event WorkflowPhaseChanged ( uint256 indexed tradeDealId , uint256 newPhase ); constructor ( address _tradeDeal ) { tradeDeal = ITradeDeal ( _tradeDeal ); } function createAndFundTradeDeal ( string memory name , string memory symbol , uint256 interestRate , uint256 fundingAmount , uint256 [] memory invoiceTokenIds ) external returns ( uint256 tradeDealId ) { // Create trade deal uint256 [] memory claimTopics = new uint256 []( 1 ); claimTopics [ 0 ] = 1 ; // KYC required tradeDealId = tradeDeal . createTradeDeal ( name , symbol , interestRate , 1000000 , // 1:1 collateral ratio claimTopics , collateralTokenAddress , interestTokenAddress , usdcTokenAddress , TradeDealLib . OperationMode . STANDARD ); // Initialize workflow workflows [ tradeDealId ] = WorkflowState ({ tradeDealId : tradeDealId , phase : 0 , totalFunding : 0 , totalRepaid : 0 , participants : new address []( 0 ) }); // Activate trade deal tradeDeal . activateTradeDeal ( tradeDealId ); // Deposit invoices as collateral for ( uint256 i = 0 ; i < invoiceTokenIds . length ; i ++ ) { tradeDeal . tdDepositInvoice ( tradeDealId , invoiceTokenIds [ i ]); } // Fund the trade deal tradeDeal . tdDepositUSDC ( tradeDealId , fundingAmount ); workflows [ tradeDealId ]. totalFunding = fundingAmount ; workflows [ tradeDealId ]. phase = 1 ; emit WorkflowPhaseChanged ( tradeDealId , 1 ); } function processRepayment ( uint256 tradeDealId , uint256 amount ) external { WorkflowState storage workflow = workflows [ tradeDealId ]; require ( workflow . phase >= 1 , \"Trade deal not funded\" ); // Process repayment tradeDeal . repayTradeDeal ( tradeDealId , amount ); workflow . totalRepaid += amount ; // Check if fully repaid bool isRepaid = tradeDeal . isTradeDealRepaid ( tradeDealId ); if ( isRepaid && workflow . phase < 3 ) { workflow . phase = 3 ; emit WorkflowPhaseChanged ( tradeDealId , 3 ); } } function distributeInterestAndFees ( uint256 tradeDealId ) external { WorkflowState storage workflow = workflows [ tradeDealId ]; require ( workflow . phase >= 1 , \"Trade deal not funded\" ); // Distribute interest tradeDeal . tdDistributeInterest ( tradeDealId ); // Update phase if needed if ( workflow . phase == 1 ) { workflow . phase = 2 ; // Active phase emit WorkflowPhaseChanged ( tradeDealId , 2 ); } } function getWorkflowStatus ( uint256 tradeDealId ) external view returns ( uint256 phase , uint256 fundingProgress , uint256 repaymentProgress , bool canRedeem ) { WorkflowState memory workflow = workflows [ tradeDealId ]; ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( tradeDealId ); phase = workflow . phase ; fundingProgress = fundingTarget > 0 ? ( currentBalance * 100 ) / fundingTarget : 0 ; repaymentProgress = totalDebt > 0 ? ( repaidAmount * 100 ) / totalDebt : 0 ; canRedeem = isRepaid && workflow . totalFunding > 0 ; } } Trade Deal Analytics Dashboard \u00b6 // Analytics and reporting for trade deals contract TradeDealAnalytics { ITradeDeal public tradeDeal ; struct AnalyticsData { uint256 totalDeals ; uint256 activeDeals ; uint256 fundedDeals ; uint256 repaidDeals ; uint256 totalVolume ; uint256 totalInterestPaid ; uint256 averageInterestRate ; } mapping ( uint256 => uint256 ) public dealCreationTime ; mapping ( uint256 => uint256 ) public dealFundingTime ; mapping ( uint256 => uint256 ) public dealRepaymentTime ; event AnalyticsUpdated ( AnalyticsData data ); function updateAnalytics () external returns ( AnalyticsData memory data ) { uint256 [] memory allDeals = tradeDeal . getAllTradeDealIds (); data . totalDeals = allDeals . length ; uint256 totalInterestRate = 0 ; for ( uint256 i = 0 ; i < allDeals . length ; i ++ ) { uint256 dealId = allDeals [ i ]; ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralRatio , bool active , TradeDealLib . OperationMode mode ) = tradeDeal . getTradeDealInfo ( dealId ); if ( active ) { data . activeDeals ++ ; } totalInterestRate += interestRate ; ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( dealId ); if ( isFunded ) { data . fundedDeals ++ ; data . totalVolume += fundingTarget ; } if ( isRepaid ) { data . repaidDeals ++ ; data . totalInterestPaid += ( repaidAmount > fundingTarget ? repaidAmount - fundingTarget : 0 ); } } if ( data . totalDeals > 0 ) { data . averageInterestRate = totalInterestRate / data . totalDeals ; } emit AnalyticsUpdated ( data ); } function getDealPerformanceMetrics ( uint256 tradeDealId ) external view returns ( uint256 timeToFunding , uint256 timeToRepayment , uint256 actualInterestRate , uint256 performanceScore ) { uint256 creationTime = dealCreationTime [ tradeDealId ]; uint256 fundingTime = dealFundingTime [ tradeDealId ]; uint256 repaymentTime = dealRepaymentTime [ tradeDealId ]; if ( fundingTime > creationTime ) { timeToFunding = fundingTime - creationTime ; } if ( repaymentTime > fundingTime && fundingTime > 0 ) { timeToRepayment = repaymentTime - fundingTime ; } ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( tradeDealId ); if ( isRepaid && fundingTarget > 0 ) { actualInterestRate = (( repaidAmount - fundingTarget ) * 10000 ) / fundingTarget ; // Calculate performance score (0-100) performanceScore = 100 ; if ( timeToFunding > 7 days ) performanceScore -= 20 ; if ( timeToRepayment > 90 days ) performanceScore -= 30 ; if ( ! isRepaid ) performanceScore -= 50 ; } } } Automated Trade Deal Manager \u00b6 // Automated management for trade deal operations contract AutomatedTradeDealManager { ITradeDeal public tradeDeal ; struct AutomationConfig { bool autoDistributeInterest ; uint256 interestDistributionFrequency ; uint256 lastInterestDistribution ; bool autoProcessRepayments ; uint256 gracePeriod ; bool autoRedemption ; } mapping ( uint256 => AutomationConfig ) public automationConfigs ; mapping ( uint256 => uint256 ) public nextScheduledAction ; event AutomationConfigured ( uint256 indexed tradeDealId , AutomationConfig config ); event AutomatedActionExecuted ( uint256 indexed tradeDealId , string action ); function configureAutomation ( uint256 tradeDealId , AutomationConfig memory config ) external onlyAuthorized { automationConfigs [ tradeDealId ] = config ; if ( config . autoDistributeInterest ) { nextScheduledAction [ tradeDealId ] = block.timestamp + config . interestDistributionFrequency ; } emit AutomationConfigured ( tradeDealId , config ); } function executeScheduledActions ( uint256 [] memory tradeDealIds ) external { for ( uint256 i = 0 ; i < tradeDealIds . length ; i ++ ) { uint256 tradeDealId = tradeDealIds [ i ]; AutomationConfig memory config = automationConfigs [ tradeDealId ]; // Auto-distribute interest if ( config . autoDistributeInterest && block.timestamp >= nextScheduledAction [ tradeDealId ]) { tradeDeal . tdDistributeInterest ( tradeDealId ); nextScheduledAction [ tradeDealId ] = block.timestamp + config . interestDistributionFrequency ; emit AutomatedActionExecuted ( tradeDealId , \"interest_distribution\" ); } // Auto-process repayments (would need additional logic) if ( config . autoProcessRepayments ) { _processAutomaticRepayments ( tradeDealId , config ); } // Auto-redemption for completed deals if ( config . autoRedemption ) { _processAutomaticRedemption ( tradeDealId ); } } } function _processAutomaticRepayments ( uint256 tradeDealId , AutomationConfig memory config ) internal { // Implementation would check for due repayments and process them // This would integrate with external payment systems or scheduled transfers ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( tradeDealId ); if ( isFunded && ! isRepaid ) { // Check if repayment is due and process if available // This would require integration with external systems totalRepaid : 0 , participants : new address []( 0 ) }); // Activate trade deal tradeDeal . activateTradeDeal ( tradeDealId ); // Deposit invoices as collateral for ( uint256 i = 0 ; i < invoiceTokenIds . length ; i ++ ) { tradeDeal . tdDepositInvoice ( tradeDealId , invoiceTokenIds [ i ]); } // Fund the trade deal tradeDeal . tdDepositUSDC ( tradeDealId , fundingAmount ); workflows [ tradeDealId ]. totalFunding = fundingAmount ; workflows [ tradeDealId ]. phase = 1 ; emit WorkflowPhaseChanged ( tradeDealId , 1 ); } function processRepayment ( uint256 tradeDealId , uint256 amount ) external { WorkflowState storage workflow = workflows [ tradeDealId ]; require ( workflow . phase >= 1 , \"Trade deal not funded\" ); // Process repayment tradeDeal . repayTradeDeal ( tradeDealId , amount ); workflow . totalRepaid += amount ; // Check if fully repaid bool isRepaid = tradeDeal . isTradeDealRepaid ( tradeDealId ); if ( isRepaid && workflow . phase < 3 ) { workflow . phase = 3 ; emit WorkflowPhaseChanged ( tradeDealId , 3 ); } } function distributeInterestAndFees ( uint256 tradeDealId ) external { WorkflowState storage workflow = workflows [ tradeDealId ]; require ( workflow . phase >= 1 , \"Trade deal not funded\" ); // Distribute interest tradeDeal . tdDistributeInterest ( tradeDealId ); // Update phase if needed if ( workflow . phase == 1 ) { workflow . phase = 2 ; // Active phase emit WorkflowPhaseChanged ( tradeDealId , 2 ); } } function getWorkflowStatus ( uint256 tradeDealId ) external view returns ( uint256 phase , uint256 fundingProgress , uint256 repaymentProgress , bool canRedeem ) { WorkflowState memory workflow = workflows [ tradeDealId ]; ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( tradeDealId ); phase = workflow . phase ; fundingProgress = fundingTarget > 0 ? ( currentBalance * 100 ) / fundingTarget : 0 ; repaymentProgress = totalDebt > 0 ? ( repaidAmount * 100 ) / totalDebt : 0 ; canRedeem = isRepaid && workflow . totalFunding > 0 ; } } Trade Deal Analytics Dashboard \u00b6 // Analytics and reporting for trade deals contract TradeDealAnalytics { ITradeDeal public tradeDeal ; struct AnalyticsData { uint256 totalDeals ; uint256 activeDeals ; uint256 fundedDeals ; uint256 repaidDeals ; uint256 totalVolume ; uint256 totalInterestPaid ; uint256 averageInterestRate ; } mapping ( uint256 => uint256 ) public dealCreationTime ; mapping ( uint256 => uint256 ) public dealFundingTime ; mapping ( uint256 => uint256 ) public dealRepaymentTime ; event AnalyticsUpdated ( AnalyticsData data ); function updateAnalytics () external returns ( AnalyticsData memory data ) { uint256 [] memory allDeals = tradeDeal . getAllTradeDealIds (); data . totalDeals = allDeals . length ; uint256 totalInterestRate = 0 ; for ( uint256 i = 0 ; i < allDeals . length ; i ++ ) { uint256 dealId = allDeals [ i ]; ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralRatio , bool active , TradeDealLib . OperationMode mode ) = tradeDeal . getTradeDealInfo ( dealId ); if ( active ) { data . activeDeals ++ ; } totalInterestRate += interestRate ; ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( dealId ); if ( isFunded ) { data . fundedDeals ++ ; data . totalVolume += fundingTarget ; } if ( isRepaid ) { data . repaidDeals ++ ; data . totalInterestPaid += ( repaidAmount > fundingTarget ? repaidAmount - fundingTarget : 0 ); } } if ( data . totalDeals > 0 ) { data . averageInterestRate = totalInterestRate / data . totalDeals ; } emit AnalyticsUpdated ( data ); } function getDealPerformanceMetrics ( uint256 tradeDealId ) external view returns ( uint256 timeToFunding , uint256 timeToRepayment , uint256 actualInterestRate , uint256 performanceScore ) { uint256 creationTime = dealCreationTime [ tradeDealId ]; uint256 fundingTime = dealFundingTime [ tradeDealId ]; uint256 repaymentTime = dealRepaymentTime [ tradeDealId ]; if ( fundingTime > creationTime ) { timeToFunding = fundingTime - creationTime ; } if ( repaymentTime > fundingTime && fundingTime > 0 ) { timeToRepayment = repaymentTime - fundingTime ; } ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( tradeDealId ); if ( isRepaid && fundingTarget > 0 ) { actualInterestRate = (( repaidAmount - fundingTarget ) * 10000 ) / fundingTarget ; // Calculate performance score (0-100) performanceScore = 100 ; if ( timeToFunding > 7 days ) performanceScore -= 20 ; if ( timeToRepayment > 90 days ) performanceScore -= 30 ; if ( ! isRepaid ) performanceScore -= 50 ; } } } Automated Trade Deal Manager \u00b6 // Automated management for trade deal operations contract AutomatedTradeDealManager { ITradeDeal public tradeDeal ; struct AutomationConfig { bool autoDistributeInterest ; uint256 interestDistributionFrequency ; uint256 lastInterestDistribution ; bool autoProcessRepayments ; uint256 gracePeriod ; bool autoRedemption ; } mapping ( uint256 => AutomationConfig ) public automationConfigs ; mapping ( uint256 => uint256 ) public nextScheduledAction ; event AutomationConfigured ( uint256 indexed tradeDealId , AutomationConfig config ); event AutomatedActionExecuted ( uint256 indexed tradeDealId , string action ); function configureAutomation ( uint256 tradeDealId , AutomationConfig memory config ) external onlyAuthorized { automationConfigs [ tradeDealId ] = config ; if ( config . autoDistributeInterest ) { nextScheduledAction [ tradeDealId ] = block.timestamp + config . interestDistributionFrequency ; } emit AutomationConfigured ( tradeDealId , config ); } function executeScheduledActions ( uint256 [] memory tradeDealIds ) external { for ( uint256 i = 0 ; i < tradeDealIds . length ; i ++ ) { uint256 tradeDealId = tradeDealIds [ i ]; AutomationConfig memory config = automationConfigs [ tradeDealId ]; // Auto-distribute interest if ( config . autoDistributeInterest && block.timestamp >= nextScheduledAction [ tradeDealId ]) { tradeDeal . tdDistributeInterest ( tradeDealId ); nextScheduledAction [ tradeDealId ] = block.timestamp + config . interestDistributionFrequency ; emit AutomatedActionExecuted ( tradeDealId , \"interest_distribution\" ); } // Auto-process repayments (would need additional logic) if ( config . autoProcessRepayments ) { _processAutomaticRepayments ( tradeDealId , config ); } // Auto-redemption for completed deals if ( config . autoRedemption ) { _processAutomaticRedemption ( tradeDealId ); } } } function _processAutomaticRepayments ( uint256 tradeDealId , AutomationConfig memory config ) internal { // Implementation would check for due repayments and process them // This would integrate with external payment systems or scheduled transfers ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( tradeDealId ); if ( isFunded && ! isRepaid ) { // Check if repayment is due and process if available // This would require integration with external systems emit AutomatedActionExecuted ( tradeDealId , \"repayment_check\" ); } } function _processAutomaticRedemption ( uint256 tradeDealId ) internal { bool isRepaid = tradeDeal . isTradeDealRepaid ( tradeDealId ); if ( isRepaid ) { // Process automatic redemption for eligible participants // This would require additional participant tracking emit AutomatedActionExecuted ( tradeDealId , \"auto_redemption\" ); } } } Events \u00b6 Trade Deal Lifecycle Events \u00b6 event TradeDealCreated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address nftAddress , address collateralAddress , address interestAddress , address usdcAddress , TradeDealLib . OperationMode operationMode ); event TradeDealUpdated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address collateralAddress , address interestAddress , address usdcAddress ); event TradeDealActivated ( uint256 indexed tradeDealId ); event TradeDealDeactivated ( uint256 indexed tradeDealId ); Participant Management Events \u00b6 event TradeDealParticipantAdded ( uint256 indexed tradeDealId , address indexed participant ); event TradeDealParticipantRemoved ( uint256 indexed tradeDealId , address indexed participant ); event TradeDealRequiredClaimTopicsSet ( uint256 indexed tradeDealId , uint256 [] claimTopics ); Collateral and Funding Events \u00b6 event InvoiceDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event InvoiceWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event USDCDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 amount , address depositor ); event USDCWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 amount ); event TradeDealFullyFunded ( uint256 indexed tradeDealId , uint256 fundingTarget ); event CollateralTokensDistributed ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount ); Interest and Fee Events \u00b6 event InterestDistributedForTradeDeal ( uint256 indexed tradeDealId , uint256 totalInterest , uint256 invoicePoolInterest , uint256 interestInterest , uint256 interestTokensMinted ); event TradeDealFeesDistributed ( uint256 indexed tradeDealId , address [] feeReceivers , uint256 [] feeAmounts ); Repayment and Settlement Events \u00b6 event TradeDealFundingWithdrawn ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount ); event TradeDealRepaid ( uint256 indexed tradeDealId , address indexed repayer , uint256 amount , bool fullyRepaid ); event CollateralTokensRedeemed ( uint256 indexed tradeDealId , address indexed redeemer , uint256 collateralAmount , uint256 usdcAmount ); Security Considerations \u00b6 Access Control \u00b6 Owner-only functions for trade deal creation and configuration Participant validation for operations and access Identity verification through claim topics Role-based permissions for administrative functions Financial Security \u00b6 Precise amount calculations and validations Overflow protection for large transactions Secure token transfer mechanisms Interest calculation accuracy and validation Operational Security \u00b6 Trade deal state validation before operations Invoice ownership verification Funding availability checks Repayment authorization validation Gas Optimization \u00b6 Efficient Operations \u00b6 Batch operations for multiple trade deals Optimized storage layout for trade deal data Minimal external calls in view functions Efficient event emission patterns Storage Optimization \u00b6 Packed storage structures where possible Efficient mapping usage for participant tracking Optimized array operations for bulk queries Cached calculations for frequently accessed data Error Handling \u00b6 Common Errors \u00b6 Trade deal not found or inactive Insufficient permissions or authorization Invalid amounts or parameters Funding or repayment validation failures Participant verification failures Best Practices \u00b6 Validate all inputs before processing Check trade deal state before operations Verify participant eligibility for operations Handle token transfer failures gracefully Provide clear error messages for debugging Testing Considerations \u00b6 Unit Tests \u00b6 Interface compliance verification Function parameter validation Return value accuracy testing Event emission verification Error condition handling Integration Tests \u00b6 Complete trade deal lifecycle workflows Multi-participant scenarios Interest distribution and fee calculations Repayment and redemption processes Cross-facet integration testing Related Documentation \u00b6 TradeDealManagementFacet - Core trade deal operations TradeDealAdminFacet - Administrative functions TradeDealOperationsFacet - Operational functions TradeDealLib - Trade deal utilities CollateralTokenFactoryFacet - Token factory integration Trade Deal Guide - Implementation guide This interface defines the comprehensive contract for trade deal functionality within the Gemforce platform, providing standardized operations for collateralized finance instruments with invoice backing and automated settlement.","title":"ITradeDeal"},{"location":"smart-contracts/interfaces/itradedeal/#itradedeal-interface","text":"","title":"ITradeDeal Interface"},{"location":"smart-contracts/interfaces/itradedeal/#overview","text":"The ITradeDeal.sol defines the comprehensive interface for trade deal functionality within the Gemforce platform. This interface establishes the standard contract for creating, managing, and operating collateralized trade deals with invoice backing, USDC funding, interest distribution, and participant management.","title":"Overview"},{"location":"smart-contracts/interfaces/itradedeal/#interface-details","text":"Interface Name : ITradeDeal License : MIT Solidity Version : ^0.8.0","title":"Interface Details"},{"location":"smart-contracts/interfaces/itradedeal/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/itradedeal/#trade-deal-lifecycle-management","text":"Create and configure trade deals with flexible parameters Activate and deactivate trade deals Update trade deal settings and token addresses Comprehensive status tracking and reporting","title":"\ud83d\udd39 Trade Deal Lifecycle Management"},{"location":"smart-contracts/interfaces/itradedeal/#collateral-and-funding-operations","text":"Invoice deposit and withdrawal as collateral USDC funding with automatic collateral token distribution Funding withdrawal for borrowers Collateral token redemption system","title":"\ud83d\udd39 Collateral and Funding Operations"},{"location":"smart-contracts/interfaces/itradedeal/#interest-and-fee-management","text":"Automated interest calculation and distribution Multi-pool interest allocation Fee distribution to configured receivers Interest token minting and management","title":"\ud83d\udd39 Interest and Fee Management"},{"location":"smart-contracts/interfaces/itradedeal/#participant-and-access-control","text":"Participant addition and removal Identity verification through claim topics Role-based access control Participant validation for operations","title":"\ud83d\udd39 Participant and Access Control"},{"location":"smart-contracts/interfaces/itradedeal/#repayment-and-settlement","text":"Flexible repayment processing Partial and full repayment support Automated settlement calculations Repayment tracking and validation","title":"\ud83d\udd39 Repayment and Settlement"},{"location":"smart-contracts/interfaces/itradedeal/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/itradedeal/#trade-deal-management-functions","text":"","title":"Trade Deal Management Functions"},{"location":"smart-contracts/interfaces/itradedeal/#createtradedeal","text":"function createTradeDeal ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , uint256 [] memory requiredClaimTopics , address collateralAddress , address interestAddress , address usdcAddress , TradeDealLib . OperationMode operationMode ) external returns ( uint256 ) Purpose : Creates a new trade deal with specified configuration parameters. Parameters : - name (string): Human-readable name for the trade deal - symbol (string): Symbol for the trade deal's collateral token - interestRate (uint256): Interest rate in basis points (100 = 1%) - collateralToInterestRatio (uint256): Conversion ratio for collateral to interest tokens - requiredClaimTopics (uint256[]): Array of claim topic IDs required for participation - collateralAddress (address): Address of the collateral token contract - interestAddress (address): Address of the interest token contract - usdcAddress (address): Address of the USDC token contract - operationMode (TradeDealLib.OperationMode): Operation mode for the trade deal Returns : - uint256 : Unique identifier for the newly created trade deal Events : TradeDealCreated(tradeDealId, name, symbol, interestRate, collateralToInterestRatio, active, nftAddress, collateralAddress, interestAddress, usdcAddress, operationMode) Example Usage : // Create a new trade deal for invoice financing string memory dealName = \"Q1 2024 Invoice Financing\" ; string memory dealSymbol = \"Q1IF\" ; uint256 interestRate = 800 ; // 8% annual interest uint256 collateralRatio = 1000000 ; // 1:1 ratio (scaled) uint256 [] memory claimTopics = new uint256 []( 2 ); claimTopics [ 0 ] = 1 ; // KYC verification claimTopics [ 1 ] = 2 ; // Accredited investor uint256 tradeDealId = ITradeDeal ( diamond ). createTradeDeal ( dealName , dealSymbol , interestRate , collateralRatio , claimTopics , collateralTokenAddress , interestTokenAddress , usdcTokenAddress , TradeDealLib . OperationMode . STANDARD ); console . log ( \"Created trade deal with ID:\" , tradeDealId );","title":"createTradeDeal()"},{"location":"smart-contracts/interfaces/itradedeal/#updatetradedeal","text":"function updateTradeDeal ( uint256 tradeDealId , string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , address collateralAddress , address interestAddress , address usdcAddress ) external Purpose : Updates the configuration of an existing trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal to update - name (string): Updated name for the trade deal - symbol (string): Updated symbol for the collateral token - interestRate (uint256): Updated interest rate in basis points - collateralToInterestRatio (uint256): Updated conversion ratio - collateralAddress (address): Updated collateral token address - interestAddress (address): Updated interest token address - usdcAddress (address): Updated USDC token address Events : TradeDealUpdated(tradeDealId, name, symbol, interestRate, collateralToInterestRatio, active, collateralAddress, interestAddress, usdcAddress) Example Usage : // Update trade deal interest rate uint256 tradeDealId = 1 ; uint256 newInterestRate = 750 ; // Reduce to 7.5% ITradeDeal ( diamond ). updateTradeDeal ( tradeDealId , \"Q1 2024 Invoice Financing - Updated\" , \"Q1IF\" , newInterestRate , 1000000 , // Keep same ratio collateralTokenAddress , interestTokenAddress , usdcTokenAddress );","title":"updateTradeDeal()"},{"location":"smart-contracts/interfaces/itradedeal/#activatetradedeal-deactivatetradedeal","text":"function activateTradeDeal ( uint256 tradeDealId ) external function deactivateTradeDeal ( uint256 tradeDealId ) external Purpose : Activates or deactivates a trade deal for participation and operations. Parameters : - tradeDealId (uint256): ID of the trade deal Events : - TradeDealActivated(tradeDealId) - TradeDealDeactivated(tradeDealId) Example Usage : // Activate trade deal for funding uint256 tradeDealId = 1 ; ITradeDeal ( diamond ). activateTradeDeal ( tradeDealId ); // Later, deactivate when funding complete ITradeDeal ( diamond ). deactivateTradeDeal ( tradeDealId );","title":"activateTradeDeal() / deactivateTradeDeal()"},{"location":"smart-contracts/interfaces/itradedeal/#collateral-and-funding-functions","text":"","title":"Collateral and Funding Functions"},{"location":"smart-contracts/interfaces/itradedeal/#tddepositinvoice-tdwithdrawinvoice","text":"function tdDepositInvoice ( uint256 tradeDealId , uint256 tokenId ) external function tdWithdrawInvoice ( uint256 tradeDealId , uint256 tokenId ) external Purpose : Deposits or withdraws invoice NFTs as collateral for trade deals. Parameters : - tradeDealId (uint256): ID of the trade deal - tokenId (uint256): ID of the invoice NFT Events : - InvoiceDepositedToTradeDeal(tradeDealId, tokenId) - InvoiceWithdrawnFromTradeDeal(tradeDealId, tokenId) Example Usage : // Deposit invoice as collateral uint256 tradeDealId = 1 ; uint256 invoiceTokenId = 123 ; // First approve the diamond to transfer the invoice IERC721 ( invoiceContract ). approve ( diamond , invoiceTokenId ); // Deposit the invoice ITradeDeal ( diamond ). tdDepositInvoice ( tradeDealId , invoiceTokenId ); console . log ( \"Invoice deposited as collateral\" ); // Later withdraw if needed ITradeDeal ( diamond ). tdWithdrawInvoice ( tradeDealId , invoiceTokenId );","title":"tdDepositInvoice() / tdWithdrawInvoice()"},{"location":"smart-contracts/interfaces/itradedeal/#tddepositusdc-tdwithdrawusdc","text":"function tdDepositUSDC ( uint256 tradeDealId , uint256 amount ) external function tdWithdrawUSDC ( uint256 tradeDealId , uint256 amount ) external Purpose : Deposits or withdraws USDC for trade deal funding. Parameters : - tradeDealId (uint256): ID of the trade deal - amount (uint256): Amount of USDC to deposit/withdraw Events : - USDCDepositedToTradeDeal(tradeDealId, amount, depositor) - CollateralTokensDistributed(tradeDealId, recipient, amount) - TradeDealFullyFunded(tradeDealId, fundingTarget) (if applicable) - USDCWithdrawnFromTradeDeal(tradeDealId, amount) Example Usage : // Fund trade deal with USDC uint256 tradeDealId = 1 ; uint256 fundingAmount = 10000 * 10 ** 6 ; // 10,000 USDC // First approve USDC transfer IERC20 ( usdcToken ). approve ( diamond , fundingAmount ); // Deposit USDC and receive collateral tokens ITradeDeal ( diamond ). tdDepositUSDC ( tradeDealId , fundingAmount ); console . log ( \"Deposited USDC and received collateral tokens\" );","title":"tdDepositUSDC() / tdWithdrawUSDC()"},{"location":"smart-contracts/interfaces/itradedeal/#withdrawtradedealfundingforborrower","text":"function withdrawTradeDealFundingForBorrower ( uint256 tradeDealId , address borrowerAddress ) external Purpose : Allows admin to withdraw funding on behalf of a borrower. Parameters : - tradeDealId (uint256): ID of the trade deal - borrowerAddress (address): Address of the borrower receiving funds Events : TradeDealFundingWithdrawn(tradeDealId, recipient, amount) Example Usage : // Admin withdraws funding for borrower uint256 tradeDealId = 1 ; address borrower = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; ITradeDeal ( diamond ). withdrawTradeDealFundingForBorrower ( tradeDealId , borrower ); console . log ( \"Funding withdrawn for borrower\" );","title":"withdrawTradeDealFundingForBorrower()"},{"location":"smart-contracts/interfaces/itradedeal/#interest-and-fee-management-functions","text":"","title":"Interest and Fee Management Functions"},{"location":"smart-contracts/interfaces/itradedeal/#tddistributeinterest","text":"function tdDistributeInterest ( uint256 tradeDealId ) external Purpose : Distributes accumulated interest for a trade deal across pools and participants. Parameters : - tradeDealId (uint256): ID of the trade deal Events : InterestDistributedForTradeDeal(tradeDealId, totalInterest, invoicePoolInterest, interestInterest, interestTokensMinted) Example Usage : // Distribute interest for trade deal uint256 tradeDealId = 1 ; ITradeDeal ( diamond ). tdDistributeInterest ( tradeDealId ); console . log ( \"Interest distributed for trade deal\" );","title":"tdDistributeInterest()"},{"location":"smart-contracts/interfaces/itradedeal/#repayment-functions","text":"","title":"Repayment Functions"},{"location":"smart-contracts/interfaces/itradedeal/#repaytradedeal-repaytradedealforborrower","text":"function repayTradeDeal ( uint256 tradeDealId , uint256 amount ) external function repayTradeDealForBorrower ( uint256 tradeDealId , address borrower , uint256 amount ) external Purpose : Processes repayments for trade deals, either by borrower or admin. Parameters : - tradeDealId (uint256): ID of the trade deal - amount (uint256): Amount to repay - borrower (address): Borrower address (for admin repayment) Events : TradeDealRepaid(tradeDealId, repayer, amount, fullyRepaid) Example Usage : // Borrower makes repayment uint256 tradeDealId = 1 ; uint256 repaymentAmount = 5000 * 10 ** 6 ; // 5,000 USDC // First approve USDC transfer IERC20 ( usdcToken ). approve ( diamond , repaymentAmount ); // Make repayment ITradeDeal ( diamond ). repayTradeDeal ( tradeDealId , repaymentAmount ); console . log ( \"Repayment made\" );","title":"repayTradeDeal() / repayTradeDealForBorrower()"},{"location":"smart-contracts/interfaces/itradedeal/#redeemcollateraltokens","text":"function redeemCollateralTokens ( uint256 tradeDealId , uint256 collateralAmount ) external Purpose : Redeems collateral tokens for USDC based on current redemption rate. Parameters : - tradeDealId (uint256): ID of the trade deal - collateralAmount (uint256): Amount of collateral tokens to redeem Events : CollateralTokensRedeemed(tradeDealId, redeemer, collateralAmount, usdcAmount) Example Usage : // Redeem collateral tokens for USDC uint256 tradeDealId = 1 ; uint256 collateralToRedeem = 1000 * 10 ** 18 ; // 1,000 collateral tokens ITradeDeal ( diamond ). redeemCollateralTokens ( tradeDealId , collateralToRedeem ); console . log ( \"Collateral tokens redeemed for USDC\" );","title":"redeemCollateralTokens()"},{"location":"smart-contracts/interfaces/itradedeal/#participant-management-functions","text":"","title":"Participant Management Functions"},{"location":"smart-contracts/interfaces/itradedeal/#settradedealrequiredclaimtopics-gettradedealrequiredclaimtopics","text":"function setTradeDealRequiredClaimTopics ( uint256 tradeDealId , uint256 [] memory claimTopics ) external function getTradeDealRequiredClaimTopics ( uint256 tradeDealId ) external view returns ( uint256 [] memory ) Purpose : Sets or retrieves required identity claim topics for trade deal participation. Parameters : - tradeDealId (uint256): ID of the trade deal - claimTopics (uint256[]): Array of claim topic IDs Events : TradeDealRequiredClaimTopicsSet(tradeDealId, claimTopics) Example Usage : // Set required claim topics uint256 tradeDealId = 1 ; uint256 [] memory requiredClaims = new uint256 []( 3 ); requiredClaims [ 0 ] = 1 ; // KYC verification requiredClaims [ 1 ] = 2 ; // Accredited investor requiredClaims [ 2 ] = 3 ; // Geographic eligibility ITradeDeal ( diamond ). setTradeDealRequiredClaimTopics ( tradeDealId , requiredClaims ); // Get current requirements uint256 [] memory currentClaims = ITradeDeal ( diamond ). getTradeDealRequiredClaimTopics ( tradeDealId );","title":"setTradeDealRequiredClaimTopics() / getTradeDealRequiredClaimTopics()"},{"location":"smart-contracts/interfaces/itradedeal/#istradedealparticipant","text":"function isTradeDealParticipant ( uint256 tradeDealId , address user ) external view returns ( bool ) Purpose : Checks if an address is a verified participant in a trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal - user (address): Address to check Returns : - bool : True if user is a verified participant Example Usage : // Check if user is a participant uint256 tradeDealId = 1 ; address user = 0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e5e1 ; bool isParticipant = ITradeDeal ( diamond ). isTradeDealParticipant ( tradeDealId , user ); if ( isParticipant ) { console . log ( \"User is verified participant\" ); } else { console . log ( \"User is not a participant\" ); }","title":"isTradeDealParticipant()"},{"location":"smart-contracts/interfaces/itradedeal/#query-functions","text":"","title":"Query Functions"},{"location":"smart-contracts/interfaces/itradedeal/#gettradedealinfo","text":"function getTradeDealInfo ( uint256 tradeDealId ) external view returns ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , TradeDealLib . OperationMode operationMode ) Purpose : Retrieves basic information about a trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal Returns : Trade deal configuration details Example Usage : // Get trade deal information uint256 tradeDealId = 1 ; ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralRatio , bool active , TradeDealLib . OperationMode mode ) = ITradeDeal ( diamond ). getTradeDealInfo ( tradeDealId ); console . log ( \"Trade Deal:\" , name ); console . log ( \"Interest Rate:\" , interestRate , \"basis points\" ); console . log ( \"Active:\" , active );","title":"getTradeDealInfo()"},{"location":"smart-contracts/interfaces/itradedeal/#gettradedealfullstatus","text":"function getTradeDealFullStatus ( uint256 tradeDealId ) external view returns ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) Purpose : Retrieves comprehensive status information for a trade deal. Parameters : - tradeDealId (uint256): ID of the trade deal Returns : Complete financial and operational status Example Usage : // Get complete trade deal status uint256 tradeDealId = 1 ; ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = ITradeDeal ( diamond ). getTradeDealFullStatus ( tradeDealId ); console . log ( \"Funding Target:\" , fundingTarget ); console . log ( \"Current Balance:\" , currentBalance ); console . log ( \"Is Funded:\" , isFunded ); console . log ( \"Total Debt:\" , totalDebt ); console . log ( \"Repaid Amount:\" , repaidAmount ); console . log ( \"Is Fully Repaid:\" , isRepaid );","title":"getTradeDealFullStatus()"},{"location":"smart-contracts/interfaces/itradedeal/#getalltradedealids","text":"function getAllTradeDealIds () external view returns ( uint256 [] memory ) Purpose : Returns all trade deal IDs in the system. Returns : Array of trade deal IDs Example Usage : // Get all trade deal IDs uint256 [] memory allDeals = ITradeDeal ( diamond ). getAllTradeDealIds (); console . log ( \"Total trade deals:\" , allDeals . length ); for ( uint256 i = 0 ; i < allDeals . length ; i ++ ) { console . log ( \"Trade Deal ID:\" , allDeals [ i ]); }","title":"getAllTradeDealIds()"},{"location":"smart-contracts/interfaces/itradedeal/#status-check-functions","text":"","title":"Status Check Functions"},{"location":"smart-contracts/interfaces/itradedeal/#istradedealfunded-istradedealrepaid","text":"function isTradeDealFunded ( uint256 tradeDealId ) external view returns ( bool ) function isTradeDealRepaid ( uint256 tradeDealId ) external view returns ( bool ) Purpose : Quick status checks for funding and repayment status. Parameters : - tradeDealId (uint256): ID of the trade deal Returns : Boolean status Example Usage : // Check trade deal status uint256 tradeDealId = 1 ; bool isFunded = ITradeDeal ( diamond ). isTradeDealFunded ( tradeDealId ); bool isRepaid = ITradeDeal ( diamond ). isTradeDealRepaid ( tradeDealId ); console . log ( \"Trade Deal Funded:\" , isFunded ); console . log ( \"Trade Deal Repaid:\" , isRepaid );","title":"isTradeDealFunded() / isTradeDealRepaid()"},{"location":"smart-contracts/interfaces/itradedeal/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/itradedeal/#complete-trade-deal-workflow","text":"// Comprehensive trade deal integration example contract TradeDealWorkflow { ITradeDeal public tradeDeal ; struct WorkflowState { uint256 tradeDealId ; uint256 phase ; // 0: Created, 1: Funded, 2: Active, 3: Repaid uint256 totalFunding ; uint256 totalRepaid ; address [] participants ; } mapping ( uint256 => WorkflowState ) public workflows ; event WorkflowPhaseChanged ( uint256 indexed tradeDealId , uint256 newPhase ); constructor ( address _tradeDeal ) { tradeDeal = ITradeDeal ( _tradeDeal ); } function createAndFundTradeDeal ( string memory name , string memory symbol , uint256 interestRate , uint256 fundingAmount , uint256 [] memory invoiceTokenIds ) external returns ( uint256 tradeDealId ) { // Create trade deal uint256 [] memory claimTopics = new uint256 []( 1 ); claimTopics [ 0 ] = 1 ; // KYC required tradeDealId = tradeDeal . createTradeDeal ( name , symbol , interestRate , 1000000 , // 1:1 collateral ratio claimTopics , collateralTokenAddress , interestTokenAddress , usdcTokenAddress , TradeDealLib . OperationMode . STANDARD ); // Initialize workflow workflows [ tradeDealId ] = WorkflowState ({ tradeDealId : tradeDealId , phase : 0 , totalFunding : 0 , totalRepaid : 0 , participants : new address []( 0 ) }); // Activate trade deal tradeDeal . activateTradeDeal ( tradeDealId ); // Deposit invoices as collateral for ( uint256 i = 0 ; i < invoiceTokenIds . length ; i ++ ) { tradeDeal . tdDepositInvoice ( tradeDealId , invoiceTokenIds [ i ]); } // Fund the trade deal tradeDeal . tdDepositUSDC ( tradeDealId , fundingAmount ); workflows [ tradeDealId ]. totalFunding = fundingAmount ; workflows [ tradeDealId ]. phase = 1 ; emit WorkflowPhaseChanged ( tradeDealId , 1 ); } function processRepayment ( uint256 tradeDealId , uint256 amount ) external { WorkflowState storage workflow = workflows [ tradeDealId ]; require ( workflow . phase >= 1 , \"Trade deal not funded\" ); // Process repayment tradeDeal . repayTradeDeal ( tradeDealId , amount ); workflow . totalRepaid += amount ; // Check if fully repaid bool isRepaid = tradeDeal . isTradeDealRepaid ( tradeDealId ); if ( isRepaid && workflow . phase < 3 ) { workflow . phase = 3 ; emit WorkflowPhaseChanged ( tradeDealId , 3 ); } } function distributeInterestAndFees ( uint256 tradeDealId ) external { WorkflowState storage workflow = workflows [ tradeDealId ]; require ( workflow . phase >= 1 , \"Trade deal not funded\" ); // Distribute interest tradeDeal . tdDistributeInterest ( tradeDealId ); // Update phase if needed if ( workflow . phase == 1 ) { workflow . phase = 2 ; // Active phase emit WorkflowPhaseChanged ( tradeDealId , 2 ); } } function getWorkflowStatus ( uint256 tradeDealId ) external view returns ( uint256 phase , uint256 fundingProgress , uint256 repaymentProgress , bool canRedeem ) { WorkflowState memory workflow = workflows [ tradeDealId ]; ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( tradeDealId ); phase = workflow . phase ; fundingProgress = fundingTarget > 0 ? ( currentBalance * 100 ) / fundingTarget : 0 ; repaymentProgress = totalDebt > 0 ? ( repaidAmount * 100 ) / totalDebt : 0 ; canRedeem = isRepaid && workflow . totalFunding > 0 ; } }","title":"Complete Trade Deal Workflow"},{"location":"smart-contracts/interfaces/itradedeal/#trade-deal-analytics-dashboard","text":"// Analytics and reporting for trade deals contract TradeDealAnalytics { ITradeDeal public tradeDeal ; struct AnalyticsData { uint256 totalDeals ; uint256 activeDeals ; uint256 fundedDeals ; uint256 repaidDeals ; uint256 totalVolume ; uint256 totalInterestPaid ; uint256 averageInterestRate ; } mapping ( uint256 => uint256 ) public dealCreationTime ; mapping ( uint256 => uint256 ) public dealFundingTime ; mapping ( uint256 => uint256 ) public dealRepaymentTime ; event AnalyticsUpdated ( AnalyticsData data ); function updateAnalytics () external returns ( AnalyticsData memory data ) { uint256 [] memory allDeals = tradeDeal . getAllTradeDealIds (); data . totalDeals = allDeals . length ; uint256 totalInterestRate = 0 ; for ( uint256 i = 0 ; i < allDeals . length ; i ++ ) { uint256 dealId = allDeals [ i ]; ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralRatio , bool active , TradeDealLib . OperationMode mode ) = tradeDeal . getTradeDealInfo ( dealId ); if ( active ) { data . activeDeals ++ ; } totalInterestRate += interestRate ; ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( dealId ); if ( isFunded ) { data . fundedDeals ++ ; data . totalVolume += fundingTarget ; } if ( isRepaid ) { data . repaidDeals ++ ; data . totalInterestPaid += ( repaidAmount > fundingTarget ? repaidAmount - fundingTarget : 0 ); } } if ( data . totalDeals > 0 ) { data . averageInterestRate = totalInterestRate / data . totalDeals ; } emit AnalyticsUpdated ( data ); } function getDealPerformanceMetrics ( uint256 tradeDealId ) external view returns ( uint256 timeToFunding , uint256 timeToRepayment , uint256 actualInterestRate , uint256 performanceScore ) { uint256 creationTime = dealCreationTime [ tradeDealId ]; uint256 fundingTime = dealFundingTime [ tradeDealId ]; uint256 repaymentTime = dealRepaymentTime [ tradeDealId ]; if ( fundingTime > creationTime ) { timeToFunding = fundingTime - creationTime ; } if ( repaymentTime > fundingTime && fundingTime > 0 ) { timeToRepayment = repaymentTime - fundingTime ; } ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( tradeDealId ); if ( isRepaid && fundingTarget > 0 ) { actualInterestRate = (( repaidAmount - fundingTarget ) * 10000 ) / fundingTarget ; // Calculate performance score (0-100) performanceScore = 100 ; if ( timeToFunding > 7 days ) performanceScore -= 20 ; if ( timeToRepayment > 90 days ) performanceScore -= 30 ; if ( ! isRepaid ) performanceScore -= 50 ; } } }","title":"Trade Deal Analytics Dashboard"},{"location":"smart-contracts/interfaces/itradedeal/#automated-trade-deal-manager","text":"// Automated management for trade deal operations contract AutomatedTradeDealManager { ITradeDeal public tradeDeal ; struct AutomationConfig { bool autoDistributeInterest ; uint256 interestDistributionFrequency ; uint256 lastInterestDistribution ; bool autoProcessRepayments ; uint256 gracePeriod ; bool autoRedemption ; } mapping ( uint256 => AutomationConfig ) public automationConfigs ; mapping ( uint256 => uint256 ) public nextScheduledAction ; event AutomationConfigured ( uint256 indexed tradeDealId , AutomationConfig config ); event AutomatedActionExecuted ( uint256 indexed tradeDealId , string action ); function configureAutomation ( uint256 tradeDealId , AutomationConfig memory config ) external onlyAuthorized { automationConfigs [ tradeDealId ] = config ; if ( config . autoDistributeInterest ) { nextScheduledAction [ tradeDealId ] = block.timestamp + config . interestDistributionFrequency ; } emit AutomationConfigured ( tradeDealId , config ); } function executeScheduledActions ( uint256 [] memory tradeDealIds ) external { for ( uint256 i = 0 ; i < tradeDealIds . length ; i ++ ) { uint256 tradeDealId = tradeDealIds [ i ]; AutomationConfig memory config = automationConfigs [ tradeDealId ]; // Auto-distribute interest if ( config . autoDistributeInterest && block.timestamp >= nextScheduledAction [ tradeDealId ]) { tradeDeal . tdDistributeInterest ( tradeDealId ); nextScheduledAction [ tradeDealId ] = block.timestamp + config . interestDistributionFrequency ; emit AutomatedActionExecuted ( tradeDealId , \"interest_distribution\" ); } // Auto-process repayments (would need additional logic) if ( config . autoProcessRepayments ) { _processAutomaticRepayments ( tradeDealId , config ); } // Auto-redemption for completed deals if ( config . autoRedemption ) { _processAutomaticRedemption ( tradeDealId ); } } } function _processAutomaticRepayments ( uint256 tradeDealId , AutomationConfig memory config ) internal { // Implementation would check for due repayments and process them // This would integrate with external payment systems or scheduled transfers ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( tradeDealId ); if ( isFunded && ! isRepaid ) { // Check if repayment is due and process if available // This would require integration with external systems totalRepaid : 0 , participants : new address []( 0 ) }); // Activate trade deal tradeDeal . activateTradeDeal ( tradeDealId ); // Deposit invoices as collateral for ( uint256 i = 0 ; i < invoiceTokenIds . length ; i ++ ) { tradeDeal . tdDepositInvoice ( tradeDealId , invoiceTokenIds [ i ]); } // Fund the trade deal tradeDeal . tdDepositUSDC ( tradeDealId , fundingAmount ); workflows [ tradeDealId ]. totalFunding = fundingAmount ; workflows [ tradeDealId ]. phase = 1 ; emit WorkflowPhaseChanged ( tradeDealId , 1 ); } function processRepayment ( uint256 tradeDealId , uint256 amount ) external { WorkflowState storage workflow = workflows [ tradeDealId ]; require ( workflow . phase >= 1 , \"Trade deal not funded\" ); // Process repayment tradeDeal . repayTradeDeal ( tradeDealId , amount ); workflow . totalRepaid += amount ; // Check if fully repaid bool isRepaid = tradeDeal . isTradeDealRepaid ( tradeDealId ); if ( isRepaid && workflow . phase < 3 ) { workflow . phase = 3 ; emit WorkflowPhaseChanged ( tradeDealId , 3 ); } } function distributeInterestAndFees ( uint256 tradeDealId ) external { WorkflowState storage workflow = workflows [ tradeDealId ]; require ( workflow . phase >= 1 , \"Trade deal not funded\" ); // Distribute interest tradeDeal . tdDistributeInterest ( tradeDealId ); // Update phase if needed if ( workflow . phase == 1 ) { workflow . phase = 2 ; // Active phase emit WorkflowPhaseChanged ( tradeDealId , 2 ); } } function getWorkflowStatus ( uint256 tradeDealId ) external view returns ( uint256 phase , uint256 fundingProgress , uint256 repaymentProgress , bool canRedeem ) { WorkflowState memory workflow = workflows [ tradeDealId ]; ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( tradeDealId ); phase = workflow . phase ; fundingProgress = fundingTarget > 0 ? ( currentBalance * 100 ) / fundingTarget : 0 ; repaymentProgress = totalDebt > 0 ? ( repaidAmount * 100 ) / totalDebt : 0 ; canRedeem = isRepaid && workflow . totalFunding > 0 ; } }","title":"Automated Trade Deal Manager"},{"location":"smart-contracts/interfaces/itradedeal/#trade-deal-analytics-dashboard_1","text":"// Analytics and reporting for trade deals contract TradeDealAnalytics { ITradeDeal public tradeDeal ; struct AnalyticsData { uint256 totalDeals ; uint256 activeDeals ; uint256 fundedDeals ; uint256 repaidDeals ; uint256 totalVolume ; uint256 totalInterestPaid ; uint256 averageInterestRate ; } mapping ( uint256 => uint256 ) public dealCreationTime ; mapping ( uint256 => uint256 ) public dealFundingTime ; mapping ( uint256 => uint256 ) public dealRepaymentTime ; event AnalyticsUpdated ( AnalyticsData data ); function updateAnalytics () external returns ( AnalyticsData memory data ) { uint256 [] memory allDeals = tradeDeal . getAllTradeDealIds (); data . totalDeals = allDeals . length ; uint256 totalInterestRate = 0 ; for ( uint256 i = 0 ; i < allDeals . length ; i ++ ) { uint256 dealId = allDeals [ i ]; ( string memory name , string memory symbol , uint256 interestRate , uint256 collateralRatio , bool active , TradeDealLib . OperationMode mode ) = tradeDeal . getTradeDealInfo ( dealId ); if ( active ) { data . activeDeals ++ ; } totalInterestRate += interestRate ; ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( dealId ); if ( isFunded ) { data . fundedDeals ++ ; data . totalVolume += fundingTarget ; } if ( isRepaid ) { data . repaidDeals ++ ; data . totalInterestPaid += ( repaidAmount > fundingTarget ? repaidAmount - fundingTarget : 0 ); } } if ( data . totalDeals > 0 ) { data . averageInterestRate = totalInterestRate / data . totalDeals ; } emit AnalyticsUpdated ( data ); } function getDealPerformanceMetrics ( uint256 tradeDealId ) external view returns ( uint256 timeToFunding , uint256 timeToRepayment , uint256 actualInterestRate , uint256 performanceScore ) { uint256 creationTime = dealCreationTime [ tradeDealId ]; uint256 fundingTime = dealFundingTime [ tradeDealId ]; uint256 repaymentTime = dealRepaymentTime [ tradeDealId ]; if ( fundingTime > creationTime ) { timeToFunding = fundingTime - creationTime ; } if ( repaymentTime > fundingTime && fundingTime > 0 ) { timeToRepayment = repaymentTime - fundingTime ; } ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( tradeDealId ); if ( isRepaid && fundingTarget > 0 ) { actualInterestRate = (( repaidAmount - fundingTarget ) * 10000 ) / fundingTarget ; // Calculate performance score (0-100) performanceScore = 100 ; if ( timeToFunding > 7 days ) performanceScore -= 20 ; if ( timeToRepayment > 90 days ) performanceScore -= 30 ; if ( ! isRepaid ) performanceScore -= 50 ; } } }","title":"Trade Deal Analytics Dashboard"},{"location":"smart-contracts/interfaces/itradedeal/#automated-trade-deal-manager_1","text":"// Automated management for trade deal operations contract AutomatedTradeDealManager { ITradeDeal public tradeDeal ; struct AutomationConfig { bool autoDistributeInterest ; uint256 interestDistributionFrequency ; uint256 lastInterestDistribution ; bool autoProcessRepayments ; uint256 gracePeriod ; bool autoRedemption ; } mapping ( uint256 => AutomationConfig ) public automationConfigs ; mapping ( uint256 => uint256 ) public nextScheduledAction ; event AutomationConfigured ( uint256 indexed tradeDealId , AutomationConfig config ); event AutomatedActionExecuted ( uint256 indexed tradeDealId , string action ); function configureAutomation ( uint256 tradeDealId , AutomationConfig memory config ) external onlyAuthorized { automationConfigs [ tradeDealId ] = config ; if ( config . autoDistributeInterest ) { nextScheduledAction [ tradeDealId ] = block.timestamp + config . interestDistributionFrequency ; } emit AutomationConfigured ( tradeDealId , config ); } function executeScheduledActions ( uint256 [] memory tradeDealIds ) external { for ( uint256 i = 0 ; i < tradeDealIds . length ; i ++ ) { uint256 tradeDealId = tradeDealIds [ i ]; AutomationConfig memory config = automationConfigs [ tradeDealId ]; // Auto-distribute interest if ( config . autoDistributeInterest && block.timestamp >= nextScheduledAction [ tradeDealId ]) { tradeDeal . tdDistributeInterest ( tradeDealId ); nextScheduledAction [ tradeDealId ] = block.timestamp + config . interestDistributionFrequency ; emit AutomatedActionExecuted ( tradeDealId , \"interest_distribution\" ); } // Auto-process repayments (would need additional logic) if ( config . autoProcessRepayments ) { _processAutomaticRepayments ( tradeDealId , config ); } // Auto-redemption for completed deals if ( config . autoRedemption ) { _processAutomaticRedemption ( tradeDealId ); } } } function _processAutomaticRepayments ( uint256 tradeDealId , AutomationConfig memory config ) internal { // Implementation would check for due repayments and process them // This would integrate with external payment systems or scheduled transfers ( uint256 fundingTarget , uint256 currentBalance , bool isFunded , bool isFundingWithdrawn , uint256 totalDebt , uint256 repaidAmount , bool isRepaid ) = tradeDeal . getTradeDealFullStatus ( tradeDealId ); if ( isFunded && ! isRepaid ) { // Check if repayment is due and process if available // This would require integration with external systems emit AutomatedActionExecuted ( tradeDealId , \"repayment_check\" ); } } function _processAutomaticRedemption ( uint256 tradeDealId ) internal { bool isRepaid = tradeDeal . isTradeDealRepaid ( tradeDealId ); if ( isRepaid ) { // Process automatic redemption for eligible participants // This would require additional participant tracking emit AutomatedActionExecuted ( tradeDealId , \"auto_redemption\" ); } } }","title":"Automated Trade Deal Manager"},{"location":"smart-contracts/interfaces/itradedeal/#events","text":"","title":"Events"},{"location":"smart-contracts/interfaces/itradedeal/#trade-deal-lifecycle-events","text":"event TradeDealCreated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address nftAddress , address collateralAddress , address interestAddress , address usdcAddress , TradeDealLib . OperationMode operationMode ); event TradeDealUpdated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address collateralAddress , address interestAddress , address usdcAddress ); event TradeDealActivated ( uint256 indexed tradeDealId ); event TradeDealDeactivated ( uint256 indexed tradeDealId );","title":"Trade Deal Lifecycle Events"},{"location":"smart-contracts/interfaces/itradedeal/#participant-management-events","text":"event TradeDealParticipantAdded ( uint256 indexed tradeDealId , address indexed participant ); event TradeDealParticipantRemoved ( uint256 indexed tradeDealId , address indexed participant ); event TradeDealRequiredClaimTopicsSet ( uint256 indexed tradeDealId , uint256 [] claimTopics );","title":"Participant Management Events"},{"location":"smart-contracts/interfaces/itradedeal/#collateral-and-funding-events","text":"event InvoiceDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event InvoiceWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event USDCDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 amount , address depositor ); event USDCWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 amount ); event TradeDealFullyFunded ( uint256 indexed tradeDealId , uint256 fundingTarget ); event CollateralTokensDistributed ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount );","title":"Collateral and Funding Events"},{"location":"smart-contracts/interfaces/itradedeal/#interest-and-fee-events","text":"event InterestDistributedForTradeDeal ( uint256 indexed tradeDealId , uint256 totalInterest , uint256 invoicePoolInterest , uint256 interestInterest , uint256 interestTokensMinted ); event TradeDealFeesDistributed ( uint256 indexed tradeDealId , address [] feeReceivers , uint256 [] feeAmounts );","title":"Interest and Fee Events"},{"location":"smart-contracts/interfaces/itradedeal/#repayment-and-settlement-events","text":"event TradeDealFundingWithdrawn ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount ); event TradeDealRepaid ( uint256 indexed tradeDealId , address indexed repayer , uint256 amount , bool fullyRepaid ); event CollateralTokensRedeemed ( uint256 indexed tradeDealId , address indexed redeemer , uint256 collateralAmount , uint256 usdcAmount );","title":"Repayment and Settlement Events"},{"location":"smart-contracts/interfaces/itradedeal/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/itradedeal/#access-control","text":"Owner-only functions for trade deal creation and configuration Participant validation for operations and access Identity verification through claim topics Role-based permissions for administrative functions","title":"Access Control"},{"location":"smart-contracts/interfaces/itradedeal/#financial-security","text":"Precise amount calculations and validations Overflow protection for large transactions Secure token transfer mechanisms Interest calculation accuracy and validation","title":"Financial Security"},{"location":"smart-contracts/interfaces/itradedeal/#operational-security","text":"Trade deal state validation before operations Invoice ownership verification Funding availability checks Repayment authorization validation","title":"Operational Security"},{"location":"smart-contracts/interfaces/itradedeal/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/interfaces/itradedeal/#efficient-operations","text":"Batch operations for multiple trade deals Optimized storage layout for trade deal data Minimal external calls in view functions Efficient event emission patterns","title":"Efficient Operations"},{"location":"smart-contracts/interfaces/itradedeal/#storage-optimization","text":"Packed storage structures where possible Efficient mapping usage for participant tracking Optimized array operations for bulk queries Cached calculations for frequently accessed data","title":"Storage Optimization"},{"location":"smart-contracts/interfaces/itradedeal/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/interfaces/itradedeal/#common-errors","text":"Trade deal not found or inactive Insufficient permissions or authorization Invalid amounts or parameters Funding or repayment validation failures Participant verification failures","title":"Common Errors"},{"location":"smart-contracts/interfaces/itradedeal/#best-practices","text":"Validate all inputs before processing Check trade deal state before operations Verify participant eligibility for operations Handle token transfer failures gracefully Provide clear error messages for debugging","title":"Best Practices"},{"location":"smart-contracts/interfaces/itradedeal/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/interfaces/itradedeal/#unit-tests","text":"Interface compliance verification Function parameter validation Return value accuracy testing Event emission verification Error condition handling","title":"Unit Tests"},{"location":"smart-contracts/interfaces/itradedeal/#integration-tests","text":"Complete trade deal lifecycle workflows Multi-participant scenarios Interest distribution and fee calculations Repayment and redemption processes Cross-facet integration testing","title":"Integration Tests"},{"location":"smart-contracts/interfaces/itradedeal/#related-documentation","text":"TradeDealManagementFacet - Core trade deal operations TradeDealAdminFacet - Administrative functions TradeDealOperationsFacet - Operational functions TradeDealLib - Trade deal utilities CollateralTokenFactoryFacet - Token factory integration Trade Deal Guide - Implementation guide This interface defines the comprehensive contract for trade deal functionality within the Gemforce platform, providing standardized operations for collateralized finance instruments with invoice backing and automated settlement.","title":"Related Documentation"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/","text":"ITrustedIssuersRegistry Interface \u00b6 The ITrustedIssuersRegistry interface defines the standard for a registry of trusted claim issuers within the Gemforce ecosystem. This registry allows smart contracts and off-chain systems to verify the authenticity and trustworthiness of entities that issue claims, attestations, or credentials. It is a critical component for identity and verification systems built on the platform. Overview \u00b6 ITrustedIssuersRegistry provides: Issuer Registration : A mechanism to register and manage trusted issuer addresses. Trust Verification : Functions to check if a given address is a trusted issuer. Status Management : Ability to activate or deactivate issuers. Metadata Association : Link additional metadata or details to each registered issuer. Event Logging : Comprehensive event tracking for all registry operations. Key Features \u00b6 Issuer Management \u00b6 Add Issuer : Register new trusted issuers with their associated metadata. Update Issuer Status : Activate, deactivate, or suspend issuer privileges. Remove Issuer : Deregister an issuer from the list. Trust Verification \u00b6 isTrustedIssuer() : Public function to check the trust status of an address. Role-Based Trust : Potentially support different levels or categories of trust. Metadata and Information \u00b6 Issuer Details : Store information like name, URL, and other relevant data about the issuer. Attestation Tracking : Keep a record of who registered or last updated an issuer. Interface Definition \u00b6 interface ITrustedIssuersRegistry { // Events event IssuerRegistered ( address indexed issuerAddress , string indexed issuerName , address indexed registrator , string metadataURI ); event IssuerStatusChanged ( address indexed issuerAddress , bool newStatus , address indexed changer ); event IssuerMetadataUpdated ( address indexed issuerAddress , string oldMetadataURI , string newMetadataURI , address indexed updater ); event IssuerRemoved ( address indexed issuerAddress , address indexed remover ); // Structs struct IssuerEntry { address issuerAddress ; string name ; string metadataURI ; bool active ; uint256 registeredAt ; uint256 lastUpdated ; address registrator ; } // Core Functions function registerIssuer ( address _issuerAddress , string calldata _name , string calldata _metadataURI ) external ; function updateIssuerStatus ( address _issuerAddress , bool _newStatus ) external ; function updateIssuerMetadata ( address _issuerAddress , string calldata _newMetadataURI ) external ; function removeIssuer ( address _issuerAddress ) external ; // View Functions function isTrustedIssuer ( address _address ) external view returns ( bool ); function getIssuerEntry ( address _issuerAddress ) external view returns ( IssuerEntry memory ); function getTrustedIssuerCount () external view returns ( uint256 ); function getTrustedIssuerAddress ( uint256 index ) external view returns ( address ); } Core Functions \u00b6 registerIssuer() \u00b6 Registers a new address as a trusted issuer in the registry. Parameters: - _issuerAddress : The address of the entity to be registered as a trusted issuer. - _name : A descriptive name for the issuer. - _metadataURI : A URI pointing to additional off-chain metadata about the issuer. Access Control: - Typically restricted to the contract owner or an authorized administrator. Usage: // Register a new trusted issuer trustedIssuersRegistry . registerIssuer ( 0xAbc123 ..., // Address of the issuer \"Example Verification Service\" , \"ipfs://example.com/issuer_meta.json\" ); isTrustedIssuer() \u00b6 Checks if a given address is currently registered as an active, trusted issuer. Parameters: - _address : The address to check. Returns: - bool : true if the address is a trusted and active issuer, false otherwise. updateIssuerStatus() \u00b6 Changes the active status of a registered issuer to true (active) or false (inactive/suspended). Parameters: - _issuerAddress : The address of the issuer whose status is to be updated. - _newStatus : The new status ( true for active, false for inactive). Implementation Example \u00b6 import \"@openzeppelin/contracts/access/Ownable.sol\" ; contract TrustedIssuersRegistry is ITrustedIssuersRegistry , Ownable { // Mapping from issuer address to its IssuerEntry details mapping ( address => IssuerEntry ) private _issuerEntries ; // Array to maintain order and iterate over active issuers address [] private _activeIssuers ; // Count of active issuers uint256 private _activeIssuerCount ; constructor () { // Owner set to deployer by default due to Ownable } function registerIssuer ( address _issuerAddress , string calldata _name , string calldata _metadataURI ) external override onlyOwner { require ( _issuerAddress != address ( 0 ), \"Issuer address cannot be zero\" ); require ( _issuerEntries [ _issuerAddress ]. issuerAddress == address ( 0 ), \"Issuer already registered\" ); _issuerEntries [ _issuerAddress ] = IssuerEntry ({ issuerAddress : _issuerAddress , name : _name , metadataURI : _metadataURI , active : true , registeredAt : block.timestamp , lastUpdated : block.timestamp , registrator : msg.sender }); _activeIssuers . push ( _issuerAddress ); _activeIssuerCount ++ ; emit IssuerRegistered ( _issuerAddress , _name , msg.sender , _metadataURI ); } function updateIssuerStatus ( address _issuerAddress , bool _newStatus ) external override onlyOwner { IssuerEntry storage entry = _issuerEntries [ _issuerAddress ]; require ( entry . issuerAddress != address ( 0 ), \"Issuer not found\" ); require ( entry . active != _newStatus , \"Status is already the same\" ); entry . active = _newStatus ; entry . lastUpdated = block.timestamp ; if ( _newStatus ) { // Add to active_issuers if not already there bool found = false ; for ( uint i = 0 ; i < _activeIssuers . length ; i ++ ) { if ( _activeIssuers [ i ] == _issuerAddress ) { found = true ; break ; } } if ( ! found ) { _activeIssuers . push ( _issuerAddress ); _activeIssuerCount ++ ; } } else { // Remove from active_issuers for ( uint256 i = 0 ; i < _activeIssuers . length ; i ++ ) { if ( _activeIssuers [ i ] == _issuerAddress ) { _activeIssuers [ i ] = _activeIssuers [ _activeIssuers . length - 1 ]; // Swap with last _activeIssuers . pop (); // Pop last element _activeIssuerCount -- ; break ; } } } emit IssuerStatusChanged ( _issuerAddress , _newStatus , msg.sender ); } function updateIssuerMetadata ( address _issuerAddress , string calldata _newMetadataURI ) external override onlyOwner { IssuerEntry storage entry = _issuerEntries [ _issuerAddress ]; require ( entry . issuerAddress != address ( 0 ), \"Issuer not found\" ); string memory oldMetadataURI = entry . metadataURI ; entry . metadataURI = _newMetadataURI ; entry . lastUpdated = block.timestamp ; emit IssuerMetadataUpdated ( _issuerAddress , oldMetadataURI , _newMetadataURI , msg.sender ); } function removeIssuer ( address _issuerAddress ) external override onlyOwner { IssuerEntry storage entry = _issuerEntries [ _issuerAddress ]; require ( entry . issuerAddress != address ( 0 ), \"Issuer not found\" ); // First, set status to inactive and remove from active list if it was active if ( entry . active ) { updateIssuerStatus ( _issuerAddress , false ); // This also handles removing from _activeIssuers } delete _issuerEntries [ _issuerAddress ]; // Clear from mapping emit IssuerRemoved ( _issuerAddress , msg.sender ); } function isTrustedIssuer ( address _address ) external view override returns ( bool ) { return _issuerEntries [ _address ]. active ; } function getIssuerEntry ( address _issuerAddress ) external view override returns ( IssuerEntry memory ) { return _issuerEntries [ _issuerAddress ]; } function getTrustedIssuerCount () external view override returns ( uint256 ) { return _activeIssuerCount ; } function getTrustedIssuerAddress ( uint256 index ) external view override returns ( address ) { require ( index < _activeIssuers . length , \"Index out of bounds\" ); return _activeIssuers [ index ]; } } Security Considerations \u00b6 Access Control \u00b6 onlyOwner : All functions that modify the registry's state ( registerIssuer , updateIssuerStatus , updateIssuerMetadata , removeIssuer ) are restricted to the contract owner. This ensures that only authorized entities can manage the list of trusted issuers. Role-Based Access Control : For multi-admin environments, Ownable can be replaced with a more granular RBAC system (e.g., OpenZeppelin's AccessControl ). Data Integrity \u00b6 Zero Address Check : Prevent registration of address(0) . Duplicate Registration : Ensure an issuer address can only be registered once. Status Consistency : Logic in updateIssuerStatus and removeIssuer manages the _activeIssuers array to keep it consistent with the active flag in IssuerEntry . Gas Efficiency \u00b6 Array Management : Adding and removing from _activeIssuers array uses basic swap-and-pop, which is gas-efficient for array elements but doesn't maintain order. If order is critical or high performance is needed for very large lists, a more sophisticated data structure might be considered, though it adds complexity. Best Practices \u00b6 Metadata \u00b6 URI Standards : Use IPFS or other decentralized storage for metadataURI to ensure immutability and availability of issuer details. Off-chain Information : The on-chain registry should only store essential information (address, name, status, metadata URI); detailed information should reside off-chain. Events \u00b6 Comprehensive Events : Emit events for all state-changing operations to enable off-chain indexing, auditing, and real-time monitoring of issuer changes. Flexibility \u00b6 Extensibility : Design with future needs in mind. If different levels of trust or categories of issuers are required, extend the IssuerEntry struct and relevant functions. Integration Examples \u00b6 Frontend Integration (TypeScript via Ethers.js) \u00b6 import { ethers , Contract } from 'ethers' ; import TrustedIssuersRegistryABI from './TrustedIssuersRegistry.json' ; // ABI for ITrustedIssuersRegistry const REGISTRY_ADDRESS = \"0x...\" ; // Your deployed TrustedIssuersRegistry contract address const getProvider = () => new ethers . providers . Web3Provider ( window . ethereum ); const getSigner = () => getProvider (). getSigner (); const getTrustedIssuersRegistryContract = () => new Contract ( REGISTRY_ADDRESS , TrustedIssuersRegistryABI , getSigner ()); async function registerNewIssuer ( issuerAddress : string , name : string , metadataURI : string ) : Promise < void > { try { const registry = getTrustedIssuersRegistryContract (); const tx = await registry . registerIssuer ( issuerAddress , name , metadataURI ); await tx . wait (); alert ( \"Issuer registered successfully!\" ); } catch ( error ) { console . error ( \"Error registering issuer:\" , error ); alert ( \"Failed to register issuer.\" ); } } async function checkIssuerTrust ( address : string ) : Promise < boolean > { try { const registry = getTrustedIssuersRegistryContract (); const isTrusted = await registry . isTrustedIssuer ( address ); return isTrusted ; } catch ( error ) { console . error ( \"Error checking issuer trust:\" , error ); throw error ; } } async function updateIssuerStatus ( issuerAddress : string , newStatus : boolean ) : Promise < void > { try { const registry = getTrustedIssuersRegistryContract (); const tx = await registry . updateIssuerStatus ( issuerAddress , newStatus ); await tx . wait (); alert ( \"Issuer status updated successfully!\" ); } catch ( error ) { console . error ( \"Error updating issuer status:\" , error ); alert ( \"Failed to update issuer status.\" ); } } // Example usage // registerNewIssuer(\"0xSomeIssuerAddress\", \"Credential Service Inc.\", \"https://credentials.com/meta.json\"); // const trusted = await checkIssuerTrust(\"0xSomeIssuerAddress\"); // true or false // updateIssuerStatus(\"0xSomeIssuerAddress\", false); // Deactivate issuer Backend Integration (Node.js for a claim validation service) \u00b6 const Web3 = require ( 'web3' ); const TrustedIssuersRegistryABI = require ( './TrustedIssuersRegistry.json' ). abi ; const web3 = new Web3 ( 'YOUR_ETHEREUM_RPC_URL' ); const registryAddress = '0x...' ; // Address of your deployed TrustedIssuersRegistry contract const trustedIssuersRegistryContract = new web3 . eth . Contract ( TrustedIssuersRegistryABI , registryAddress ); async function validateClaimIssuer ( claimIssuerAddress ) { try { const isTrusted = await trustedIssuersRegistryContract . methods . isTrustedIssuer ( claimIssuerAddress ). call (); if ( isTrusted ) { console . log ( `Issuer ${ claimIssuerAddress } is trusted.` ); // Proceed with claim verification logic return true ; } else { console . log ( `Issuer ${ claimIssuerAddress } is NOT trusted.` ); // Reject claim or flag for manual review return false ; } } catch ( error ) { console . error ( \"Error validating claim issuer:\" , error ); throw error ; } } async function getIssuerDetails ( issuerAddress ) { try { const issuerEntry = await trustedIssuersRegistryContract . methods . getIssuerEntry ( issuerAddress ). call (); console . log ( \"Issuer Details:\" , issuerEntry ); return issuerEntry ; } catch ( error ) { console . error ( \"Error fetching issuer details:\" , error ); throw error ; } } // Example usage in a backend service // validateClaimIssuer(\"0xAnotherIssuerAddress\"); // getIssuerDetails(\"0xSomeIssuerAddress\"); Related Documentation \u00b6 IIdentity Interface ERC735 Claim Holder Interface Trusted Issuer Library Ownable Contract Standards Compliance \u00b6 Ownable : Utilizes OpenZeppelin's Ownable for administrative access control.","title":"TRUSTEDIssuersRegistry"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#itrustedissuersregistry-interface","text":"The ITrustedIssuersRegistry interface defines the standard for a registry of trusted claim issuers within the Gemforce ecosystem. This registry allows smart contracts and off-chain systems to verify the authenticity and trustworthiness of entities that issue claims, attestations, or credentials. It is a critical component for identity and verification systems built on the platform.","title":"ITrustedIssuersRegistry Interface"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#overview","text":"ITrustedIssuersRegistry provides: Issuer Registration : A mechanism to register and manage trusted issuer addresses. Trust Verification : Functions to check if a given address is a trusted issuer. Status Management : Ability to activate or deactivate issuers. Metadata Association : Link additional metadata or details to each registered issuer. Event Logging : Comprehensive event tracking for all registry operations.","title":"Overview"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#issuer-management","text":"Add Issuer : Register new trusted issuers with their associated metadata. Update Issuer Status : Activate, deactivate, or suspend issuer privileges. Remove Issuer : Deregister an issuer from the list.","title":"Issuer Management"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#trust-verification","text":"isTrustedIssuer() : Public function to check the trust status of an address. Role-Based Trust : Potentially support different levels or categories of trust.","title":"Trust Verification"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#metadata-and-information","text":"Issuer Details : Store information like name, URL, and other relevant data about the issuer. Attestation Tracking : Keep a record of who registered or last updated an issuer.","title":"Metadata and Information"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#interface-definition","text":"interface ITrustedIssuersRegistry { // Events event IssuerRegistered ( address indexed issuerAddress , string indexed issuerName , address indexed registrator , string metadataURI ); event IssuerStatusChanged ( address indexed issuerAddress , bool newStatus , address indexed changer ); event IssuerMetadataUpdated ( address indexed issuerAddress , string oldMetadataURI , string newMetadataURI , address indexed updater ); event IssuerRemoved ( address indexed issuerAddress , address indexed remover ); // Structs struct IssuerEntry { address issuerAddress ; string name ; string metadataURI ; bool active ; uint256 registeredAt ; uint256 lastUpdated ; address registrator ; } // Core Functions function registerIssuer ( address _issuerAddress , string calldata _name , string calldata _metadataURI ) external ; function updateIssuerStatus ( address _issuerAddress , bool _newStatus ) external ; function updateIssuerMetadata ( address _issuerAddress , string calldata _newMetadataURI ) external ; function removeIssuer ( address _issuerAddress ) external ; // View Functions function isTrustedIssuer ( address _address ) external view returns ( bool ); function getIssuerEntry ( address _issuerAddress ) external view returns ( IssuerEntry memory ); function getTrustedIssuerCount () external view returns ( uint256 ); function getTrustedIssuerAddress ( uint256 index ) external view returns ( address ); }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#registerissuer","text":"Registers a new address as a trusted issuer in the registry. Parameters: - _issuerAddress : The address of the entity to be registered as a trusted issuer. - _name : A descriptive name for the issuer. - _metadataURI : A URI pointing to additional off-chain metadata about the issuer. Access Control: - Typically restricted to the contract owner or an authorized administrator. Usage: // Register a new trusted issuer trustedIssuersRegistry . registerIssuer ( 0xAbc123 ..., // Address of the issuer \"Example Verification Service\" , \"ipfs://example.com/issuer_meta.json\" );","title":"registerIssuer()"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#istrustedissuer","text":"Checks if a given address is currently registered as an active, trusted issuer. Parameters: - _address : The address to check. Returns: - bool : true if the address is a trusted and active issuer, false otherwise.","title":"isTrustedIssuer()"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#updateissuerstatus","text":"Changes the active status of a registered issuer to true (active) or false (inactive/suspended). Parameters: - _issuerAddress : The address of the issuer whose status is to be updated. - _newStatus : The new status ( true for active, false for inactive).","title":"updateIssuerStatus()"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#implementation-example","text":"import \"@openzeppelin/contracts/access/Ownable.sol\" ; contract TrustedIssuersRegistry is ITrustedIssuersRegistry , Ownable { // Mapping from issuer address to its IssuerEntry details mapping ( address => IssuerEntry ) private _issuerEntries ; // Array to maintain order and iterate over active issuers address [] private _activeIssuers ; // Count of active issuers uint256 private _activeIssuerCount ; constructor () { // Owner set to deployer by default due to Ownable } function registerIssuer ( address _issuerAddress , string calldata _name , string calldata _metadataURI ) external override onlyOwner { require ( _issuerAddress != address ( 0 ), \"Issuer address cannot be zero\" ); require ( _issuerEntries [ _issuerAddress ]. issuerAddress == address ( 0 ), \"Issuer already registered\" ); _issuerEntries [ _issuerAddress ] = IssuerEntry ({ issuerAddress : _issuerAddress , name : _name , metadataURI : _metadataURI , active : true , registeredAt : block.timestamp , lastUpdated : block.timestamp , registrator : msg.sender }); _activeIssuers . push ( _issuerAddress ); _activeIssuerCount ++ ; emit IssuerRegistered ( _issuerAddress , _name , msg.sender , _metadataURI ); } function updateIssuerStatus ( address _issuerAddress , bool _newStatus ) external override onlyOwner { IssuerEntry storage entry = _issuerEntries [ _issuerAddress ]; require ( entry . issuerAddress != address ( 0 ), \"Issuer not found\" ); require ( entry . active != _newStatus , \"Status is already the same\" ); entry . active = _newStatus ; entry . lastUpdated = block.timestamp ; if ( _newStatus ) { // Add to active_issuers if not already there bool found = false ; for ( uint i = 0 ; i < _activeIssuers . length ; i ++ ) { if ( _activeIssuers [ i ] == _issuerAddress ) { found = true ; break ; } } if ( ! found ) { _activeIssuers . push ( _issuerAddress ); _activeIssuerCount ++ ; } } else { // Remove from active_issuers for ( uint256 i = 0 ; i < _activeIssuers . length ; i ++ ) { if ( _activeIssuers [ i ] == _issuerAddress ) { _activeIssuers [ i ] = _activeIssuers [ _activeIssuers . length - 1 ]; // Swap with last _activeIssuers . pop (); // Pop last element _activeIssuerCount -- ; break ; } } } emit IssuerStatusChanged ( _issuerAddress , _newStatus , msg.sender ); } function updateIssuerMetadata ( address _issuerAddress , string calldata _newMetadataURI ) external override onlyOwner { IssuerEntry storage entry = _issuerEntries [ _issuerAddress ]; require ( entry . issuerAddress != address ( 0 ), \"Issuer not found\" ); string memory oldMetadataURI = entry . metadataURI ; entry . metadataURI = _newMetadataURI ; entry . lastUpdated = block.timestamp ; emit IssuerMetadataUpdated ( _issuerAddress , oldMetadataURI , _newMetadataURI , msg.sender ); } function removeIssuer ( address _issuerAddress ) external override onlyOwner { IssuerEntry storage entry = _issuerEntries [ _issuerAddress ]; require ( entry . issuerAddress != address ( 0 ), \"Issuer not found\" ); // First, set status to inactive and remove from active list if it was active if ( entry . active ) { updateIssuerStatus ( _issuerAddress , false ); // This also handles removing from _activeIssuers } delete _issuerEntries [ _issuerAddress ]; // Clear from mapping emit IssuerRemoved ( _issuerAddress , msg.sender ); } function isTrustedIssuer ( address _address ) external view override returns ( bool ) { return _issuerEntries [ _address ]. active ; } function getIssuerEntry ( address _issuerAddress ) external view override returns ( IssuerEntry memory ) { return _issuerEntries [ _issuerAddress ]; } function getTrustedIssuerCount () external view override returns ( uint256 ) { return _activeIssuerCount ; } function getTrustedIssuerAddress ( uint256 index ) external view override returns ( address ) { require ( index < _activeIssuers . length , \"Index out of bounds\" ); return _activeIssuers [ index ]; } }","title":"Implementation Example"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#access-control","text":"onlyOwner : All functions that modify the registry's state ( registerIssuer , updateIssuerStatus , updateIssuerMetadata , removeIssuer ) are restricted to the contract owner. This ensures that only authorized entities can manage the list of trusted issuers. Role-Based Access Control : For multi-admin environments, Ownable can be replaced with a more granular RBAC system (e.g., OpenZeppelin's AccessControl ).","title":"Access Control"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#data-integrity","text":"Zero Address Check : Prevent registration of address(0) . Duplicate Registration : Ensure an issuer address can only be registered once. Status Consistency : Logic in updateIssuerStatus and removeIssuer manages the _activeIssuers array to keep it consistent with the active flag in IssuerEntry .","title":"Data Integrity"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#gas-efficiency","text":"Array Management : Adding and removing from _activeIssuers array uses basic swap-and-pop, which is gas-efficient for array elements but doesn't maintain order. If order is critical or high performance is needed for very large lists, a more sophisticated data structure might be considered, though it adds complexity.","title":"Gas Efficiency"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#metadata","text":"URI Standards : Use IPFS or other decentralized storage for metadataURI to ensure immutability and availability of issuer details. Off-chain Information : The on-chain registry should only store essential information (address, name, status, metadata URI); detailed information should reside off-chain.","title":"Metadata"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#events","text":"Comprehensive Events : Emit events for all state-changing operations to enable off-chain indexing, auditing, and real-time monitoring of issuer changes.","title":"Events"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#flexibility","text":"Extensibility : Design with future needs in mind. If different levels of trust or categories of issuers are required, extend the IssuerEntry struct and relevant functions.","title":"Flexibility"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#frontend-integration-typescript-via-ethersjs","text":"import { ethers , Contract } from 'ethers' ; import TrustedIssuersRegistryABI from './TrustedIssuersRegistry.json' ; // ABI for ITrustedIssuersRegistry const REGISTRY_ADDRESS = \"0x...\" ; // Your deployed TrustedIssuersRegistry contract address const getProvider = () => new ethers . providers . Web3Provider ( window . ethereum ); const getSigner = () => getProvider (). getSigner (); const getTrustedIssuersRegistryContract = () => new Contract ( REGISTRY_ADDRESS , TrustedIssuersRegistryABI , getSigner ()); async function registerNewIssuer ( issuerAddress : string , name : string , metadataURI : string ) : Promise < void > { try { const registry = getTrustedIssuersRegistryContract (); const tx = await registry . registerIssuer ( issuerAddress , name , metadataURI ); await tx . wait (); alert ( \"Issuer registered successfully!\" ); } catch ( error ) { console . error ( \"Error registering issuer:\" , error ); alert ( \"Failed to register issuer.\" ); } } async function checkIssuerTrust ( address : string ) : Promise < boolean > { try { const registry = getTrustedIssuersRegistryContract (); const isTrusted = await registry . isTrustedIssuer ( address ); return isTrusted ; } catch ( error ) { console . error ( \"Error checking issuer trust:\" , error ); throw error ; } } async function updateIssuerStatus ( issuerAddress : string , newStatus : boolean ) : Promise < void > { try { const registry = getTrustedIssuersRegistryContract (); const tx = await registry . updateIssuerStatus ( issuerAddress , newStatus ); await tx . wait (); alert ( \"Issuer status updated successfully!\" ); } catch ( error ) { console . error ( \"Error updating issuer status:\" , error ); alert ( \"Failed to update issuer status.\" ); } } // Example usage // registerNewIssuer(\"0xSomeIssuerAddress\", \"Credential Service Inc.\", \"https://credentials.com/meta.json\"); // const trusted = await checkIssuerTrust(\"0xSomeIssuerAddress\"); // true or false // updateIssuerStatus(\"0xSomeIssuerAddress\", false); // Deactivate issuer","title":"Frontend Integration (TypeScript via Ethers.js)"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#backend-integration-nodejs-for-a-claim-validation-service","text":"const Web3 = require ( 'web3' ); const TrustedIssuersRegistryABI = require ( './TrustedIssuersRegistry.json' ). abi ; const web3 = new Web3 ( 'YOUR_ETHEREUM_RPC_URL' ); const registryAddress = '0x...' ; // Address of your deployed TrustedIssuersRegistry contract const trustedIssuersRegistryContract = new web3 . eth . Contract ( TrustedIssuersRegistryABI , registryAddress ); async function validateClaimIssuer ( claimIssuerAddress ) { try { const isTrusted = await trustedIssuersRegistryContract . methods . isTrustedIssuer ( claimIssuerAddress ). call (); if ( isTrusted ) { console . log ( `Issuer ${ claimIssuerAddress } is trusted.` ); // Proceed with claim verification logic return true ; } else { console . log ( `Issuer ${ claimIssuerAddress } is NOT trusted.` ); // Reject claim or flag for manual review return false ; } } catch ( error ) { console . error ( \"Error validating claim issuer:\" , error ); throw error ; } } async function getIssuerDetails ( issuerAddress ) { try { const issuerEntry = await trustedIssuersRegistryContract . methods . getIssuerEntry ( issuerAddress ). call (); console . log ( \"Issuer Details:\" , issuerEntry ); return issuerEntry ; } catch ( error ) { console . error ( \"Error fetching issuer details:\" , error ); throw error ; } } // Example usage in a backend service // validateClaimIssuer(\"0xAnotherIssuerAddress\"); // getIssuerDetails(\"0xSomeIssuerAddress\");","title":"Backend Integration (Node.js for a claim validation service)"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#related-documentation","text":"IIdentity Interface ERC735 Claim Holder Interface Trusted Issuer Library Ownable Contract","title":"Related Documentation"},{"location":"smart-contracts/interfaces/itrusted-issuers-registry/#standards-compliance","text":"Ownable : Utilizes OpenZeppelin's Ownable for administrative access control.","title":"Standards Compliance"},{"location":"smart-contracts/interfaces/ivariable-price/","text":"IVariablePrice Interface \u00b6 The IVariablePrice interface defines the standard for smart contracts that implement dynamic pricing mechanisms within the Gemforce ecosystem. This interface allows for flexible and algorithmic determination of token or asset prices based on factors such as demand, time, supply, or other custom parameters. Overview \u00b6 IVariablePrice provides: Dynamic Pricing : Functions to calculate prices based on various input parameters. Pricing Strategy Management : Mechanisms to select and configure different pricing models (e.g., fixed, linear, exponential, logarithmic). Flexibility : Supports multiple pricing scenarios for NFTs, tokens, or services. Queryability : Allows external contracts or off-chain systems to query current prices. Key Features \u00b6 Price Calculation \u00b6 getPrice() : Core function to obtain the current price given specific context (e.g., amount, current block, accumulated sales). Strategy-Dependent Inputs : The function parameters will vary based on the chosen pricing strategy. Strategy Management \u00b6 Set Strategy : Option to select and configure a pricing strategy. Strategy Parameters : Define parameters unique to each strategy (e.g., initial price, curve steepness, time decay). Integration \u00b6 Designed to be easily integrated into marketplaces, sale contracts, or any system requiring dynamic pricing. Interface Definition \u00b6 interface IVariablePrice { // Events event PriceStrategyUpdated ( bytes32 indexed strategyId , string indexed strategyName , address indexed configurator ); event PriceComponentUpdated ( bytes32 indexed strategyId , string indexed componentName , bytes newValue , address indexed updater ); // Struct to define a pricing strategy struct PricingStrategyConfig { string name ; uint256 strategyType ; // e.g., 0 for Fixed, 1 for Linear, 2 for Geometric, 3 for Logarithmic; bytes parameters ; // ABI-encoded parameters specific to the strategy bool active ; } // Core Pricing Function function getPrice ( bytes32 strategyId , uint256 currentSupply , // Current items sold or tokens minted uint256 quantity , // Quantity being purchased uint256 timeElapsed , // Time since sale started (optional) uint256 initialPrice // Base price or reference price ) external view returns ( uint256 price ); // Strategy Management Functions function setPricingStrategy ( string calldata name , uint256 strategyType , bytes calldata parameters ) external ; function activatePricingStrategy ( bytes32 strategyId ) external ; function deactivatePricingStrategy ( bytes32 strategyId ) external ; // View Functions function getPricingStrategyConfig ( bytes32 strategyId ) external view returns ( PricingStrategyConfig memory ); function getActiveStrategyId () external view returns ( bytes32 ); // For contracts that only manage one active strategy // Function to get price for a specific strategy directly (if applicable) function getPriceForStrategy ( bytes32 strategyId , uint256 currentSupply , uint256 quantity , uint256 timeElapsed , uint256 initialPrice ) external view returns ( uint256 price ); } Core Functions \u00b6 getPrice() \u00b6 Calculates the price for a specified quantity given the current state of the sale or system. Parameters: - strategyId : A unique identifier for the pricing strategy to use. - currentSupply : The current quantity of items sold or tokens minted (used for supply-dependent curves). - quantity : The number of items or tokens for which the price is being queried. - timeElapsed : The time elapsed since the sale or pricing mechanism started (used for time-dependent curves). - initialPrice : A base or starting price for the calculation. Returns: - uint256 : The calculated total price for the given quantity . Usage: // Get price based on a specific strategy ID uint256 currentPrice = variablePriceContract . getPrice ( myStrategyId , totalMintedNFTs , // e.g., 100 1 , // quantity to buy block.timestamp - saleStartTime , 1 ether // base price ); setPricingStrategy() \u00b6 Defines or updates a new pricing strategy. The parameters field is abi.encoded data specific to the chosen strategyType . Parameters: - name : A descriptive name for the strategy (e.g., \"LinearDutchAuction\"). - strategyType : An enum or integer representing the type of pricing curve (e.g., 0 for Fixed, 1 for Linear). - parameters : Bytes containing ABI-encoded parameters specific to the chosen strategy (e.g., slopeForLinear , decayRateForExponential ). Access Control: - Typically restricted to the contract owner or an authorized administrator. Implementation Example \u00b6 import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/utils/math/SafeMath.sol\" ; contract VariablePriceEngine is IVariablePrice , Ownable { using SafeMath for uint256 ; // Defines different pricing curve types enum StrategyType { FIXED , // 0: Price is always fixed LINEAR_DECREASE , // 1: Price decreases linearly over time or supply EXPONENTIAL_DECREASE , // 2: Price decreases exponentially over time or supply LOGARITHMIC_INCREASE , // 3: Price increases logarithmically with supply BATCH_AUCTION // 4: For specific batch processing, often simpler } uint256 public constant TOTAL_BASIS_POINTS = 10000 ; // For percentage calculations (100% = 10000 bp) // Mapping from strategyId to its configuration mapping ( bytes32 => PricingStrategyConfig ) private _pricingStrategies ; // Store strategy IDs for enumeration bytes32 [] private _strategyIds ; // Optional: a single active strategy bytes32 private _activeStrategyId ; constructor () { // Owner set to deployer by default due to Ownable // A default fixed price strategy could be set here } function setPricingStrategy ( string calldata name , uint256 strategyType , bytes calldata parameters ) external override onlyOwner { bytes32 strategyId = keccak256 ( abi . encodePacked ( name , strategyType )); // Ensure strategyType is valid require ( strategyType <= uint256 ( StrategyType . BATCH_AUCTION ), \"Invalid strategy type\" ); _pricingStrategies [ strategyId ] = PricingStrategyConfig ({ name : name , strategyType : strategyType , parameters : parameters , active : true // Active by default when set }); bool found = false ; for ( uint256 i = 0 ; i < _strategyIds . length ; i ++ ) { if ( _strategyIds [ i ] == strategyId ) { found = true ; break ; } } if ( ! found ) { _strategyIds . push ( strategyId ); } emit PriceStrategyUpdated ( strategyId , name , msg.sender ); } function activatePricingStrategy ( bytes32 strategyId ) external override onlyOwner { require ( _pricingStrategies [ strategyId ]. name . length > 0 , \"Strategy not found\" ); // Check if strategy exists _pricingStrategies [ strategyId ]. active = true ; _activeStrategyId = strategyId ; // Set as global active strategy if applicable emit PriceComponentUpdated ( strategyId , \"active\" , abi . encode ( true ), msg.sender ); } function deactivatePricingStrategy ( bytes32 strategyId ) external override onlyOwner { require ( _pricingStrategies [ strategyId ]. name . length > 0 , \"Strategy not found\" ); _pricingStrategies [ strategyId ]. active = false ; if ( _activeStrategyId == strategyId ) { _activeStrategyId = bytes32 ( 0 ); // Clear active strategy if deactivated } emit PriceComponentUpdated ( strategyId , \"active\" , abi . encode ( false ), msg.sender ); } function getPrice ( bytes32 strategyId , uint256 currentSupply , uint256 quantity , uint256 timeElapsed , uint256 initialPrice ) external view override returns ( uint256 price ) { PricingStrategyConfig memory config = _pricingStrategies [ strategyId ]; require ( config . name . length > 0 && config . active , \"Strategy not found or inactive\" ); price = _calculatePrice ( config . strategyType , config . parameters , currentSupply , quantity , timeElapsed , initialPrice ); return price ; } function getPriceForStrategy ( bytes32 strategyId , uint256 currentSupply , uint256 quantity , uint256 timeElapsed , uint256 initialPrice ) external view override returns ( uint256 price ) { return getPrice ( strategyId , currentSupply , quantity , timeElapsed , initialPrice ); } function _calculatePrice ( uint256 strategyType , bytes memory parameters , uint256 currentSupply , uint256 quantity , uint256 timeElapsed , uint256 initialPrice ) internal view returns ( uint256 ) { if ( strategyType == uint256 ( StrategyType . FIXED )) { // Parameters: none needed for fixed, or a single uint256 for the fixed price itself return initialPrice . mul ( quantity ); } else if ( strategyType == uint256 ( StrategyType . LINEAR_DECREASE )) { // Parameters: (uint256 decayRatePerUnit, uint256 floorPrice) ( uint256 decayRatePerUnit , uint256 floorPrice ) = abi . decode ( parameters , ( uint256 , uint256 )); uint256 effectivePrice = initialPrice . sub ( currentSupply . mul ( decayRatePerUnit )); effectivePrice = effectivePrice > floorPrice ? effectivePrice : floorPrice ; return effectivePrice . mul ( quantity ); } else if ( strategyType == uint256 ( StrategyType . EXPONENTIAL_DECREASE )) { // Parameters: (uint256 decayFactor, uint256 floorPrice) // Example: initialPrice * (decayFactor / 10000)^currentSupply // decayFactor is in basis points, e.g., 9900 for 99% (0.99) ( uint256 decayFactor , uint256 floorPrice ) = abi . decode ( parameters , ( uint256 , uint256 )); uint256 priceAtCurrentSupply = initialPrice ; for ( uint256 i = 0 ; i < currentSupply ; i ++ ) { priceAtCurrentSupply = priceAtCurrentSupply . mul ( decayFactor ). div ( TOTAL_BASIS_POINTS ); } priceAtCurrentSupply = priceAtCurrentSupply > floorPrice ? priceAtCurrentSupply : floorPrice ; return priceAtCurrentSupply . mul ( quantity ); } else if ( strategyType == uint256 ( StrategyType . LOGARITHMIC_INCREASE )) { // Parameters: (uint256 growthFactor, uint256 capPrice) // This is complex on-chain; often approximated or done off-chain. // Placeholder: simple growth based on quantity ( uint256 growthFactor , uint256 capPrice ) = abi . decode ( parameters , ( uint256 , uint256 )); // Mathematical log function is not easily available in Solidity. // A simplified approximation or a lookup table would be needed for a real scenario. // For example, an approximation: price increases with currentSupply's square root // using Newton's method for sqrt, or a simplified linear increase to approximate. // This is a simplified example of logarithmic-like growth: // Price increases by (growthFactor * sqrt(currentSupply)) units (growthFactor in basis points) uint256 currentPrice = initialPrice ; if ( currentSupply > 0 ) { // Approximate square root (e.g., using integer square root if available or simple loop) uint256 sqrtSupply = currentSupply ; if ( currentSupply > 1 ) { // Simple integer sqrt approximation uint256 z = currentSupply . add ( 1 ). div ( 2 ); uint256 y = currentSupply ; while ( z < y ) { y = z ; z = ( currentSupply . div ( z ). add ( z )). div ( 2 ); } sqrtSupply = y ; } currentPrice = currentPrice . add ( sqrtSupply . mul ( growthFactor ). div ( TOTAL_BASIS_POINTS )); } currentPrice = currentPrice < capPrice ? currentPrice : capPrice ; return currentPrice . mul ( quantity ); } else if ( strategyType == uint256 ( StrategyType . BATCH_AUCTION )) { // Specific logic for batch auctions, might consider lowest bid in range // or fixed price for batches. return initialPrice . mul ( quantity ); } else { revert ( \"Unknown pricing strategy type\" ); } } function getPricingStrategyConfig ( bytes32 strategyId ) external view override returns ( PricingStrategyConfig memory ) { return _pricingStrategies [ strategyId ]; } function getActiveStrategyId () external view override returns ( bytes32 ) { return _activeStrategyId ; } function getAllStrategyIds () external view returns ( bytes32 [] memory ) { return _strategyIds ; } } Security Considerations \u00b6 Access Control \u00b6 onlyOwner : Functions that modify or configure pricing strategies ( setPricingStrategy , activatePricingStrategy , deactivatePricingStrategy ) must be restricted to the contract owner or an authorized administrator. Unauthorized changes to pricing logic could lead to financial exploits. Mathematical Precision \u00b6 Fixed-Point Arithmetic : Solidity does not natively support floating-point numbers. All price calculations must use fixed-point arithmetic, typically by scaling all values by a large constant (e.g., 10**18 for WAD or 10**4 for basis points) and then performing division/multiplication with SafeMath . SafeMath : Crucial for all arithmetic operations to prevent overflow and underflow vulnerabilities. Strategy Implementation \u00b6 Complexity : Highly complex mathematical functions (e.g., true logarithms, exponentials) are difficult and gas-expensive to implement accurately on-chain. Approximations or off-chain calculations validated by the contract might be necessary. Precision Loss : Be aware of potential precision loss when performing divisions and multiplications in fixed-point arithmetic. Choose appropriate scaling factors. Best Practices \u00b6 Modular Strategies \u00b6 Separation of Concerns : Each pricing strategy (linear, exponential, fixed, etc.) should ideally be a distinct, self-contained unit within the contract or even a separate library, invoked by a dispatcher-like getPrice function. Parameters : Clearly define and document the abi.encoded parameters required for each strategy type. Oracles for External Data \u00b6 External Factors : If pricing depends on external factors (e.g., real-time market data, off-chain computations), use secure oracles (like Chainlink) to feed this data to the contract. Gas Efficiency \u00b6 Pre-computation : If a price curve is static or changes infrequently, consider pre-computing checkpoints or a lookup table on-chain to reduce gas costs during getPrice calls. Pull vs. Push : If prices are pushed from an external source, ensure that the pushing mechanism is secure and not easily manipulable. Integration Examples \u00b6 Frontend Integration (TypeScript via Ethers.js) \u00b6 import { ethers , Contract } from 'ethers' ; import VariablePriceABI from './VariablePriceEngine.json' ; // ABI for IVariablePrice const VARIABLE_PRICE_ADDRESS = \"0x...\" ; // Deployed VariablePriceEngine contract address // Assumes 'provider' is already set up from Web3Modal, Metamask, etc. const getPriceContract = ( signer? : ethers.Signer ) => { return new Contract ( VARIABLE_PRICE_ADDRESS , VariablePriceABI , signer || new ethers . providers . Web3Provider ( window . ethereum )); }; async function getPriceFromContract ( strategyId : string , // hex string currentSupply : number , quantity : number , timeElapsed : number , initialPrice : ethers.BigNumberish ) : Promise < ethers . BigNumber > { try { const priceContract = getPriceContract (); const price = await priceContract . getPrice ( strategyId , currentSupply , quantity , timeElapsed , initialPrice ); return price ; } catch ( error ) { console . error ( \"Error getting price:\" , error ); throw error ; } } async function setLinearDecreaseStrategy ( name : string , decayRatePerUnit : ethers.BigNumberish , floorPrice : ethers.BigNumberish ) : Promise < void > { try { const priceContract = getPriceContract ( getPriceContract (). signer as ethers . Signer ); const strategyType_LINEAR_DECREASE = 1 ; // Corresponds to enum in Solidity const parameters = ethers . utils . defaultAbiCoder . encode ( [ \"uint256\" , \"uint256\" ], // Match _calculatePrice's abi.decode for LINEAR_DECREASE [ decayRatePerUnit , floorPrice ] ); const tx = await priceContract . setPricingStrategy ( name , strategyType_LINEAR_DECREASE , parameters ); await tx . wait (); alert ( `Linear Decrease strategy ' ${ name } ' set!` ); } catch ( error ) { console . error ( \"Error setting strategy:\" , error ); alert ( \"Failed to set pricing strategy.\" ); } } // Example usage // const myStrategyId = \"0x...\"; // Get this from backend or previous setup // const calculatedPrice = await getPriceFromContract(myStrategyId, 100, 1, 3600, ethers.utils.parseEther(\"1\")); // console.log(\"Calculated Price:\", ethers.utils.formatEther(calculatedPrice)); // setLinearDecreaseStrategy(\"NFT_Price_Decay\", ethers.utils.parseUnits(\"0.001\", \"ether\"), ethers.utils.parseEther(\"0.1\")); // 0.001 ETH decay per unit, 0.1 ETH floor Backend Integration (Node.js for a pricing service) \u00b6 const Web3 = require ( 'web3' ); const VariablePriceABI = require ( './VariablePriceEngine.json' ). abi ; const web3 = new Web3 ( 'YOUR_ETHEREUM_RPC_URL' ); const variablePriceAddress = '0x...' ; // Your deployed VariablePriceEngine contract address const adminPrivateKey = 'YOUR_ADMIN_PRIVATE_KEY' ; // Private key of the account authorized to set strategies const variablePriceContract = new web3 . eth . Contract ( VariablePriceABI , variablePriceAddress ); const adminAccount = web3 . eth . accounts . privateKeyToAccount ( adminPrivateKey ); web3 . eth . accounts . wallet . add ( adminAccount ); async function getConfiguredPrice ( strategyName , currentSupply , quantity , timeElapsed , initialPrice ) { try { // Need to derive strategyId from name and type in JS if not static // For simplicity, let's assume a known strategyId for a fixed price strategy const FIXED_PRICE_STRATEGY_ID = web3 . utils . keccak256 ( web3 . eth . abi . encodePacked ( \"FixedPrice\" , 0 )); // Assuming FixedPrice strategy type is 0 const price = await variablePriceContract . methods . getPrice ( FIXED_PRICE_STRATEGY_ID , currentSupply , quantity , timeElapsed , initialPrice ). call (); console . log ( `Price for ${ quantity } items: ${ web3 . utils . fromWei ( price , 'ether' ) } ETH` ); return price ; } catch ( error ) { console . error ( \"Backend: Error getting price:\" , error ); throw error ; } } async function configureExponentialDecreaseStrategy ( strategyName , decayFactor , floorPrice ) { try { const strategyType_EXPONENTIAL_DECREASE = 2 ; // Corresponds to enum in Solidity const parameters = web3 . eth . abi . encodeParameters ( [ 'uint256' , 'uint256' ], // decayFactor (basis points, 10000 = 100%), floorPrice [ decayFactor , floorPrice ] ); const tx = variablePriceContract . methods . setPricingStrategy ( strategyName , strategyType_EXPONENTIAL_DECREASE , parameters ); const gasLimit = await tx . estimateGas ({ from : adminAccount . address }); const receipt = await tx . send ({ from : adminAccount . address , gas : gasLimit }); console . log ( `Exponential Decrease strategy ' ${ strategyName } ' configured. Tx Hash: ${ receipt . transactionHash } ` ); return receipt ; } catch ( error ) { console . error ( \"Backend: Error configuring strategy:\" , error ); throw error ; } } // Example usage // getConfiguredPrice(\"FixedPrice\", 0, 1, 0, web3.utils.toWei(\"0.5\", \"ether\")); // configureExponentialDecreaseStrategy(\"EarlyBirdSale\", 9900, web3.utils.toWei(\"0.05\", \"ether\")); // 99% of current price, 0.05 ETH floor Related Documentation \u00b6 Variable Price Library MultiSale Interface (often uses variable pricing) OpenZeppelin SafeMath Solidity ABI Encoding and Decoding Standards Compliance \u00b6 Ownable : Utilizes OpenZeppelin's Ownable for administrative access control.","title":"IVariablePrice Interface"},{"location":"smart-contracts/interfaces/ivariable-price/#ivariableprice-interface","text":"The IVariablePrice interface defines the standard for smart contracts that implement dynamic pricing mechanisms within the Gemforce ecosystem. This interface allows for flexible and algorithmic determination of token or asset prices based on factors such as demand, time, supply, or other custom parameters.","title":"IVariablePrice Interface"},{"location":"smart-contracts/interfaces/ivariable-price/#overview","text":"IVariablePrice provides: Dynamic Pricing : Functions to calculate prices based on various input parameters. Pricing Strategy Management : Mechanisms to select and configure different pricing models (e.g., fixed, linear, exponential, logarithmic). Flexibility : Supports multiple pricing scenarios for NFTs, tokens, or services. Queryability : Allows external contracts or off-chain systems to query current prices.","title":"Overview"},{"location":"smart-contracts/interfaces/ivariable-price/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/interfaces/ivariable-price/#price-calculation","text":"getPrice() : Core function to obtain the current price given specific context (e.g., amount, current block, accumulated sales). Strategy-Dependent Inputs : The function parameters will vary based on the chosen pricing strategy.","title":"Price Calculation"},{"location":"smart-contracts/interfaces/ivariable-price/#strategy-management","text":"Set Strategy : Option to select and configure a pricing strategy. Strategy Parameters : Define parameters unique to each strategy (e.g., initial price, curve steepness, time decay).","title":"Strategy Management"},{"location":"smart-contracts/interfaces/ivariable-price/#integration","text":"Designed to be easily integrated into marketplaces, sale contracts, or any system requiring dynamic pricing.","title":"Integration"},{"location":"smart-contracts/interfaces/ivariable-price/#interface-definition","text":"interface IVariablePrice { // Events event PriceStrategyUpdated ( bytes32 indexed strategyId , string indexed strategyName , address indexed configurator ); event PriceComponentUpdated ( bytes32 indexed strategyId , string indexed componentName , bytes newValue , address indexed updater ); // Struct to define a pricing strategy struct PricingStrategyConfig { string name ; uint256 strategyType ; // e.g., 0 for Fixed, 1 for Linear, 2 for Geometric, 3 for Logarithmic; bytes parameters ; // ABI-encoded parameters specific to the strategy bool active ; } // Core Pricing Function function getPrice ( bytes32 strategyId , uint256 currentSupply , // Current items sold or tokens minted uint256 quantity , // Quantity being purchased uint256 timeElapsed , // Time since sale started (optional) uint256 initialPrice // Base price or reference price ) external view returns ( uint256 price ); // Strategy Management Functions function setPricingStrategy ( string calldata name , uint256 strategyType , bytes calldata parameters ) external ; function activatePricingStrategy ( bytes32 strategyId ) external ; function deactivatePricingStrategy ( bytes32 strategyId ) external ; // View Functions function getPricingStrategyConfig ( bytes32 strategyId ) external view returns ( PricingStrategyConfig memory ); function getActiveStrategyId () external view returns ( bytes32 ); // For contracts that only manage one active strategy // Function to get price for a specific strategy directly (if applicable) function getPriceForStrategy ( bytes32 strategyId , uint256 currentSupply , uint256 quantity , uint256 timeElapsed , uint256 initialPrice ) external view returns ( uint256 price ); }","title":"Interface Definition"},{"location":"smart-contracts/interfaces/ivariable-price/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/interfaces/ivariable-price/#getprice","text":"Calculates the price for a specified quantity given the current state of the sale or system. Parameters: - strategyId : A unique identifier for the pricing strategy to use. - currentSupply : The current quantity of items sold or tokens minted (used for supply-dependent curves). - quantity : The number of items or tokens for which the price is being queried. - timeElapsed : The time elapsed since the sale or pricing mechanism started (used for time-dependent curves). - initialPrice : A base or starting price for the calculation. Returns: - uint256 : The calculated total price for the given quantity . Usage: // Get price based on a specific strategy ID uint256 currentPrice = variablePriceContract . getPrice ( myStrategyId , totalMintedNFTs , // e.g., 100 1 , // quantity to buy block.timestamp - saleStartTime , 1 ether // base price );","title":"getPrice()"},{"location":"smart-contracts/interfaces/ivariable-price/#setpricingstrategy","text":"Defines or updates a new pricing strategy. The parameters field is abi.encoded data specific to the chosen strategyType . Parameters: - name : A descriptive name for the strategy (e.g., \"LinearDutchAuction\"). - strategyType : An enum or integer representing the type of pricing curve (e.g., 0 for Fixed, 1 for Linear). - parameters : Bytes containing ABI-encoded parameters specific to the chosen strategy (e.g., slopeForLinear , decayRateForExponential ). Access Control: - Typically restricted to the contract owner or an authorized administrator.","title":"setPricingStrategy()"},{"location":"smart-contracts/interfaces/ivariable-price/#implementation-example","text":"import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/utils/math/SafeMath.sol\" ; contract VariablePriceEngine is IVariablePrice , Ownable { using SafeMath for uint256 ; // Defines different pricing curve types enum StrategyType { FIXED , // 0: Price is always fixed LINEAR_DECREASE , // 1: Price decreases linearly over time or supply EXPONENTIAL_DECREASE , // 2: Price decreases exponentially over time or supply LOGARITHMIC_INCREASE , // 3: Price increases logarithmically with supply BATCH_AUCTION // 4: For specific batch processing, often simpler } uint256 public constant TOTAL_BASIS_POINTS = 10000 ; // For percentage calculations (100% = 10000 bp) // Mapping from strategyId to its configuration mapping ( bytes32 => PricingStrategyConfig ) private _pricingStrategies ; // Store strategy IDs for enumeration bytes32 [] private _strategyIds ; // Optional: a single active strategy bytes32 private _activeStrategyId ; constructor () { // Owner set to deployer by default due to Ownable // A default fixed price strategy could be set here } function setPricingStrategy ( string calldata name , uint256 strategyType , bytes calldata parameters ) external override onlyOwner { bytes32 strategyId = keccak256 ( abi . encodePacked ( name , strategyType )); // Ensure strategyType is valid require ( strategyType <= uint256 ( StrategyType . BATCH_AUCTION ), \"Invalid strategy type\" ); _pricingStrategies [ strategyId ] = PricingStrategyConfig ({ name : name , strategyType : strategyType , parameters : parameters , active : true // Active by default when set }); bool found = false ; for ( uint256 i = 0 ; i < _strategyIds . length ; i ++ ) { if ( _strategyIds [ i ] == strategyId ) { found = true ; break ; } } if ( ! found ) { _strategyIds . push ( strategyId ); } emit PriceStrategyUpdated ( strategyId , name , msg.sender ); } function activatePricingStrategy ( bytes32 strategyId ) external override onlyOwner { require ( _pricingStrategies [ strategyId ]. name . length > 0 , \"Strategy not found\" ); // Check if strategy exists _pricingStrategies [ strategyId ]. active = true ; _activeStrategyId = strategyId ; // Set as global active strategy if applicable emit PriceComponentUpdated ( strategyId , \"active\" , abi . encode ( true ), msg.sender ); } function deactivatePricingStrategy ( bytes32 strategyId ) external override onlyOwner { require ( _pricingStrategies [ strategyId ]. name . length > 0 , \"Strategy not found\" ); _pricingStrategies [ strategyId ]. active = false ; if ( _activeStrategyId == strategyId ) { _activeStrategyId = bytes32 ( 0 ); // Clear active strategy if deactivated } emit PriceComponentUpdated ( strategyId , \"active\" , abi . encode ( false ), msg.sender ); } function getPrice ( bytes32 strategyId , uint256 currentSupply , uint256 quantity , uint256 timeElapsed , uint256 initialPrice ) external view override returns ( uint256 price ) { PricingStrategyConfig memory config = _pricingStrategies [ strategyId ]; require ( config . name . length > 0 && config . active , \"Strategy not found or inactive\" ); price = _calculatePrice ( config . strategyType , config . parameters , currentSupply , quantity , timeElapsed , initialPrice ); return price ; } function getPriceForStrategy ( bytes32 strategyId , uint256 currentSupply , uint256 quantity , uint256 timeElapsed , uint256 initialPrice ) external view override returns ( uint256 price ) { return getPrice ( strategyId , currentSupply , quantity , timeElapsed , initialPrice ); } function _calculatePrice ( uint256 strategyType , bytes memory parameters , uint256 currentSupply , uint256 quantity , uint256 timeElapsed , uint256 initialPrice ) internal view returns ( uint256 ) { if ( strategyType == uint256 ( StrategyType . FIXED )) { // Parameters: none needed for fixed, or a single uint256 for the fixed price itself return initialPrice . mul ( quantity ); } else if ( strategyType == uint256 ( StrategyType . LINEAR_DECREASE )) { // Parameters: (uint256 decayRatePerUnit, uint256 floorPrice) ( uint256 decayRatePerUnit , uint256 floorPrice ) = abi . decode ( parameters , ( uint256 , uint256 )); uint256 effectivePrice = initialPrice . sub ( currentSupply . mul ( decayRatePerUnit )); effectivePrice = effectivePrice > floorPrice ? effectivePrice : floorPrice ; return effectivePrice . mul ( quantity ); } else if ( strategyType == uint256 ( StrategyType . EXPONENTIAL_DECREASE )) { // Parameters: (uint256 decayFactor, uint256 floorPrice) // Example: initialPrice * (decayFactor / 10000)^currentSupply // decayFactor is in basis points, e.g., 9900 for 99% (0.99) ( uint256 decayFactor , uint256 floorPrice ) = abi . decode ( parameters , ( uint256 , uint256 )); uint256 priceAtCurrentSupply = initialPrice ; for ( uint256 i = 0 ; i < currentSupply ; i ++ ) { priceAtCurrentSupply = priceAtCurrentSupply . mul ( decayFactor ). div ( TOTAL_BASIS_POINTS ); } priceAtCurrentSupply = priceAtCurrentSupply > floorPrice ? priceAtCurrentSupply : floorPrice ; return priceAtCurrentSupply . mul ( quantity ); } else if ( strategyType == uint256 ( StrategyType . LOGARITHMIC_INCREASE )) { // Parameters: (uint256 growthFactor, uint256 capPrice) // This is complex on-chain; often approximated or done off-chain. // Placeholder: simple growth based on quantity ( uint256 growthFactor , uint256 capPrice ) = abi . decode ( parameters , ( uint256 , uint256 )); // Mathematical log function is not easily available in Solidity. // A simplified approximation or a lookup table would be needed for a real scenario. // For example, an approximation: price increases with currentSupply's square root // using Newton's method for sqrt, or a simplified linear increase to approximate. // This is a simplified example of logarithmic-like growth: // Price increases by (growthFactor * sqrt(currentSupply)) units (growthFactor in basis points) uint256 currentPrice = initialPrice ; if ( currentSupply > 0 ) { // Approximate square root (e.g., using integer square root if available or simple loop) uint256 sqrtSupply = currentSupply ; if ( currentSupply > 1 ) { // Simple integer sqrt approximation uint256 z = currentSupply . add ( 1 ). div ( 2 ); uint256 y = currentSupply ; while ( z < y ) { y = z ; z = ( currentSupply . div ( z ). add ( z )). div ( 2 ); } sqrtSupply = y ; } currentPrice = currentPrice . add ( sqrtSupply . mul ( growthFactor ). div ( TOTAL_BASIS_POINTS )); } currentPrice = currentPrice < capPrice ? currentPrice : capPrice ; return currentPrice . mul ( quantity ); } else if ( strategyType == uint256 ( StrategyType . BATCH_AUCTION )) { // Specific logic for batch auctions, might consider lowest bid in range // or fixed price for batches. return initialPrice . mul ( quantity ); } else { revert ( \"Unknown pricing strategy type\" ); } } function getPricingStrategyConfig ( bytes32 strategyId ) external view override returns ( PricingStrategyConfig memory ) { return _pricingStrategies [ strategyId ]; } function getActiveStrategyId () external view override returns ( bytes32 ) { return _activeStrategyId ; } function getAllStrategyIds () external view returns ( bytes32 [] memory ) { return _strategyIds ; } }","title":"Implementation Example"},{"location":"smart-contracts/interfaces/ivariable-price/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/interfaces/ivariable-price/#access-control","text":"onlyOwner : Functions that modify or configure pricing strategies ( setPricingStrategy , activatePricingStrategy , deactivatePricingStrategy ) must be restricted to the contract owner or an authorized administrator. Unauthorized changes to pricing logic could lead to financial exploits.","title":"Access Control"},{"location":"smart-contracts/interfaces/ivariable-price/#mathematical-precision","text":"Fixed-Point Arithmetic : Solidity does not natively support floating-point numbers. All price calculations must use fixed-point arithmetic, typically by scaling all values by a large constant (e.g., 10**18 for WAD or 10**4 for basis points) and then performing division/multiplication with SafeMath . SafeMath : Crucial for all arithmetic operations to prevent overflow and underflow vulnerabilities.","title":"Mathematical Precision"},{"location":"smart-contracts/interfaces/ivariable-price/#strategy-implementation","text":"Complexity : Highly complex mathematical functions (e.g., true logarithms, exponentials) are difficult and gas-expensive to implement accurately on-chain. Approximations or off-chain calculations validated by the contract might be necessary. Precision Loss : Be aware of potential precision loss when performing divisions and multiplications in fixed-point arithmetic. Choose appropriate scaling factors.","title":"Strategy Implementation"},{"location":"smart-contracts/interfaces/ivariable-price/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/interfaces/ivariable-price/#modular-strategies","text":"Separation of Concerns : Each pricing strategy (linear, exponential, fixed, etc.) should ideally be a distinct, self-contained unit within the contract or even a separate library, invoked by a dispatcher-like getPrice function. Parameters : Clearly define and document the abi.encoded parameters required for each strategy type.","title":"Modular Strategies"},{"location":"smart-contracts/interfaces/ivariable-price/#oracles-for-external-data","text":"External Factors : If pricing depends on external factors (e.g., real-time market data, off-chain computations), use secure oracles (like Chainlink) to feed this data to the contract.","title":"Oracles for External Data"},{"location":"smart-contracts/interfaces/ivariable-price/#gas-efficiency","text":"Pre-computation : If a price curve is static or changes infrequently, consider pre-computing checkpoints or a lookup table on-chain to reduce gas costs during getPrice calls. Pull vs. Push : If prices are pushed from an external source, ensure that the pushing mechanism is secure and not easily manipulable.","title":"Gas Efficiency"},{"location":"smart-contracts/interfaces/ivariable-price/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/interfaces/ivariable-price/#frontend-integration-typescript-via-ethersjs","text":"import { ethers , Contract } from 'ethers' ; import VariablePriceABI from './VariablePriceEngine.json' ; // ABI for IVariablePrice const VARIABLE_PRICE_ADDRESS = \"0x...\" ; // Deployed VariablePriceEngine contract address // Assumes 'provider' is already set up from Web3Modal, Metamask, etc. const getPriceContract = ( signer? : ethers.Signer ) => { return new Contract ( VARIABLE_PRICE_ADDRESS , VariablePriceABI , signer || new ethers . providers . Web3Provider ( window . ethereum )); }; async function getPriceFromContract ( strategyId : string , // hex string currentSupply : number , quantity : number , timeElapsed : number , initialPrice : ethers.BigNumberish ) : Promise < ethers . BigNumber > { try { const priceContract = getPriceContract (); const price = await priceContract . getPrice ( strategyId , currentSupply , quantity , timeElapsed , initialPrice ); return price ; } catch ( error ) { console . error ( \"Error getting price:\" , error ); throw error ; } } async function setLinearDecreaseStrategy ( name : string , decayRatePerUnit : ethers.BigNumberish , floorPrice : ethers.BigNumberish ) : Promise < void > { try { const priceContract = getPriceContract ( getPriceContract (). signer as ethers . Signer ); const strategyType_LINEAR_DECREASE = 1 ; // Corresponds to enum in Solidity const parameters = ethers . utils . defaultAbiCoder . encode ( [ \"uint256\" , \"uint256\" ], // Match _calculatePrice's abi.decode for LINEAR_DECREASE [ decayRatePerUnit , floorPrice ] ); const tx = await priceContract . setPricingStrategy ( name , strategyType_LINEAR_DECREASE , parameters ); await tx . wait (); alert ( `Linear Decrease strategy ' ${ name } ' set!` ); } catch ( error ) { console . error ( \"Error setting strategy:\" , error ); alert ( \"Failed to set pricing strategy.\" ); } } // Example usage // const myStrategyId = \"0x...\"; // Get this from backend or previous setup // const calculatedPrice = await getPriceFromContract(myStrategyId, 100, 1, 3600, ethers.utils.parseEther(\"1\")); // console.log(\"Calculated Price:\", ethers.utils.formatEther(calculatedPrice)); // setLinearDecreaseStrategy(\"NFT_Price_Decay\", ethers.utils.parseUnits(\"0.001\", \"ether\"), ethers.utils.parseEther(\"0.1\")); // 0.001 ETH decay per unit, 0.1 ETH floor","title":"Frontend Integration (TypeScript via Ethers.js)"},{"location":"smart-contracts/interfaces/ivariable-price/#backend-integration-nodejs-for-a-pricing-service","text":"const Web3 = require ( 'web3' ); const VariablePriceABI = require ( './VariablePriceEngine.json' ). abi ; const web3 = new Web3 ( 'YOUR_ETHEREUM_RPC_URL' ); const variablePriceAddress = '0x...' ; // Your deployed VariablePriceEngine contract address const adminPrivateKey = 'YOUR_ADMIN_PRIVATE_KEY' ; // Private key of the account authorized to set strategies const variablePriceContract = new web3 . eth . Contract ( VariablePriceABI , variablePriceAddress ); const adminAccount = web3 . eth . accounts . privateKeyToAccount ( adminPrivateKey ); web3 . eth . accounts . wallet . add ( adminAccount ); async function getConfiguredPrice ( strategyName , currentSupply , quantity , timeElapsed , initialPrice ) { try { // Need to derive strategyId from name and type in JS if not static // For simplicity, let's assume a known strategyId for a fixed price strategy const FIXED_PRICE_STRATEGY_ID = web3 . utils . keccak256 ( web3 . eth . abi . encodePacked ( \"FixedPrice\" , 0 )); // Assuming FixedPrice strategy type is 0 const price = await variablePriceContract . methods . getPrice ( FIXED_PRICE_STRATEGY_ID , currentSupply , quantity , timeElapsed , initialPrice ). call (); console . log ( `Price for ${ quantity } items: ${ web3 . utils . fromWei ( price , 'ether' ) } ETH` ); return price ; } catch ( error ) { console . error ( \"Backend: Error getting price:\" , error ); throw error ; } } async function configureExponentialDecreaseStrategy ( strategyName , decayFactor , floorPrice ) { try { const strategyType_EXPONENTIAL_DECREASE = 2 ; // Corresponds to enum in Solidity const parameters = web3 . eth . abi . encodeParameters ( [ 'uint256' , 'uint256' ], // decayFactor (basis points, 10000 = 100%), floorPrice [ decayFactor , floorPrice ] ); const tx = variablePriceContract . methods . setPricingStrategy ( strategyName , strategyType_EXPONENTIAL_DECREASE , parameters ); const gasLimit = await tx . estimateGas ({ from : adminAccount . address }); const receipt = await tx . send ({ from : adminAccount . address , gas : gasLimit }); console . log ( `Exponential Decrease strategy ' ${ strategyName } ' configured. Tx Hash: ${ receipt . transactionHash } ` ); return receipt ; } catch ( error ) { console . error ( \"Backend: Error configuring strategy:\" , error ); throw error ; } } // Example usage // getConfiguredPrice(\"FixedPrice\", 0, 1, 0, web3.utils.toWei(\"0.5\", \"ether\")); // configureExponentialDecreaseStrategy(\"EarlyBirdSale\", 9900, web3.utils.toWei(\"0.05\", \"ether\")); // 99% of current price, 0.05 ETH floor","title":"Backend Integration (Node.js for a pricing service)"},{"location":"smart-contracts/interfaces/ivariable-price/#related-documentation","text":"Variable Price Library MultiSale Interface (often uses variable pricing) OpenZeppelin SafeMath Solidity ABI Encoding and Decoding","title":"Related Documentation"},{"location":"smart-contracts/interfaces/ivariable-price/#standards-compliance","text":"Ownable : Utilizes OpenZeppelin's Ownable for administrative access control.","title":"Standards Compliance"},{"location":"smart-contracts/libraries/attribute-lib/","text":"AttributeLib Library \u00b6 Overview \u00b6 The AttributeLib library provides core utilities for managing token attributes within the Gemforce platform. This library implements a flexible attribute system that allows tokens to have dynamic, typed metadata stored on-chain, supporting various data types and efficient key-value storage. Key Features \u00b6 Typed Attributes : Support for multiple data types (String, Bytes32, Uint256, Arrays) Dynamic Metadata : Runtime attribute assignment and modification Efficient Storage : Optimized key-value storage with indexing Burn Protection : Prevents attribute operations on burned tokens Batch Operations : Support for setting multiple attributes simultaneously Event Tracking : Comprehensive event emission for attribute changes Library Definition \u00b6 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.6 ; library AttributeLib { // Storage management function attributeStorage () internal pure returns ( AttributeStorage storage ); // Attribute retrieval function _getAttribute ( AttributeContract storage self , uint256 tokenId , string memory key ) internal view returns ( Attribute memory ); function _getAttributeValues ( uint256 id ) internal view returns ( string [] memory ); function _getAttributeKeys ( AttributeContract storage self , uint256 tokenId ) internal view returns ( string [] memory ); // Attribute modification function _setAttribute ( AttributeContract storage self , uint256 tokenId , Attribute memory attribute ) internal ; function _setAttributes ( AttributeContract storage self , uint256 tokenId , Attribute [] memory _attributes ) internal ; function _removeAttribute ( AttributeContract storage self , uint256 tokenId , string memory key ) internal ; // Token lifecycle function _burn ( AttributeContract storage self , uint256 tokenId ) internal ; } Data Structures \u00b6 AttributeType Enum \u00b6 enum AttributeType { Unknown , // Undefined type String , // String value Bytes32 , // 32-byte value Uint256 , // 256-bit unsigned integer Uint8 , // 8-bit unsigned integer Uint256Array , // Array of 256-bit unsigned integers Uint8Array // Array of 8-bit unsigned integers } Purpose : Defines supported attribute data types for type-safe operations. Attribute Struct \u00b6 struct Attribute { string key ; // Attribute identifier AttributeType attributeType ; // Type of the attribute value string value ; // String representation of the value } Purpose : Core attribute data structure containing key, type, and value. Design Notes : - All values stored as strings for simplicity and gas efficiency - Type information preserved for proper interpretation - Key serves as unique identifier within token scope AttributeContract Struct \u00b6 struct AttributeContract { mapping ( uint256 => bool ) burnedIds ; // Burned token tracking mapping ( uint256 => mapping ( string => Attribute )) attributes ; // Token attributes mapping ( uint256 => string []) attributeKeys ; // Token attribute keys mapping ( uint256 => mapping ( string => uint256 )) attributeKeysIndexes ; // Key index mapping } Purpose : Complete storage structure for token attribute management. Components : - burnedIds : Tracks burned tokens to prevent attribute operations - attributes : Nested mapping for token-specific attribute storage - attributeKeys : Ordered list of attribute keys per token - attributeKeysIndexes : Efficient key lookup and removal indexing AttributeStorage Struct \u00b6 struct AttributeStorage { AttributeContract attributes ; } Purpose : Diamond storage wrapper for attribute data. Storage Position : bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nextblock.bitgem.app.AttributeStorage.storage\" ); Core Functions \u00b6 Storage Management \u00b6 attributeStorage() \u00b6 function attributeStorage () internal pure returns ( AttributeStorage storage ds ) Purpose : Access Diamond storage for attribute data using assembly. Implementation : function attributeStorage () internal pure returns ( AttributeStorage storage ds ) { bytes32 position = DIAMOND_STORAGE_POSITION ; assembly { ds . slot := position } } Returns : Storage reference to attribute data Usage : All attribute functions use this to access persistent storage. Attribute Retrieval \u00b6 _getAttribute() \u00b6 function _getAttribute ( AttributeContract storage self , uint256 tokenId , string memory key ) internal view returns ( Attribute memory ) Purpose : Retrieve a specific attribute for a token by key. Parameters : - self : Storage reference to attribute contract - tokenId : Token identifier - key : Attribute key to retrieve Returns : Attribute struct containing key, type, and value Security : Prevents access to burned token attributes Example Usage : // Get token rarity attribute Attribute memory rarityAttr = AttributeLib . _getAttribute ( attributeStorage . attributes , tokenId , \"rarity\" ); console . log ( \"Token rarity:\" , rarityAttr . value ); _getAttributeValues() \u00b6 function _getAttributeValues ( uint256 id ) internal view returns ( string [] memory ) Purpose : Retrieve all attribute values for a token in key order. Parameters : - id : Token identifier Returns : Array of attribute values as strings Implementation : function _getAttributeValues ( uint256 id ) internal view returns ( string [] memory ) { AttributeContract storage ct = AttributeLib . attributeStorage (). attributes ; string [] memory keys = ct . attributeKeys [ id ]; string [] memory values = new string []( keys . length ); uint256 keysLength = keys . length ; for ( uint256 i = 0 ; i < keysLength ; i ++ ) { values [ i ] = ct . attributes [ id ][ keys [ i ]]. value ; } return values ; } Use Cases : - Metadata generation for NFTs - Bulk attribute export - Attribute comparison operations _getAttributeKeys() \u00b6 function _getAttributeKeys ( AttributeContract storage self , uint256 tokenId ) internal view returns ( string [] memory ) Purpose : Retrieve all attribute keys for a token. Parameters : - self : Storage reference to attribute contract - tokenId : Token identifier Returns : Array of attribute keys Security : Prevents access to burned token attributes Example Usage : // Get all attribute keys for a token string [] memory keys = AttributeLib . _getAttributeKeys ( attributeStorage . attributes , tokenId ); for ( uint256 i = 0 ; i < keys . length ; i ++ ) { console . log ( \"Attribute key:\" , keys [ i ]); } Attribute Modification \u00b6 _setAttribute() \u00b6 function _setAttribute ( AttributeContract storage self , uint256 tokenId , Attribute memory attribute ) internal Purpose : Set or update a single attribute for a token. Parameters : - self : Storage reference to attribute contract - tokenId : Token identifier - attribute : Attribute data to set Process : 1. Verify token is not burned 2. Check if attribute key is new 3. Add key to keys array if new 4. Update key index mapping 5. Store attribute data Security : Prevents modification of burned token attributes Example Usage : // Set token rarity attribute Attribute memory rarityAttr = Attribute ({ key : \"rarity\" , attributeType : AttributeType . String , value : \"Legendary\" }); AttributeLib . _setAttribute ( attributeStorage . attributes , tokenId , rarityAttr ); _setAttributes() \u00b6 function _setAttributes ( AttributeContract storage self , uint256 tokenId , Attribute [] memory _attributes ) internal Purpose : Set multiple attributes for a token in a single operation. Parameters : - self : Storage reference to attribute contract - tokenId : Token identifier - _attributes : Array of attributes to set Implementation : function _setAttributes ( AttributeContract storage self , uint256 tokenId , Attribute [] memory _attributes ) internal { require ( self . burnedIds [ tokenId ] == false , \"Token has been burned\" ); uint256 attributesLength = _attributes . length ; for ( uint256 i = 0 ; i < attributesLength ; i ++ ) { _setAttribute ( self , tokenId , _attributes [ i ]); } } Benefits : - Gas efficient for multiple attributes - Atomic operation for consistency - Simplified batch updates Example Usage : // Set multiple attributes at once Attribute [] memory attributes = new Attribute []( 3 ); attributes [ 0 ] = Attribute ( \"rarity\" , AttributeType . String , \"Epic\" ); attributes [ 1 ] = Attribute ( \"level\" , AttributeType . Uint256 , \"25\" ); attributes [ 2 ] = Attribute ( \"element\" , AttributeType . String , \"Fire\" ); AttributeLib . _setAttributes ( attributeStorage . attributes , tokenId , attributes ); _removeAttribute() \u00b6 function _removeAttribute ( AttributeContract storage self , uint256 tokenId , string memory key ) internal Purpose : Remove a specific attribute from a token. Parameters : - self : Storage reference to attribute contract - tokenId : Token identifier - key : Attribute key to remove Process : 1. Verify token is not burned 2. Delete attribute data 3. Find key index in keys array 4. Shift remaining keys to fill gap 5. Update key indexes 6. Remove last element from array 7. Emit removal event Security : Prevents modification of burned token attributes Example Usage : // Remove temporary attribute AttributeLib . _removeAttribute ( attributeStorage . attributes , tokenId , \"temporary_boost\" ); Token Lifecycle \u00b6 _burn() \u00b6 function _burn ( AttributeContract storage self , uint256 tokenId ) internal Purpose : Mark a token as burned to prevent future attribute operations. Parameters : - self : Storage reference to attribute contract - tokenId : Token identifier to burn Implementation : function _burn ( AttributeContract storage self , uint256 tokenId ) internal { self . burnedIds [ tokenId ] = true ; } Effects : - Prevents all future attribute operations on the token - Preserves existing attribute data for historical purposes - Enables gas-efficient burn protection checks Integration Examples \u00b6 NFT Collection with Dynamic Attributes \u00b6 // NFT collection with evolving attributes contract EvolvingNFT { using AttributeLib for AttributeLib . AttributeStorage ; struct Evolution { uint256 requiredLevel ; string [] newAttributes ; string [] attributeValues ; } mapping ( uint256 => uint256 ) public tokenLevels ; mapping ( uint256 => uint256 ) public tokenExperience ; mapping ( uint256 => Evolution []) public evolutionPaths ; event TokenEvolved ( uint256 indexed tokenId , uint256 newLevel ); event ExperienceGained ( uint256 indexed tokenId , uint256 experience ); event AttributeEvolved ( uint256 indexed tokenId , string attribute , string newValue ); function initializeToken ( uint256 tokenId , string [] memory initialAttributes , string [] memory initialValues ) external { require ( _exists ( tokenId ), \"Token does not exist\" ); require ( initialAttributes . length == initialValues . length , \"Arrays length mismatch\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Set initial attributes Attribute [] memory attributes = new Attribute []( initialAttributes . length + 2 ); for ( uint256 i = 0 ; i < initialAttributes . length ; i ++ ) { attributes [ i ] = Attribute ({ key : initialAttributes [ i ], attributeType : AttributeType . String , value : initialValues [ i ] }); } // Add level and experience attributes [ initialAttributes . length ] = Attribute ({ key : \"level\" , attributeType : AttributeType . Uint256 , value : \"1\" }); attributes [ initialAttributes . length + 1 ] = Attribute ({ key : \"experience\" , attributeType : AttributeType . Uint256 , value : \"0\" }); AttributeLib . _setAttributes ( attrStorage . attributes , tokenId , attributes ); tokenLevels [ tokenId ] = 1 ; tokenExperience [ tokenId ] = 0 ; } function gainExperience ( uint256 tokenId , uint256 experience ) external { require ( _exists ( tokenId ), \"Token does not exist\" ); require ( experience > 0 , \"Experience must be positive\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Update experience tokenExperience [ tokenId ] += experience ; // Update experience attribute Attribute memory expAttr = Attribute ({ key : \"experience\" , attributeType : AttributeType . Uint256 , value : Strings . toString ( tokenExperience [ tokenId ]) }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , expAttr ); emit ExperienceGained ( tokenId , experience ); // Check for level up _checkLevelUp ( tokenId ); } function _checkLevelUp ( uint256 tokenId ) internal { uint256 currentLevel = tokenLevels [ tokenId ]; uint256 currentExp = tokenExperience [ tokenId ]; uint256 requiredExp = currentLevel * 100 ; // Simple formula if ( currentExp >= requiredExp ) { uint256 newLevel = currentLevel + 1 ; tokenLevels [ tokenId ] = newLevel ; AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Update level attribute Attribute memory levelAttr = Attribute ({ key : \"level\" , attributeType : AttributeType . Uint256 , value : Strings . toString ( newLevel ) }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , levelAttr ); emit TokenEvolved ( tokenId , newLevel ); // Apply evolution changes _applyEvolution ( tokenId , newLevel ); } } function _applyEvolution ( uint256 tokenId , uint256 newLevel ) internal { Evolution [] memory evolutions = evolutionPaths [ tokenId ]; for ( uint256 i = 0 ; i < evolutions . length ; i ++ ) { if ( evolutions [ i ]. requiredLevel == newLevel ) { AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Apply evolution attributes for ( uint256 j = 0 ; j < evolutions [ i ]. newAttributes . length ; j ++ ) { Attribute memory attr = Attribute ({ key : evolutions [ i ]. newAttributes [ j ], attributeType : AttributeType . String , value : evolutions [ i ]. attributeValues [ j ] }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , attr ); emit AttributeEvolved ( tokenId , evolutions [ i ]. newAttributes [ j ], evolutions [ i ]. attributeValues [ j ]); } break ; } } } function getTokenAttributes ( uint256 tokenId ) external view returns ( string [] memory keys , string [] memory values ) { require ( _exists ( tokenId ), \"Token does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); keys = AttributeLib . _getAttributeKeys ( attrStorage . attributes , tokenId ); values = AttributeLib . _getAttributeValues ( tokenId ); } function getAttribute ( uint256 tokenId , string memory key ) external view returns ( Attribute memory ) { require ( _exists ( tokenId ), \"Token does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); return AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , key ); } function _exists ( uint256 tokenId ) internal view returns ( bool ) { // Implementation would check token existence return true ; } } Gaming Item System \u00b6 // Gaming items with dynamic stats and upgrades contract GameItems { using AttributeLib for AttributeLib . AttributeStorage ; struct ItemType { string name ; string category ; string [] baseAttributes ; string [] baseValues ; uint256 maxLevel ; } struct UpgradePath { uint256 level ; string attribute ; string valueModifier ; uint256 cost ; } mapping ( uint256 => ItemType ) public itemTypes ; mapping ( uint256 => UpgradePath []) public upgradePaths ; mapping ( uint256 => uint256 ) public itemTypeIds ; IERC20 public upgradeToken ; event ItemCreated ( uint256 indexed tokenId , uint256 itemTypeId ); event ItemUpgraded ( uint256 indexed tokenId , string attribute , string newValue ); event ItemEnchanted ( uint256 indexed tokenId , string enchantment ); constructor ( address _upgradeToken ) { upgradeToken = IERC20 ( _upgradeToken ); } function createItemType ( uint256 itemTypeId , string memory name , string memory category , string [] memory baseAttributes , string [] memory baseValues , uint256 maxLevel ) external onlyGameMaster { require ( baseAttributes . length == baseValues . length , \"Arrays length mismatch\" ); itemTypes [ itemTypeId ] = ItemType ({ name : name , category : category , baseAttributes : baseAttributes , baseValues : baseValues , maxLevel : maxLevel }); } function mintItem ( address to , uint256 tokenId , uint256 itemTypeId ) external onlyGameMaster { ItemType memory itemType = itemTypes [ itemTypeId ]; require ( bytes ( itemType . name ). length > 0 , \"Item type does not exist\" ); // Mint token (implementation would call ERC721 mint) _mint ( to , tokenId ); itemTypeIds [ tokenId ] = itemTypeId ; AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Set base attributes Attribute [] memory attributes = new Attribute []( itemType . baseAttributes . length + 3 ); for ( uint256 i = 0 ; i < itemType . baseAttributes . length ; i ++ ) { attributes [ i ] = Attribute ({ key : itemType . baseAttributes [ i ], attributeType : AttributeType . String , value : itemType . baseValues [ i ] }); } // Add metadata attributes attributes [ itemType . baseAttributes . length ] = Attribute ({ key : \"item_type\" , attributeType : AttributeType . String , value : itemType . name }); attributes [ itemType . baseAttributes . length + 1 ] = Attribute ({ key : \"category\" , attributeType : AttributeType . String , value : itemType . category }); attributes [ itemType . baseAttributes . length + 2 ] = Attribute ({ key : \"level\" , attributeType : AttributeType . Uint256 , value : \"1\" }); AttributeLib . _setAttributes ( attrStorage . attributes , tokenId , attributes ); emit ItemCreated ( tokenId , itemTypeId ); } function upgradeItem ( uint256 tokenId , string memory attribute ) external { require ( _exists ( tokenId ), \"Token does not exist\" ); require ( _isApprovedOrOwner ( msg.sender , tokenId ), \"Not authorized\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Get current level Attribute memory levelAttr = AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , \"level\" ); uint256 currentLevel = StringsLib . parseUint ( levelAttr . value ); ItemType memory itemType = itemTypes [ itemTypeIds [ tokenId ]]; require ( currentLevel < itemType . maxLevel , \"Item at max level\" ); // Find upgrade path UpgradePath [] memory paths = upgradePaths [ itemTypeIds [ tokenId ]]; UpgradePath memory upgradePath ; bool found = false ; for ( uint256 i = 0 ; i < paths . length ; i ++ ) { if ( paths [ i ]. level == currentLevel + 1 && keccak256 ( bytes ( paths [ i ]. attribute )) == keccak256 ( bytes ( attribute ))) { upgradePath = paths [ i ]; found = true ; break ; } } require ( found , \"Upgrade path not found\" ); // Pay upgrade cost upgradeToken . transferFrom ( msg.sender , address ( this ), upgradePath . cost ); // Apply upgrade Attribute memory currentAttr = AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , attribute ); uint256 currentValue = StringsLib . parseUint ( currentAttr . value ); uint256 modifier = StringsLib . parseUint ( upgradePath . valueModifier ); uint256 newValue = currentValue + modifier ; Attribute memory newAttr = Attribute ({ key : attribute , attributeType : currentAttr . attributeType , value : Strings . toString ( newValue ) }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , newAttr ); // Update level Attribute memory newLevelAttr = Attribute ({ key : \"level\" , attributeType : AttributeType . Uint256 , value : Strings . toString ( currentLevel + 1 ) }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , newLevelAttr ); emit ItemUpgraded ( tokenId , attribute , Strings . toString ( newValue )); } function enchantItem ( uint256 tokenId , string memory enchantment , string memory value ) external onlyGameMaster { require ( _exists ( tokenId ), \"Token does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); Attribute memory enchantAttr = Attribute ({ key : enchantment , attributeType : AttributeType . String , value : value }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , enchantAttr ); emit ItemEnchanted ( tokenId , enchantment ); } function getItemStats ( uint256 tokenId ) external view returns ( string [] memory attributes , string [] memory values , string memory itemType , uint256 level ) { require ( _exists ( tokenId ), \"Token does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); attributes = AttributeLib . _getAttributeKeys ( attrStorage . attributes , tokenId ); values = AttributeLib . _getAttributeValues ( tokenId ); Attribute memory typeAttr = AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , \"item_type\" ); Attribute memory levelAttr = AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , \"level\" ); itemType = typeAttr . value ; level = StringsLib . parseUint ( levelAttr . value ); } function burnItem ( uint256 tokenId ) external { require ( _isApprovedOrOwner ( msg.sender , tokenId ), \"Not authorized\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); AttributeLib . _burn ( attrStorage . attributes , tokenId ); // Burn token (implementation would call ERC721 burn) _burn ( tokenId ); } function _mint ( address to , uint256 tokenId ) internal { // Implementation would mint ERC721 token } function _burn ( uint256 tokenId ) internal { // Implementation would burn ERC721 token } function _exists ( uint256 tokenId ) internal view returns ( bool ) { // Implementation would check token existence return true ; } function _isApprovedOrOwner ( address spender , uint256 tokenId ) internal view returns ( bool ) { // Implementation would check authorization return true ; } modifier onlyGameMaster () { // Implementation would check game master role _ ; } } Certificate System with Verifiable Attributes \u00b6 // Certificate system with verifiable attributes contract VerifiableCertificates { using AttributeLib for AttributeLib . AttributeStorage ; struct CertificateTemplate { string name ; string [] requiredAttributes ; address issuer ; bool active ; } struct Verification { address verifier ; uint256 timestamp ; bool verified ; string notes ; } mapping ( string => CertificateTemplate ) public certificateTemplates ; mapping ( uint256 => Verification []) public verifications ; mapping ( address => bool ) public authorizedVerifiers ; event CertificateIssued ( uint256 indexed tokenId , string template , address indexed recipient ); event AttributeVerified ( uint256 indexed tokenId , string attribute , address indexed verifier ); event VerificationAdded ( uint256 indexed tokenId , address indexed verifier , bool verified ); function createCertificateTemplate ( string memory templateName , string [] memory requiredAttributes ) external { certificateTemplates [ templateName ] = CertificateTemplate ({ name : templateName , requiredAttributes : requiredAttributes , issuer : msg.sender , active : true }); } function issueCertificate ( uint256 tokenId , address recipient , string memory templateName , string [] memory attributeValues ) external { CertificateTemplate memory template = certificateTemplates [ templateName ]; require ( template . active , \"Template not active\" ); require ( msg.sender == template . issuer , \"Not authorized issuer\" ); require ( template . requiredAttributes . length == attributeValues . length , \"Attributes length mismatch\" ); // Mint certificate token _mint ( recipient , tokenId ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Set certificate attributes Attribute [] memory attributes = new Attribute []( template . requiredAttributes . length + 3 ); for ( uint256 i = 0 ; i < template . requiredAttributes . length ; i ++ ) { attributes [ i ] = Attribute ({ key : template . requiredAttributes [ i ], attributeType : AttributeType . String , value : attributeValues [ i ] }); } // Add metadata attributes [ template . requiredAttributes . length ] = Attribute ({ key : \"template\" , attributeType : AttributeType . String , value : templateName }); attributes [ template . requiredAttributes . length + 1 ] = Attribute ({ key : \"issuer\" , attributeType : AttributeType . String , value : Strings . toHexString ( uint160 ( template . issuer ), 20 ) }); attributes [ template . requiredAttributes . length + 2 ] = Attribute ({ key : \"issue_date\" , attributeType : AttributeType . Uint256 , value : Strings . toString ( block.timestamp ) }); AttributeLib . _setAttributes ( attrStorage . attributes , tokenId , attributes ); emit CertificateIssued ( tokenId , templateName , recipient ); } function addVerification ( uint256 tokenId , bool verified , string memory notes ) external { require ( authorizedVerifiers [ msg.sender ], \"Not authorized verifier\" ); require ( _exists ( tokenId ), \"Certificate does not exist\" ); verifications [ tokenId ]. push ( Verification ({ verifier : msg.sender , timestamp : block.timestamp , verified : verified , notes : notes })); emit VerificationAdded ( tokenId , msg.sender , verified ); } function verifyAttribute ( uint256 tokenId , string memory attribute , string memory expectedValue ) external view returns ( bool ) { require ( _exists ( tokenId ), \"Certificate does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); Attribute memory attr = AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , attribute ); return keccak256 ( bytes ( attr . value )) == keccak256 ( bytes ( expectedValue )); } function getCertificateData ( uint256 tokenId ) external view returns ( string [] memory attributes , string [] memory values , Verification [] memory certificateVerifications ) { require ( _exists ( tokenId ), \"Certificate does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); attributes = AttributeLib . _getAttributeKeys ( attrStorage . attributes , tokenId ); values = AttributeLib . _getAttributeValues ( tokenId ); certificateVerifications = verifications [ tokenId ]; } function revokeCertificate ( uint256 tokenId ) external { require ( _exists ( tokenId ), \"Certificate does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); Attribute memory issuerAttr = AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , \"issuer\" ); address issuer = parseAddress ( issuerAttr . value ); require ( msg.sender == issuer , \"Not authorized\" ); // Add revocation attribute Attribute memory revokedAttr = Attribute ({ key : \"revoked\" , attributeType : AttributeType . Uint256 , value : Strings . toString ( block.timestamp ) }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , revokedAttr ); } function parseAddress ( string memory addressString ) internal pure returns ( address ) { // Implementation would parse hex string to address return address ( 0 ); } function _mint ( address to , uint256 tokenId ) internal { // Implementation would mint ERC721 token } function _exists ( uint256 tokenId ) internal view returns ( bool ) { // Implementation would check token existence return true ; } } Events \u00b6 Attribute Events \u00b6 event AttributeSet ( address indexed tokenAddress , uint256 tokenId , Attribute attribute ); event AttributeRemoved ( address indexed tokenAddress , uint256 tokenId , string attributeKey ); Security Considerations \u00b6 Burn Protection \u00b6 All attribute operations check burn status Prevents modification of burned token attributes Preserves historical data for burned tokens Efficient burn status checking Access Control \u00b6 No built-in access control (delegated to calling contracts) Calling contracts must implement proper authorization Event emission for audit trails Access Control \u00b6 No built-in access control (delegated to calling contracts) Calling contracts must implement proper authorization Event emission for audit trails Attribute modification requires proper token ownership validation Data Integrity \u00b6 Type information preserved for proper value interpretation String storage for all values ensures consistency Key uniqueness enforced within token scope Efficient indexing for key management Gas Optimization \u00b6 Storage Efficiency \u00b6 Optimized key-value storage with indexing Minimal storage writes during attribute operations Efficient key removal with array compaction Batch operations for multiple attributes Function Efficiency \u00b6 Direct storage access without external calls Efficient key lookup using index mapping Minimal gas overhead for attribute operations Optimized loops for batch operations Error Handling \u00b6 Common Errors \u00b6 \"Token has been burned\" - Attempt to modify burned token attributes Array length mismatches in batch operations Invalid token IDs or non-existent tokens Unauthorized attribute modifications Best Practices \u00b6 Always validate token existence before operations Check burn status before attribute modifications Implement proper access control in calling contracts Use batch operations for multiple attributes Handle missing attributes gracefully Testing Considerations \u00b6 Unit Tests \u00b6 Attribute setting and retrieval Batch attribute operations Key management and indexing Burn protection functionality Event emission verification Integration Tests \u00b6 Cross-contract attribute usage NFT metadata integration Gaming system attribute evolution Certificate verification workflows Attribute-based access control Edge Cases \u00b6 Empty attribute values Maximum key length handling Large attribute arrays Concurrent attribute modifications Burn state transitions Related Documentation \u00b6 IAttribute Interface - Attribute interface definition AttributeFacet - Attribute facet implementation ERC721 Integration - NFT attribute integration Gaming Attributes Guide - Gaming system attribute patterns Metadata Standards - Attribute metadata best practices This library provides comprehensive utilities for managing dynamic token attributes within the Gemforce platform, supporting typed metadata, efficient storage, and flexible attribute systems for NFTs, gaming items, certificates, and other tokenized assets.","title":"Attribute Lib"},{"location":"smart-contracts/libraries/attribute-lib/#attributelib-library","text":"","title":"AttributeLib Library"},{"location":"smart-contracts/libraries/attribute-lib/#overview","text":"The AttributeLib library provides core utilities for managing token attributes within the Gemforce platform. This library implements a flexible attribute system that allows tokens to have dynamic, typed metadata stored on-chain, supporting various data types and efficient key-value storage.","title":"Overview"},{"location":"smart-contracts/libraries/attribute-lib/#key-features","text":"Typed Attributes : Support for multiple data types (String, Bytes32, Uint256, Arrays) Dynamic Metadata : Runtime attribute assignment and modification Efficient Storage : Optimized key-value storage with indexing Burn Protection : Prevents attribute operations on burned tokens Batch Operations : Support for setting multiple attributes simultaneously Event Tracking : Comprehensive event emission for attribute changes","title":"Key Features"},{"location":"smart-contracts/libraries/attribute-lib/#library-definition","text":"// SPDX-License-Identifier: MIT pragma solidity ^ 0.8.6 ; library AttributeLib { // Storage management function attributeStorage () internal pure returns ( AttributeStorage storage ); // Attribute retrieval function _getAttribute ( AttributeContract storage self , uint256 tokenId , string memory key ) internal view returns ( Attribute memory ); function _getAttributeValues ( uint256 id ) internal view returns ( string [] memory ); function _getAttributeKeys ( AttributeContract storage self , uint256 tokenId ) internal view returns ( string [] memory ); // Attribute modification function _setAttribute ( AttributeContract storage self , uint256 tokenId , Attribute memory attribute ) internal ; function _setAttributes ( AttributeContract storage self , uint256 tokenId , Attribute [] memory _attributes ) internal ; function _removeAttribute ( AttributeContract storage self , uint256 tokenId , string memory key ) internal ; // Token lifecycle function _burn ( AttributeContract storage self , uint256 tokenId ) internal ; }","title":"Library Definition"},{"location":"smart-contracts/libraries/attribute-lib/#data-structures","text":"","title":"Data Structures"},{"location":"smart-contracts/libraries/attribute-lib/#attributetype-enum","text":"enum AttributeType { Unknown , // Undefined type String , // String value Bytes32 , // 32-byte value Uint256 , // 256-bit unsigned integer Uint8 , // 8-bit unsigned integer Uint256Array , // Array of 256-bit unsigned integers Uint8Array // Array of 8-bit unsigned integers } Purpose : Defines supported attribute data types for type-safe operations.","title":"AttributeType Enum"},{"location":"smart-contracts/libraries/attribute-lib/#attribute-struct","text":"struct Attribute { string key ; // Attribute identifier AttributeType attributeType ; // Type of the attribute value string value ; // String representation of the value } Purpose : Core attribute data structure containing key, type, and value. Design Notes : - All values stored as strings for simplicity and gas efficiency - Type information preserved for proper interpretation - Key serves as unique identifier within token scope","title":"Attribute Struct"},{"location":"smart-contracts/libraries/attribute-lib/#attributecontract-struct","text":"struct AttributeContract { mapping ( uint256 => bool ) burnedIds ; // Burned token tracking mapping ( uint256 => mapping ( string => Attribute )) attributes ; // Token attributes mapping ( uint256 => string []) attributeKeys ; // Token attribute keys mapping ( uint256 => mapping ( string => uint256 )) attributeKeysIndexes ; // Key index mapping } Purpose : Complete storage structure for token attribute management. Components : - burnedIds : Tracks burned tokens to prevent attribute operations - attributes : Nested mapping for token-specific attribute storage - attributeKeys : Ordered list of attribute keys per token - attributeKeysIndexes : Efficient key lookup and removal indexing","title":"AttributeContract Struct"},{"location":"smart-contracts/libraries/attribute-lib/#attributestorage-struct","text":"struct AttributeStorage { AttributeContract attributes ; } Purpose : Diamond storage wrapper for attribute data. Storage Position : bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nextblock.bitgem.app.AttributeStorage.storage\" );","title":"AttributeStorage Struct"},{"location":"smart-contracts/libraries/attribute-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/attribute-lib/#storage-management","text":"","title":"Storage Management"},{"location":"smart-contracts/libraries/attribute-lib/#attributestorage","text":"function attributeStorage () internal pure returns ( AttributeStorage storage ds ) Purpose : Access Diamond storage for attribute data using assembly. Implementation : function attributeStorage () internal pure returns ( AttributeStorage storage ds ) { bytes32 position = DIAMOND_STORAGE_POSITION ; assembly { ds . slot := position } } Returns : Storage reference to attribute data Usage : All attribute functions use this to access persistent storage.","title":"attributeStorage()"},{"location":"smart-contracts/libraries/attribute-lib/#attribute-retrieval","text":"","title":"Attribute Retrieval"},{"location":"smart-contracts/libraries/attribute-lib/#_getattribute","text":"function _getAttribute ( AttributeContract storage self , uint256 tokenId , string memory key ) internal view returns ( Attribute memory ) Purpose : Retrieve a specific attribute for a token by key. Parameters : - self : Storage reference to attribute contract - tokenId : Token identifier - key : Attribute key to retrieve Returns : Attribute struct containing key, type, and value Security : Prevents access to burned token attributes Example Usage : // Get token rarity attribute Attribute memory rarityAttr = AttributeLib . _getAttribute ( attributeStorage . attributes , tokenId , \"rarity\" ); console . log ( \"Token rarity:\" , rarityAttr . value );","title":"_getAttribute()"},{"location":"smart-contracts/libraries/attribute-lib/#_getattributevalues","text":"function _getAttributeValues ( uint256 id ) internal view returns ( string [] memory ) Purpose : Retrieve all attribute values for a token in key order. Parameters : - id : Token identifier Returns : Array of attribute values as strings Implementation : function _getAttributeValues ( uint256 id ) internal view returns ( string [] memory ) { AttributeContract storage ct = AttributeLib . attributeStorage (). attributes ; string [] memory keys = ct . attributeKeys [ id ]; string [] memory values = new string []( keys . length ); uint256 keysLength = keys . length ; for ( uint256 i = 0 ; i < keysLength ; i ++ ) { values [ i ] = ct . attributes [ id ][ keys [ i ]]. value ; } return values ; } Use Cases : - Metadata generation for NFTs - Bulk attribute export - Attribute comparison operations","title":"_getAttributeValues()"},{"location":"smart-contracts/libraries/attribute-lib/#_getattributekeys","text":"function _getAttributeKeys ( AttributeContract storage self , uint256 tokenId ) internal view returns ( string [] memory ) Purpose : Retrieve all attribute keys for a token. Parameters : - self : Storage reference to attribute contract - tokenId : Token identifier Returns : Array of attribute keys Security : Prevents access to burned token attributes Example Usage : // Get all attribute keys for a token string [] memory keys = AttributeLib . _getAttributeKeys ( attributeStorage . attributes , tokenId ); for ( uint256 i = 0 ; i < keys . length ; i ++ ) { console . log ( \"Attribute key:\" , keys [ i ]); }","title":"_getAttributeKeys()"},{"location":"smart-contracts/libraries/attribute-lib/#attribute-modification","text":"","title":"Attribute Modification"},{"location":"smart-contracts/libraries/attribute-lib/#_setattribute","text":"function _setAttribute ( AttributeContract storage self , uint256 tokenId , Attribute memory attribute ) internal Purpose : Set or update a single attribute for a token. Parameters : - self : Storage reference to attribute contract - tokenId : Token identifier - attribute : Attribute data to set Process : 1. Verify token is not burned 2. Check if attribute key is new 3. Add key to keys array if new 4. Update key index mapping 5. Store attribute data Security : Prevents modification of burned token attributes Example Usage : // Set token rarity attribute Attribute memory rarityAttr = Attribute ({ key : \"rarity\" , attributeType : AttributeType . String , value : \"Legendary\" }); AttributeLib . _setAttribute ( attributeStorage . attributes , tokenId , rarityAttr );","title":"_setAttribute()"},{"location":"smart-contracts/libraries/attribute-lib/#_setattributes","text":"function _setAttributes ( AttributeContract storage self , uint256 tokenId , Attribute [] memory _attributes ) internal Purpose : Set multiple attributes for a token in a single operation. Parameters : - self : Storage reference to attribute contract - tokenId : Token identifier - _attributes : Array of attributes to set Implementation : function _setAttributes ( AttributeContract storage self , uint256 tokenId , Attribute [] memory _attributes ) internal { require ( self . burnedIds [ tokenId ] == false , \"Token has been burned\" ); uint256 attributesLength = _attributes . length ; for ( uint256 i = 0 ; i < attributesLength ; i ++ ) { _setAttribute ( self , tokenId , _attributes [ i ]); } } Benefits : - Gas efficient for multiple attributes - Atomic operation for consistency - Simplified batch updates Example Usage : // Set multiple attributes at once Attribute [] memory attributes = new Attribute []( 3 ); attributes [ 0 ] = Attribute ( \"rarity\" , AttributeType . String , \"Epic\" ); attributes [ 1 ] = Attribute ( \"level\" , AttributeType . Uint256 , \"25\" ); attributes [ 2 ] = Attribute ( \"element\" , AttributeType . String , \"Fire\" ); AttributeLib . _setAttributes ( attributeStorage . attributes , tokenId , attributes );","title":"_setAttributes()"},{"location":"smart-contracts/libraries/attribute-lib/#_removeattribute","text":"function _removeAttribute ( AttributeContract storage self , uint256 tokenId , string memory key ) internal Purpose : Remove a specific attribute from a token. Parameters : - self : Storage reference to attribute contract - tokenId : Token identifier - key : Attribute key to remove Process : 1. Verify token is not burned 2. Delete attribute data 3. Find key index in keys array 4. Shift remaining keys to fill gap 5. Update key indexes 6. Remove last element from array 7. Emit removal event Security : Prevents modification of burned token attributes Example Usage : // Remove temporary attribute AttributeLib . _removeAttribute ( attributeStorage . attributes , tokenId , \"temporary_boost\" );","title":"_removeAttribute()"},{"location":"smart-contracts/libraries/attribute-lib/#token-lifecycle","text":"","title":"Token Lifecycle"},{"location":"smart-contracts/libraries/attribute-lib/#_burn","text":"function _burn ( AttributeContract storage self , uint256 tokenId ) internal Purpose : Mark a token as burned to prevent future attribute operations. Parameters : - self : Storage reference to attribute contract - tokenId : Token identifier to burn Implementation : function _burn ( AttributeContract storage self , uint256 tokenId ) internal { self . burnedIds [ tokenId ] = true ; } Effects : - Prevents all future attribute operations on the token - Preserves existing attribute data for historical purposes - Enables gas-efficient burn protection checks","title":"_burn()"},{"location":"smart-contracts/libraries/attribute-lib/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/libraries/attribute-lib/#nft-collection-with-dynamic-attributes","text":"// NFT collection with evolving attributes contract EvolvingNFT { using AttributeLib for AttributeLib . AttributeStorage ; struct Evolution { uint256 requiredLevel ; string [] newAttributes ; string [] attributeValues ; } mapping ( uint256 => uint256 ) public tokenLevels ; mapping ( uint256 => uint256 ) public tokenExperience ; mapping ( uint256 => Evolution []) public evolutionPaths ; event TokenEvolved ( uint256 indexed tokenId , uint256 newLevel ); event ExperienceGained ( uint256 indexed tokenId , uint256 experience ); event AttributeEvolved ( uint256 indexed tokenId , string attribute , string newValue ); function initializeToken ( uint256 tokenId , string [] memory initialAttributes , string [] memory initialValues ) external { require ( _exists ( tokenId ), \"Token does not exist\" ); require ( initialAttributes . length == initialValues . length , \"Arrays length mismatch\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Set initial attributes Attribute [] memory attributes = new Attribute []( initialAttributes . length + 2 ); for ( uint256 i = 0 ; i < initialAttributes . length ; i ++ ) { attributes [ i ] = Attribute ({ key : initialAttributes [ i ], attributeType : AttributeType . String , value : initialValues [ i ] }); } // Add level and experience attributes [ initialAttributes . length ] = Attribute ({ key : \"level\" , attributeType : AttributeType . Uint256 , value : \"1\" }); attributes [ initialAttributes . length + 1 ] = Attribute ({ key : \"experience\" , attributeType : AttributeType . Uint256 , value : \"0\" }); AttributeLib . _setAttributes ( attrStorage . attributes , tokenId , attributes ); tokenLevels [ tokenId ] = 1 ; tokenExperience [ tokenId ] = 0 ; } function gainExperience ( uint256 tokenId , uint256 experience ) external { require ( _exists ( tokenId ), \"Token does not exist\" ); require ( experience > 0 , \"Experience must be positive\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Update experience tokenExperience [ tokenId ] += experience ; // Update experience attribute Attribute memory expAttr = Attribute ({ key : \"experience\" , attributeType : AttributeType . Uint256 , value : Strings . toString ( tokenExperience [ tokenId ]) }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , expAttr ); emit ExperienceGained ( tokenId , experience ); // Check for level up _checkLevelUp ( tokenId ); } function _checkLevelUp ( uint256 tokenId ) internal { uint256 currentLevel = tokenLevels [ tokenId ]; uint256 currentExp = tokenExperience [ tokenId ]; uint256 requiredExp = currentLevel * 100 ; // Simple formula if ( currentExp >= requiredExp ) { uint256 newLevel = currentLevel + 1 ; tokenLevels [ tokenId ] = newLevel ; AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Update level attribute Attribute memory levelAttr = Attribute ({ key : \"level\" , attributeType : AttributeType . Uint256 , value : Strings . toString ( newLevel ) }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , levelAttr ); emit TokenEvolved ( tokenId , newLevel ); // Apply evolution changes _applyEvolution ( tokenId , newLevel ); } } function _applyEvolution ( uint256 tokenId , uint256 newLevel ) internal { Evolution [] memory evolutions = evolutionPaths [ tokenId ]; for ( uint256 i = 0 ; i < evolutions . length ; i ++ ) { if ( evolutions [ i ]. requiredLevel == newLevel ) { AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Apply evolution attributes for ( uint256 j = 0 ; j < evolutions [ i ]. newAttributes . length ; j ++ ) { Attribute memory attr = Attribute ({ key : evolutions [ i ]. newAttributes [ j ], attributeType : AttributeType . String , value : evolutions [ i ]. attributeValues [ j ] }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , attr ); emit AttributeEvolved ( tokenId , evolutions [ i ]. newAttributes [ j ], evolutions [ i ]. attributeValues [ j ]); } break ; } } } function getTokenAttributes ( uint256 tokenId ) external view returns ( string [] memory keys , string [] memory values ) { require ( _exists ( tokenId ), \"Token does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); keys = AttributeLib . _getAttributeKeys ( attrStorage . attributes , tokenId ); values = AttributeLib . _getAttributeValues ( tokenId ); } function getAttribute ( uint256 tokenId , string memory key ) external view returns ( Attribute memory ) { require ( _exists ( tokenId ), \"Token does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); return AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , key ); } function _exists ( uint256 tokenId ) internal view returns ( bool ) { // Implementation would check token existence return true ; } }","title":"NFT Collection with Dynamic Attributes"},{"location":"smart-contracts/libraries/attribute-lib/#gaming-item-system","text":"// Gaming items with dynamic stats and upgrades contract GameItems { using AttributeLib for AttributeLib . AttributeStorage ; struct ItemType { string name ; string category ; string [] baseAttributes ; string [] baseValues ; uint256 maxLevel ; } struct UpgradePath { uint256 level ; string attribute ; string valueModifier ; uint256 cost ; } mapping ( uint256 => ItemType ) public itemTypes ; mapping ( uint256 => UpgradePath []) public upgradePaths ; mapping ( uint256 => uint256 ) public itemTypeIds ; IERC20 public upgradeToken ; event ItemCreated ( uint256 indexed tokenId , uint256 itemTypeId ); event ItemUpgraded ( uint256 indexed tokenId , string attribute , string newValue ); event ItemEnchanted ( uint256 indexed tokenId , string enchantment ); constructor ( address _upgradeToken ) { upgradeToken = IERC20 ( _upgradeToken ); } function createItemType ( uint256 itemTypeId , string memory name , string memory category , string [] memory baseAttributes , string [] memory baseValues , uint256 maxLevel ) external onlyGameMaster { require ( baseAttributes . length == baseValues . length , \"Arrays length mismatch\" ); itemTypes [ itemTypeId ] = ItemType ({ name : name , category : category , baseAttributes : baseAttributes , baseValues : baseValues , maxLevel : maxLevel }); } function mintItem ( address to , uint256 tokenId , uint256 itemTypeId ) external onlyGameMaster { ItemType memory itemType = itemTypes [ itemTypeId ]; require ( bytes ( itemType . name ). length > 0 , \"Item type does not exist\" ); // Mint token (implementation would call ERC721 mint) _mint ( to , tokenId ); itemTypeIds [ tokenId ] = itemTypeId ; AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Set base attributes Attribute [] memory attributes = new Attribute []( itemType . baseAttributes . length + 3 ); for ( uint256 i = 0 ; i < itemType . baseAttributes . length ; i ++ ) { attributes [ i ] = Attribute ({ key : itemType . baseAttributes [ i ], attributeType : AttributeType . String , value : itemType . baseValues [ i ] }); } // Add metadata attributes attributes [ itemType . baseAttributes . length ] = Attribute ({ key : \"item_type\" , attributeType : AttributeType . String , value : itemType . name }); attributes [ itemType . baseAttributes . length + 1 ] = Attribute ({ key : \"category\" , attributeType : AttributeType . String , value : itemType . category }); attributes [ itemType . baseAttributes . length + 2 ] = Attribute ({ key : \"level\" , attributeType : AttributeType . Uint256 , value : \"1\" }); AttributeLib . _setAttributes ( attrStorage . attributes , tokenId , attributes ); emit ItemCreated ( tokenId , itemTypeId ); } function upgradeItem ( uint256 tokenId , string memory attribute ) external { require ( _exists ( tokenId ), \"Token does not exist\" ); require ( _isApprovedOrOwner ( msg.sender , tokenId ), \"Not authorized\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Get current level Attribute memory levelAttr = AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , \"level\" ); uint256 currentLevel = StringsLib . parseUint ( levelAttr . value ); ItemType memory itemType = itemTypes [ itemTypeIds [ tokenId ]]; require ( currentLevel < itemType . maxLevel , \"Item at max level\" ); // Find upgrade path UpgradePath [] memory paths = upgradePaths [ itemTypeIds [ tokenId ]]; UpgradePath memory upgradePath ; bool found = false ; for ( uint256 i = 0 ; i < paths . length ; i ++ ) { if ( paths [ i ]. level == currentLevel + 1 && keccak256 ( bytes ( paths [ i ]. attribute )) == keccak256 ( bytes ( attribute ))) { upgradePath = paths [ i ]; found = true ; break ; } } require ( found , \"Upgrade path not found\" ); // Pay upgrade cost upgradeToken . transferFrom ( msg.sender , address ( this ), upgradePath . cost ); // Apply upgrade Attribute memory currentAttr = AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , attribute ); uint256 currentValue = StringsLib . parseUint ( currentAttr . value ); uint256 modifier = StringsLib . parseUint ( upgradePath . valueModifier ); uint256 newValue = currentValue + modifier ; Attribute memory newAttr = Attribute ({ key : attribute , attributeType : currentAttr . attributeType , value : Strings . toString ( newValue ) }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , newAttr ); // Update level Attribute memory newLevelAttr = Attribute ({ key : \"level\" , attributeType : AttributeType . Uint256 , value : Strings . toString ( currentLevel + 1 ) }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , newLevelAttr ); emit ItemUpgraded ( tokenId , attribute , Strings . toString ( newValue )); } function enchantItem ( uint256 tokenId , string memory enchantment , string memory value ) external onlyGameMaster { require ( _exists ( tokenId ), \"Token does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); Attribute memory enchantAttr = Attribute ({ key : enchantment , attributeType : AttributeType . String , value : value }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , enchantAttr ); emit ItemEnchanted ( tokenId , enchantment ); } function getItemStats ( uint256 tokenId ) external view returns ( string [] memory attributes , string [] memory values , string memory itemType , uint256 level ) { require ( _exists ( tokenId ), \"Token does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); attributes = AttributeLib . _getAttributeKeys ( attrStorage . attributes , tokenId ); values = AttributeLib . _getAttributeValues ( tokenId ); Attribute memory typeAttr = AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , \"item_type\" ); Attribute memory levelAttr = AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , \"level\" ); itemType = typeAttr . value ; level = StringsLib . parseUint ( levelAttr . value ); } function burnItem ( uint256 tokenId ) external { require ( _isApprovedOrOwner ( msg.sender , tokenId ), \"Not authorized\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); AttributeLib . _burn ( attrStorage . attributes , tokenId ); // Burn token (implementation would call ERC721 burn) _burn ( tokenId ); } function _mint ( address to , uint256 tokenId ) internal { // Implementation would mint ERC721 token } function _burn ( uint256 tokenId ) internal { // Implementation would burn ERC721 token } function _exists ( uint256 tokenId ) internal view returns ( bool ) { // Implementation would check token existence return true ; } function _isApprovedOrOwner ( address spender , uint256 tokenId ) internal view returns ( bool ) { // Implementation would check authorization return true ; } modifier onlyGameMaster () { // Implementation would check game master role _ ; } }","title":"Gaming Item System"},{"location":"smart-contracts/libraries/attribute-lib/#certificate-system-with-verifiable-attributes","text":"// Certificate system with verifiable attributes contract VerifiableCertificates { using AttributeLib for AttributeLib . AttributeStorage ; struct CertificateTemplate { string name ; string [] requiredAttributes ; address issuer ; bool active ; } struct Verification { address verifier ; uint256 timestamp ; bool verified ; string notes ; } mapping ( string => CertificateTemplate ) public certificateTemplates ; mapping ( uint256 => Verification []) public verifications ; mapping ( address => bool ) public authorizedVerifiers ; event CertificateIssued ( uint256 indexed tokenId , string template , address indexed recipient ); event AttributeVerified ( uint256 indexed tokenId , string attribute , address indexed verifier ); event VerificationAdded ( uint256 indexed tokenId , address indexed verifier , bool verified ); function createCertificateTemplate ( string memory templateName , string [] memory requiredAttributes ) external { certificateTemplates [ templateName ] = CertificateTemplate ({ name : templateName , requiredAttributes : requiredAttributes , issuer : msg.sender , active : true }); } function issueCertificate ( uint256 tokenId , address recipient , string memory templateName , string [] memory attributeValues ) external { CertificateTemplate memory template = certificateTemplates [ templateName ]; require ( template . active , \"Template not active\" ); require ( msg.sender == template . issuer , \"Not authorized issuer\" ); require ( template . requiredAttributes . length == attributeValues . length , \"Attributes length mismatch\" ); // Mint certificate token _mint ( recipient , tokenId ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); // Set certificate attributes Attribute [] memory attributes = new Attribute []( template . requiredAttributes . length + 3 ); for ( uint256 i = 0 ; i < template . requiredAttributes . length ; i ++ ) { attributes [ i ] = Attribute ({ key : template . requiredAttributes [ i ], attributeType : AttributeType . String , value : attributeValues [ i ] }); } // Add metadata attributes [ template . requiredAttributes . length ] = Attribute ({ key : \"template\" , attributeType : AttributeType . String , value : templateName }); attributes [ template . requiredAttributes . length + 1 ] = Attribute ({ key : \"issuer\" , attributeType : AttributeType . String , value : Strings . toHexString ( uint160 ( template . issuer ), 20 ) }); attributes [ template . requiredAttributes . length + 2 ] = Attribute ({ key : \"issue_date\" , attributeType : AttributeType . Uint256 , value : Strings . toString ( block.timestamp ) }); AttributeLib . _setAttributes ( attrStorage . attributes , tokenId , attributes ); emit CertificateIssued ( tokenId , templateName , recipient ); } function addVerification ( uint256 tokenId , bool verified , string memory notes ) external { require ( authorizedVerifiers [ msg.sender ], \"Not authorized verifier\" ); require ( _exists ( tokenId ), \"Certificate does not exist\" ); verifications [ tokenId ]. push ( Verification ({ verifier : msg.sender , timestamp : block.timestamp , verified : verified , notes : notes })); emit VerificationAdded ( tokenId , msg.sender , verified ); } function verifyAttribute ( uint256 tokenId , string memory attribute , string memory expectedValue ) external view returns ( bool ) { require ( _exists ( tokenId ), \"Certificate does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); Attribute memory attr = AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , attribute ); return keccak256 ( bytes ( attr . value )) == keccak256 ( bytes ( expectedValue )); } function getCertificateData ( uint256 tokenId ) external view returns ( string [] memory attributes , string [] memory values , Verification [] memory certificateVerifications ) { require ( _exists ( tokenId ), \"Certificate does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); attributes = AttributeLib . _getAttributeKeys ( attrStorage . attributes , tokenId ); values = AttributeLib . _getAttributeValues ( tokenId ); certificateVerifications = verifications [ tokenId ]; } function revokeCertificate ( uint256 tokenId ) external { require ( _exists ( tokenId ), \"Certificate does not exist\" ); AttributeLib . AttributeStorage storage attrStorage = AttributeLib . attributeStorage (); Attribute memory issuerAttr = AttributeLib . _getAttribute ( attrStorage . attributes , tokenId , \"issuer\" ); address issuer = parseAddress ( issuerAttr . value ); require ( msg.sender == issuer , \"Not authorized\" ); // Add revocation attribute Attribute memory revokedAttr = Attribute ({ key : \"revoked\" , attributeType : AttributeType . Uint256 , value : Strings . toString ( block.timestamp ) }); AttributeLib . _setAttribute ( attrStorage . attributes , tokenId , revokedAttr ); } function parseAddress ( string memory addressString ) internal pure returns ( address ) { // Implementation would parse hex string to address return address ( 0 ); } function _mint ( address to , uint256 tokenId ) internal { // Implementation would mint ERC721 token } function _exists ( uint256 tokenId ) internal view returns ( bool ) { // Implementation would check token existence return true ; } }","title":"Certificate System with Verifiable Attributes"},{"location":"smart-contracts/libraries/attribute-lib/#events","text":"","title":"Events"},{"location":"smart-contracts/libraries/attribute-lib/#attribute-events","text":"event AttributeSet ( address indexed tokenAddress , uint256 tokenId , Attribute attribute ); event AttributeRemoved ( address indexed tokenAddress , uint256 tokenId , string attributeKey );","title":"Attribute Events"},{"location":"smart-contracts/libraries/attribute-lib/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/attribute-lib/#burn-protection","text":"All attribute operations check burn status Prevents modification of burned token attributes Preserves historical data for burned tokens Efficient burn status checking","title":"Burn Protection"},{"location":"smart-contracts/libraries/attribute-lib/#access-control","text":"No built-in access control (delegated to calling contracts) Calling contracts must implement proper authorization Event emission for audit trails","title":"Access Control"},{"location":"smart-contracts/libraries/attribute-lib/#access-control_1","text":"No built-in access control (delegated to calling contracts) Calling contracts must implement proper authorization Event emission for audit trails Attribute modification requires proper token ownership validation","title":"Access Control"},{"location":"smart-contracts/libraries/attribute-lib/#data-integrity","text":"Type information preserved for proper value interpretation String storage for all values ensures consistency Key uniqueness enforced within token scope Efficient indexing for key management","title":"Data Integrity"},{"location":"smart-contracts/libraries/attribute-lib/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/libraries/attribute-lib/#storage-efficiency","text":"Optimized key-value storage with indexing Minimal storage writes during attribute operations Efficient key removal with array compaction Batch operations for multiple attributes","title":"Storage Efficiency"},{"location":"smart-contracts/libraries/attribute-lib/#function-efficiency","text":"Direct storage access without external calls Efficient key lookup using index mapping Minimal gas overhead for attribute operations Optimized loops for batch operations","title":"Function Efficiency"},{"location":"smart-contracts/libraries/attribute-lib/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/libraries/attribute-lib/#common-errors","text":"\"Token has been burned\" - Attempt to modify burned token attributes Array length mismatches in batch operations Invalid token IDs or non-existent tokens Unauthorized attribute modifications","title":"Common Errors"},{"location":"smart-contracts/libraries/attribute-lib/#best-practices","text":"Always validate token existence before operations Check burn status before attribute modifications Implement proper access control in calling contracts Use batch operations for multiple attributes Handle missing attributes gracefully","title":"Best Practices"},{"location":"smart-contracts/libraries/attribute-lib/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/libraries/attribute-lib/#unit-tests","text":"Attribute setting and retrieval Batch attribute operations Key management and indexing Burn protection functionality Event emission verification","title":"Unit Tests"},{"location":"smart-contracts/libraries/attribute-lib/#integration-tests","text":"Cross-contract attribute usage NFT metadata integration Gaming system attribute evolution Certificate verification workflows Attribute-based access control","title":"Integration Tests"},{"location":"smart-contracts/libraries/attribute-lib/#edge-cases","text":"Empty attribute values Maximum key length handling Large attribute arrays Concurrent attribute modifications Burn state transitions","title":"Edge Cases"},{"location":"smart-contracts/libraries/attribute-lib/#related-documentation","text":"IAttribute Interface - Attribute interface definition AttributeFacet - Attribute facet implementation ERC721 Integration - NFT attribute integration Gaming Attributes Guide - Gaming system attribute patterns Metadata Standards - Attribute metadata best practices This library provides comprehensive utilities for managing dynamic token attributes within the Gemforce platform, supporting typed metadata, efficient storage, and flexible attribute systems for NFTs, gaming items, certificates, and other tokenized assets.","title":"Related Documentation"},{"location":"smart-contracts/libraries/carbon-credit-lib/","text":"CarbonCreditLib Library \u00b6 Overview \u00b6 The CarbonCreditLib library provides core utilities and data structures for managing carbon credits associated with ERC721 tokens within the Gemforce platform. This library implements the Diamond Standard storage pattern and provides essential functions for carbon credit initialization, retirement, and status management. Key Features \u00b6 Diamond Storage Pattern : Secure storage isolation using Diamond Standard Token Balance Management : Track carbon credit balances per ERC721 token Credit Retirement : Permanent retirement of carbon credits to prevent double-counting Status Tracking : Monitor active vs. retired carbon credit status Token Validation : Ensure token existence before operations Gas Optimization : Efficient storage layout and operations Library Definition \u00b6 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; enum CarbonCreditStatus { ACTIVE , RETIRED } import \"@openzeppelin/contracts/interfaces/IERC721.sol\" ; library CarbonCreditLib { struct CarbonCreditStorage { mapping ( uint256 => uint256 ) tokenBalances ; } bytes32 constant CARBON_CREDIT_STORAGE_POSITION = keccak256 ( \"diamond.standard.carbon.credit.storage\" ); function carbonCreditStorage () internal pure returns ( CarbonCreditStorage storage cs ); function _tokenExists ( uint256 tokenId ) internal view returns ( bool ); function initializeBalance ( CarbonCreditStorage storage self , uint256 tokenId , uint256 initialBalance ) internal ; function retireCredits ( CarbonCreditStorage storage self , uint256 tokenId , uint256 amount ) internal ; function getBalance ( CarbonCreditStorage storage self , uint256 tokenId ) internal view returns ( uint256 ); function getCarbonCreditStatus ( CarbonCreditStorage storage self , uint256 tokenId ) internal view returns ( CarbonCreditStatus ); } Data Structures \u00b6 CarbonCreditStatus Enum \u00b6 enum CarbonCreditStatus { ACTIVE , // Token has remaining carbon credits RETIRED // All carbon credits have been retired } Purpose : Represents the current status of carbon credits for a token. Values : - ACTIVE (0): Token has remaining carbon credits available - RETIRED (1): All carbon credits have been permanently retired CarbonCreditStorage Struct \u00b6 struct CarbonCreditStorage { mapping ( uint256 => uint256 ) tokenBalances ; } Purpose : Diamond storage structure for carbon credit data. Fields : - tokenBalances : Mapping from token ID to carbon credit balance Storage Management \u00b6 carbonCreditStorage() \u00b6 function carbonCreditStorage () internal pure returns ( CarbonCreditStorage storage cs ) Purpose : Access the Diamond storage slot for carbon credit data. Returns : Storage reference to the carbon credit storage structure Implementation : function carbonCreditStorage () internal pure returns ( CarbonCreditStorage storage cs ) { bytes32 position = CARBON_CREDIT_STORAGE_POSITION ; assembly { cs . slot := position } } Storage Position : keccak256(\"diamond.standard.carbon.credit.storage\") Usage Example : // Access carbon credit storage in a facet CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 balance = cs . tokenBalances [ tokenId ]; Core Functions \u00b6 Token Validation \u00b6 _tokenExists() \u00b6 function _tokenExists ( uint256 tokenId ) internal view returns ( bool ) Purpose : Verify that an ERC721 token exists by checking if it has an owner. Parameters : - tokenId (uint256): The ID of the token to check Returns : Boolean indicating whether the token exists Implementation Details : - Uses try-catch to safely call ownerOf() - Returns false if the call reverts (token doesn't exist) - Returns true if owner is not zero address Example Usage : // Check if token exists before operations uint256 tokenId = 1 ; bool exists = CarbonCreditLib . _tokenExists ( tokenId ); require ( exists , \"Token does not exist\" ); Balance Management \u00b6 initializeBalance() \u00b6 function initializeBalance ( CarbonCreditStorage storage self , uint256 tokenId , uint256 initialBalance ) internal Purpose : Initialize carbon credit balance for a specific ERC721 token. Parameters : - self (CarbonCreditStorage storage): Storage reference - tokenId (uint256): The ID of the ERC721 token - initialBalance (uint256): The initial carbon credit balance Requirements : - Token must not already have carbon credits initialized - Token must exist (have a valid owner) - Initial balance must be greater than zero Validation Logic : require ( self . tokenBalances [ tokenId ] == 0 , \"Carbon credits already initialized\" ); require ( _tokenExists ( tokenId ), \"Token does not exist\" ); require ( initialBalance > 0 , \"Initial balance must be greater than zero\" ); Example Usage : // Initialize carbon credits for a newly minted environmental NFT CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 tokenId = 1 ; uint256 initialCredits = 1000 ; CarbonCreditLib . initializeBalance ( cs , tokenId , initialCredits ); retireCredits() \u00b6 function retireCredits ( CarbonCreditStorage storage self , uint256 tokenId , uint256 amount ) internal Purpose : Permanently retire a specified amount of carbon credits from a token. Parameters : - self (CarbonCreditStorage storage): Storage reference - tokenId (uint256): The ID of the ERC721 token - amount (uint256): The amount of carbon credits to retire Requirements : - Amount must be greater than zero - Token must have sufficient carbon credit balance - Retirement is permanent and irreversible Validation Logic : require ( amount > 0 , \"Amount must be greater than zero\" ); require ( self . tokenBalances [ tokenId ] >= amount , \"Insufficient balance\" ); Example Usage : // Retire carbon credits to offset emissions CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 tokenId = 1 ; uint256 retireAmount = 250 ; CarbonCreditLib . retireCredits ( cs , tokenId , retireAmount ); Query Functions \u00b6 getBalance() \u00b6 function getBalance ( CarbonCreditStorage storage self , uint256 tokenId ) internal view returns ( uint256 ) Purpose : Get the current carbon credit balance for a specific token. Parameters : - self (CarbonCreditStorage storage): Storage reference - tokenId (uint256): The ID of the ERC721 token Returns : Current carbon credit balance for the token Example Usage : // Check current carbon credit balance CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 tokenId = 1 ; uint256 balance = CarbonCreditLib . getBalance ( cs , tokenId ); getCarbonCreditStatus() \u00b6 function getCarbonCreditStatus ( CarbonCreditStorage storage self , uint256 tokenId ) internal view returns ( CarbonCreditStatus ) Purpose : Get the current status of carbon credits for a token. Parameters : - self (CarbonCreditStorage storage): Storage reference - tokenId (uint256): The ID of the ERC721 token Returns : CarbonCreditStatus enum value Logic : - Returns RETIRED if balance is zero - Returns ACTIVE if balance is greater than zero Example Usage : // Check carbon credit status CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 tokenId = 1 ; CarbonCreditStatus status = CarbonCreditLib . getCarbonCreditStatus ( cs , tokenId ); if ( status == CarbonCreditStatus . ACTIVE ) { // Token has active carbon credits } else { // All credits have been retired } Integration Examples \u00b6 Environmental NFT Contract \u00b6 // Environmental NFT contract using CarbonCreditLib contract EnvironmentalNFT is ERC721 , IDiamondCut { using CarbonCreditLib for CarbonCreditLib . CarbonCreditStorage ; event CarbonCreditsInitialized ( uint256 indexed tokenId , uint256 initialBalance ); event CarbonCreditsRetired ( uint256 indexed tokenId , uint256 amount , uint256 remainingBalance ); function mintWithCarbonCredits ( address to , uint256 tokenId , uint256 carbonCredits , string memory uri ) external onlyMinter { // Mint the NFT _mint ( to , tokenId ); _setTokenURI ( tokenId , uri ); // Initialize carbon credits CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); CarbonCreditLib . initializeBalance ( cs , tokenId , carbonCredits ); emit CarbonCreditsInitialized ( tokenId , carbonCredits ); } function retireCarbonCredits ( uint256 tokenId , uint256 amount ) external { require ( ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 balanceBefore = CarbonCreditLib . getBalance ( cs , tokenId ); CarbonCreditLib . retireCredits ( cs , tokenId , amount ); uint256 balanceAfter = CarbonCreditLib . getBalance ( cs , tokenId ); emit CarbonCreditsRetired ( tokenId , amount , balanceAfter ); } function getCarbonCreditInfo ( uint256 tokenId ) external view returns ( uint256 balance , CarbonCreditStatus status ) { CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); balance = CarbonCreditLib . getBalance ( cs , tokenId ); status = CarbonCreditLib . getCarbonCreditStatus ( cs , tokenId ); } modifier onlyMinter () { // Implementation would check for minter role _ ; } } Carbon Credit Marketplace \u00b6 // Marketplace for trading environmental NFTs with carbon credits contract CarbonCreditMarketplace { using CarbonCreditLib for CarbonCreditLib . CarbonCreditStorage ; struct Listing { uint256 tokenId ; address seller ; uint256 price ; uint256 carbonCredits ; bool active ; } mapping ( uint256 => Listing ) public listings ; uint256 public nextListingId ; event NFTListed ( uint256 indexed listingId , uint256 indexed tokenId , uint256 carbonCredits , uint256 price ); event NFTPurchased ( uint256 indexed listingId , address indexed buyer , uint256 creditsRetired ); function listNFT ( uint256 tokenId , uint256 price , address nftContract ) external returns ( uint256 listingId ) { require ( IERC721 ( nftContract ). ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); // Get carbon credit information CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 carbonCredits = CarbonCreditLib . getBalance ( cs , tokenId ); require ( carbonCredits > 0 , \"No carbon credits associated\" ); listingId = nextListingId ++ ; listings [ listingId ] = Listing ({ tokenId : tokenId , seller : msg.sender , price : price , carbonCredits : carbonCredits , active : true }); emit NFTListed ( listingId , tokenId , carbonCredits , price ); } function purchaseNFT ( uint256 listingId , uint256 creditsToRetire , address nftContract ) external payable { Listing storage listing = listings [ listingId ]; require ( listing . active , \"Listing not active\" ); require ( msg.value >= listing . price , \"Insufficient payment\" ); CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 currentCredits = CarbonCreditLib . getBalance ( cs , listing . tokenId ); require ( creditsToRetire <= currentCredits , \"Cannot retire more credits than available\" ); // Transfer NFT IERC721 ( nftContract ). safeTransferFrom ( listing . seller , msg.sender , listing . tokenId ); // Retire carbon credits if requested if ( creditsToRetire > 0 ) { CarbonCreditLib . retireCredits ( cs , listing . tokenId , creditsToRetire ); } // Transfer payment payable ( listing . seller ). transfer ( msg.value ); listing . active = false ; emit NFTPurchased ( listingId , msg.sender , creditsToRetire ); } function getListingCarbonInfo ( uint256 listingId ) external view returns ( uint256 currentBalance , CarbonCreditStatus status , uint256 listedCredits ) { Listing memory listing = listings [ listingId ]; CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); currentBalance = CarbonCreditLib . getBalance ( cs , listing . tokenId ); status = CarbonCreditLib . getCarbonCreditStatus ( cs , listing . tokenId ); listedCredits = listing . carbonCredits ; } } Carbon Offset Tracking System \u00b6 // System for tracking carbon offset activities contract CarbonOffsetTracker { using CarbonCreditLib for CarbonCreditLib . CarbonCreditStorage ; struct OffsetRecord { address offsetter ; uint256 tokenId ; uint256 amount ; uint256 timestamp ; string purpose ; } mapping ( uint256 => OffsetRecord ) public offsetRecords ; mapping ( address => uint256 []) public userOffsets ; uint256 public nextRecordId ; event CarbonOffset ( uint256 indexed recordId , address indexed offsetter , uint256 indexed tokenId , uint256 amount , string purpose ); function recordCarbonOffset ( uint256 tokenId , uint256 amount , string memory purpose , address nftContract ) external returns ( uint256 recordId ) { require ( IERC721 ( nftContract ). ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); // Verify sufficient balance uint256 currentBalance = CarbonCreditLib . getBalance ( cs , tokenId ); require ( currentBalance >= amount , \"Insufficient carbon credits\" ); // Retire the credits CarbonCreditLib . retireCredits ( cs , tokenId , amount ); // Record the offset recordId = nextRecordId ++ ; offsetRecords [ recordId ] = OffsetRecord ({ offsetter : msg.sender , tokenId : tokenId , amount : amount , timestamp : block.timestamp , purpose : purpose }); userOffsets [ msg.sender ]. push ( recordId ); emit CarbonOffset ( recordId , msg.sender , tokenId , amount , purpose ); } function getUserOffsetSummary ( address user ) external view returns ( uint256 totalOffsetsCount , uint256 totalCreditsRetired , uint256 [] memory recordIds ) { recordIds = userOffsets [ user ]; totalOffsetsCount = recordIds . length ; for ( uint256 i = 0 ; i < recordIds . length ; i ++ ) { totalCreditsRetired += offsetRecords [ recordIds [ i ]]. amount ; } } function getTokenOffsetHistory ( uint256 tokenId ) external view returns ( uint256 [] memory recordIds , uint256 totalRetired ) { // Find all offset records for this token uint256 count = 0 ; for ( uint256 i = 0 ; i < nextRecordId ; i ++ ) { if ( offsetRecords [ i ]. tokenId == tokenId ) { count ++ ; } } recordIds = new uint256 []( count ); uint256 index = 0 ; for ( uint256 i = 0 ; i < nextRecordId ; i ++ ) { if ( offsetRecords [ i ]. tokenId == tokenId ) { recordIds [ index ] = i ; totalRetired += offsetRecords [ i ]. amount ; index ++ ; } } } } Security Considerations \u00b6 Storage Security \u00b6 Uses Diamond Standard storage pattern for isolation Prevents storage collisions with unique storage position Secure access control through internal functions only Validation Security \u00b6 Token existence validation before operations Balance validation before retirement Prevention of double initialization Overflow protection in balance calculations Operational Security \u00b6 Immutable retirement operations Consistent state management Safe external contract interactions Error handling for edge cases Gas Optimization \u00b6 Storage Efficiency \u00b6 Minimal storage footprint with single mapping Efficient storage slot usage Optimized for Diamond Standard pattern Function Efficiency \u00b6 Internal functions for gas savings Minimal external calls Efficient validation logic Optimized assembly for storage access Error Handling \u00b6 Common Errors \u00b6 \"Carbon credits already initialized\" - Attempting to initialize twice \"Token does not exist\" - Operating on non-existent token \"Initial balance must be greater than zero\" - Invalid initialization \"Amount must be greater than zero\" - Invalid retirement amount \"Insufficient balance\" - Attempting to retire more than available Best Practices \u00b6 Always validate token existence before operations Check balances before retirement operations Handle initialization state properly Use appropriate error messages for debugging Testing Considerations \u00b6 Unit Tests \u00b6 Storage pattern implementation Token existence validation Balance initialization and management Credit retirement functionality Status determination logic Integration Tests \u00b6 Integration with ERC721 contracts Diamond facet integration Multi-token operations Edge case handling Gas usage optimization Related Documentation \u00b6 ICarbonCredit Interface - Carbon credit interface definition CarbonCreditFacet - Carbon credit facet implementation Diamond Standard Guide - Diamond pattern implementation Environmental NFT Guide - Environmental asset tokenization Carbon Offset Integration - Carbon offset program integration This library provides the core utilities and data structures for carbon credit management within the Gemforce platform, implementing secure storage patterns and essential operations for environmental asset tokenization.","title":"Carbon Credit Lib"},{"location":"smart-contracts/libraries/carbon-credit-lib/#carboncreditlib-library","text":"","title":"CarbonCreditLib Library"},{"location":"smart-contracts/libraries/carbon-credit-lib/#overview","text":"The CarbonCreditLib library provides core utilities and data structures for managing carbon credits associated with ERC721 tokens within the Gemforce platform. This library implements the Diamond Standard storage pattern and provides essential functions for carbon credit initialization, retirement, and status management.","title":"Overview"},{"location":"smart-contracts/libraries/carbon-credit-lib/#key-features","text":"Diamond Storage Pattern : Secure storage isolation using Diamond Standard Token Balance Management : Track carbon credit balances per ERC721 token Credit Retirement : Permanent retirement of carbon credits to prevent double-counting Status Tracking : Monitor active vs. retired carbon credit status Token Validation : Ensure token existence before operations Gas Optimization : Efficient storage layout and operations","title":"Key Features"},{"location":"smart-contracts/libraries/carbon-credit-lib/#library-definition","text":"// SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; enum CarbonCreditStatus { ACTIVE , RETIRED } import \"@openzeppelin/contracts/interfaces/IERC721.sol\" ; library CarbonCreditLib { struct CarbonCreditStorage { mapping ( uint256 => uint256 ) tokenBalances ; } bytes32 constant CARBON_CREDIT_STORAGE_POSITION = keccak256 ( \"diamond.standard.carbon.credit.storage\" ); function carbonCreditStorage () internal pure returns ( CarbonCreditStorage storage cs ); function _tokenExists ( uint256 tokenId ) internal view returns ( bool ); function initializeBalance ( CarbonCreditStorage storage self , uint256 tokenId , uint256 initialBalance ) internal ; function retireCredits ( CarbonCreditStorage storage self , uint256 tokenId , uint256 amount ) internal ; function getBalance ( CarbonCreditStorage storage self , uint256 tokenId ) internal view returns ( uint256 ); function getCarbonCreditStatus ( CarbonCreditStorage storage self , uint256 tokenId ) internal view returns ( CarbonCreditStatus ); }","title":"Library Definition"},{"location":"smart-contracts/libraries/carbon-credit-lib/#data-structures","text":"","title":"Data Structures"},{"location":"smart-contracts/libraries/carbon-credit-lib/#carboncreditstatus-enum","text":"enum CarbonCreditStatus { ACTIVE , // Token has remaining carbon credits RETIRED // All carbon credits have been retired } Purpose : Represents the current status of carbon credits for a token. Values : - ACTIVE (0): Token has remaining carbon credits available - RETIRED (1): All carbon credits have been permanently retired","title":"CarbonCreditStatus Enum"},{"location":"smart-contracts/libraries/carbon-credit-lib/#carboncreditstorage-struct","text":"struct CarbonCreditStorage { mapping ( uint256 => uint256 ) tokenBalances ; } Purpose : Diamond storage structure for carbon credit data. Fields : - tokenBalances : Mapping from token ID to carbon credit balance","title":"CarbonCreditStorage Struct"},{"location":"smart-contracts/libraries/carbon-credit-lib/#storage-management","text":"","title":"Storage Management"},{"location":"smart-contracts/libraries/carbon-credit-lib/#carboncreditstorage","text":"function carbonCreditStorage () internal pure returns ( CarbonCreditStorage storage cs ) Purpose : Access the Diamond storage slot for carbon credit data. Returns : Storage reference to the carbon credit storage structure Implementation : function carbonCreditStorage () internal pure returns ( CarbonCreditStorage storage cs ) { bytes32 position = CARBON_CREDIT_STORAGE_POSITION ; assembly { cs . slot := position } } Storage Position : keccak256(\"diamond.standard.carbon.credit.storage\") Usage Example : // Access carbon credit storage in a facet CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 balance = cs . tokenBalances [ tokenId ];","title":"carbonCreditStorage()"},{"location":"smart-contracts/libraries/carbon-credit-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/carbon-credit-lib/#token-validation","text":"","title":"Token Validation"},{"location":"smart-contracts/libraries/carbon-credit-lib/#_tokenexists","text":"function _tokenExists ( uint256 tokenId ) internal view returns ( bool ) Purpose : Verify that an ERC721 token exists by checking if it has an owner. Parameters : - tokenId (uint256): The ID of the token to check Returns : Boolean indicating whether the token exists Implementation Details : - Uses try-catch to safely call ownerOf() - Returns false if the call reverts (token doesn't exist) - Returns true if owner is not zero address Example Usage : // Check if token exists before operations uint256 tokenId = 1 ; bool exists = CarbonCreditLib . _tokenExists ( tokenId ); require ( exists , \"Token does not exist\" );","title":"_tokenExists()"},{"location":"smart-contracts/libraries/carbon-credit-lib/#balance-management","text":"","title":"Balance Management"},{"location":"smart-contracts/libraries/carbon-credit-lib/#initializebalance","text":"function initializeBalance ( CarbonCreditStorage storage self , uint256 tokenId , uint256 initialBalance ) internal Purpose : Initialize carbon credit balance for a specific ERC721 token. Parameters : - self (CarbonCreditStorage storage): Storage reference - tokenId (uint256): The ID of the ERC721 token - initialBalance (uint256): The initial carbon credit balance Requirements : - Token must not already have carbon credits initialized - Token must exist (have a valid owner) - Initial balance must be greater than zero Validation Logic : require ( self . tokenBalances [ tokenId ] == 0 , \"Carbon credits already initialized\" ); require ( _tokenExists ( tokenId ), \"Token does not exist\" ); require ( initialBalance > 0 , \"Initial balance must be greater than zero\" ); Example Usage : // Initialize carbon credits for a newly minted environmental NFT CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 tokenId = 1 ; uint256 initialCredits = 1000 ; CarbonCreditLib . initializeBalance ( cs , tokenId , initialCredits );","title":"initializeBalance()"},{"location":"smart-contracts/libraries/carbon-credit-lib/#retirecredits","text":"function retireCredits ( CarbonCreditStorage storage self , uint256 tokenId , uint256 amount ) internal Purpose : Permanently retire a specified amount of carbon credits from a token. Parameters : - self (CarbonCreditStorage storage): Storage reference - tokenId (uint256): The ID of the ERC721 token - amount (uint256): The amount of carbon credits to retire Requirements : - Amount must be greater than zero - Token must have sufficient carbon credit balance - Retirement is permanent and irreversible Validation Logic : require ( amount > 0 , \"Amount must be greater than zero\" ); require ( self . tokenBalances [ tokenId ] >= amount , \"Insufficient balance\" ); Example Usage : // Retire carbon credits to offset emissions CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 tokenId = 1 ; uint256 retireAmount = 250 ; CarbonCreditLib . retireCredits ( cs , tokenId , retireAmount );","title":"retireCredits()"},{"location":"smart-contracts/libraries/carbon-credit-lib/#query-functions","text":"","title":"Query Functions"},{"location":"smart-contracts/libraries/carbon-credit-lib/#getbalance","text":"function getBalance ( CarbonCreditStorage storage self , uint256 tokenId ) internal view returns ( uint256 ) Purpose : Get the current carbon credit balance for a specific token. Parameters : - self (CarbonCreditStorage storage): Storage reference - tokenId (uint256): The ID of the ERC721 token Returns : Current carbon credit balance for the token Example Usage : // Check current carbon credit balance CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 tokenId = 1 ; uint256 balance = CarbonCreditLib . getBalance ( cs , tokenId );","title":"getBalance()"},{"location":"smart-contracts/libraries/carbon-credit-lib/#getcarboncreditstatus","text":"function getCarbonCreditStatus ( CarbonCreditStorage storage self , uint256 tokenId ) internal view returns ( CarbonCreditStatus ) Purpose : Get the current status of carbon credits for a token. Parameters : - self (CarbonCreditStorage storage): Storage reference - tokenId (uint256): The ID of the ERC721 token Returns : CarbonCreditStatus enum value Logic : - Returns RETIRED if balance is zero - Returns ACTIVE if balance is greater than zero Example Usage : // Check carbon credit status CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 tokenId = 1 ; CarbonCreditStatus status = CarbonCreditLib . getCarbonCreditStatus ( cs , tokenId ); if ( status == CarbonCreditStatus . ACTIVE ) { // Token has active carbon credits } else { // All credits have been retired }","title":"getCarbonCreditStatus()"},{"location":"smart-contracts/libraries/carbon-credit-lib/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/libraries/carbon-credit-lib/#environmental-nft-contract","text":"// Environmental NFT contract using CarbonCreditLib contract EnvironmentalNFT is ERC721 , IDiamondCut { using CarbonCreditLib for CarbonCreditLib . CarbonCreditStorage ; event CarbonCreditsInitialized ( uint256 indexed tokenId , uint256 initialBalance ); event CarbonCreditsRetired ( uint256 indexed tokenId , uint256 amount , uint256 remainingBalance ); function mintWithCarbonCredits ( address to , uint256 tokenId , uint256 carbonCredits , string memory uri ) external onlyMinter { // Mint the NFT _mint ( to , tokenId ); _setTokenURI ( tokenId , uri ); // Initialize carbon credits CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); CarbonCreditLib . initializeBalance ( cs , tokenId , carbonCredits ); emit CarbonCreditsInitialized ( tokenId , carbonCredits ); } function retireCarbonCredits ( uint256 tokenId , uint256 amount ) external { require ( ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 balanceBefore = CarbonCreditLib . getBalance ( cs , tokenId ); CarbonCreditLib . retireCredits ( cs , tokenId , amount ); uint256 balanceAfter = CarbonCreditLib . getBalance ( cs , tokenId ); emit CarbonCreditsRetired ( tokenId , amount , balanceAfter ); } function getCarbonCreditInfo ( uint256 tokenId ) external view returns ( uint256 balance , CarbonCreditStatus status ) { CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); balance = CarbonCreditLib . getBalance ( cs , tokenId ); status = CarbonCreditLib . getCarbonCreditStatus ( cs , tokenId ); } modifier onlyMinter () { // Implementation would check for minter role _ ; } }","title":"Environmental NFT Contract"},{"location":"smart-contracts/libraries/carbon-credit-lib/#carbon-credit-marketplace","text":"// Marketplace for trading environmental NFTs with carbon credits contract CarbonCreditMarketplace { using CarbonCreditLib for CarbonCreditLib . CarbonCreditStorage ; struct Listing { uint256 tokenId ; address seller ; uint256 price ; uint256 carbonCredits ; bool active ; } mapping ( uint256 => Listing ) public listings ; uint256 public nextListingId ; event NFTListed ( uint256 indexed listingId , uint256 indexed tokenId , uint256 carbonCredits , uint256 price ); event NFTPurchased ( uint256 indexed listingId , address indexed buyer , uint256 creditsRetired ); function listNFT ( uint256 tokenId , uint256 price , address nftContract ) external returns ( uint256 listingId ) { require ( IERC721 ( nftContract ). ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); // Get carbon credit information CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 carbonCredits = CarbonCreditLib . getBalance ( cs , tokenId ); require ( carbonCredits > 0 , \"No carbon credits associated\" ); listingId = nextListingId ++ ; listings [ listingId ] = Listing ({ tokenId : tokenId , seller : msg.sender , price : price , carbonCredits : carbonCredits , active : true }); emit NFTListed ( listingId , tokenId , carbonCredits , price ); } function purchaseNFT ( uint256 listingId , uint256 creditsToRetire , address nftContract ) external payable { Listing storage listing = listings [ listingId ]; require ( listing . active , \"Listing not active\" ); require ( msg.value >= listing . price , \"Insufficient payment\" ); CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); uint256 currentCredits = CarbonCreditLib . getBalance ( cs , listing . tokenId ); require ( creditsToRetire <= currentCredits , \"Cannot retire more credits than available\" ); // Transfer NFT IERC721 ( nftContract ). safeTransferFrom ( listing . seller , msg.sender , listing . tokenId ); // Retire carbon credits if requested if ( creditsToRetire > 0 ) { CarbonCreditLib . retireCredits ( cs , listing . tokenId , creditsToRetire ); } // Transfer payment payable ( listing . seller ). transfer ( msg.value ); listing . active = false ; emit NFTPurchased ( listingId , msg.sender , creditsToRetire ); } function getListingCarbonInfo ( uint256 listingId ) external view returns ( uint256 currentBalance , CarbonCreditStatus status , uint256 listedCredits ) { Listing memory listing = listings [ listingId ]; CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); currentBalance = CarbonCreditLib . getBalance ( cs , listing . tokenId ); status = CarbonCreditLib . getCarbonCreditStatus ( cs , listing . tokenId ); listedCredits = listing . carbonCredits ; } }","title":"Carbon Credit Marketplace"},{"location":"smart-contracts/libraries/carbon-credit-lib/#carbon-offset-tracking-system","text":"// System for tracking carbon offset activities contract CarbonOffsetTracker { using CarbonCreditLib for CarbonCreditLib . CarbonCreditStorage ; struct OffsetRecord { address offsetter ; uint256 tokenId ; uint256 amount ; uint256 timestamp ; string purpose ; } mapping ( uint256 => OffsetRecord ) public offsetRecords ; mapping ( address => uint256 []) public userOffsets ; uint256 public nextRecordId ; event CarbonOffset ( uint256 indexed recordId , address indexed offsetter , uint256 indexed tokenId , uint256 amount , string purpose ); function recordCarbonOffset ( uint256 tokenId , uint256 amount , string memory purpose , address nftContract ) external returns ( uint256 recordId ) { require ( IERC721 ( nftContract ). ownerOf ( tokenId ) == msg.sender , \"Not token owner\" ); CarbonCreditLib . CarbonCreditStorage storage cs = CarbonCreditLib . carbonCreditStorage (); // Verify sufficient balance uint256 currentBalance = CarbonCreditLib . getBalance ( cs , tokenId ); require ( currentBalance >= amount , \"Insufficient carbon credits\" ); // Retire the credits CarbonCreditLib . retireCredits ( cs , tokenId , amount ); // Record the offset recordId = nextRecordId ++ ; offsetRecords [ recordId ] = OffsetRecord ({ offsetter : msg.sender , tokenId : tokenId , amount : amount , timestamp : block.timestamp , purpose : purpose }); userOffsets [ msg.sender ]. push ( recordId ); emit CarbonOffset ( recordId , msg.sender , tokenId , amount , purpose ); } function getUserOffsetSummary ( address user ) external view returns ( uint256 totalOffsetsCount , uint256 totalCreditsRetired , uint256 [] memory recordIds ) { recordIds = userOffsets [ user ]; totalOffsetsCount = recordIds . length ; for ( uint256 i = 0 ; i < recordIds . length ; i ++ ) { totalCreditsRetired += offsetRecords [ recordIds [ i ]]. amount ; } } function getTokenOffsetHistory ( uint256 tokenId ) external view returns ( uint256 [] memory recordIds , uint256 totalRetired ) { // Find all offset records for this token uint256 count = 0 ; for ( uint256 i = 0 ; i < nextRecordId ; i ++ ) { if ( offsetRecords [ i ]. tokenId == tokenId ) { count ++ ; } } recordIds = new uint256 []( count ); uint256 index = 0 ; for ( uint256 i = 0 ; i < nextRecordId ; i ++ ) { if ( offsetRecords [ i ]. tokenId == tokenId ) { recordIds [ index ] = i ; totalRetired += offsetRecords [ i ]. amount ; index ++ ; } } } }","title":"Carbon Offset Tracking System"},{"location":"smart-contracts/libraries/carbon-credit-lib/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/carbon-credit-lib/#storage-security","text":"Uses Diamond Standard storage pattern for isolation Prevents storage collisions with unique storage position Secure access control through internal functions only","title":"Storage Security"},{"location":"smart-contracts/libraries/carbon-credit-lib/#validation-security","text":"Token existence validation before operations Balance validation before retirement Prevention of double initialization Overflow protection in balance calculations","title":"Validation Security"},{"location":"smart-contracts/libraries/carbon-credit-lib/#operational-security","text":"Immutable retirement operations Consistent state management Safe external contract interactions Error handling for edge cases","title":"Operational Security"},{"location":"smart-contracts/libraries/carbon-credit-lib/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/libraries/carbon-credit-lib/#storage-efficiency","text":"Minimal storage footprint with single mapping Efficient storage slot usage Optimized for Diamond Standard pattern","title":"Storage Efficiency"},{"location":"smart-contracts/libraries/carbon-credit-lib/#function-efficiency","text":"Internal functions for gas savings Minimal external calls Efficient validation logic Optimized assembly for storage access","title":"Function Efficiency"},{"location":"smart-contracts/libraries/carbon-credit-lib/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/libraries/carbon-credit-lib/#common-errors","text":"\"Carbon credits already initialized\" - Attempting to initialize twice \"Token does not exist\" - Operating on non-existent token \"Initial balance must be greater than zero\" - Invalid initialization \"Amount must be greater than zero\" - Invalid retirement amount \"Insufficient balance\" - Attempting to retire more than available","title":"Common Errors"},{"location":"smart-contracts/libraries/carbon-credit-lib/#best-practices","text":"Always validate token existence before operations Check balances before retirement operations Handle initialization state properly Use appropriate error messages for debugging","title":"Best Practices"},{"location":"smart-contracts/libraries/carbon-credit-lib/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/libraries/carbon-credit-lib/#unit-tests","text":"Storage pattern implementation Token existence validation Balance initialization and management Credit retirement functionality Status determination logic","title":"Unit Tests"},{"location":"smart-contracts/libraries/carbon-credit-lib/#integration-tests","text":"Integration with ERC721 contracts Diamond facet integration Multi-token operations Edge case handling Gas usage optimization","title":"Integration Tests"},{"location":"smart-contracts/libraries/carbon-credit-lib/#related-documentation","text":"ICarbonCredit Interface - Carbon credit interface definition CarbonCreditFacet - Carbon credit facet implementation Diamond Standard Guide - Diamond pattern implementation Environmental NFT Guide - Environmental asset tokenization Carbon Offset Integration - Carbon offset program integration This library provides the core utilities and data structures for carbon credit management within the Gemforce platform, implementing secure storage patterns and essential operations for environmental asset tokenization.","title":"Related Documentation"},{"location":"smart-contracts/libraries/diamond-factory-lib/","text":"DiamondFactoryLib Library \u00b6 Overview \u00b6 The DiamondFactoryLib library provides core utilities for creating and managing Diamond proxy contracts using the factory pattern. This library implements the Diamond Factory Standard, enabling deterministic deployment of Diamond contracts with configurable facet sets and initialization parameters. Key Features \u00b6 Deterministic Deployment : Uses CREATE2 for predictable contract addresses Facet Set Management : Pre-configured facet combinations for different use cases Diamond Creation : Factory pattern for deploying Diamond proxy contracts Initialization Support : Automated Diamond initialization with custom parameters Registry Management : Tracking and management of deployed Diamonds Flexible Configuration : Support for custom facet combinations and settings Library Definition \u00b6 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.6 ; library DiamondFactoryLib { // Storage management function diamondFactoryStorage () internal pure returns ( DiamondFactoryStorage storage ); // Facet set management function _addFacetSet ( DiamondFactoryStorage storage self , string memory setName , IDiamondCut . FacetCut [] memory facets ) internal ; function _getFacets ( DiamondFactoryStorage storage self , string memory setName ) internal view returns ( IDiamondCut . FacetCut [] memory ); function _setFacet ( DiamondFactoryStorage storage self , string memory setName , uint256 idx , IDiamondCut . FacetCut memory facet ) internal ; // Diamond deployment function _getDiamondAddress ( DiamondFactoryStorage storage , address factoryAddress , string memory symbol , bytes memory creationCode ) internal view returns ( address ); function create (...) internal returns ( address payable ); function createFromSet (...) internal returns ( address payable ); // Registry management function add ( DiamondFactoryStorage storage self , string memory symbol , address payable diamondAddress ) internal ; function remove ( DiamondFactoryStorage storage self , string memory symbol ) internal ; } Data Structures \u00b6 ContractData Struct \u00b6 struct ContractData { mapping ( string => address ) diamondAddresses ; // Symbol to Diamond address mapping string [] diamondSymbols ; // Array of all Diamond symbols mapping ( string => IDiamondCut . FacetCut []) facetsToAdd ; // Named facet sets string [] facetSets ; // Array of facet set names string defaultFacetSet ; // Default facet set name bytes diamondBytecode ; // Diamond contract bytecode } Purpose : Core data structure containing all factory state and configuration. Components : - diamondAddresses : Maps Diamond symbols to deployed contract addresses - diamondSymbols : Maintains list of all deployed Diamond symbols - facetsToAdd : Named collections of facets for different Diamond types - facetSets : List of available facet set names - defaultFacetSet : Default facet configuration for new Diamonds - diamondBytecode : Compiled bytecode for Diamond proxy deployment DiamondFactoryStorage Struct \u00b6 struct DiamondFactoryStorage { ContractData contractData ; } Purpose : Diamond storage wrapper for factory data. Storage Position : bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nextblock.bitgem.app.DiamondFactoryStorage.storage\" ); IDiamondElement Interface \u00b6 interface IDiamondElement { function initialize ( address owner , DiamondSettings memory settings , IDiamondCut . FacetCut [] calldata facets , address diamondInit , bytes calldata initData ) external payable ; } Purpose : Interface for Diamond initialization after deployment. Core Functions \u00b6 Storage Management \u00b6 diamondFactoryStorage() \u00b6 function diamondFactoryStorage () internal pure returns ( DiamondFactoryStorage storage ds ) Purpose : Access Diamond storage for factory data using assembly. Implementation : function diamondFactoryStorage () internal pure returns ( DiamondFactoryStorage storage ds ) { bytes32 position = DIAMOND_STORAGE_POSITION ; assembly { ds . slot := position } } Returns : Storage reference to factory data Usage : All factory functions use this to access persistent storage. Facet Set Management \u00b6 _addFacetSet() \u00b6 function _addFacetSet ( DiamondFactoryStorage storage self , string memory setName , IDiamondCut . FacetCut [] memory facets ) internal Purpose : Add a named collection of facets for Diamond deployment. Parameters : - self : Storage reference to factory data - setName : Unique name for the facet set - facets : Array of facet cuts to include in the set Process : 1. Add each facet to the named set 2. Register set name if not already present 3. Enable reuse of facet configurations Example Usage : // Create marketplace facet set IDiamondCut . FacetCut [] memory marketplaceFacets = new IDiamondCut . FacetCut []( 3 ); marketplaceFacets [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : marketplaceFacetAddress , action : IDiamondCut . FacetCutAction . Add , functionSelectors : marketplaceSelectors }); marketplaceFacets [ 1 ] = IDiamondCut . FacetCut ({ facetAddress : erc721FacetAddress , action : IDiamondCut . FacetCutAction . Add , functionSelectors : erc721Selectors }); marketplaceFacets [ 2 ] = IDiamondCut . FacetCut ({ facetAddress : ownershipFacetAddress , action : IDiamondCut . FacetCutAction . Add , functionSelectors : ownershipSelectors }); DiamondFactoryLib . _addFacetSet ( storage , \"marketplace\" , marketplaceFacets ); _getFacets() \u00b6 function _getFacets ( DiamondFactoryStorage storage self , string memory setName ) internal view returns ( IDiamondCut . FacetCut [] memory ) Purpose : Retrieve all facets for a named set. Parameters : - self : Storage reference to factory data - setName : Name of the facet set to retrieve Returns : Array of facet cuts for the specified set Example Usage : // Get marketplace facets for deployment IDiamondCut . FacetCut [] memory facets = DiamondFactoryLib . _getFacets ( storage , \"marketplace\" ); _setFacet() \u00b6 function _setFacet ( DiamondFactoryStorage storage self , string memory setName , uint256 idx , IDiamondCut . FacetCut memory facet ) internal Purpose : Update a specific facet within a named set. Parameters : - self : Storage reference to factory data - setName : Name of the facet set - idx : Index of the facet to update - facet : New facet cut data Use Cases : - Upgrading facet addresses - Modifying function selectors - Changing facet cut actions Example Usage : // Update marketplace facet to new version IDiamondCut . FacetCut memory newMarketplaceFacet = IDiamondCut . FacetCut ({ facetAddress : newMarketplaceFacetAddress , action : IDiamondCut . FacetCutAction . Replace , functionSelectors : marketplaceSelectors }); DiamondFactoryLib . _setFacet ( storage , \"marketplace\" , 0 , newMarketplaceFacet ); Diamond Deployment \u00b6 _getDiamondAddress() \u00b6 function _getDiamondAddress ( DiamondFactoryStorage storage , address factoryAddress , string memory symbol , bytes memory creationCode ) internal view returns ( address ) Purpose : Calculate the deterministic address for a Diamond before deployment. Parameters : - factoryAddress : Address of the factory contract - symbol : Unique symbol for the Diamond - creationCode : Bytecode for Diamond deployment Implementation : return Create2 . computeAddress ( keccak256 ( abi . encodePacked ( factoryAddress , symbol )), keccak256 ( creationCode ) ); Returns : Predicted Diamond contract address Benefits : - Enables address prediction before deployment - Supports cross-chain address consistency - Allows for address-dependent logic create() \u00b6 function create ( DiamondFactoryStorage storage self , address diamondAddress , DiamondSettings memory params , address diamondInit , bytes calldata _calldata , bytes memory _creationCode , IDiamondCut . FacetCut [] memory facets ) internal returns ( address payable _diamondAddress ) Purpose : Deploy a new Diamond with custom facet configuration. Parameters : - self : Storage reference to factory data - diamondAddress : Predicted Diamond address (for salt generation) - params : Diamond configuration settings - diamondInit : Address of initialization contract - _calldata : Initialization function call data - _creationCode : Diamond contract bytecode - facets : Custom facet configuration Process : 1. Deploy Diamond using CREATE2 with deterministic salt 2. Verify deployment success 3. Register Diamond in factory storage 4. Initialize Diamond with provided parameters and facets Example Usage : // Deploy custom Diamond with specific facets DiamondSettings memory settings = DiamondSettings ({ name : \"Custom NFT Collection\" , symbol : \"CUSTOM\" , baseURI : \"https://api.example.com/metadata/\" , owner : msg.sender }); IDiamondCut . FacetCut [] memory customFacets = new IDiamondCut . FacetCut []( 2 ); customFacets [ 0 ] = marketplaceFacet ; customFacets [ 1 ] = royaltyFacet ; address diamondAddress = DiamondFactoryLib . create ( storage , predictedAddress , settings , initContract , initCalldata , diamondBytecode , customFacets ); createFromSet() \u00b6 function createFromSet ( DiamondFactoryStorage storage self , address diamondAddress , DiamondSettings memory params , address diamondInit , bytes calldata _calldata , bytes memory _creationCode , string memory facetSet ) internal returns ( address payable _diamondAddress ) Purpose : Deploy a new Diamond using a pre-configured facet set. Parameters : - self : Storage reference to factory data - diamondAddress : Predicted Diamond address - params : Diamond configuration settings - diamondInit : Address of initialization contract - _calldata : Initialization function call data - _creationCode : Diamond contract bytecode - facetSet : Name of pre-configured facet set Process : 1. Deploy Diamond using CREATE2 2. Retrieve facets from named set 3. Initialize Diamond with set facets Example Usage : // Deploy Diamond using marketplace facet set address diamondAddress = DiamondFactoryLib . createFromSet ( storage , predictedAddress , settings , initContract , initCalldata , diamondBytecode , \"marketplace\" ); Registry Management \u00b6 add() \u00b6 function add ( DiamondFactoryStorage storage self , string memory symbol , address payable diamondAddress ) internal Purpose : Register an existing Diamond with the factory. Parameters : - self : Storage reference to factory data - symbol : Unique symbol for the Diamond - diamondAddress : Address of existing Diamond Use Cases : - Importing externally deployed Diamonds - Migrating from other factory contracts - Manual registration of special Diamonds remove() \u00b6 function remove ( DiamondFactoryStorage storage self , string memory symbol ) internal Purpose : Unregister a Diamond from the factory. Parameters : - self : Storage reference to factory data - symbol : Symbol of Diamond to remove Process : 1. Clear address mapping 2. Remove symbol from array (swap with last element) 3. Update array length Note : Does not destroy the Diamond contract, only removes factory tracking. Integration Examples \u00b6 NFT Collection Factory \u00b6 // Factory for creating NFT collection Diamonds contract NFTCollectionFactory { using DiamondFactoryLib for DiamondFactoryLib . DiamondFactoryStorage ; struct CollectionTemplate { string name ; string description ; string facetSet ; uint256 deploymentFee ; bool active ; } mapping ( string => CollectionTemplate ) public templates ; mapping ( address => string []) public userCollections ; event TemplateCreated ( string indexed templateName , string facetSet ); event CollectionDeployed ( address indexed diamond , string symbol , address indexed creator ); function createTemplate ( string memory templateName , string memory description , IDiamondCut . FacetCut [] memory facets , uint256 deploymentFee ) external onlyOwner { // Add facet set for template DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); DiamondFactoryLib . _addFacetSet ( ds , templateName , facets ); templates [ templateName ] = CollectionTemplate ({ name : templateName , description : description , facetSet : templateName , deploymentFee : deploymentFee , active : true }); emit TemplateCreated ( templateName , templateName ); } function deployCollection ( string memory templateName , string memory collectionName , string memory symbol , string memory baseURI , uint256 maxSupply ) external payable returns ( address diamond ) { CollectionTemplate memory template = templates [ templateName ]; require ( template . active , \"Template not active\" ); require ( msg.value >= template . deploymentFee , \"Insufficient fee\" ); DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); // Prepare Diamond settings DiamondSettings memory settings = DiamondSettings ({ name : collectionName , symbol : symbol , baseURI : baseURI , maxSupply : maxSupply , owner : msg.sender }); // Get predicted address bytes memory creationCode = getDiamondBytecode (); address predictedAddress = DiamondFactoryLib . _getDiamondAddress ( ds , address ( this ), symbol , creationCode ); // Deploy Diamond diamond = DiamondFactoryLib . createFromSet ( ds , predictedAddress , settings , getInitContract (), getInitCalldata ( settings ), creationCode , template . facetSet ); // Track user collections userCollections [ msg.sender ]. push ( symbol ); emit CollectionDeployed ( diamond , symbol , msg.sender ); } function getUserCollections ( address user ) external view returns ( string [] memory ) { return userCollections [ user ]; } function getCollectionAddress ( string memory symbol ) external view returns ( address ) { DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); return ds . contractData . diamondAddresses [ symbol ]; } function getDiamondBytecode () internal pure returns ( bytes memory ) { // Return compiled Diamond bytecode } function getInitContract () internal pure returns ( address ) { // Return Diamond initialization contract address } function getInitCalldata ( DiamondSettings memory settings ) internal pure returns ( bytes memory ) { // Return initialization calldata } modifier onlyOwner () { // Implementation _ ; } } Gaming Platform Factory \u00b6 // Factory for creating game-specific Diamonds contract GamePlatformFactory { using DiamondFactoryLib for DiamondFactoryLib . DiamondFactoryStorage ; struct GameType { string name ; string [] requiredFacets ; uint256 licenseFee ; address licenseToken ; bool requiresLicense ; } mapping ( string => GameType ) public gameTypes ; mapping ( address => bool ) public licensedDevelopers ; event GameTypeRegistered ( string indexed gameType , string [] facets ); event GameDeployed ( address indexed diamond , string gameType , address indexed developer ); event DeveloperLicensed ( address indexed developer , string gameType ); function registerGameType ( string memory gameTypeName , string [] memory facetNames , IDiamondCut . FacetCut [][] memory facetSets , uint256 licenseFee , address licenseToken ) external onlyPlatformOwner { DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); // Register each facet set for ( uint256 i = 0 ; i < facetNames . length ; i ++ ) { DiamondFactoryLib . _addFacetSet ( ds , facetNames [ i ], facetSets [ i ]); } gameTypes [ gameTypeName ] = GameType ({ name : gameTypeName , requiredFacets : facetNames , licenseFee : licenseFee , licenseToken : licenseToken , requiresLicense : licenseFee > 0 }); emit GameTypeRegistered ( gameTypeName , facetNames ); } function purchaseLicense ( string memory gameType ) external { GameType memory game = gameTypes [ gameType ]; require ( game . requiresLicense , \"No license required\" ); // Transfer license fee IERC20 ( game . licenseToken ). transferFrom ( msg.sender , address ( this ), game . licenseFee ); licensedDevelopers [ msg.sender ] = true ; emit DeveloperLicensed ( msg.sender , gameType ); } function deployGame ( string memory gameType , string memory gameName , string memory symbol , GameSettings memory gameSettings ) external returns ( address diamond ) { GameType memory game = gameTypes [ gameType ]; require ( bytes ( game . name ). length > 0 , \"Game type not registered\" ); if ( game . requiresLicense ) { require ( licensedDevelopers [ msg.sender ], \"License required\" ); } DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); // Combine all required facets IDiamondCut . FacetCut [] memory allFacets = combineGameFacets ( game . requiredFacets ); DiamondSettings memory settings = DiamondSettings ({ name : gameName , symbol : symbol , owner : msg.sender , gameType : gameType , gameSettings : gameSettings }); bytes memory creationCode = getGameDiamondBytecode (); address predictedAddress = DiamondFactoryLib . _getDiamondAddress ( ds , address ( this ), symbol , creationCode ); diamond = DiamondFactoryLib . create ( ds , predictedAddress , settings , getGameInitContract (), getGameInitCalldata ( settings ), creationCode , allFacets ); emit GameDeployed ( diamond , gameType , msg.sender ); } function combineGameFacets ( string [] memory facetNames ) internal view returns ( IDiamondCut . FacetCut [] memory ) { DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); // Calculate total facets needed uint256 totalFacets = 0 ; for ( uint256 i = 0 ; i < facetNames . length ; i ++ ) { totalFacets += DiamondFactoryLib . _getFacets ( ds , facetNames [ i ]). length ; } // Combine all facets IDiamondCut . FacetCut [] memory combined = new IDiamondCut . FacetCut []( totalFacets ); uint256 index = 0 ; for ( uint256 i = 0 ; i < facetNames . length ; i ++ ) { IDiamondCut . FacetCut [] memory facets = DiamondFactoryLib . _getFacets ( ds , facetNames [ i ]); for ( uint256 j = 0 ; j < facets . length ; j ++ ) { combined [ index ++ ] = facets [ j ]; } } return combined ; } function getGameDiamondBytecode () internal pure returns ( bytes memory ) { // Return game-specific Diamond bytecode } function getGameInitContract () internal pure returns ( address ) { // Return game Diamond initialization contract } function getGameInitCalldata ( DiamondSettings memory settings ) internal pure returns ( bytes memory ) { // Return game initialization calldata } modifier onlyPlatformOwner () { // Implementation _ ; } } DeFi Protocol Factory \u00b6 // Factory for creating DeFi protocol Diamonds contract DeFiProtocolFactory { using DiamondFactoryLib for DiamondFactoryLib . DiamondFactoryStorage ; struct ProtocolConfig { string protocolType ; address [] requiredTokens ; uint256 minLiquidity ; uint256 governanceThreshold ; bool requiresGovernance ; } mapping ( string => ProtocolConfig ) public protocolConfigs ; mapping ( address => address []) public userProtocols ; event ProtocolConfigured ( string indexed protocolType , address [] tokens ); event ProtocolDeployed ( address indexed diamond , string protocolType , address indexed creator ); function configureProtocol ( string memory protocolType , IDiamondCut . FacetCut [] memory coreFacets , IDiamondCut . FacetCut [] memory governanceFacets , address [] memory requiredTokens , uint256 minLiquidity , uint256 governanceThreshold ) external onlyGovernance { DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); // Add core protocol facets DiamondFactoryLib . _addFacetSet ( ds , string ( abi . encodePacked ( protocolType , \"_core\" )), coreFacets ); // Add governance facets if provided if ( governanceFacets . length > 0 ) { DiamondFactoryLib . _addFacetSet ( ds , string ( abi . encodePacked ( protocolType , \"_governance\" )), governanceFacets ); } protocolConfigs [ protocolType ] = ProtocolConfig ({ protocolType : protocolType , requiredTokens : requiredTokens , minLiquidity : minLiquidity , governanceThreshold : governanceThreshold , requiresGovernance : governanceFacets . length > 0 }); emit ProtocolConfigured ( protocolType , requiredTokens ); } function deployProtocol ( string memory protocolType , string memory protocolName , string memory symbol , address [] memory initialTokens , uint256 initialLiquidity ) external payable returns ( address diamond ) { ProtocolConfig memory config = protocolConfigs [ protocolType ]; require ( bytes ( config . protocolType ). length > 0 , \"Protocol not configured\" ); require ( initialLiquidity >= config . minLiquidity , \"Insufficient liquidity\" ); // Validate required tokens are included for ( uint256 i = 0 ; i < config . requiredTokens . length ; i ++ ) { bool found = false ; for ( uint256 j = 0 ; j < initialTokens . length ; j ++ ) { if ( config . requiredTokens [ i ] == initialTokens [ j ]) { found = true ; break ; } } require ( found , \"Missing required token\" ); } DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); // Get core facets IDiamondCut . FacetCut [] memory coreFacets = DiamondFactoryLib . _getFacets ( ds , string ( abi . encodePacked ( protocolType , \"_core\" )) ); // Add governance facets if required IDiamondCut . FacetCut [] memory allFacets ; if ( config . requiresGovernance ) { IDiamondCut . FacetCut [] memory govFacets = DiamondFactoryLib . _getFacets ( ds , string ( abi . encodePacked ( protocolType , \"_governance\" )) ); allFacets = combineFacets ( coreFacets , govFacets ); } else { allFacets = coreFacets ; } ProtocolSettings memory settings = ProtocolSettings ({ name : protocolName , symbol : symbol , protocolType : protocolType , tokens : initialTokens , initialLiquidity : initialLiquidity , owner : msg.sender }); bytes memory creationCode = getProtocolDiamondBytecode (); address predictedAddress = DiamondFactoryLib . _getDiamondAddress ( ds , address ( this ), symbol , creationCode ); diamond = DiamondFactoryLib . create ( ds , predictedAddress , DiamondSettings ( settings ), getProtocolInitContract (), getProtocolInitCalldata ( settings ), creationCode , allFacets ); // Track user protocols userProtocols [ msg.sender ]. push ( diamond ); emit ProtocolDeployed ( diamond , protocolType , msg.sender ); } function getUserProtocols ( address user ) external view returns ( address [] memory ) { return userProtocols [ user ]; } function combineFacets ( IDiamondCut . FacetCut [] memory facets1 , IDiamondCut . FacetCut [] memory facets2 ) internal pure returns ( IDiamondCut . FacetCut [] memory ) { IDiamondCut . FacetCut [] memory combined = new IDiamondCut . FacetCut []( facets1 . length + facets2 . length ); for ( uint256 i = 0 ; i < facets1 . length ; i ++ ) { combined [ i ] = facets1 [ i ]; } for ( uint256 i = 0 ; i < facets2 . length ; i ++ ) { combined [ facets1 . length + i ] = facets2 [ i ]; } return combined ; } function getProtocolDiamondBytecode () internal pure returns ( bytes memory ) { // Return protocol Diamond bytecode } function getProtocolInitContract () internal pure returns ( address ) { // Return protocol initialization contract } function getProtocolInitCalldata ( ProtocolSettings memory settings ) internal pure returns ( bytes memory ) { // Return protocol initialization calldata } modifier onlyGovernance () { // Implementation _ ; } } Security Considerations \u00b6 CREATE2 Security \u00b6 Deterministic address generation prevents front-running Salt includes factory address and symbol for uniqueness Bytecode hash ensures deployment integrity Address prediction enables secure cross-chain operations Access Control \u00b6 Factory owner controls facet set management Diamond ownership transferred to deployer Initialization parameters validated before deployment Registry management restricted to authorized functions Deployment Safety \u00b6 Deployment failure handling with require statements Initialization atomicity through single transaction Facet validation before Diamond creation Storage consistency through proper registry updates Gas Optimization \u00b6 Storage Efficiency \u00b6 Efficient mapping structures for Diamond registry Minimal storage writes during deployment Optimized facet set storage and retrieval Batch operations for facet management Deployment Efficiency \u00b6 CREATE2 for deterministic deployment Single transaction initialization Efficient facet combination algorithms Minimal external calls during deployment Error Handling \u00b6 Common Errors \u00b6 \"create_failed\" - Diamond deployment failure \"Invalid facet set\" - Unknown or empty facet set \"Symbol already exists\" - Duplicate Diamond symbol \"Initialization failed\" - Diamond initialization error Best Practices \u00b6 Validate all parameters before deployment Check facet set existence before use Verify Diamond deployment success Handle initialization failures gracefully Testing Considerations \u00b6 Unit Tests \u00b6 Facet set management operations Diamond address prediction accuracy Deployment with custom facets Registry management functions Integration Tests \u00b6 End-to-end Diamond deployment Multi-facet Diamond creation Cross-contract initialization Factory upgrade scenarios Related Documentation \u00b6 IDiamondFactory Interface - Factory interface definition Diamond Contract - Core Diamond proxy implementation DiamondCut Facet - Diamond upgrade functionality Diamond Factory Standard EIP - Standard specification Diamond Deployment Guide - Deployment best practices This library provides comprehensive utilities for creating and managing Diamond proxy contracts using the factory pattern, enabling scalable deployment of upgradeable smart contract systems with configurable functionality.","title":"Diamond Factory Lib"},{"location":"smart-contracts/libraries/diamond-factory-lib/#diamondfactorylib-library","text":"","title":"DiamondFactoryLib Library"},{"location":"smart-contracts/libraries/diamond-factory-lib/#overview","text":"The DiamondFactoryLib library provides core utilities for creating and managing Diamond proxy contracts using the factory pattern. This library implements the Diamond Factory Standard, enabling deterministic deployment of Diamond contracts with configurable facet sets and initialization parameters.","title":"Overview"},{"location":"smart-contracts/libraries/diamond-factory-lib/#key-features","text":"Deterministic Deployment : Uses CREATE2 for predictable contract addresses Facet Set Management : Pre-configured facet combinations for different use cases Diamond Creation : Factory pattern for deploying Diamond proxy contracts Initialization Support : Automated Diamond initialization with custom parameters Registry Management : Tracking and management of deployed Diamonds Flexible Configuration : Support for custom facet combinations and settings","title":"Key Features"},{"location":"smart-contracts/libraries/diamond-factory-lib/#library-definition","text":"// SPDX-License-Identifier: MIT pragma solidity ^ 0.8.6 ; library DiamondFactoryLib { // Storage management function diamondFactoryStorage () internal pure returns ( DiamondFactoryStorage storage ); // Facet set management function _addFacetSet ( DiamondFactoryStorage storage self , string memory setName , IDiamondCut . FacetCut [] memory facets ) internal ; function _getFacets ( DiamondFactoryStorage storage self , string memory setName ) internal view returns ( IDiamondCut . FacetCut [] memory ); function _setFacet ( DiamondFactoryStorage storage self , string memory setName , uint256 idx , IDiamondCut . FacetCut memory facet ) internal ; // Diamond deployment function _getDiamondAddress ( DiamondFactoryStorage storage , address factoryAddress , string memory symbol , bytes memory creationCode ) internal view returns ( address ); function create (...) internal returns ( address payable ); function createFromSet (...) internal returns ( address payable ); // Registry management function add ( DiamondFactoryStorage storage self , string memory symbol , address payable diamondAddress ) internal ; function remove ( DiamondFactoryStorage storage self , string memory symbol ) internal ; }","title":"Library Definition"},{"location":"smart-contracts/libraries/diamond-factory-lib/#data-structures","text":"","title":"Data Structures"},{"location":"smart-contracts/libraries/diamond-factory-lib/#contractdata-struct","text":"struct ContractData { mapping ( string => address ) diamondAddresses ; // Symbol to Diamond address mapping string [] diamondSymbols ; // Array of all Diamond symbols mapping ( string => IDiamondCut . FacetCut []) facetsToAdd ; // Named facet sets string [] facetSets ; // Array of facet set names string defaultFacetSet ; // Default facet set name bytes diamondBytecode ; // Diamond contract bytecode } Purpose : Core data structure containing all factory state and configuration. Components : - diamondAddresses : Maps Diamond symbols to deployed contract addresses - diamondSymbols : Maintains list of all deployed Diamond symbols - facetsToAdd : Named collections of facets for different Diamond types - facetSets : List of available facet set names - defaultFacetSet : Default facet configuration for new Diamonds - diamondBytecode : Compiled bytecode for Diamond proxy deployment","title":"ContractData Struct"},{"location":"smart-contracts/libraries/diamond-factory-lib/#diamondfactorystorage-struct","text":"struct DiamondFactoryStorage { ContractData contractData ; } Purpose : Diamond storage wrapper for factory data. Storage Position : bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nextblock.bitgem.app.DiamondFactoryStorage.storage\" );","title":"DiamondFactoryStorage Struct"},{"location":"smart-contracts/libraries/diamond-factory-lib/#idiamondelement-interface","text":"interface IDiamondElement { function initialize ( address owner , DiamondSettings memory settings , IDiamondCut . FacetCut [] calldata facets , address diamondInit , bytes calldata initData ) external payable ; } Purpose : Interface for Diamond initialization after deployment.","title":"IDiamondElement Interface"},{"location":"smart-contracts/libraries/diamond-factory-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/diamond-factory-lib/#storage-management","text":"","title":"Storage Management"},{"location":"smart-contracts/libraries/diamond-factory-lib/#diamondfactorystorage","text":"function diamondFactoryStorage () internal pure returns ( DiamondFactoryStorage storage ds ) Purpose : Access Diamond storage for factory data using assembly. Implementation : function diamondFactoryStorage () internal pure returns ( DiamondFactoryStorage storage ds ) { bytes32 position = DIAMOND_STORAGE_POSITION ; assembly { ds . slot := position } } Returns : Storage reference to factory data Usage : All factory functions use this to access persistent storage.","title":"diamondFactoryStorage()"},{"location":"smart-contracts/libraries/diamond-factory-lib/#facet-set-management","text":"","title":"Facet Set Management"},{"location":"smart-contracts/libraries/diamond-factory-lib/#_addfacetset","text":"function _addFacetSet ( DiamondFactoryStorage storage self , string memory setName , IDiamondCut . FacetCut [] memory facets ) internal Purpose : Add a named collection of facets for Diamond deployment. Parameters : - self : Storage reference to factory data - setName : Unique name for the facet set - facets : Array of facet cuts to include in the set Process : 1. Add each facet to the named set 2. Register set name if not already present 3. Enable reuse of facet configurations Example Usage : // Create marketplace facet set IDiamondCut . FacetCut [] memory marketplaceFacets = new IDiamondCut . FacetCut []( 3 ); marketplaceFacets [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : marketplaceFacetAddress , action : IDiamondCut . FacetCutAction . Add , functionSelectors : marketplaceSelectors }); marketplaceFacets [ 1 ] = IDiamondCut . FacetCut ({ facetAddress : erc721FacetAddress , action : IDiamondCut . FacetCutAction . Add , functionSelectors : erc721Selectors }); marketplaceFacets [ 2 ] = IDiamondCut . FacetCut ({ facetAddress : ownershipFacetAddress , action : IDiamondCut . FacetCutAction . Add , functionSelectors : ownershipSelectors }); DiamondFactoryLib . _addFacetSet ( storage , \"marketplace\" , marketplaceFacets );","title":"_addFacetSet()"},{"location":"smart-contracts/libraries/diamond-factory-lib/#_getfacets","text":"function _getFacets ( DiamondFactoryStorage storage self , string memory setName ) internal view returns ( IDiamondCut . FacetCut [] memory ) Purpose : Retrieve all facets for a named set. Parameters : - self : Storage reference to factory data - setName : Name of the facet set to retrieve Returns : Array of facet cuts for the specified set Example Usage : // Get marketplace facets for deployment IDiamondCut . FacetCut [] memory facets = DiamondFactoryLib . _getFacets ( storage , \"marketplace\" );","title":"_getFacets()"},{"location":"smart-contracts/libraries/diamond-factory-lib/#_setfacet","text":"function _setFacet ( DiamondFactoryStorage storage self , string memory setName , uint256 idx , IDiamondCut . FacetCut memory facet ) internal Purpose : Update a specific facet within a named set. Parameters : - self : Storage reference to factory data - setName : Name of the facet set - idx : Index of the facet to update - facet : New facet cut data Use Cases : - Upgrading facet addresses - Modifying function selectors - Changing facet cut actions Example Usage : // Update marketplace facet to new version IDiamondCut . FacetCut memory newMarketplaceFacet = IDiamondCut . FacetCut ({ facetAddress : newMarketplaceFacetAddress , action : IDiamondCut . FacetCutAction . Replace , functionSelectors : marketplaceSelectors }); DiamondFactoryLib . _setFacet ( storage , \"marketplace\" , 0 , newMarketplaceFacet );","title":"_setFacet()"},{"location":"smart-contracts/libraries/diamond-factory-lib/#diamond-deployment","text":"","title":"Diamond Deployment"},{"location":"smart-contracts/libraries/diamond-factory-lib/#_getdiamondaddress","text":"function _getDiamondAddress ( DiamondFactoryStorage storage , address factoryAddress , string memory symbol , bytes memory creationCode ) internal view returns ( address ) Purpose : Calculate the deterministic address for a Diamond before deployment. Parameters : - factoryAddress : Address of the factory contract - symbol : Unique symbol for the Diamond - creationCode : Bytecode for Diamond deployment Implementation : return Create2 . computeAddress ( keccak256 ( abi . encodePacked ( factoryAddress , symbol )), keccak256 ( creationCode ) ); Returns : Predicted Diamond contract address Benefits : - Enables address prediction before deployment - Supports cross-chain address consistency - Allows for address-dependent logic","title":"_getDiamondAddress()"},{"location":"smart-contracts/libraries/diamond-factory-lib/#create","text":"function create ( DiamondFactoryStorage storage self , address diamondAddress , DiamondSettings memory params , address diamondInit , bytes calldata _calldata , bytes memory _creationCode , IDiamondCut . FacetCut [] memory facets ) internal returns ( address payable _diamondAddress ) Purpose : Deploy a new Diamond with custom facet configuration. Parameters : - self : Storage reference to factory data - diamondAddress : Predicted Diamond address (for salt generation) - params : Diamond configuration settings - diamondInit : Address of initialization contract - _calldata : Initialization function call data - _creationCode : Diamond contract bytecode - facets : Custom facet configuration Process : 1. Deploy Diamond using CREATE2 with deterministic salt 2. Verify deployment success 3. Register Diamond in factory storage 4. Initialize Diamond with provided parameters and facets Example Usage : // Deploy custom Diamond with specific facets DiamondSettings memory settings = DiamondSettings ({ name : \"Custom NFT Collection\" , symbol : \"CUSTOM\" , baseURI : \"https://api.example.com/metadata/\" , owner : msg.sender }); IDiamondCut . FacetCut [] memory customFacets = new IDiamondCut . FacetCut []( 2 ); customFacets [ 0 ] = marketplaceFacet ; customFacets [ 1 ] = royaltyFacet ; address diamondAddress = DiamondFactoryLib . create ( storage , predictedAddress , settings , initContract , initCalldata , diamondBytecode , customFacets );","title":"create()"},{"location":"smart-contracts/libraries/diamond-factory-lib/#createfromset","text":"function createFromSet ( DiamondFactoryStorage storage self , address diamondAddress , DiamondSettings memory params , address diamondInit , bytes calldata _calldata , bytes memory _creationCode , string memory facetSet ) internal returns ( address payable _diamondAddress ) Purpose : Deploy a new Diamond using a pre-configured facet set. Parameters : - self : Storage reference to factory data - diamondAddress : Predicted Diamond address - params : Diamond configuration settings - diamondInit : Address of initialization contract - _calldata : Initialization function call data - _creationCode : Diamond contract bytecode - facetSet : Name of pre-configured facet set Process : 1. Deploy Diamond using CREATE2 2. Retrieve facets from named set 3. Initialize Diamond with set facets Example Usage : // Deploy Diamond using marketplace facet set address diamondAddress = DiamondFactoryLib . createFromSet ( storage , predictedAddress , settings , initContract , initCalldata , diamondBytecode , \"marketplace\" );","title":"createFromSet()"},{"location":"smart-contracts/libraries/diamond-factory-lib/#registry-management","text":"","title":"Registry Management"},{"location":"smart-contracts/libraries/diamond-factory-lib/#add","text":"function add ( DiamondFactoryStorage storage self , string memory symbol , address payable diamondAddress ) internal Purpose : Register an existing Diamond with the factory. Parameters : - self : Storage reference to factory data - symbol : Unique symbol for the Diamond - diamondAddress : Address of existing Diamond Use Cases : - Importing externally deployed Diamonds - Migrating from other factory contracts - Manual registration of special Diamonds","title":"add()"},{"location":"smart-contracts/libraries/diamond-factory-lib/#remove","text":"function remove ( DiamondFactoryStorage storage self , string memory symbol ) internal Purpose : Unregister a Diamond from the factory. Parameters : - self : Storage reference to factory data - symbol : Symbol of Diamond to remove Process : 1. Clear address mapping 2. Remove symbol from array (swap with last element) 3. Update array length Note : Does not destroy the Diamond contract, only removes factory tracking.","title":"remove()"},{"location":"smart-contracts/libraries/diamond-factory-lib/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/libraries/diamond-factory-lib/#nft-collection-factory","text":"// Factory for creating NFT collection Diamonds contract NFTCollectionFactory { using DiamondFactoryLib for DiamondFactoryLib . DiamondFactoryStorage ; struct CollectionTemplate { string name ; string description ; string facetSet ; uint256 deploymentFee ; bool active ; } mapping ( string => CollectionTemplate ) public templates ; mapping ( address => string []) public userCollections ; event TemplateCreated ( string indexed templateName , string facetSet ); event CollectionDeployed ( address indexed diamond , string symbol , address indexed creator ); function createTemplate ( string memory templateName , string memory description , IDiamondCut . FacetCut [] memory facets , uint256 deploymentFee ) external onlyOwner { // Add facet set for template DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); DiamondFactoryLib . _addFacetSet ( ds , templateName , facets ); templates [ templateName ] = CollectionTemplate ({ name : templateName , description : description , facetSet : templateName , deploymentFee : deploymentFee , active : true }); emit TemplateCreated ( templateName , templateName ); } function deployCollection ( string memory templateName , string memory collectionName , string memory symbol , string memory baseURI , uint256 maxSupply ) external payable returns ( address diamond ) { CollectionTemplate memory template = templates [ templateName ]; require ( template . active , \"Template not active\" ); require ( msg.value >= template . deploymentFee , \"Insufficient fee\" ); DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); // Prepare Diamond settings DiamondSettings memory settings = DiamondSettings ({ name : collectionName , symbol : symbol , baseURI : baseURI , maxSupply : maxSupply , owner : msg.sender }); // Get predicted address bytes memory creationCode = getDiamondBytecode (); address predictedAddress = DiamondFactoryLib . _getDiamondAddress ( ds , address ( this ), symbol , creationCode ); // Deploy Diamond diamond = DiamondFactoryLib . createFromSet ( ds , predictedAddress , settings , getInitContract (), getInitCalldata ( settings ), creationCode , template . facetSet ); // Track user collections userCollections [ msg.sender ]. push ( symbol ); emit CollectionDeployed ( diamond , symbol , msg.sender ); } function getUserCollections ( address user ) external view returns ( string [] memory ) { return userCollections [ user ]; } function getCollectionAddress ( string memory symbol ) external view returns ( address ) { DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); return ds . contractData . diamondAddresses [ symbol ]; } function getDiamondBytecode () internal pure returns ( bytes memory ) { // Return compiled Diamond bytecode } function getInitContract () internal pure returns ( address ) { // Return Diamond initialization contract address } function getInitCalldata ( DiamondSettings memory settings ) internal pure returns ( bytes memory ) { // Return initialization calldata } modifier onlyOwner () { // Implementation _ ; } }","title":"NFT Collection Factory"},{"location":"smart-contracts/libraries/diamond-factory-lib/#gaming-platform-factory","text":"// Factory for creating game-specific Diamonds contract GamePlatformFactory { using DiamondFactoryLib for DiamondFactoryLib . DiamondFactoryStorage ; struct GameType { string name ; string [] requiredFacets ; uint256 licenseFee ; address licenseToken ; bool requiresLicense ; } mapping ( string => GameType ) public gameTypes ; mapping ( address => bool ) public licensedDevelopers ; event GameTypeRegistered ( string indexed gameType , string [] facets ); event GameDeployed ( address indexed diamond , string gameType , address indexed developer ); event DeveloperLicensed ( address indexed developer , string gameType ); function registerGameType ( string memory gameTypeName , string [] memory facetNames , IDiamondCut . FacetCut [][] memory facetSets , uint256 licenseFee , address licenseToken ) external onlyPlatformOwner { DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); // Register each facet set for ( uint256 i = 0 ; i < facetNames . length ; i ++ ) { DiamondFactoryLib . _addFacetSet ( ds , facetNames [ i ], facetSets [ i ]); } gameTypes [ gameTypeName ] = GameType ({ name : gameTypeName , requiredFacets : facetNames , licenseFee : licenseFee , licenseToken : licenseToken , requiresLicense : licenseFee > 0 }); emit GameTypeRegistered ( gameTypeName , facetNames ); } function purchaseLicense ( string memory gameType ) external { GameType memory game = gameTypes [ gameType ]; require ( game . requiresLicense , \"No license required\" ); // Transfer license fee IERC20 ( game . licenseToken ). transferFrom ( msg.sender , address ( this ), game . licenseFee ); licensedDevelopers [ msg.sender ] = true ; emit DeveloperLicensed ( msg.sender , gameType ); } function deployGame ( string memory gameType , string memory gameName , string memory symbol , GameSettings memory gameSettings ) external returns ( address diamond ) { GameType memory game = gameTypes [ gameType ]; require ( bytes ( game . name ). length > 0 , \"Game type not registered\" ); if ( game . requiresLicense ) { require ( licensedDevelopers [ msg.sender ], \"License required\" ); } DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); // Combine all required facets IDiamondCut . FacetCut [] memory allFacets = combineGameFacets ( game . requiredFacets ); DiamondSettings memory settings = DiamondSettings ({ name : gameName , symbol : symbol , owner : msg.sender , gameType : gameType , gameSettings : gameSettings }); bytes memory creationCode = getGameDiamondBytecode (); address predictedAddress = DiamondFactoryLib . _getDiamondAddress ( ds , address ( this ), symbol , creationCode ); diamond = DiamondFactoryLib . create ( ds , predictedAddress , settings , getGameInitContract (), getGameInitCalldata ( settings ), creationCode , allFacets ); emit GameDeployed ( diamond , gameType , msg.sender ); } function combineGameFacets ( string [] memory facetNames ) internal view returns ( IDiamondCut . FacetCut [] memory ) { DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); // Calculate total facets needed uint256 totalFacets = 0 ; for ( uint256 i = 0 ; i < facetNames . length ; i ++ ) { totalFacets += DiamondFactoryLib . _getFacets ( ds , facetNames [ i ]). length ; } // Combine all facets IDiamondCut . FacetCut [] memory combined = new IDiamondCut . FacetCut []( totalFacets ); uint256 index = 0 ; for ( uint256 i = 0 ; i < facetNames . length ; i ++ ) { IDiamondCut . FacetCut [] memory facets = DiamondFactoryLib . _getFacets ( ds , facetNames [ i ]); for ( uint256 j = 0 ; j < facets . length ; j ++ ) { combined [ index ++ ] = facets [ j ]; } } return combined ; } function getGameDiamondBytecode () internal pure returns ( bytes memory ) { // Return game-specific Diamond bytecode } function getGameInitContract () internal pure returns ( address ) { // Return game Diamond initialization contract } function getGameInitCalldata ( DiamondSettings memory settings ) internal pure returns ( bytes memory ) { // Return game initialization calldata } modifier onlyPlatformOwner () { // Implementation _ ; } }","title":"Gaming Platform Factory"},{"location":"smart-contracts/libraries/diamond-factory-lib/#defi-protocol-factory","text":"// Factory for creating DeFi protocol Diamonds contract DeFiProtocolFactory { using DiamondFactoryLib for DiamondFactoryLib . DiamondFactoryStorage ; struct ProtocolConfig { string protocolType ; address [] requiredTokens ; uint256 minLiquidity ; uint256 governanceThreshold ; bool requiresGovernance ; } mapping ( string => ProtocolConfig ) public protocolConfigs ; mapping ( address => address []) public userProtocols ; event ProtocolConfigured ( string indexed protocolType , address [] tokens ); event ProtocolDeployed ( address indexed diamond , string protocolType , address indexed creator ); function configureProtocol ( string memory protocolType , IDiamondCut . FacetCut [] memory coreFacets , IDiamondCut . FacetCut [] memory governanceFacets , address [] memory requiredTokens , uint256 minLiquidity , uint256 governanceThreshold ) external onlyGovernance { DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); // Add core protocol facets DiamondFactoryLib . _addFacetSet ( ds , string ( abi . encodePacked ( protocolType , \"_core\" )), coreFacets ); // Add governance facets if provided if ( governanceFacets . length > 0 ) { DiamondFactoryLib . _addFacetSet ( ds , string ( abi . encodePacked ( protocolType , \"_governance\" )), governanceFacets ); } protocolConfigs [ protocolType ] = ProtocolConfig ({ protocolType : protocolType , requiredTokens : requiredTokens , minLiquidity : minLiquidity , governanceThreshold : governanceThreshold , requiresGovernance : governanceFacets . length > 0 }); emit ProtocolConfigured ( protocolType , requiredTokens ); } function deployProtocol ( string memory protocolType , string memory protocolName , string memory symbol , address [] memory initialTokens , uint256 initialLiquidity ) external payable returns ( address diamond ) { ProtocolConfig memory config = protocolConfigs [ protocolType ]; require ( bytes ( config . protocolType ). length > 0 , \"Protocol not configured\" ); require ( initialLiquidity >= config . minLiquidity , \"Insufficient liquidity\" ); // Validate required tokens are included for ( uint256 i = 0 ; i < config . requiredTokens . length ; i ++ ) { bool found = false ; for ( uint256 j = 0 ; j < initialTokens . length ; j ++ ) { if ( config . requiredTokens [ i ] == initialTokens [ j ]) { found = true ; break ; } } require ( found , \"Missing required token\" ); } DiamondFactoryLib . DiamondFactoryStorage storage ds = DiamondFactoryLib . diamondFactoryStorage (); // Get core facets IDiamondCut . FacetCut [] memory coreFacets = DiamondFactoryLib . _getFacets ( ds , string ( abi . encodePacked ( protocolType , \"_core\" )) ); // Add governance facets if required IDiamondCut . FacetCut [] memory allFacets ; if ( config . requiresGovernance ) { IDiamondCut . FacetCut [] memory govFacets = DiamondFactoryLib . _getFacets ( ds , string ( abi . encodePacked ( protocolType , \"_governance\" )) ); allFacets = combineFacets ( coreFacets , govFacets ); } else { allFacets = coreFacets ; } ProtocolSettings memory settings = ProtocolSettings ({ name : protocolName , symbol : symbol , protocolType : protocolType , tokens : initialTokens , initialLiquidity : initialLiquidity , owner : msg.sender }); bytes memory creationCode = getProtocolDiamondBytecode (); address predictedAddress = DiamondFactoryLib . _getDiamondAddress ( ds , address ( this ), symbol , creationCode ); diamond = DiamondFactoryLib . create ( ds , predictedAddress , DiamondSettings ( settings ), getProtocolInitContract (), getProtocolInitCalldata ( settings ), creationCode , allFacets ); // Track user protocols userProtocols [ msg.sender ]. push ( diamond ); emit ProtocolDeployed ( diamond , protocolType , msg.sender ); } function getUserProtocols ( address user ) external view returns ( address [] memory ) { return userProtocols [ user ]; } function combineFacets ( IDiamondCut . FacetCut [] memory facets1 , IDiamondCut . FacetCut [] memory facets2 ) internal pure returns ( IDiamondCut . FacetCut [] memory ) { IDiamondCut . FacetCut [] memory combined = new IDiamondCut . FacetCut []( facets1 . length + facets2 . length ); for ( uint256 i = 0 ; i < facets1 . length ; i ++ ) { combined [ i ] = facets1 [ i ]; } for ( uint256 i = 0 ; i < facets2 . length ; i ++ ) { combined [ facets1 . length + i ] = facets2 [ i ]; } return combined ; } function getProtocolDiamondBytecode () internal pure returns ( bytes memory ) { // Return protocol Diamond bytecode } function getProtocolInitContract () internal pure returns ( address ) { // Return protocol initialization contract } function getProtocolInitCalldata ( ProtocolSettings memory settings ) internal pure returns ( bytes memory ) { // Return protocol initialization calldata } modifier onlyGovernance () { // Implementation _ ; } }","title":"DeFi Protocol Factory"},{"location":"smart-contracts/libraries/diamond-factory-lib/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/diamond-factory-lib/#create2-security","text":"Deterministic address generation prevents front-running Salt includes factory address and symbol for uniqueness Bytecode hash ensures deployment integrity Address prediction enables secure cross-chain operations","title":"CREATE2 Security"},{"location":"smart-contracts/libraries/diamond-factory-lib/#access-control","text":"Factory owner controls facet set management Diamond ownership transferred to deployer Initialization parameters validated before deployment Registry management restricted to authorized functions","title":"Access Control"},{"location":"smart-contracts/libraries/diamond-factory-lib/#deployment-safety","text":"Deployment failure handling with require statements Initialization atomicity through single transaction Facet validation before Diamond creation Storage consistency through proper registry updates","title":"Deployment Safety"},{"location":"smart-contracts/libraries/diamond-factory-lib/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/libraries/diamond-factory-lib/#storage-efficiency","text":"Efficient mapping structures for Diamond registry Minimal storage writes during deployment Optimized facet set storage and retrieval Batch operations for facet management","title":"Storage Efficiency"},{"location":"smart-contracts/libraries/diamond-factory-lib/#deployment-efficiency","text":"CREATE2 for deterministic deployment Single transaction initialization Efficient facet combination algorithms Minimal external calls during deployment","title":"Deployment Efficiency"},{"location":"smart-contracts/libraries/diamond-factory-lib/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/libraries/diamond-factory-lib/#common-errors","text":"\"create_failed\" - Diamond deployment failure \"Invalid facet set\" - Unknown or empty facet set \"Symbol already exists\" - Duplicate Diamond symbol \"Initialization failed\" - Diamond initialization error","title":"Common Errors"},{"location":"smart-contracts/libraries/diamond-factory-lib/#best-practices","text":"Validate all parameters before deployment Check facet set existence before use Verify Diamond deployment success Handle initialization failures gracefully","title":"Best Practices"},{"location":"smart-contracts/libraries/diamond-factory-lib/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/libraries/diamond-factory-lib/#unit-tests","text":"Facet set management operations Diamond address prediction accuracy Deployment with custom facets Registry management functions","title":"Unit Tests"},{"location":"smart-contracts/libraries/diamond-factory-lib/#integration-tests","text":"End-to-end Diamond deployment Multi-facet Diamond creation Cross-contract initialization Factory upgrade scenarios","title":"Integration Tests"},{"location":"smart-contracts/libraries/diamond-factory-lib/#related-documentation","text":"IDiamondFactory Interface - Factory interface definition Diamond Contract - Core Diamond proxy implementation DiamondCut Facet - Diamond upgrade functionality Diamond Factory Standard EIP - Standard specification Diamond Deployment Guide - Deployment best practices This library provides comprehensive utilities for creating and managing Diamond proxy contracts using the factory pattern, enabling scalable deployment of upgradeable smart contract systems with configurable functionality.","title":"Related Documentation"},{"location":"smart-contracts/libraries/diamond-lib/","text":"DiamondLib Library \u00b6 Overview \u00b6 DiamondLib is a specialized diamond storage library that provides access to the Gemforce-specific diamond storage structure. This library extends the standard Diamond pattern with application-specific storage management for the Gemforce platform. Key Features \u00b6 Gemforce Diamond Storage : Provides access to platform-specific diamond storage Storage Isolation : Uses unique storage position for Gemforce diamond data ERC Standards Integration : Imports and integrates with ERC721, ERC165, and other standards Diamond Pattern Extension : Extends the standard diamond pattern for Gemforce use cases Storage Structure \u00b6 Diamond Storage Position \u00b6 The library uses a unique storage position to avoid conflicts with other diamond implementations: bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nextblock.bitgem.app.DiamondStorage.storage\" ); This ensures that Gemforce diamond storage is isolated from other diamond implementations that might be used in the same contract ecosystem. Core Functions \u00b6 Storage Access \u00b6 diamondStorage() \u00b6 function diamondStorage () internal pure returns ( DiamondStorage storage ds ) Returns the Gemforce-specific diamond storage struct using assembly for gas-efficient access. Returns: - ds : The diamond storage struct containing all platform-specific data Implementation Details: - Uses assembly for direct storage slot access - Provides gas-efficient storage access pattern - Ensures consistent storage location across all facets Dependencies \u00b6 The library imports several key interfaces and libraries: Standard Interfaces \u00b6 IERC165 : Interface detection standard IERC721 : Non-fungible token standard IERC721Metadata : NFT metadata extension Diamond Interfaces \u00b6 IDiamondCut : Diamond upgrade operations IDiamondLoupe : Diamond introspection IERC173 : Contract ownership standard DiamondStorage : Platform-specific storage structure IToken : Token definition interface Related Libraries \u00b6 LibDiamond : Core diamond functionality ERC721ALib : ERC721A implementation library Initialization \u00b6 DiamondInit : Diamond initialization contract Usage Patterns \u00b6 Accessing Diamond Storage \u00b6 import { DiamondLib } from \"./libraries/DiamondLib.sol\" ; contract MyFacet { function someFunction () external { DiamondStorage storage ds = DiamondLib . diamondStorage (); // Access platform-specific storage } } Integration with Facets \u00b6 // In a facet contract function getPlatformData () external view returns ( SomeData memory ) { DiamondStorage storage ds = DiamondLib . diamondStorage (); return ds . platformSpecificData ; } Storage Architecture \u00b6 Separation of Concerns \u00b6 LibDiamond : Handles core diamond functionality (facet management, upgrades) DiamondLib : Manages Gemforce-specific storage and data structures Facet Libraries : Handle domain-specific logic and storage Storage Isolation Benefits \u00b6 Conflict Prevention : Unique storage position prevents conflicts Upgrade Safety : Isolated storage reduces upgrade risks Platform Specificity : Allows platform-specific optimizations Modularity : Clean separation between core and platform features Integration Points \u00b6 Core Diamond System \u00b6 Works alongside LibDiamond for complete diamond functionality Provides platform-specific storage while LibDiamond handles upgrades Integrates with diamond initialization processes Token Systems \u00b6 Integrates with ERC721A library for NFT functionality Supports token definition structures Enables platform-specific token features Facet Architecture \u00b6 Used by all Gemforce facets for consistent storage access Provides unified storage interface across the platform Enables cross-facet data sharing Best Practices \u00b6 Storage Access \u00b6 Consistent Usage : Always use DiamondLib.diamondStorage() for platform storage Gas Efficiency : Leverage assembly-based storage access for performance Storage Isolation : Keep platform storage separate from facet-specific storage Development Patterns \u00b6 Import Consistency : Always import DiamondLib in facets needing platform storage Storage Structure : Follow established patterns for storage organization Upgrade Compatibility : Ensure storage changes are upgrade-compatible Security Considerations \u00b6 Storage Position : Never modify the DIAMOND_STORAGE_POSITION constant Access Control : Implement proper access controls for storage modifications Data Integrity : Validate data before storing in diamond storage Relationship to LibDiamond \u00b6 Aspect LibDiamond DiamondLib Purpose Core diamond functionality Platform-specific storage Storage Standard diamond storage Gemforce diamond storage Scope Universal diamond operations Platform-specific operations Usage Upgrade management Application data access Migration and Upgrades \u00b6 Storage Compatibility \u00b6 Maintains backward compatibility with existing storage layouts Supports incremental storage structure updates Provides migration paths for storage changes Upgrade Considerations \u00b6 Storage position remains constant across upgrades New storage fields can be added safely Existing storage fields should not be modified Related Documentation \u00b6 LibDiamond Library - Core diamond functionality Diamond Standard Overview - Diamond pattern implementation IDiamond Interface - Diamond interface specification ERC721A Library - NFT implementation library Diamond Factory Library - Diamond deployment utilities Technical Notes \u00b6 Assembly Usage \u00b6 The library uses assembly for storage access to achieve gas efficiency: assembly { ds . slot := position } This pattern is safe and widely used in diamond implementations for optimal performance. Storage Position Calculation \u00b6 The storage position is calculated using: keccak256 ( \"diamond.nextblock.bitgem.app.DiamondStorage.storage\" ) This ensures a unique, deterministic storage location that won't conflict with other systems.","title":"DiamondLib"},{"location":"smart-contracts/libraries/diamond-lib/#diamondlib-library","text":"","title":"DiamondLib Library"},{"location":"smart-contracts/libraries/diamond-lib/#overview","text":"DiamondLib is a specialized diamond storage library that provides access to the Gemforce-specific diamond storage structure. This library extends the standard Diamond pattern with application-specific storage management for the Gemforce platform.","title":"Overview"},{"location":"smart-contracts/libraries/diamond-lib/#key-features","text":"Gemforce Diamond Storage : Provides access to platform-specific diamond storage Storage Isolation : Uses unique storage position for Gemforce diamond data ERC Standards Integration : Imports and integrates with ERC721, ERC165, and other standards Diamond Pattern Extension : Extends the standard diamond pattern for Gemforce use cases","title":"Key Features"},{"location":"smart-contracts/libraries/diamond-lib/#storage-structure","text":"","title":"Storage Structure"},{"location":"smart-contracts/libraries/diamond-lib/#diamond-storage-position","text":"The library uses a unique storage position to avoid conflicts with other diamond implementations: bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nextblock.bitgem.app.DiamondStorage.storage\" ); This ensures that Gemforce diamond storage is isolated from other diamond implementations that might be used in the same contract ecosystem.","title":"Diamond Storage Position"},{"location":"smart-contracts/libraries/diamond-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/diamond-lib/#storage-access","text":"","title":"Storage Access"},{"location":"smart-contracts/libraries/diamond-lib/#diamondstorage","text":"function diamondStorage () internal pure returns ( DiamondStorage storage ds ) Returns the Gemforce-specific diamond storage struct using assembly for gas-efficient access. Returns: - ds : The diamond storage struct containing all platform-specific data Implementation Details: - Uses assembly for direct storage slot access - Provides gas-efficient storage access pattern - Ensures consistent storage location across all facets","title":"diamondStorage()"},{"location":"smart-contracts/libraries/diamond-lib/#dependencies","text":"The library imports several key interfaces and libraries:","title":"Dependencies"},{"location":"smart-contracts/libraries/diamond-lib/#standard-interfaces","text":"IERC165 : Interface detection standard IERC721 : Non-fungible token standard IERC721Metadata : NFT metadata extension","title":"Standard Interfaces"},{"location":"smart-contracts/libraries/diamond-lib/#diamond-interfaces","text":"IDiamondCut : Diamond upgrade operations IDiamondLoupe : Diamond introspection IERC173 : Contract ownership standard DiamondStorage : Platform-specific storage structure IToken : Token definition interface","title":"Diamond Interfaces"},{"location":"smart-contracts/libraries/diamond-lib/#related-libraries","text":"LibDiamond : Core diamond functionality ERC721ALib : ERC721A implementation library","title":"Related Libraries"},{"location":"smart-contracts/libraries/diamond-lib/#initialization","text":"DiamondInit : Diamond initialization contract","title":"Initialization"},{"location":"smart-contracts/libraries/diamond-lib/#usage-patterns","text":"","title":"Usage Patterns"},{"location":"smart-contracts/libraries/diamond-lib/#accessing-diamond-storage","text":"import { DiamondLib } from \"./libraries/DiamondLib.sol\" ; contract MyFacet { function someFunction () external { DiamondStorage storage ds = DiamondLib . diamondStorage (); // Access platform-specific storage } }","title":"Accessing Diamond Storage"},{"location":"smart-contracts/libraries/diamond-lib/#integration-with-facets","text":"// In a facet contract function getPlatformData () external view returns ( SomeData memory ) { DiamondStorage storage ds = DiamondLib . diamondStorage (); return ds . platformSpecificData ; }","title":"Integration with Facets"},{"location":"smart-contracts/libraries/diamond-lib/#storage-architecture","text":"","title":"Storage Architecture"},{"location":"smart-contracts/libraries/diamond-lib/#separation-of-concerns","text":"LibDiamond : Handles core diamond functionality (facet management, upgrades) DiamondLib : Manages Gemforce-specific storage and data structures Facet Libraries : Handle domain-specific logic and storage","title":"Separation of Concerns"},{"location":"smart-contracts/libraries/diamond-lib/#storage-isolation-benefits","text":"Conflict Prevention : Unique storage position prevents conflicts Upgrade Safety : Isolated storage reduces upgrade risks Platform Specificity : Allows platform-specific optimizations Modularity : Clean separation between core and platform features","title":"Storage Isolation Benefits"},{"location":"smart-contracts/libraries/diamond-lib/#integration-points","text":"","title":"Integration Points"},{"location":"smart-contracts/libraries/diamond-lib/#core-diamond-system","text":"Works alongside LibDiamond for complete diamond functionality Provides platform-specific storage while LibDiamond handles upgrades Integrates with diamond initialization processes","title":"Core Diamond System"},{"location":"smart-contracts/libraries/diamond-lib/#token-systems","text":"Integrates with ERC721A library for NFT functionality Supports token definition structures Enables platform-specific token features","title":"Token Systems"},{"location":"smart-contracts/libraries/diamond-lib/#facet-architecture","text":"Used by all Gemforce facets for consistent storage access Provides unified storage interface across the platform Enables cross-facet data sharing","title":"Facet Architecture"},{"location":"smart-contracts/libraries/diamond-lib/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/libraries/diamond-lib/#storage-access_1","text":"Consistent Usage : Always use DiamondLib.diamondStorage() for platform storage Gas Efficiency : Leverage assembly-based storage access for performance Storage Isolation : Keep platform storage separate from facet-specific storage","title":"Storage Access"},{"location":"smart-contracts/libraries/diamond-lib/#development-patterns","text":"Import Consistency : Always import DiamondLib in facets needing platform storage Storage Structure : Follow established patterns for storage organization Upgrade Compatibility : Ensure storage changes are upgrade-compatible","title":"Development Patterns"},{"location":"smart-contracts/libraries/diamond-lib/#security-considerations","text":"Storage Position : Never modify the DIAMOND_STORAGE_POSITION constant Access Control : Implement proper access controls for storage modifications Data Integrity : Validate data before storing in diamond storage","title":"Security Considerations"},{"location":"smart-contracts/libraries/diamond-lib/#relationship-to-libdiamond","text":"Aspect LibDiamond DiamondLib Purpose Core diamond functionality Platform-specific storage Storage Standard diamond storage Gemforce diamond storage Scope Universal diamond operations Platform-specific operations Usage Upgrade management Application data access","title":"Relationship to LibDiamond"},{"location":"smart-contracts/libraries/diamond-lib/#migration-and-upgrades","text":"","title":"Migration and Upgrades"},{"location":"smart-contracts/libraries/diamond-lib/#storage-compatibility","text":"Maintains backward compatibility with existing storage layouts Supports incremental storage structure updates Provides migration paths for storage changes","title":"Storage Compatibility"},{"location":"smart-contracts/libraries/diamond-lib/#upgrade-considerations","text":"Storage position remains constant across upgrades New storage fields can be added safely Existing storage fields should not be modified","title":"Upgrade Considerations"},{"location":"smart-contracts/libraries/diamond-lib/#related-documentation","text":"LibDiamond Library - Core diamond functionality Diamond Standard Overview - Diamond pattern implementation IDiamond Interface - Diamond interface specification ERC721A Library - NFT implementation library Diamond Factory Library - Diamond deployment utilities","title":"Related Documentation"},{"location":"smart-contracts/libraries/diamond-lib/#technical-notes","text":"","title":"Technical Notes"},{"location":"smart-contracts/libraries/diamond-lib/#assembly-usage","text":"The library uses assembly for storage access to achieve gas efficiency: assembly { ds . slot := position } This pattern is safe and widely used in diamond implementations for optimal performance.","title":"Assembly Usage"},{"location":"smart-contracts/libraries/diamond-lib/#storage-position-calculation","text":"The storage position is calculated using: keccak256 ( \"diamond.nextblock.bitgem.app.DiamondStorage.storage\" ) This ensures a unique, deterministic storage location that won't conflict with other systems.","title":"Storage Position Calculation"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/","text":"ERC721AEnumerationLib Library \u00b6 Overview \u00b6 ERC721AEnumerationLib provides enumeration functionality for ERC721A tokens, implementing the ERC721Enumerable extension. This library enables efficient querying and iteration over token collections, allowing applications to discover tokens by index and enumerate tokens owned by specific addresses. Key Features \u00b6 Token Enumeration : Query tokens by global index Owner Token Listing : Enumerate tokens owned by specific addresses Gas-Optimized Operations : Efficient O(1) add/remove operations with swap-and-pop pattern ERC721Enumerable Compliance : Full compatibility with the ERC721Enumerable standard Index Tracking : Maintains bidirectional mappings between tokens and indices Core Functions \u00b6 Public Query Functions \u00b6 tokenOfOwnerByIndex() \u00b6 function tokenOfOwnerByIndex ( ERC721EnumerableContract storage self , address owner , uint256 index ) internal view returns ( uint256 ) Returns the token ID at the specified index in the owner's token list. Parameters: - owner : Address of the token owner - index : Index in the owner's token array (0-based) Returns: - Token ID at the specified index Usage: // Get the first token owned by an address uint256 firstToken = ERC721AEnumerationLib . tokenOfOwnerByIndex ( enumStorage , owner , 0 ); totalSupply() \u00b6 function totalSupply ( ERC721EnumerableContract storage self ) internal view returns ( uint256 ) Returns the total number of tokens in the collection. Returns: - Total number of tokens currently in existence tokenByIndex() \u00b6 function tokenByIndex ( ERC721EnumerableContract storage self , uint256 index ) internal view returns ( uint256 ) Returns the token ID at the specified global index. Parameters: - index : Global index in the all tokens array (0-based) Returns: - Token ID at the specified global index Usage: // Get the 10th token in the collection uint256 token = ERC721AEnumerationLib . tokenByIndex ( enumStorage , 9 ); Internal Management Functions \u00b6 _addTokenToOwnerEnumeration() \u00b6 function _addTokenToOwnerEnumeration ( ERC721EnumerableContract storage self , address to , uint256 tokenId ) internal Adds a token to the owner's enumeration tracking when minted or transferred. Parameters: - to : Address receiving the token - tokenId : ID of the token being added Internal Logic: - Adds token to the end of owner's token array - Records the token's position in the owner's array - Updates bidirectional mapping for efficient lookups _addTokenToAllTokensEnumeration() \u00b6 function _addTokenToAllTokensEnumeration ( ERC721EnumerableContract storage self , uint256 tokenId ) internal Adds a token to the global enumeration tracking when minted. Parameters: - tokenId : ID of the token being added Internal Logic: - Adds token to the end of global tokens array - Records the token's position in the global array - Maintains global token index mapping _removeTokenFromOwnerEnumeration() \u00b6 function _removeTokenFromOwnerEnumeration ( ERC721EnumerableContract storage self , address from , uint256 tokenId ) internal Removes a token from the owner's enumeration tracking when transferred or burned. Parameters: - from : Address losing the token - tokenId : ID of the token being removed Gas Optimization Features: - Swap-and-Pop Pattern : Moves last token to deleted position to avoid gaps - O(1) Complexity : Constant time removal regardless of collection size - Index Preservation : Maintains array compactness without shifting elements _removeTokenFromAllTokensEnumeration() \u00b6 function _removeTokenFromAllTokensEnumeration ( ERC721EnumerableContract storage self , uint256 tokenId ) internal Removes a token from the global enumeration tracking when burned. Parameters: - tokenId : ID of the token being removed Gas Optimization Features: - Swap-and-Pop Pattern : Maintains array compactness - O(1) Complexity : Efficient removal from global tracking - Index Updates : Properly updates moved token's index Storage Structure \u00b6 The enumeration library uses the following storage mappings: struct ERC721EnumerableContract { // Mapping from owner to list of owned token IDs mapping ( address => mapping ( uint256 => uint256 )) _ownedTokens ; // Mapping from token ID to index of the owner tokens list mapping ( uint256 => uint256 ) _ownedTokensIndex ; // Array with all token ids, used for enumeration uint256 [] _allTokens ; // Mapping from token id to position in the allTokens array mapping ( uint256 => uint256 ) _allTokensIndex ; } Gas Optimization Techniques \u00b6 Swap-and-Pop Pattern \u00b6 The library uses an efficient swap-and-pop pattern for removals: Identify Position : Find the index of the token to remove Swap with Last : Move the last token to the position being vacated Update Index : Update the moved token's index mapping Pop Last : Remove the last element (now duplicate) This approach: - Maintains array compactness without gaps - Achieves O(1) time complexity for removals - Minimizes gas costs by avoiding array shifts Bidirectional Mappings \u00b6 The library maintains bidirectional mappings between tokens and indices: - Token \u2192 Index : Quick lookup of token position - Index \u2192 Token : Direct access to token by position - Efficient Updates : Both mappings updated atomically Integration Patterns \u00b6 With ERC721A Library \u00b6 import { ERC721ALib } from \"./ERC721ALib.sol\" ; import { ERC721AEnumerationLib } from \"./ERC721AEnumerationLib.sol\" ; contract NFTFacet { function mint ( address to , uint256 quantity ) external { // Mint tokens using ERC721A ERC721ALib . _mint ( erc721Storage , msg.sender , to , quantity , \"\" , true ); // Update enumeration for each token uint256 startTokenId = ERC721ALib . currentIndex ( erc721Storage ) - quantity ; for ( uint256 i = 0 ; i < quantity ; i ++ ) { ERC721AEnumerationLib . _addTokenToOwnerEnumeration ( enumStorage , to , startTokenId + i ); ERC721AEnumerationLib . _addTokenToAllTokensEnumeration ( enumStorage , startTokenId + i ); } } } Hook Integration \u00b6 // In ERC721A hooks function _beforeTokenTransfers ( address from , address to , uint256 startTokenId , uint256 quantity ) internal override { super . _beforeTokenTransfers ( from , to , startTokenId , quantity ); for ( uint256 i = 0 ; i < quantity ; i ++ ) { uint256 tokenId = startTokenId + i ; if ( from != address ( 0 )) { ERC721AEnumerationLib . _removeTokenFromOwnerEnumeration ( enumStorage , from , tokenId ); } if ( to != address ( 0 )) { ERC721AEnumerationLib . _addTokenToOwnerEnumeration ( enumStorage , to , tokenId ); } else { ERC721AEnumerationLib . _removeTokenFromAllTokensEnumeration ( enumStorage , tokenId ); } if ( from == address ( 0 )) { ERC721AEnumerationLib . _addTokenToAllTokensEnumeration ( enumStorage , tokenId ); } } } Usage Examples \u00b6 Querying Owner Tokens \u00b6 function getOwnerTokens ( address owner ) external view returns ( uint256 [] memory ) { uint256 balance = IERC721 ( address ( this )). balanceOf ( owner ); uint256 [] memory tokens = new uint256 []( balance ); for ( uint256 i = 0 ; i < balance ; i ++ ) { tokens [ i ] = ERC721AEnumerationLib . tokenOfOwnerByIndex ( enumStorage , owner , i ); } return tokens ; } Paginated Token Listing \u00b6 function getTokensPaginated ( uint256 offset , uint256 limit ) external view returns ( uint256 [] memory ) { uint256 total = ERC721AEnumerationLib . totalSupply ( enumStorage ); require ( offset < total , \"Offset out of bounds\" ); uint256 end = offset + limit ; if ( end > total ) { end = total ; } uint256 [] memory tokens = new uint256 []( end - offset ); for ( uint256 i = offset ; i < end ; i ++ ) { tokens [ i - offset ] = ERC721AEnumerationLib . tokenByIndex ( enumStorage , i ); } return tokens ; } Random Token Selection \u00b6 function getRandomToken ( uint256 seed ) external view returns ( uint256 ) { uint256 total = ERC721AEnumerationLib . totalSupply ( enumStorage ); require ( total > 0 , \"No tokens exist\" ); uint256 randomIndex = seed % total ; return ERC721AEnumerationLib . tokenByIndex ( enumStorage , randomIndex ); } Performance Characteristics \u00b6 Time Complexity \u00b6 Query Operations : O(1) for all query functions Add Operations : O(1) for adding tokens to enumeration Remove Operations : O(1) for removing tokens from enumeration Gas Costs (Approximate) \u00b6 Add to Owner Enumeration : ~5,000 gas Remove from Owner Enumeration : ~8,000 gas Add to Global Enumeration : ~5,000 gas Remove from Global Enumeration : ~8,000 gas Query Operations : ~500-1,000 gas Storage Overhead \u00b6 Per Token : 2 storage slots (owner index + global index) Per Owner : Dynamic array of owned tokens Global : Single array of all tokens Security Considerations \u00b6 Index Bounds Checking \u00b6 All query functions validate index bounds Prevents out-of-bounds array access Returns appropriate error messages State Consistency \u00b6 Enumeration state must be kept in sync with token transfers Proper integration with transfer hooks is essential Bidirectional mappings must be updated atomically Gas Limits \u00b6 Large collections may hit gas limits for batch operations Consider pagination for operations over many tokens Monitor gas usage in enumeration updates Best Practices \u00b6 Hook Integration : Always integrate enumeration updates with transfer hooks Batch Operations : Consider gas costs when processing multiple tokens Index Validation : Always validate indices before array access State Synchronization : Ensure enumeration state stays consistent with token state Gas Monitoring : Monitor gas usage for large collections Related Documentation \u00b6 ERC721A Library - Core ERC721A implementation ERC721Enumerable Standard - ERC721 enumeration extension Diamond Library - Diamond pattern integration Gemforce Minter Facet - Minting interface Migration Notes \u00b6 When upgrading from standard ERC721 enumeration: - Storage layout is compatible with OpenZeppelin's implementation - Gas costs are significantly optimized - API remains fully compatible - Integration requires proper hook setup","title":"ERC721A Enumeration Lib"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#erc721aenumerationlib-library","text":"","title":"ERC721AEnumerationLib Library"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#overview","text":"ERC721AEnumerationLib provides enumeration functionality for ERC721A tokens, implementing the ERC721Enumerable extension. This library enables efficient querying and iteration over token collections, allowing applications to discover tokens by index and enumerate tokens owned by specific addresses.","title":"Overview"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#key-features","text":"Token Enumeration : Query tokens by global index Owner Token Listing : Enumerate tokens owned by specific addresses Gas-Optimized Operations : Efficient O(1) add/remove operations with swap-and-pop pattern ERC721Enumerable Compliance : Full compatibility with the ERC721Enumerable standard Index Tracking : Maintains bidirectional mappings between tokens and indices","title":"Key Features"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#public-query-functions","text":"","title":"Public Query Functions"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#tokenofownerbyindex","text":"function tokenOfOwnerByIndex ( ERC721EnumerableContract storage self , address owner , uint256 index ) internal view returns ( uint256 ) Returns the token ID at the specified index in the owner's token list. Parameters: - owner : Address of the token owner - index : Index in the owner's token array (0-based) Returns: - Token ID at the specified index Usage: // Get the first token owned by an address uint256 firstToken = ERC721AEnumerationLib . tokenOfOwnerByIndex ( enumStorage , owner , 0 );","title":"tokenOfOwnerByIndex()"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#totalsupply","text":"function totalSupply ( ERC721EnumerableContract storage self ) internal view returns ( uint256 ) Returns the total number of tokens in the collection. Returns: - Total number of tokens currently in existence","title":"totalSupply()"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#tokenbyindex","text":"function tokenByIndex ( ERC721EnumerableContract storage self , uint256 index ) internal view returns ( uint256 ) Returns the token ID at the specified global index. Parameters: - index : Global index in the all tokens array (0-based) Returns: - Token ID at the specified global index Usage: // Get the 10th token in the collection uint256 token = ERC721AEnumerationLib . tokenByIndex ( enumStorage , 9 );","title":"tokenByIndex()"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#internal-management-functions","text":"","title":"Internal Management Functions"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#_addtokentoownerenumeration","text":"function _addTokenToOwnerEnumeration ( ERC721EnumerableContract storage self , address to , uint256 tokenId ) internal Adds a token to the owner's enumeration tracking when minted or transferred. Parameters: - to : Address receiving the token - tokenId : ID of the token being added Internal Logic: - Adds token to the end of owner's token array - Records the token's position in the owner's array - Updates bidirectional mapping for efficient lookups","title":"_addTokenToOwnerEnumeration()"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#_addtokentoalltokensenumeration","text":"function _addTokenToAllTokensEnumeration ( ERC721EnumerableContract storage self , uint256 tokenId ) internal Adds a token to the global enumeration tracking when minted. Parameters: - tokenId : ID of the token being added Internal Logic: - Adds token to the end of global tokens array - Records the token's position in the global array - Maintains global token index mapping","title":"_addTokenToAllTokensEnumeration()"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#_removetokenfromownerenumeration","text":"function _removeTokenFromOwnerEnumeration ( ERC721EnumerableContract storage self , address from , uint256 tokenId ) internal Removes a token from the owner's enumeration tracking when transferred or burned. Parameters: - from : Address losing the token - tokenId : ID of the token being removed Gas Optimization Features: - Swap-and-Pop Pattern : Moves last token to deleted position to avoid gaps - O(1) Complexity : Constant time removal regardless of collection size - Index Preservation : Maintains array compactness without shifting elements","title":"_removeTokenFromOwnerEnumeration()"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#_removetokenfromalltokensenumeration","text":"function _removeTokenFromAllTokensEnumeration ( ERC721EnumerableContract storage self , uint256 tokenId ) internal Removes a token from the global enumeration tracking when burned. Parameters: - tokenId : ID of the token being removed Gas Optimization Features: - Swap-and-Pop Pattern : Maintains array compactness - O(1) Complexity : Efficient removal from global tracking - Index Updates : Properly updates moved token's index","title":"_removeTokenFromAllTokensEnumeration()"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#storage-structure","text":"The enumeration library uses the following storage mappings: struct ERC721EnumerableContract { // Mapping from owner to list of owned token IDs mapping ( address => mapping ( uint256 => uint256 )) _ownedTokens ; // Mapping from token ID to index of the owner tokens list mapping ( uint256 => uint256 ) _ownedTokensIndex ; // Array with all token ids, used for enumeration uint256 [] _allTokens ; // Mapping from token id to position in the allTokens array mapping ( uint256 => uint256 ) _allTokensIndex ; }","title":"Storage Structure"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#gas-optimization-techniques","text":"","title":"Gas Optimization Techniques"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#swap-and-pop-pattern","text":"The library uses an efficient swap-and-pop pattern for removals: Identify Position : Find the index of the token to remove Swap with Last : Move the last token to the position being vacated Update Index : Update the moved token's index mapping Pop Last : Remove the last element (now duplicate) This approach: - Maintains array compactness without gaps - Achieves O(1) time complexity for removals - Minimizes gas costs by avoiding array shifts","title":"Swap-and-Pop Pattern"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#bidirectional-mappings","text":"The library maintains bidirectional mappings between tokens and indices: - Token \u2192 Index : Quick lookup of token position - Index \u2192 Token : Direct access to token by position - Efficient Updates : Both mappings updated atomically","title":"Bidirectional Mappings"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#integration-patterns","text":"","title":"Integration Patterns"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#with-erc721a-library","text":"import { ERC721ALib } from \"./ERC721ALib.sol\" ; import { ERC721AEnumerationLib } from \"./ERC721AEnumerationLib.sol\" ; contract NFTFacet { function mint ( address to , uint256 quantity ) external { // Mint tokens using ERC721A ERC721ALib . _mint ( erc721Storage , msg.sender , to , quantity , \"\" , true ); // Update enumeration for each token uint256 startTokenId = ERC721ALib . currentIndex ( erc721Storage ) - quantity ; for ( uint256 i = 0 ; i < quantity ; i ++ ) { ERC721AEnumerationLib . _addTokenToOwnerEnumeration ( enumStorage , to , startTokenId + i ); ERC721AEnumerationLib . _addTokenToAllTokensEnumeration ( enumStorage , startTokenId + i ); } } }","title":"With ERC721A Library"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#hook-integration","text":"// In ERC721A hooks function _beforeTokenTransfers ( address from , address to , uint256 startTokenId , uint256 quantity ) internal override { super . _beforeTokenTransfers ( from , to , startTokenId , quantity ); for ( uint256 i = 0 ; i < quantity ; i ++ ) { uint256 tokenId = startTokenId + i ; if ( from != address ( 0 )) { ERC721AEnumerationLib . _removeTokenFromOwnerEnumeration ( enumStorage , from , tokenId ); } if ( to != address ( 0 )) { ERC721AEnumerationLib . _addTokenToOwnerEnumeration ( enumStorage , to , tokenId ); } else { ERC721AEnumerationLib . _removeTokenFromAllTokensEnumeration ( enumStorage , tokenId ); } if ( from == address ( 0 )) { ERC721AEnumerationLib . _addTokenToAllTokensEnumeration ( enumStorage , tokenId ); } } }","title":"Hook Integration"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#usage-examples","text":"","title":"Usage Examples"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#querying-owner-tokens","text":"function getOwnerTokens ( address owner ) external view returns ( uint256 [] memory ) { uint256 balance = IERC721 ( address ( this )). balanceOf ( owner ); uint256 [] memory tokens = new uint256 []( balance ); for ( uint256 i = 0 ; i < balance ; i ++ ) { tokens [ i ] = ERC721AEnumerationLib . tokenOfOwnerByIndex ( enumStorage , owner , i ); } return tokens ; }","title":"Querying Owner Tokens"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#paginated-token-listing","text":"function getTokensPaginated ( uint256 offset , uint256 limit ) external view returns ( uint256 [] memory ) { uint256 total = ERC721AEnumerationLib . totalSupply ( enumStorage ); require ( offset < total , \"Offset out of bounds\" ); uint256 end = offset + limit ; if ( end > total ) { end = total ; } uint256 [] memory tokens = new uint256 []( end - offset ); for ( uint256 i = offset ; i < end ; i ++ ) { tokens [ i - offset ] = ERC721AEnumerationLib . tokenByIndex ( enumStorage , i ); } return tokens ; }","title":"Paginated Token Listing"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#random-token-selection","text":"function getRandomToken ( uint256 seed ) external view returns ( uint256 ) { uint256 total = ERC721AEnumerationLib . totalSupply ( enumStorage ); require ( total > 0 , \"No tokens exist\" ); uint256 randomIndex = seed % total ; return ERC721AEnumerationLib . tokenByIndex ( enumStorage , randomIndex ); }","title":"Random Token Selection"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#performance-characteristics","text":"","title":"Performance Characteristics"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#time-complexity","text":"Query Operations : O(1) for all query functions Add Operations : O(1) for adding tokens to enumeration Remove Operations : O(1) for removing tokens from enumeration","title":"Time Complexity"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#gas-costs-approximate","text":"Add to Owner Enumeration : ~5,000 gas Remove from Owner Enumeration : ~8,000 gas Add to Global Enumeration : ~5,000 gas Remove from Global Enumeration : ~8,000 gas Query Operations : ~500-1,000 gas","title":"Gas Costs (Approximate)"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#storage-overhead","text":"Per Token : 2 storage slots (owner index + global index) Per Owner : Dynamic array of owned tokens Global : Single array of all tokens","title":"Storage Overhead"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#index-bounds-checking","text":"All query functions validate index bounds Prevents out-of-bounds array access Returns appropriate error messages","title":"Index Bounds Checking"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#state-consistency","text":"Enumeration state must be kept in sync with token transfers Proper integration with transfer hooks is essential Bidirectional mappings must be updated atomically","title":"State Consistency"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#gas-limits","text":"Large collections may hit gas limits for batch operations Consider pagination for operations over many tokens Monitor gas usage in enumeration updates","title":"Gas Limits"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#best-practices","text":"Hook Integration : Always integrate enumeration updates with transfer hooks Batch Operations : Consider gas costs when processing multiple tokens Index Validation : Always validate indices before array access State Synchronization : Ensure enumeration state stays consistent with token state Gas Monitoring : Monitor gas usage for large collections","title":"Best Practices"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#related-documentation","text":"ERC721A Library - Core ERC721A implementation ERC721Enumerable Standard - ERC721 enumeration extension Diamond Library - Diamond pattern integration Gemforce Minter Facet - Minting interface","title":"Related Documentation"},{"location":"smart-contracts/libraries/erc721a-enumeration-lib/#migration-notes","text":"When upgrading from standard ERC721 enumeration: - Storage layout is compatible with OpenZeppelin's implementation - Gas costs are significantly optimized - API remains fully compatible - Integration requires proper hook setup","title":"Migration Notes"},{"location":"smart-contracts/libraries/erc721a-lib/","text":"ERC721ALib Library \u00b6 Overview \u00b6 ERC721ALib is a gas-optimized implementation of the ERC721 Non-Fungible Token standard, based on the ERC721A specification by Chiru Labs. This library provides efficient batch minting capabilities and optimized storage patterns for NFT collections, making it ideal for large-scale NFT projects. Key Features \u00b6 Gas-Optimized Minting : Batch mint multiple tokens with minimal gas overhead Efficient Storage : Optimized storage layout reduces gas costs for transfers and queries ERC721 Compatibility : Full compatibility with the ERC721 standard Burn Functionality : Support for token burning with proper accounting Auxiliary Data : Additional per-address data storage (e.g., whitelist usage) Safe Transfer Support : Built-in safe transfer checks for contract recipients Storage Structure \u00b6 ERC721AStorage \u00b6 The main storage structure for ERC721A functionality: struct ERC721AStorage { ERC721EnumerableContract enumerations ; ERC721AContract erc721Contract ; } ERC721AContract \u00b6 Core contract storage containing all NFT data: - Token ownership mappings - Approval mappings - Address data (balance, minted count, burned count, auxiliary data) - Current index and burn counter Core Functions \u00b6 Supply and Balance Queries \u00b6 totalSupply() \u00b6 function totalSupply ( ERC721AContract storage self ) internal view returns ( uint256 ) Returns the total number of tokens in circulation (minted - burned). balanceOf() \u00b6 function balanceOf ( ERC721AContract storage self , address owner ) internal view returns ( uint256 ) Returns the number of tokens owned by a specific address. Minting Statistics \u00b6 _numberMinted() \u00b6 function _numberMinted ( ERC721AContract storage self , address owner ) internal view returns ( uint256 ) Returns the total number of tokens minted by an address. _numberBurned() \u00b6 function _numberBurned ( ERC721AContract storage self , address owner ) internal view returns ( uint256 ) Returns the total number of tokens burned by or on behalf of an address. Auxiliary Data Management \u00b6 _getAux() \u00b6 function _getAux ( ERC721AContract storage self , address owner ) internal view returns ( uint64 ) Returns auxiliary data for an address (e.g., whitelist mint slots used). _setAux() \u00b6 function _setAux ( ERC721AContract storage self , address owner , uint64 aux ) internal Sets auxiliary data for an address. Token Ownership \u00b6 ownershipOf() \u00b6 function ownershipOf ( ERC721AContract storage self , uint256 tokenId ) internal view returns ( TokenOwnership memory ) Returns detailed ownership information for a token, including: - Owner address - Start timestamp - Burned status _ownerOf() \u00b6 function _ownerOf ( ERC721AContract storage self , uint256 tokenId ) internal view returns ( address ) Returns the owner address of a specific token. Token Existence and Approval \u00b6 _exists() \u00b6 function _exists ( ERC721AContract storage self , uint256 tokenId ) internal view returns ( bool ) Checks if a token exists (has been minted and not burned). getApproved() \u00b6 function getApproved ( ERC721AContract storage self , uint256 tokenId ) internal view returns ( address ) Returns the approved address for a specific token. setApprovalForAll() \u00b6 function setApprovalForAll ( ERC721AContract storage self , address sender , address operator , bool approved ) internal Sets or unsets approval for all tokens owned by sender. isApprovedForAll() \u00b6 function isApprovedForAll ( ERC721AContract storage self , address owner , address operator ) internal view returns ( bool ) Checks if an operator is approved for all tokens of an owner. Minting Operations \u00b6 _mint() \u00b6 function _mint ( ERC721AContract storage self , address msgSender , address to , uint256 quantity , bytes memory _data , bool safe ) internal Mints quantity tokens to the to address with gas optimization for batch operations. Parameters: - msgSender : The address initiating the mint - to : Recipient address - quantity : Number of tokens to mint - _data : Additional data for safe transfer check - safe : Whether to perform safe transfer checks Gas Optimization: - Only stores ownership data for the first token in a batch - Subsequent tokens inherit ownership through lookup algorithm - Significantly reduces gas costs for batch minting Transfer Operations \u00b6 _transfer() \u00b6 function _transfer ( ERC721AContract storage self , address msgSender , address from , address to , uint256 tokenId , bool _force ) internal Transfers a token from one address to another with proper ownership updates. Parameters: - _force : Bypasses approval checks when true (for internal operations) Features: - Automatic approval clearing - Ownership slot optimization for gas efficiency - Proper balance updates Burning Operations \u00b6 _burn() \u00b6 function _burn ( ERC721AContract storage self , uint256 tokenId ) internal Burns a token, marking it as destroyed while maintaining ownership history. Features: - Maintains burn counter for supply calculations - Preserves ownership data with burned flag - Updates address statistics Gas Optimization Features \u00b6 Batch Minting Efficiency \u00b6 Single Storage Write : Only the first token in a batch requires ownership storage Lookup Algorithm : Subsequent tokens find ownership through backward iteration Reduced Gas Costs : Significant savings for large batch mints Storage Layout Optimization \u00b6 Packed Structs : Address data packed into single storage slots Minimal Writes : Only necessary storage updates during operations Efficient Mappings : Optimized mapping structures for common operations Transfer Optimization \u00b6 Ownership Slot Management : Efficient handling of ownership slots during transfers Balance Updates : Minimal storage writes for balance changes Approval Clearing : Gas-efficient approval management Error Handling \u00b6 The library defines comprehensive custom errors for gas-efficient reverts: error ApprovalCallerNotOwnerNorApproved (); error ApprovalQueryForNonexistentToken (); error MintToZeroAddress (); error MintZeroQuantity (); error OwnerQueryForNonexistentToken (); error TransferCallerNotOwnerNorApproved (); error TransferFromIncorrectOwner (); error TransferToNonERC721ReceiverImplementer (); Hook Functions \u00b6 _beforeTokenTransfers() \u00b6 function _beforeTokenTransfers ( ERC721AContract storage self , address from , address to , uint256 startTokenId , uint256 quantity , bool force ) internal Hook called before token transfers, minting, or burning. Can be overridden for custom logic. _afterTokenTransfers() \u00b6 function _afterTokenTransfers ( ERC721AContract storage self , address from , address to , uint256 startTokenId , uint256 quantity ) internal Hook called after token transfers, minting, or burning. Can be overridden for custom logic. Usage Examples \u00b6 Basic Minting \u00b6 // Mint 5 tokens to an address ERC721ALib . _mint ( erc721Storage , msg.sender , recipient , 5 , \"\" , true ); Batch Operations \u00b6 // Check total supply uint256 supply = ERC721ALib . totalSupply ( erc721Storage ); // Check user's minted count uint256 minted = ERC721ALib . _numberMinted ( erc721Storage , user ); // Set auxiliary data (e.g., whitelist usage) ERC721ALib . _setAux ( erc721Storage , user , 3 ); Transfer Operations \u00b6 // Transfer token ERC721ALib . _transfer ( erc721Storage , msg.sender , from , to , tokenId , false ); // Burn token ERC721ALib . _burn ( erc721Storage , tokenId ); Integration with Diamond Pattern \u00b6 The library is designed to work within the Diamond pattern: import { ERC721ALib } from \"./libraries/ERC721ALib.sol\" ; contract NFTFacet { function mint ( address to , uint256 quantity ) external { ERC721AStorage storage s = erc721AStorage (); ERC721ALib . _mint ( s . erc721Contract , msg.sender , to , quantity , \"\" , true ); } } Security Considerations \u00b6 Access Control \u00b6 Minting Permissions : Implement proper access controls for minting functions Transfer Restrictions : Consider implementing transfer restrictions if needed Burn Authorization : Ensure only authorized parties can burn tokens Validation \u00b6 Address Validation : All functions validate against zero addresses Quantity Limits : Implement reasonable limits for batch operations Overflow Protection : Built-in protection against arithmetic overflows Safe Transfers \u00b6 Contract Recipients : Automatic checks for contract recipients Callback Validation : Proper handling of ERC721Receiver callbacks Reentrancy Protection : Consider reentrancy guards for external calls Performance Characteristics \u00b6 Gas Costs (Approximate) \u00b6 Single Mint : ~50,000 gas Batch Mint (10 tokens) : ~55,000 gas (5,500 per additional token) Transfer : ~30,000 gas Burn : ~25,000 gas Storage Efficiency \u00b6 Ownership Storage : Only first token in batch requires storage Address Data : Packed into single storage slots Minimal Overhead : Efficient data structures minimize storage costs Related Documentation \u00b6 ERC721A Enumeration Library - Enumeration extension Attribute Library - Token attribute management Diamond Library - Diamond pattern integration Gemforce Minter Facet - Minting interface ERC721A Standard - ERC721 specification Best Practices \u00b6 Batch Minting : Use batch minting for gas efficiency when minting multiple tokens Auxiliary Data : Leverage auxiliary data for additional per-address information Hook Implementation : Use hooks for custom logic without modifying core functions Error Handling : Use custom errors for gas-efficient error reporting Access Control : Implement proper permissions for all minting and administrative functions","title":"ERC721A Lib"},{"location":"smart-contracts/libraries/erc721a-lib/#erc721alib-library","text":"","title":"ERC721ALib Library"},{"location":"smart-contracts/libraries/erc721a-lib/#overview","text":"ERC721ALib is a gas-optimized implementation of the ERC721 Non-Fungible Token standard, based on the ERC721A specification by Chiru Labs. This library provides efficient batch minting capabilities and optimized storage patterns for NFT collections, making it ideal for large-scale NFT projects.","title":"Overview"},{"location":"smart-contracts/libraries/erc721a-lib/#key-features","text":"Gas-Optimized Minting : Batch mint multiple tokens with minimal gas overhead Efficient Storage : Optimized storage layout reduces gas costs for transfers and queries ERC721 Compatibility : Full compatibility with the ERC721 standard Burn Functionality : Support for token burning with proper accounting Auxiliary Data : Additional per-address data storage (e.g., whitelist usage) Safe Transfer Support : Built-in safe transfer checks for contract recipients","title":"Key Features"},{"location":"smart-contracts/libraries/erc721a-lib/#storage-structure","text":"","title":"Storage Structure"},{"location":"smart-contracts/libraries/erc721a-lib/#erc721astorage","text":"The main storage structure for ERC721A functionality: struct ERC721AStorage { ERC721EnumerableContract enumerations ; ERC721AContract erc721Contract ; }","title":"ERC721AStorage"},{"location":"smart-contracts/libraries/erc721a-lib/#erc721acontract","text":"Core contract storage containing all NFT data: - Token ownership mappings - Approval mappings - Address data (balance, minted count, burned count, auxiliary data) - Current index and burn counter","title":"ERC721AContract"},{"location":"smart-contracts/libraries/erc721a-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/erc721a-lib/#supply-and-balance-queries","text":"","title":"Supply and Balance Queries"},{"location":"smart-contracts/libraries/erc721a-lib/#totalsupply","text":"function totalSupply ( ERC721AContract storage self ) internal view returns ( uint256 ) Returns the total number of tokens in circulation (minted - burned).","title":"totalSupply()"},{"location":"smart-contracts/libraries/erc721a-lib/#balanceof","text":"function balanceOf ( ERC721AContract storage self , address owner ) internal view returns ( uint256 ) Returns the number of tokens owned by a specific address.","title":"balanceOf()"},{"location":"smart-contracts/libraries/erc721a-lib/#minting-statistics","text":"","title":"Minting Statistics"},{"location":"smart-contracts/libraries/erc721a-lib/#_numberminted","text":"function _numberMinted ( ERC721AContract storage self , address owner ) internal view returns ( uint256 ) Returns the total number of tokens minted by an address.","title":"_numberMinted()"},{"location":"smart-contracts/libraries/erc721a-lib/#_numberburned","text":"function _numberBurned ( ERC721AContract storage self , address owner ) internal view returns ( uint256 ) Returns the total number of tokens burned by or on behalf of an address.","title":"_numberBurned()"},{"location":"smart-contracts/libraries/erc721a-lib/#auxiliary-data-management","text":"","title":"Auxiliary Data Management"},{"location":"smart-contracts/libraries/erc721a-lib/#_getaux","text":"function _getAux ( ERC721AContract storage self , address owner ) internal view returns ( uint64 ) Returns auxiliary data for an address (e.g., whitelist mint slots used).","title":"_getAux()"},{"location":"smart-contracts/libraries/erc721a-lib/#_setaux","text":"function _setAux ( ERC721AContract storage self , address owner , uint64 aux ) internal Sets auxiliary data for an address.","title":"_setAux()"},{"location":"smart-contracts/libraries/erc721a-lib/#token-ownership","text":"","title":"Token Ownership"},{"location":"smart-contracts/libraries/erc721a-lib/#ownershipof","text":"function ownershipOf ( ERC721AContract storage self , uint256 tokenId ) internal view returns ( TokenOwnership memory ) Returns detailed ownership information for a token, including: - Owner address - Start timestamp - Burned status","title":"ownershipOf()"},{"location":"smart-contracts/libraries/erc721a-lib/#_ownerof","text":"function _ownerOf ( ERC721AContract storage self , uint256 tokenId ) internal view returns ( address ) Returns the owner address of a specific token.","title":"_ownerOf()"},{"location":"smart-contracts/libraries/erc721a-lib/#token-existence-and-approval","text":"","title":"Token Existence and Approval"},{"location":"smart-contracts/libraries/erc721a-lib/#_exists","text":"function _exists ( ERC721AContract storage self , uint256 tokenId ) internal view returns ( bool ) Checks if a token exists (has been minted and not burned).","title":"_exists()"},{"location":"smart-contracts/libraries/erc721a-lib/#getapproved","text":"function getApproved ( ERC721AContract storage self , uint256 tokenId ) internal view returns ( address ) Returns the approved address for a specific token.","title":"getApproved()"},{"location":"smart-contracts/libraries/erc721a-lib/#setapprovalforall","text":"function setApprovalForAll ( ERC721AContract storage self , address sender , address operator , bool approved ) internal Sets or unsets approval for all tokens owned by sender.","title":"setApprovalForAll()"},{"location":"smart-contracts/libraries/erc721a-lib/#isapprovedforall","text":"function isApprovedForAll ( ERC721AContract storage self , address owner , address operator ) internal view returns ( bool ) Checks if an operator is approved for all tokens of an owner.","title":"isApprovedForAll()"},{"location":"smart-contracts/libraries/erc721a-lib/#minting-operations","text":"","title":"Minting Operations"},{"location":"smart-contracts/libraries/erc721a-lib/#_mint","text":"function _mint ( ERC721AContract storage self , address msgSender , address to , uint256 quantity , bytes memory _data , bool safe ) internal Mints quantity tokens to the to address with gas optimization for batch operations. Parameters: - msgSender : The address initiating the mint - to : Recipient address - quantity : Number of tokens to mint - _data : Additional data for safe transfer check - safe : Whether to perform safe transfer checks Gas Optimization: - Only stores ownership data for the first token in a batch - Subsequent tokens inherit ownership through lookup algorithm - Significantly reduces gas costs for batch minting","title":"_mint()"},{"location":"smart-contracts/libraries/erc721a-lib/#transfer-operations","text":"","title":"Transfer Operations"},{"location":"smart-contracts/libraries/erc721a-lib/#_transfer","text":"function _transfer ( ERC721AContract storage self , address msgSender , address from , address to , uint256 tokenId , bool _force ) internal Transfers a token from one address to another with proper ownership updates. Parameters: - _force : Bypasses approval checks when true (for internal operations) Features: - Automatic approval clearing - Ownership slot optimization for gas efficiency - Proper balance updates","title":"_transfer()"},{"location":"smart-contracts/libraries/erc721a-lib/#burning-operations","text":"","title":"Burning Operations"},{"location":"smart-contracts/libraries/erc721a-lib/#_burn","text":"function _burn ( ERC721AContract storage self , uint256 tokenId ) internal Burns a token, marking it as destroyed while maintaining ownership history. Features: - Maintains burn counter for supply calculations - Preserves ownership data with burned flag - Updates address statistics","title":"_burn()"},{"location":"smart-contracts/libraries/erc721a-lib/#gas-optimization-features","text":"","title":"Gas Optimization Features"},{"location":"smart-contracts/libraries/erc721a-lib/#batch-minting-efficiency","text":"Single Storage Write : Only the first token in a batch requires ownership storage Lookup Algorithm : Subsequent tokens find ownership through backward iteration Reduced Gas Costs : Significant savings for large batch mints","title":"Batch Minting Efficiency"},{"location":"smart-contracts/libraries/erc721a-lib/#storage-layout-optimization","text":"Packed Structs : Address data packed into single storage slots Minimal Writes : Only necessary storage updates during operations Efficient Mappings : Optimized mapping structures for common operations","title":"Storage Layout Optimization"},{"location":"smart-contracts/libraries/erc721a-lib/#transfer-optimization","text":"Ownership Slot Management : Efficient handling of ownership slots during transfers Balance Updates : Minimal storage writes for balance changes Approval Clearing : Gas-efficient approval management","title":"Transfer Optimization"},{"location":"smart-contracts/libraries/erc721a-lib/#error-handling","text":"The library defines comprehensive custom errors for gas-efficient reverts: error ApprovalCallerNotOwnerNorApproved (); error ApprovalQueryForNonexistentToken (); error MintToZeroAddress (); error MintZeroQuantity (); error OwnerQueryForNonexistentToken (); error TransferCallerNotOwnerNorApproved (); error TransferFromIncorrectOwner (); error TransferToNonERC721ReceiverImplementer ();","title":"Error Handling"},{"location":"smart-contracts/libraries/erc721a-lib/#hook-functions","text":"","title":"Hook Functions"},{"location":"smart-contracts/libraries/erc721a-lib/#_beforetokentransfers","text":"function _beforeTokenTransfers ( ERC721AContract storage self , address from , address to , uint256 startTokenId , uint256 quantity , bool force ) internal Hook called before token transfers, minting, or burning. Can be overridden for custom logic.","title":"_beforeTokenTransfers()"},{"location":"smart-contracts/libraries/erc721a-lib/#_aftertokentransfers","text":"function _afterTokenTransfers ( ERC721AContract storage self , address from , address to , uint256 startTokenId , uint256 quantity ) internal Hook called after token transfers, minting, or burning. Can be overridden for custom logic.","title":"_afterTokenTransfers()"},{"location":"smart-contracts/libraries/erc721a-lib/#usage-examples","text":"","title":"Usage Examples"},{"location":"smart-contracts/libraries/erc721a-lib/#basic-minting","text":"// Mint 5 tokens to an address ERC721ALib . _mint ( erc721Storage , msg.sender , recipient , 5 , \"\" , true );","title":"Basic Minting"},{"location":"smart-contracts/libraries/erc721a-lib/#batch-operations","text":"// Check total supply uint256 supply = ERC721ALib . totalSupply ( erc721Storage ); // Check user's minted count uint256 minted = ERC721ALib . _numberMinted ( erc721Storage , user ); // Set auxiliary data (e.g., whitelist usage) ERC721ALib . _setAux ( erc721Storage , user , 3 );","title":"Batch Operations"},{"location":"smart-contracts/libraries/erc721a-lib/#transfer-operations_1","text":"// Transfer token ERC721ALib . _transfer ( erc721Storage , msg.sender , from , to , tokenId , false ); // Burn token ERC721ALib . _burn ( erc721Storage , tokenId );","title":"Transfer Operations"},{"location":"smart-contracts/libraries/erc721a-lib/#integration-with-diamond-pattern","text":"The library is designed to work within the Diamond pattern: import { ERC721ALib } from \"./libraries/ERC721ALib.sol\" ; contract NFTFacet { function mint ( address to , uint256 quantity ) external { ERC721AStorage storage s = erc721AStorage (); ERC721ALib . _mint ( s . erc721Contract , msg.sender , to , quantity , \"\" , true ); } }","title":"Integration with Diamond Pattern"},{"location":"smart-contracts/libraries/erc721a-lib/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/erc721a-lib/#access-control","text":"Minting Permissions : Implement proper access controls for minting functions Transfer Restrictions : Consider implementing transfer restrictions if needed Burn Authorization : Ensure only authorized parties can burn tokens","title":"Access Control"},{"location":"smart-contracts/libraries/erc721a-lib/#validation","text":"Address Validation : All functions validate against zero addresses Quantity Limits : Implement reasonable limits for batch operations Overflow Protection : Built-in protection against arithmetic overflows","title":"Validation"},{"location":"smart-contracts/libraries/erc721a-lib/#safe-transfers","text":"Contract Recipients : Automatic checks for contract recipients Callback Validation : Proper handling of ERC721Receiver callbacks Reentrancy Protection : Consider reentrancy guards for external calls","title":"Safe Transfers"},{"location":"smart-contracts/libraries/erc721a-lib/#performance-characteristics","text":"","title":"Performance Characteristics"},{"location":"smart-contracts/libraries/erc721a-lib/#gas-costs-approximate","text":"Single Mint : ~50,000 gas Batch Mint (10 tokens) : ~55,000 gas (5,500 per additional token) Transfer : ~30,000 gas Burn : ~25,000 gas","title":"Gas Costs (Approximate)"},{"location":"smart-contracts/libraries/erc721a-lib/#storage-efficiency","text":"Ownership Storage : Only first token in batch requires storage Address Data : Packed into single storage slots Minimal Overhead : Efficient data structures minimize storage costs","title":"Storage Efficiency"},{"location":"smart-contracts/libraries/erc721a-lib/#related-documentation","text":"ERC721A Enumeration Library - Enumeration extension Attribute Library - Token attribute management Diamond Library - Diamond pattern integration Gemforce Minter Facet - Minting interface ERC721A Standard - ERC721 specification","title":"Related Documentation"},{"location":"smart-contracts/libraries/erc721a-lib/#best-practices","text":"Batch Minting : Use batch minting for gas efficiency when minting multiple tokens Auxiliary Data : Leverage auxiliary data for additional per-address information Hook Implementation : Use hooks for custom logic without modifying core functions Error Handling : Use custom errors for gas-efficient error reporting Access Control : Implement proper permissions for all minting and administrative functions","title":"Best Practices"},{"location":"smart-contracts/libraries/fee-distributor-lib/","text":"FeeDistributorLib Library \u00b6 Overview \u00b6 The FeeDistributorLib library provides core utilities for automated fee distribution within the Gemforce platform. This library implements flexible revenue sharing mechanisms that automatically distribute fees to multiple recipients based on configurable weights, supporting both native ETH and ERC20 token distributions. Key Features \u00b6 Flexible Fee Distribution : Configurable weight-based fee allocation Multi-Currency Support : Native ETH and ERC20 token distribution Basis Point Precision : Accurate percentage-based fee calculations Automatic Distribution : Seamless integration with transaction flows Safety Checks : Comprehensive validation and overflow protection Gas Efficient : Optimized batch distribution operations Library Definition \u00b6 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; library FeeDistributorLib { // Initialization function _initializeFeeDistributor ( IdentitySystemStorage . IdentitySystem storage ds , address _distributionToken , uint256 _totalWeightBasis ) internal ; // Configuration function _setFeeReceivers ( IdentitySystemStorage . IdentitySystem storage ds , address [] memory _feeReceivers , uint256 [] memory _feeWeights ) internal returns ( address [] memory , uint256 [] memory ); function _getFeeReceivers ( IdentitySystemStorage . IdentitySystem storage ds ) internal view returns ( address [] memory , uint256 [] memory ); // Calculations function _calculateAmounts ( IdentitySystemStorage . IdentitySystem storage ds , uint256 principalAmount ) internal view returns ( uint256 adjustedAmount , uint256 [] memory feeAmounts ); // Distribution function _distributeAmounts ( IdentitySystemStorage . IdentitySystem storage ds , address self , address principalAmountReceiver , uint256 _principalAmount ) internal returns ( address , uint256 , address [] memory , uint256 [] memory ); } Data Structures \u00b6 FeeDistributorStorage Struct \u00b6 struct FeeDistributorStorage { address [] feeReceivers ; // Array of fee recipient addresses uint256 [] feeWeights ; // Array of weights for each recipient uint256 totalWeightBasis ; // Total basis for weight calculations (e.g., 10000 for basis points) address distributionToken ; // ERC20 token address (address(0) for native ETH) } Purpose : Complete configuration for fee distribution system. Components : - feeReceivers : Addresses that will receive fee distributions - feeWeights : Corresponding weights for each receiver (must sum to totalWeightBasis) - totalWeightBasis : Denominator for percentage calculations (typically 10000 for basis points) - distributionToken : Token contract address or address(0) for native ETH Core Functions \u00b6 Initialization \u00b6 _initializeFeeDistributor() \u00b6 function _initializeFeeDistributor ( IdentitySystemStorage . IdentitySystem storage ds , address _distributionToken , uint256 _totalWeightBasis ) internal Purpose : Initialize the fee distribution system with basic parameters. Parameters : - ds : Diamond storage reference - _distributionToken : Token contract address (address(0) for native ETH) - _totalWeightBasis : Basis for weight calculations (e.g., 10000 for basis points) Validation : - Prevents re-initialization - Requires positive weight basis - Allows address(0) for native currency distribution Example Usage : // Initialize for USDC distribution with basis points FeeDistributorLib . _initializeFeeDistributor ( ds , 0xA0b86a33E6441c8C06DD2b7c94b7E0e8c0c8c8c8 , // USDC address 10000 // 10000 basis points = 100% ); // Initialize for native ETH distribution FeeDistributorLib . _initializeFeeDistributor ( ds , address ( 0 ), // Native ETH 10000 ); Configuration Management \u00b6 _setFeeReceivers() \u00b6 function _setFeeReceivers ( IdentitySystemStorage . IdentitySystem storage ds , address [] memory _feeReceivers , uint256 [] memory _feeWeights ) internal returns ( address [] memory , uint256 [] memory ) Purpose : Configure fee recipients and their distribution weights. Parameters : - ds : Diamond storage reference - _feeReceivers : Array of recipient addresses - _feeWeights : Array of weights corresponding to each recipient Returns : Arrays of receivers and weights for event emission Validation : - Array lengths must match - At least one receiver required - No zero addresses allowed - All weights must be positive - Weights must sum exactly to totalWeightBasis Example Usage : // Set up 3-way fee distribution address [] memory receivers = new address []( 3 ); receivers [ 0 ] = 0x1234 ...; // Platform treasury receivers [ 1 ] = 0x5678 ...; // Development fund receivers [ 2 ] = 0x9abc ...; // Marketing fund uint256 [] memory weights = new uint256 []( 3 ); weights [ 0 ] = 5000 ; // 50% weights [ 1 ] = 3000 ; // 30% weights [ 2 ] = 2000 ; // 20% FeeDistributorLib . _setFeeReceivers ( ds , receivers , weights ); _getFeeReceivers() \u00b6 function _getFeeReceivers ( IdentitySystemStorage . IdentitySystem storage ds ) internal view returns ( address [] memory feeReceivers_ , uint256 [] memory feeWeights_ ) Purpose : Retrieve current fee distribution configuration. Parameters : - ds : Diamond storage reference Returns : Arrays of current receivers and their weights Example Usage : // Get current fee configuration ( address [] memory receivers , uint256 [] memory weights ) = FeeDistributorLib . _getFeeReceivers ( ds ); for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { console . log ( \"Receiver:\" , receivers [ i ], \"Weight:\" , weights [ i ]); } Fee Calculations \u00b6 _calculateAmounts() \u00b6 function _calculateAmounts ( IdentitySystemStorage . IdentitySystem storage ds , uint256 principalAmount ) internal view returns ( uint256 adjustedAmount , uint256 [] memory feeAmounts ) Purpose : Calculate fee distributions and remaining principal amount. Parameters : - ds : Diamond storage reference - principalAmount : Total amount before fee deduction Returns : - adjustedAmount : Principal amount after fee deduction - feeAmounts : Array of individual fee amounts for each receiver Calculation Logic : // For each receiver: feeAmount = ( principalAmount * weight ) / totalWeightBasis // Adjusted amount: adjustedAmount = principalAmount - sum ( feeAmounts ) Safety Features : - Handles zero receivers (pass-through mode) - Prevents total fees from exceeding principal - Protects against overflow in calculations Example Usage : // Calculate fees for a 1000 USDC transaction uint256 principal = 1000 * 10 ** 6 ; // 1000 USDC ( uint256 adjusted , uint256 [] memory fees ) = FeeDistributorLib . _calculateAmounts ( ds , principal ); console . log ( \"Principal after fees:\" , adjusted ); for ( uint256 i = 0 ; i < fees . length ; i ++ ) { console . log ( \"Fee\" , i , \":\" , fees [ i ]); } Distribution Execution \u00b6 _distributeAmounts() \u00b6 function _distributeAmounts ( IdentitySystemStorage . IdentitySystem storage ds , address self , address principalAmountReceiver , uint256 _principalAmount ) internal returns ( address adjustedAmountReceiver_ , uint256 adjustedAmount_ , address [] memory feeReceivers_ , uint256 [] memory feeAmounts_ ) Purpose : Execute the actual distribution of fees and principal amount. Parameters : - ds : Diamond storage reference - self : Address of the calling contract (for balance checks) - principalAmountReceiver : Address to receive the adjusted principal - _principalAmount : Total amount to distribute Returns : Distribution details for event emission Process : 1. Calculate fee amounts and adjusted principal 2. Check contract balance sufficiency 3. Transfer fees to each receiver 4. Transfer adjusted principal to designated receiver 5. Return distribution details Native ETH Distribution : // Check balance require ( self . balance >= _principalAmount , \"Insufficient native balance\" ); // Transfer fees for ( uint i = 0 ; i < receivers . length ; i ++ ) { if ( feeAmounts [ i ] > 0 ) { ( bool success , ) = payable ( receivers [ i ]). call { value : feeAmounts [ i ]}( \"\" ); require ( success , \"Native fee transfer failed\" ); } } // Transfer principal if ( adjustedAmount > 0 ) { ( bool success , ) = payable ( principalAmountReceiver ). call { value : adjustedAmount }( \"\" ); require ( success , \"Native principal transfer failed\" ); } ERC20 Token Distribution : // Check balance IERC20 token = IERC20 ( distributionToken ); require ( token . balanceOf ( self ) >= _principalAmount , \"Insufficient token balance\" ); // Transfer fees for ( uint i = 0 ; i < receivers . length ; i ++ ) { if ( feeAmounts [ i ] > 0 ) { token . safeTransfer ( receivers [ i ], feeAmounts [ i ]); } } // Transfer principal if ( adjustedAmount > 0 ) { token . safeTransfer ( principalAmountReceiver , adjustedAmount ); } Integration Examples \u00b6 NFT Marketplace with Revenue Sharing \u00b6 // NFT marketplace with automatic fee distribution contract NFTMarketplace { using FeeDistributorLib for IdentitySystemStorage . IdentitySystem ; struct Listing { uint256 tokenId ; address seller ; uint256 price ; bool active ; } struct MarketplaceConfig { uint256 platformFee ; // Basis points address platformTreasury ; address developmentFund ; address marketingFund ; } mapping ( uint256 => Listing ) public listings ; MarketplaceConfig public config ; IdentitySystemStorage . IdentitySystem internal ds ; event ListingCreated ( uint256 indexed tokenId , address indexed seller , uint256 price ); event ItemSold ( uint256 indexed tokenId , address indexed buyer , address indexed seller , uint256 price ); event FeesDistributed ( address [] receivers , uint256 [] amounts , uint256 totalFees ); constructor ( address _platformTreasury , address _developmentFund , address _marketingFund , uint256 _platformFee ) { config = MarketplaceConfig ({ platformFee : _platformFee , platformTreasury : _platformTreasury , developmentFund : _developmentFund , marketingFund : _marketingFund }); // Initialize fee distributor for native ETH FeeDistributorLib . _initializeFeeDistributor ( ds , address ( 0 ), 10000 ); // Set up fee distribution: 60% treasury, 25% development, 15% marketing address [] memory receivers = new address []( 3 ); receivers [ 0 ] = _platformTreasury ; receivers [ 1 ] = _developmentFund ; receivers [ 2 ] = _marketingFund ; uint256 [] memory weights = new uint256 []( 3 ); weights [ 0 ] = 6000 ; // 60% weights [ 1 ] = 2500 ; // 25% weights [ 2 ] = 1500 ; // 15% FeeDistributorLib . _setFeeReceivers ( ds , receivers , weights ); } function createListing ( uint256 tokenId , uint256 price ) external { require ( _isApprovedOrOwner ( msg.sender , tokenId ), \"Not authorized\" ); require ( price > 0 , \"Price must be positive\" ); listings [ tokenId ] = Listing ({ tokenId : tokenId , seller : msg.sender , price : price , active : true }); emit ListingCreated ( tokenId , msg.sender , price ); } function buyItem ( uint256 tokenId ) external payable { Listing storage listing = listings [ tokenId ]; require ( listing . active , \"Listing not active\" ); require ( msg.value >= listing . price , \"Insufficient payment\" ); listing . active = false ; // Calculate platform fee uint256 platformFeeAmount = ( listing . price * config . platformFee ) / 10000 ; uint256 sellerAmount = listing . price - platformFeeAmount ; // Transfer NFT to buyer _transfer ( listing . seller , msg.sender , tokenId ); // Distribute platform fees if ( platformFeeAmount > 0 ) { ( address adjustedReceiver , uint256 adjustedAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = FeeDistributorLib . _distributeAmounts ( ds , address ( this ), address ( this ), // Platform keeps any remainder platformFeeAmount ); emit FeesDistributed ( feeReceivers , feeAmounts , platformFeeAmount ); } // Transfer remaining amount to seller if ( sellerAmount > 0 ) { payable ( listing . seller ). transfer ( sellerAmount ); } // Refund excess payment if ( msg.value > listing . price ) { payable ( msg.sender ). transfer ( msg.value - listing . price ); } emit ItemSold ( tokenId , msg.sender , listing . seller , listing . price ); } function updateFeeDistribution ( address [] memory newReceivers , uint256 [] memory newWeights ) external onlyOwner { FeeDistributorLib . _setFeeReceivers ( ds , newReceivers , newWeights ); } function getFeeDistribution () external view returns ( address [] memory receivers , uint256 [] memory weights ) { return FeeDistributorLib . _getFeeReceivers ( ds ); } function _transfer ( address from , address to , uint256 tokenId ) internal { // Implementation would transfer ERC721 token } function _isApprovedOrOwner ( address spender , uint256 tokenId ) internal view returns ( bool ) { // Implementation would check ERC721 authorization return true ; } modifier onlyOwner () { // Implementation would check ownership _ ; } } DeFi Protocol with Token Distribution \u00b6 // DeFi protocol with automatic token fee distribution contract DeFiProtocol { using FeeDistributorLib for IdentitySystemStorage . IdentitySystem ; using SafeERC20 for IERC20 ; struct ProtocolConfig { IERC20 rewardToken ; uint256 protocolFee ; // Basis points uint256 totalValueLocked ; uint256 totalRewardsDistributed ; } struct StakeInfo { uint256 amount ; uint256 rewardDebt ; uint256 lastStakeTime ; } ProtocolConfig public config ; mapping ( address => StakeInfo ) public stakes ; IdentitySystemStorage . IdentitySystem internal ds ; event Staked ( address indexed user , uint256 amount ); event Unstaked ( address indexed user , uint256 amount ); event RewardsDistributed ( address [] stakeholders , uint256 [] amounts , uint256 totalRewards ); event ProtocolFeesDistributed ( address [] receivers , uint256 [] amounts ); constructor ( address _rewardToken , uint256 _protocolFee , address _treasury , address _developmentFund , address _stakeholderRewards ) { config . rewardToken = IERC20 ( _rewardToken ); config . protocolFee = _protocolFee ; // Initialize fee distributor for reward token FeeDistributorLib . _initializeFeeDistributor ( ds , _rewardToken , 10000 ); // Set up fee distribution: 40% treasury, 30% development, 30% stakeholder rewards address [] memory receivers = new address []( 3 ); receivers [ 0 ] = _treasury ; receivers [ 1 ] = _developmentFund ; receivers [ 2 ] = _stakeholderRewards ; uint256 [] memory weights = new uint256 []( 3 ); weights [ 0 ] = 4000 ; // 40% weights [ 1 ] = 3000 ; // 30% weights [ 2 ] = 3000 ; // 30% FeeDistributorLib . _setFeeReceivers ( ds , receivers , weights ); } function stake ( uint256 amount ) external { require ( amount > 0 , \"Amount must be positive\" ); // Transfer tokens from user config . rewardToken . safeTransferFrom ( msg.sender , address ( this ), amount ); // Update stake info StakeInfo storage stakeInfo = stakes [ msg.sender ]; stakeInfo . amount += amount ; stakeInfo . lastStakeTime = block.timestamp ; config . totalValueLocked += amount ; emit Staked ( msg.sender , amount ); } function unstake ( uint256 amount ) external { StakeInfo storage stakeInfo = stakes [ msg.sender ]; require ( stakeInfo . amount >= amount , \"Insufficient stake\" ); stakeInfo . amount -= amount ; config . totalValueLocked -= amount ; // Calculate protocol fee on unstaking uint256 protocolFeeAmount = ( amount * config . protocolFee ) / 10000 ; uint256 userAmount = amount - protocolFeeAmount ; // Distribute protocol fees if ( protocolFeeAmount > 0 ) { ( address adjustedReceiver , uint256 adjustedAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = FeeDistributorLib . _distributeAmounts ( ds , address ( this ), address ( this ), // Protocol keeps remainder protocolFeeAmount ); emit ProtocolFeesDistributed ( feeReceivers , feeAmounts ); } // Transfer remaining amount to user if ( userAmount > 0 ) { config . rewardToken . safeTransfer ( msg.sender , userAmount ); } emit Unstaked ( msg.sender , amount ); } function distributeRewards ( uint256 totalRewards ) external onlyOwner { require ( totalRewards > 0 , \"Rewards must be positive\" ); require ( config . totalValueLocked > 0 , \"No stakes to distribute to\" ); // Transfer rewards to contract config . rewardToken . safeTransferFrom ( msg.sender , address ( this ), totalRewards ); // Calculate individual rewards based on stake proportion // This is a simplified example - real implementation would be more complex address [] memory stakeholders = _getStakeholders (); uint256 [] memory rewardAmounts = new uint256 []( stakeholders . length ); for ( uint256 i = 0 ; i < stakeholders . length ; i ++ ) { address stakeholder = stakeholders [ i ]; uint256 stakeAmount = stakes [ stakeholder ]. amount ; uint256 reward = ( totalRewards * stakeAmount ) / config . totalValueLocked ; rewardAmounts [ i ] = reward ; if ( reward > 0 ) { config . rewardToken . safeTransfer ( stakeholder , reward ); } } config . totalRewardsDistributed += totalRewards ; emit RewardsDistributed ( stakeholders , rewardAmounts , totalRewards ); } function updateFeeDistribution ( address [] memory newReceivers , uint256 [] memory newWeights ) external onlyOwner { FeeDistributorLib . _setFeeReceivers ( ds , newReceivers , newWeights ); } function getProtocolStats () external view returns ( uint256 totalValueLocked , uint256 totalRewardsDistributed , uint256 protocolFee , address [] memory feeReceivers , uint256 [] memory feeWeights ) { totalValueLocked = config . totalValueLocked ; totalRewardsDistributed = config . totalRewardsDistributed ; protocolFee = config . protocolFee ; ( feeReceivers , feeWeights ) = FeeDistributorLib . _getFeeReceivers ( ds ); } function _getStakeholders () internal view returns ( address [] memory ) { // Implementation would return array of addresses with active stakes // This is simplified for example purposes address [] memory stakeholders = new address []( 1 ); stakeholders [ 0 ] = msg.sender ; return stakeholders ; } modifier onlyOwner () { // Implementation would check ownership _ ; } } Gaming Platform Revenue Distribution \u00b6 // Gaming platform with multi-tier revenue sharing contract GamePlatform { using FeeDistributorLib for IdentitySystemStorage . IdentitySystem ; using SafeERC20 for IERC20 ; struct GameDeveloper { address developerAddress ; uint256 revenueShare ; // Basis points uint256 totalEarnings ; bool active ; } struct GameSession { uint256 gameId ; address player ; uint256 cost ; uint256 timestamp ; bool completed ; } mapping ( uint256 => GameDeveloper ) public developers ; mapping ( uint256 => GameSession ) public sessions ; mapping ( uint256 => uint256 ) public gameDeveloper ; // gameId => developerId IERC20 public platformToken ; IdentitySystemStorage . IdentitySystem internal ds ; uint256 public nextDeveloperId ; uint256 public nextSessionId ; event DeveloperRegistered ( uint256 indexed developerId , address developer , uint256 revenueShare ); event GameSessionStarted ( uint256 indexed sessionId , uint256 gameId , address player , uint256 cost ); event RevenueDistributed ( uint256 indexed sessionId , address developer , uint256 developerShare , uint256 platformShare ); constructor ( address _platformToken ) { platformToken = IERC20 ( _platformToken ); // Initialize fee distributor for platform token FeeDistributorLib . _initializeFeeDistributor ( ds , _platformToken , 10000 ); // Set up platform revenue distribution address [] memory receivers = new address []( 4 ); receivers [ 0 ] = address ( this ); // Platform treasury receivers [ 1 ] = 0x1234567890123456789012345678901234567890 ; // Operations receivers [ 2 ] = 0x2345678901234567890123456789012345678901 ; // Development receivers [ 3 ] = 0x3456789012345678901234567890123456789012 ; // Marketing uint256 [] memory weights = new uint256 []( 4 ); weights [ 0 ] = 4000 ; // 40% platform treasury weights [ 1 ] = 2500 ; // 25% operations weights [ 2 ] = 2000 ; // 20% development weights [ 3 ] = 1500 ; // 15% marketing FeeDistributorLib . _setFeeReceivers ( ds , receivers , weights ); } function registerDeveloper ( address developerAddress , uint256 revenueShare ) external onlyOwner returns ( uint256 developerId ) { require ( developerAddress != address ( 0 ), \"Invalid developer address\" ); require ( revenueShare <= 7000 , \"Revenue share too high\" ); // Max 70% developerId = nextDeveloperId ++ ; developers [ developerId ] = GameDeveloper ({ developerAddress : developerAddress , revenueShare : revenueShare , totalEarnings : 0 , active : true }); emit DeveloperRegistered ( developerId , developerAddress , revenueShare ); } function startGameSession ( uint256 gameId , uint256 cost ) external returns ( uint256 sessionId ) { require ( cost > 0 , \"Cost must be positive\" ); require ( gameDeveloper [ gameId ] != 0 , \"Game not registered\" ); // Transfer payment from player platformToken . safeTransferFrom ( msg.sender , address ( this ), cost ); sessionId = nextSessionId ++ ; sessions [ sessionId ] = GameSession ({ gameId : gameId , player : msg.sender , cost : cost , timestamp : block.timestamp , completed : false }); emit GameSessionStarted ( sessionId , gameId , msg.sender , cost ); } function completeGameSession ( uint256 sessionId ) external { GameSession storage session = sessions [ sessionId ]; require ( ! session . completed , \"Session already completed\" ); require ( session . player == msg.sender , \"Not session owner\" ); session . completed = true ; uint256 developerId = gameDeveloper [ session . gameId ]; GameDeveloper storage developer = developers [ developerId ]; require ( developer . active , \"Developer not active\" ); // Calculate developer share uint256 developerShare = ( session . cost * developer . revenueShare ) / 10000 ; uint256 platformShare = session . cost - developerShare ; // Transfer developer share directly if ( developerShare > 0 ) { platformToken . safeTransfer ( developer . developerAddress , developerShare ); developer . totalEarnings += developerShare ; } // Distribute platform share among platform stakeholders if ( platformShare > 0 ) { ( address adjustedReceiver , uint256 adjustedAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = FeeDistributorLib . _distributeAmounts ( ds , address ( this ), address ( this ), // Platform treasury gets adjusted amount platformShare ); } emit RevenueDistributed ( sessionId , developer . developerAddress , developerShare , platformShare ); } function updatePlatformDistribution ( address [] memory newReceivers , uint256 [] memory newWeights ) external onlyOwner { FeeDistributorLib . _setFeeReceivers ( ds , newReceivers , newWeights ); } function getDeveloperStats ( uint256 developerId ) external view returns ( address developerAddress , uint256 revenueShare , uint256 totalEarnings , bool active ) { GameDeveloper memory dev = developers [ developerId ]; return ( dev . developerAddress , dev . revenueShare , dev . totalEarnings , dev . active ); } function getPlatformDistribution () external view returns ( address [] memory receivers , uint256 [] memory weights ) { return FeeDistributorLib . _getFeeReceivers ( ds ); } function registerGame ( uint256 gameId , uint256 developerId ) external onlyOwner { require ( developers [ developerId ]. active , \"Developer not active\" ); gameDeveloper [ gameId ] = developerId ; } modifier onlyOwner () { // Implementation would check ownership _ ; } } Security Considerations \u00b6 Financial Security \u00b6 Overflow Protection : Safe arithmetic operations prevent calculation errors Balance Validation : Checks contract balance before distribution Transfer Safety : Uses SafeERC20 for token transfers and proper error handling for ETH Weight Validation : Ensures weights sum exactly to basis to prevent over/under distribution Access Control \u00b6 Initialization Protection : Prevents re-initialization of the system Configuration Validation : Validates all receiver addresses and weights Administrative Functions : Proper access control for configuration changes Distribution Integrity \u00b6 Atomic Operations : All distributions complete or fail together Remainder Handling : Proper handling of rounding remainders Zero Amount Protection : Skips zero-amount transfers to save gas Gas Optimization \u00b6 Batch Operations \u00b6 Single Loop Distribution : Efficient batch transfer operations Minimal Storage Reads : Optimized storage access patterns Skip Zero Transfers : Avoids unnecessary transfer operations Efficient Calculations : Optimized fee calculation algorithms Storage Efficiency \u00b6 Compact Data Structures : Efficient storage layout Minimal Storage Writes : Reduced storage operations Array Operations : Efficient array handling and iteration Error Handling \u00b6 Common Errors \u00b6 \"Already initialized\" - Attempt to re-initialize the system \"Array lengths mismatch\" - Mismatched receiver and weight arrays \"Weights must sum to basis\" - Invalid weight configuration \"Insufficient balance\" - Contract lacks funds for distribution \"Transfer failed\" - ETH or token transfer failure Best Practices \u00b6 Validate all inputs before processing Check contract balances before distribution Use proper error messages for debugging Handle edge cases gracefully (zero receivers, zero amounts) Testing Considerations \u00b6 Unit Tests \u00b6 Fee calculation accuracy Distribution logic validation Edge case handling (zero amounts, single receiver) Error condition testing Integration Tests \u00b6 Multi-contract distribution scenarios Token and ETH distribution workflows Configuration update scenarios Real-world usage patterns Security Testing \u00b6 Overflow/underflow protection Reentrancy attack prevention Access control validation Financial integrity verification Related Documentation \u00b6 FeeDistributorFacet - Fee distributor facet implementation Revenue Sharing Guide - Revenue sharing implementation patterns Tokenomics Guide - Token economics best practices Financial Security - Financial security considerations Gas Optimization Guide - Performance optimization techniques This library provides comprehensive utilities for automated fee distribution within the Gemforce platform, supporting flexible revenue sharing mechanisms with configurable weights, multi-currency support, and robust security features for various business models and tokenomics scenarios.","title":"Fee Distributor Lib"},{"location":"smart-contracts/libraries/fee-distributor-lib/#feedistributorlib-library","text":"","title":"FeeDistributorLib Library"},{"location":"smart-contracts/libraries/fee-distributor-lib/#overview","text":"The FeeDistributorLib library provides core utilities for automated fee distribution within the Gemforce platform. This library implements flexible revenue sharing mechanisms that automatically distribute fees to multiple recipients based on configurable weights, supporting both native ETH and ERC20 token distributions.","title":"Overview"},{"location":"smart-contracts/libraries/fee-distributor-lib/#key-features","text":"Flexible Fee Distribution : Configurable weight-based fee allocation Multi-Currency Support : Native ETH and ERC20 token distribution Basis Point Precision : Accurate percentage-based fee calculations Automatic Distribution : Seamless integration with transaction flows Safety Checks : Comprehensive validation and overflow protection Gas Efficient : Optimized batch distribution operations","title":"Key Features"},{"location":"smart-contracts/libraries/fee-distributor-lib/#library-definition","text":"// SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; library FeeDistributorLib { // Initialization function _initializeFeeDistributor ( IdentitySystemStorage . IdentitySystem storage ds , address _distributionToken , uint256 _totalWeightBasis ) internal ; // Configuration function _setFeeReceivers ( IdentitySystemStorage . IdentitySystem storage ds , address [] memory _feeReceivers , uint256 [] memory _feeWeights ) internal returns ( address [] memory , uint256 [] memory ); function _getFeeReceivers ( IdentitySystemStorage . IdentitySystem storage ds ) internal view returns ( address [] memory , uint256 [] memory ); // Calculations function _calculateAmounts ( IdentitySystemStorage . IdentitySystem storage ds , uint256 principalAmount ) internal view returns ( uint256 adjustedAmount , uint256 [] memory feeAmounts ); // Distribution function _distributeAmounts ( IdentitySystemStorage . IdentitySystem storage ds , address self , address principalAmountReceiver , uint256 _principalAmount ) internal returns ( address , uint256 , address [] memory , uint256 [] memory ); }","title":"Library Definition"},{"location":"smart-contracts/libraries/fee-distributor-lib/#data-structures","text":"","title":"Data Structures"},{"location":"smart-contracts/libraries/fee-distributor-lib/#feedistributorstorage-struct","text":"struct FeeDistributorStorage { address [] feeReceivers ; // Array of fee recipient addresses uint256 [] feeWeights ; // Array of weights for each recipient uint256 totalWeightBasis ; // Total basis for weight calculations (e.g., 10000 for basis points) address distributionToken ; // ERC20 token address (address(0) for native ETH) } Purpose : Complete configuration for fee distribution system. Components : - feeReceivers : Addresses that will receive fee distributions - feeWeights : Corresponding weights for each receiver (must sum to totalWeightBasis) - totalWeightBasis : Denominator for percentage calculations (typically 10000 for basis points) - distributionToken : Token contract address or address(0) for native ETH","title":"FeeDistributorStorage Struct"},{"location":"smart-contracts/libraries/fee-distributor-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/fee-distributor-lib/#initialization","text":"","title":"Initialization"},{"location":"smart-contracts/libraries/fee-distributor-lib/#_initializefeedistributor","text":"function _initializeFeeDistributor ( IdentitySystemStorage . IdentitySystem storage ds , address _distributionToken , uint256 _totalWeightBasis ) internal Purpose : Initialize the fee distribution system with basic parameters. Parameters : - ds : Diamond storage reference - _distributionToken : Token contract address (address(0) for native ETH) - _totalWeightBasis : Basis for weight calculations (e.g., 10000 for basis points) Validation : - Prevents re-initialization - Requires positive weight basis - Allows address(0) for native currency distribution Example Usage : // Initialize for USDC distribution with basis points FeeDistributorLib . _initializeFeeDistributor ( ds , 0xA0b86a33E6441c8C06DD2b7c94b7E0e8c0c8c8c8 , // USDC address 10000 // 10000 basis points = 100% ); // Initialize for native ETH distribution FeeDistributorLib . _initializeFeeDistributor ( ds , address ( 0 ), // Native ETH 10000 );","title":"_initializeFeeDistributor()"},{"location":"smart-contracts/libraries/fee-distributor-lib/#configuration-management","text":"","title":"Configuration Management"},{"location":"smart-contracts/libraries/fee-distributor-lib/#_setfeereceivers","text":"function _setFeeReceivers ( IdentitySystemStorage . IdentitySystem storage ds , address [] memory _feeReceivers , uint256 [] memory _feeWeights ) internal returns ( address [] memory , uint256 [] memory ) Purpose : Configure fee recipients and their distribution weights. Parameters : - ds : Diamond storage reference - _feeReceivers : Array of recipient addresses - _feeWeights : Array of weights corresponding to each recipient Returns : Arrays of receivers and weights for event emission Validation : - Array lengths must match - At least one receiver required - No zero addresses allowed - All weights must be positive - Weights must sum exactly to totalWeightBasis Example Usage : // Set up 3-way fee distribution address [] memory receivers = new address []( 3 ); receivers [ 0 ] = 0x1234 ...; // Platform treasury receivers [ 1 ] = 0x5678 ...; // Development fund receivers [ 2 ] = 0x9abc ...; // Marketing fund uint256 [] memory weights = new uint256 []( 3 ); weights [ 0 ] = 5000 ; // 50% weights [ 1 ] = 3000 ; // 30% weights [ 2 ] = 2000 ; // 20% FeeDistributorLib . _setFeeReceivers ( ds , receivers , weights );","title":"_setFeeReceivers()"},{"location":"smart-contracts/libraries/fee-distributor-lib/#_getfeereceivers","text":"function _getFeeReceivers ( IdentitySystemStorage . IdentitySystem storage ds ) internal view returns ( address [] memory feeReceivers_ , uint256 [] memory feeWeights_ ) Purpose : Retrieve current fee distribution configuration. Parameters : - ds : Diamond storage reference Returns : Arrays of current receivers and their weights Example Usage : // Get current fee configuration ( address [] memory receivers , uint256 [] memory weights ) = FeeDistributorLib . _getFeeReceivers ( ds ); for ( uint256 i = 0 ; i < receivers . length ; i ++ ) { console . log ( \"Receiver:\" , receivers [ i ], \"Weight:\" , weights [ i ]); }","title":"_getFeeReceivers()"},{"location":"smart-contracts/libraries/fee-distributor-lib/#fee-calculations","text":"","title":"Fee Calculations"},{"location":"smart-contracts/libraries/fee-distributor-lib/#_calculateamounts","text":"function _calculateAmounts ( IdentitySystemStorage . IdentitySystem storage ds , uint256 principalAmount ) internal view returns ( uint256 adjustedAmount , uint256 [] memory feeAmounts ) Purpose : Calculate fee distributions and remaining principal amount. Parameters : - ds : Diamond storage reference - principalAmount : Total amount before fee deduction Returns : - adjustedAmount : Principal amount after fee deduction - feeAmounts : Array of individual fee amounts for each receiver Calculation Logic : // For each receiver: feeAmount = ( principalAmount * weight ) / totalWeightBasis // Adjusted amount: adjustedAmount = principalAmount - sum ( feeAmounts ) Safety Features : - Handles zero receivers (pass-through mode) - Prevents total fees from exceeding principal - Protects against overflow in calculations Example Usage : // Calculate fees for a 1000 USDC transaction uint256 principal = 1000 * 10 ** 6 ; // 1000 USDC ( uint256 adjusted , uint256 [] memory fees ) = FeeDistributorLib . _calculateAmounts ( ds , principal ); console . log ( \"Principal after fees:\" , adjusted ); for ( uint256 i = 0 ; i < fees . length ; i ++ ) { console . log ( \"Fee\" , i , \":\" , fees [ i ]); }","title":"_calculateAmounts()"},{"location":"smart-contracts/libraries/fee-distributor-lib/#distribution-execution","text":"","title":"Distribution Execution"},{"location":"smart-contracts/libraries/fee-distributor-lib/#_distributeamounts","text":"function _distributeAmounts ( IdentitySystemStorage . IdentitySystem storage ds , address self , address principalAmountReceiver , uint256 _principalAmount ) internal returns ( address adjustedAmountReceiver_ , uint256 adjustedAmount_ , address [] memory feeReceivers_ , uint256 [] memory feeAmounts_ ) Purpose : Execute the actual distribution of fees and principal amount. Parameters : - ds : Diamond storage reference - self : Address of the calling contract (for balance checks) - principalAmountReceiver : Address to receive the adjusted principal - _principalAmount : Total amount to distribute Returns : Distribution details for event emission Process : 1. Calculate fee amounts and adjusted principal 2. Check contract balance sufficiency 3. Transfer fees to each receiver 4. Transfer adjusted principal to designated receiver 5. Return distribution details Native ETH Distribution : // Check balance require ( self . balance >= _principalAmount , \"Insufficient native balance\" ); // Transfer fees for ( uint i = 0 ; i < receivers . length ; i ++ ) { if ( feeAmounts [ i ] > 0 ) { ( bool success , ) = payable ( receivers [ i ]). call { value : feeAmounts [ i ]}( \"\" ); require ( success , \"Native fee transfer failed\" ); } } // Transfer principal if ( adjustedAmount > 0 ) { ( bool success , ) = payable ( principalAmountReceiver ). call { value : adjustedAmount }( \"\" ); require ( success , \"Native principal transfer failed\" ); } ERC20 Token Distribution : // Check balance IERC20 token = IERC20 ( distributionToken ); require ( token . balanceOf ( self ) >= _principalAmount , \"Insufficient token balance\" ); // Transfer fees for ( uint i = 0 ; i < receivers . length ; i ++ ) { if ( feeAmounts [ i ] > 0 ) { token . safeTransfer ( receivers [ i ], feeAmounts [ i ]); } } // Transfer principal if ( adjustedAmount > 0 ) { token . safeTransfer ( principalAmountReceiver , adjustedAmount ); }","title":"_distributeAmounts()"},{"location":"smart-contracts/libraries/fee-distributor-lib/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/libraries/fee-distributor-lib/#nft-marketplace-with-revenue-sharing","text":"// NFT marketplace with automatic fee distribution contract NFTMarketplace { using FeeDistributorLib for IdentitySystemStorage . IdentitySystem ; struct Listing { uint256 tokenId ; address seller ; uint256 price ; bool active ; } struct MarketplaceConfig { uint256 platformFee ; // Basis points address platformTreasury ; address developmentFund ; address marketingFund ; } mapping ( uint256 => Listing ) public listings ; MarketplaceConfig public config ; IdentitySystemStorage . IdentitySystem internal ds ; event ListingCreated ( uint256 indexed tokenId , address indexed seller , uint256 price ); event ItemSold ( uint256 indexed tokenId , address indexed buyer , address indexed seller , uint256 price ); event FeesDistributed ( address [] receivers , uint256 [] amounts , uint256 totalFees ); constructor ( address _platformTreasury , address _developmentFund , address _marketingFund , uint256 _platformFee ) { config = MarketplaceConfig ({ platformFee : _platformFee , platformTreasury : _platformTreasury , developmentFund : _developmentFund , marketingFund : _marketingFund }); // Initialize fee distributor for native ETH FeeDistributorLib . _initializeFeeDistributor ( ds , address ( 0 ), 10000 ); // Set up fee distribution: 60% treasury, 25% development, 15% marketing address [] memory receivers = new address []( 3 ); receivers [ 0 ] = _platformTreasury ; receivers [ 1 ] = _developmentFund ; receivers [ 2 ] = _marketingFund ; uint256 [] memory weights = new uint256 []( 3 ); weights [ 0 ] = 6000 ; // 60% weights [ 1 ] = 2500 ; // 25% weights [ 2 ] = 1500 ; // 15% FeeDistributorLib . _setFeeReceivers ( ds , receivers , weights ); } function createListing ( uint256 tokenId , uint256 price ) external { require ( _isApprovedOrOwner ( msg.sender , tokenId ), \"Not authorized\" ); require ( price > 0 , \"Price must be positive\" ); listings [ tokenId ] = Listing ({ tokenId : tokenId , seller : msg.sender , price : price , active : true }); emit ListingCreated ( tokenId , msg.sender , price ); } function buyItem ( uint256 tokenId ) external payable { Listing storage listing = listings [ tokenId ]; require ( listing . active , \"Listing not active\" ); require ( msg.value >= listing . price , \"Insufficient payment\" ); listing . active = false ; // Calculate platform fee uint256 platformFeeAmount = ( listing . price * config . platformFee ) / 10000 ; uint256 sellerAmount = listing . price - platformFeeAmount ; // Transfer NFT to buyer _transfer ( listing . seller , msg.sender , tokenId ); // Distribute platform fees if ( platformFeeAmount > 0 ) { ( address adjustedReceiver , uint256 adjustedAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = FeeDistributorLib . _distributeAmounts ( ds , address ( this ), address ( this ), // Platform keeps any remainder platformFeeAmount ); emit FeesDistributed ( feeReceivers , feeAmounts , platformFeeAmount ); } // Transfer remaining amount to seller if ( sellerAmount > 0 ) { payable ( listing . seller ). transfer ( sellerAmount ); } // Refund excess payment if ( msg.value > listing . price ) { payable ( msg.sender ). transfer ( msg.value - listing . price ); } emit ItemSold ( tokenId , msg.sender , listing . seller , listing . price ); } function updateFeeDistribution ( address [] memory newReceivers , uint256 [] memory newWeights ) external onlyOwner { FeeDistributorLib . _setFeeReceivers ( ds , newReceivers , newWeights ); } function getFeeDistribution () external view returns ( address [] memory receivers , uint256 [] memory weights ) { return FeeDistributorLib . _getFeeReceivers ( ds ); } function _transfer ( address from , address to , uint256 tokenId ) internal { // Implementation would transfer ERC721 token } function _isApprovedOrOwner ( address spender , uint256 tokenId ) internal view returns ( bool ) { // Implementation would check ERC721 authorization return true ; } modifier onlyOwner () { // Implementation would check ownership _ ; } }","title":"NFT Marketplace with Revenue Sharing"},{"location":"smart-contracts/libraries/fee-distributor-lib/#defi-protocol-with-token-distribution","text":"// DeFi protocol with automatic token fee distribution contract DeFiProtocol { using FeeDistributorLib for IdentitySystemStorage . IdentitySystem ; using SafeERC20 for IERC20 ; struct ProtocolConfig { IERC20 rewardToken ; uint256 protocolFee ; // Basis points uint256 totalValueLocked ; uint256 totalRewardsDistributed ; } struct StakeInfo { uint256 amount ; uint256 rewardDebt ; uint256 lastStakeTime ; } ProtocolConfig public config ; mapping ( address => StakeInfo ) public stakes ; IdentitySystemStorage . IdentitySystem internal ds ; event Staked ( address indexed user , uint256 amount ); event Unstaked ( address indexed user , uint256 amount ); event RewardsDistributed ( address [] stakeholders , uint256 [] amounts , uint256 totalRewards ); event ProtocolFeesDistributed ( address [] receivers , uint256 [] amounts ); constructor ( address _rewardToken , uint256 _protocolFee , address _treasury , address _developmentFund , address _stakeholderRewards ) { config . rewardToken = IERC20 ( _rewardToken ); config . protocolFee = _protocolFee ; // Initialize fee distributor for reward token FeeDistributorLib . _initializeFeeDistributor ( ds , _rewardToken , 10000 ); // Set up fee distribution: 40% treasury, 30% development, 30% stakeholder rewards address [] memory receivers = new address []( 3 ); receivers [ 0 ] = _treasury ; receivers [ 1 ] = _developmentFund ; receivers [ 2 ] = _stakeholderRewards ; uint256 [] memory weights = new uint256 []( 3 ); weights [ 0 ] = 4000 ; // 40% weights [ 1 ] = 3000 ; // 30% weights [ 2 ] = 3000 ; // 30% FeeDistributorLib . _setFeeReceivers ( ds , receivers , weights ); } function stake ( uint256 amount ) external { require ( amount > 0 , \"Amount must be positive\" ); // Transfer tokens from user config . rewardToken . safeTransferFrom ( msg.sender , address ( this ), amount ); // Update stake info StakeInfo storage stakeInfo = stakes [ msg.sender ]; stakeInfo . amount += amount ; stakeInfo . lastStakeTime = block.timestamp ; config . totalValueLocked += amount ; emit Staked ( msg.sender , amount ); } function unstake ( uint256 amount ) external { StakeInfo storage stakeInfo = stakes [ msg.sender ]; require ( stakeInfo . amount >= amount , \"Insufficient stake\" ); stakeInfo . amount -= amount ; config . totalValueLocked -= amount ; // Calculate protocol fee on unstaking uint256 protocolFeeAmount = ( amount * config . protocolFee ) / 10000 ; uint256 userAmount = amount - protocolFeeAmount ; // Distribute protocol fees if ( protocolFeeAmount > 0 ) { ( address adjustedReceiver , uint256 adjustedAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = FeeDistributorLib . _distributeAmounts ( ds , address ( this ), address ( this ), // Protocol keeps remainder protocolFeeAmount ); emit ProtocolFeesDistributed ( feeReceivers , feeAmounts ); } // Transfer remaining amount to user if ( userAmount > 0 ) { config . rewardToken . safeTransfer ( msg.sender , userAmount ); } emit Unstaked ( msg.sender , amount ); } function distributeRewards ( uint256 totalRewards ) external onlyOwner { require ( totalRewards > 0 , \"Rewards must be positive\" ); require ( config . totalValueLocked > 0 , \"No stakes to distribute to\" ); // Transfer rewards to contract config . rewardToken . safeTransferFrom ( msg.sender , address ( this ), totalRewards ); // Calculate individual rewards based on stake proportion // This is a simplified example - real implementation would be more complex address [] memory stakeholders = _getStakeholders (); uint256 [] memory rewardAmounts = new uint256 []( stakeholders . length ); for ( uint256 i = 0 ; i < stakeholders . length ; i ++ ) { address stakeholder = stakeholders [ i ]; uint256 stakeAmount = stakes [ stakeholder ]. amount ; uint256 reward = ( totalRewards * stakeAmount ) / config . totalValueLocked ; rewardAmounts [ i ] = reward ; if ( reward > 0 ) { config . rewardToken . safeTransfer ( stakeholder , reward ); } } config . totalRewardsDistributed += totalRewards ; emit RewardsDistributed ( stakeholders , rewardAmounts , totalRewards ); } function updateFeeDistribution ( address [] memory newReceivers , uint256 [] memory newWeights ) external onlyOwner { FeeDistributorLib . _setFeeReceivers ( ds , newReceivers , newWeights ); } function getProtocolStats () external view returns ( uint256 totalValueLocked , uint256 totalRewardsDistributed , uint256 protocolFee , address [] memory feeReceivers , uint256 [] memory feeWeights ) { totalValueLocked = config . totalValueLocked ; totalRewardsDistributed = config . totalRewardsDistributed ; protocolFee = config . protocolFee ; ( feeReceivers , feeWeights ) = FeeDistributorLib . _getFeeReceivers ( ds ); } function _getStakeholders () internal view returns ( address [] memory ) { // Implementation would return array of addresses with active stakes // This is simplified for example purposes address [] memory stakeholders = new address []( 1 ); stakeholders [ 0 ] = msg.sender ; return stakeholders ; } modifier onlyOwner () { // Implementation would check ownership _ ; } }","title":"DeFi Protocol with Token Distribution"},{"location":"smart-contracts/libraries/fee-distributor-lib/#gaming-platform-revenue-distribution","text":"// Gaming platform with multi-tier revenue sharing contract GamePlatform { using FeeDistributorLib for IdentitySystemStorage . IdentitySystem ; using SafeERC20 for IERC20 ; struct GameDeveloper { address developerAddress ; uint256 revenueShare ; // Basis points uint256 totalEarnings ; bool active ; } struct GameSession { uint256 gameId ; address player ; uint256 cost ; uint256 timestamp ; bool completed ; } mapping ( uint256 => GameDeveloper ) public developers ; mapping ( uint256 => GameSession ) public sessions ; mapping ( uint256 => uint256 ) public gameDeveloper ; // gameId => developerId IERC20 public platformToken ; IdentitySystemStorage . IdentitySystem internal ds ; uint256 public nextDeveloperId ; uint256 public nextSessionId ; event DeveloperRegistered ( uint256 indexed developerId , address developer , uint256 revenueShare ); event GameSessionStarted ( uint256 indexed sessionId , uint256 gameId , address player , uint256 cost ); event RevenueDistributed ( uint256 indexed sessionId , address developer , uint256 developerShare , uint256 platformShare ); constructor ( address _platformToken ) { platformToken = IERC20 ( _platformToken ); // Initialize fee distributor for platform token FeeDistributorLib . _initializeFeeDistributor ( ds , _platformToken , 10000 ); // Set up platform revenue distribution address [] memory receivers = new address []( 4 ); receivers [ 0 ] = address ( this ); // Platform treasury receivers [ 1 ] = 0x1234567890123456789012345678901234567890 ; // Operations receivers [ 2 ] = 0x2345678901234567890123456789012345678901 ; // Development receivers [ 3 ] = 0x3456789012345678901234567890123456789012 ; // Marketing uint256 [] memory weights = new uint256 []( 4 ); weights [ 0 ] = 4000 ; // 40% platform treasury weights [ 1 ] = 2500 ; // 25% operations weights [ 2 ] = 2000 ; // 20% development weights [ 3 ] = 1500 ; // 15% marketing FeeDistributorLib . _setFeeReceivers ( ds , receivers , weights ); } function registerDeveloper ( address developerAddress , uint256 revenueShare ) external onlyOwner returns ( uint256 developerId ) { require ( developerAddress != address ( 0 ), \"Invalid developer address\" ); require ( revenueShare <= 7000 , \"Revenue share too high\" ); // Max 70% developerId = nextDeveloperId ++ ; developers [ developerId ] = GameDeveloper ({ developerAddress : developerAddress , revenueShare : revenueShare , totalEarnings : 0 , active : true }); emit DeveloperRegistered ( developerId , developerAddress , revenueShare ); } function startGameSession ( uint256 gameId , uint256 cost ) external returns ( uint256 sessionId ) { require ( cost > 0 , \"Cost must be positive\" ); require ( gameDeveloper [ gameId ] != 0 , \"Game not registered\" ); // Transfer payment from player platformToken . safeTransferFrom ( msg.sender , address ( this ), cost ); sessionId = nextSessionId ++ ; sessions [ sessionId ] = GameSession ({ gameId : gameId , player : msg.sender , cost : cost , timestamp : block.timestamp , completed : false }); emit GameSessionStarted ( sessionId , gameId , msg.sender , cost ); } function completeGameSession ( uint256 sessionId ) external { GameSession storage session = sessions [ sessionId ]; require ( ! session . completed , \"Session already completed\" ); require ( session . player == msg.sender , \"Not session owner\" ); session . completed = true ; uint256 developerId = gameDeveloper [ session . gameId ]; GameDeveloper storage developer = developers [ developerId ]; require ( developer . active , \"Developer not active\" ); // Calculate developer share uint256 developerShare = ( session . cost * developer . revenueShare ) / 10000 ; uint256 platformShare = session . cost - developerShare ; // Transfer developer share directly if ( developerShare > 0 ) { platformToken . safeTransfer ( developer . developerAddress , developerShare ); developer . totalEarnings += developerShare ; } // Distribute platform share among platform stakeholders if ( platformShare > 0 ) { ( address adjustedReceiver , uint256 adjustedAmount , address [] memory feeReceivers , uint256 [] memory feeAmounts ) = FeeDistributorLib . _distributeAmounts ( ds , address ( this ), address ( this ), // Platform treasury gets adjusted amount platformShare ); } emit RevenueDistributed ( sessionId , developer . developerAddress , developerShare , platformShare ); } function updatePlatformDistribution ( address [] memory newReceivers , uint256 [] memory newWeights ) external onlyOwner { FeeDistributorLib . _setFeeReceivers ( ds , newReceivers , newWeights ); } function getDeveloperStats ( uint256 developerId ) external view returns ( address developerAddress , uint256 revenueShare , uint256 totalEarnings , bool active ) { GameDeveloper memory dev = developers [ developerId ]; return ( dev . developerAddress , dev . revenueShare , dev . totalEarnings , dev . active ); } function getPlatformDistribution () external view returns ( address [] memory receivers , uint256 [] memory weights ) { return FeeDistributorLib . _getFeeReceivers ( ds ); } function registerGame ( uint256 gameId , uint256 developerId ) external onlyOwner { require ( developers [ developerId ]. active , \"Developer not active\" ); gameDeveloper [ gameId ] = developerId ; } modifier onlyOwner () { // Implementation would check ownership _ ; } }","title":"Gaming Platform Revenue Distribution"},{"location":"smart-contracts/libraries/fee-distributor-lib/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/fee-distributor-lib/#financial-security","text":"Overflow Protection : Safe arithmetic operations prevent calculation errors Balance Validation : Checks contract balance before distribution Transfer Safety : Uses SafeERC20 for token transfers and proper error handling for ETH Weight Validation : Ensures weights sum exactly to basis to prevent over/under distribution","title":"Financial Security"},{"location":"smart-contracts/libraries/fee-distributor-lib/#access-control","text":"Initialization Protection : Prevents re-initialization of the system Configuration Validation : Validates all receiver addresses and weights Administrative Functions : Proper access control for configuration changes","title":"Access Control"},{"location":"smart-contracts/libraries/fee-distributor-lib/#distribution-integrity","text":"Atomic Operations : All distributions complete or fail together Remainder Handling : Proper handling of rounding remainders Zero Amount Protection : Skips zero-amount transfers to save gas","title":"Distribution Integrity"},{"location":"smart-contracts/libraries/fee-distributor-lib/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/libraries/fee-distributor-lib/#batch-operations","text":"Single Loop Distribution : Efficient batch transfer operations Minimal Storage Reads : Optimized storage access patterns Skip Zero Transfers : Avoids unnecessary transfer operations Efficient Calculations : Optimized fee calculation algorithms","title":"Batch Operations"},{"location":"smart-contracts/libraries/fee-distributor-lib/#storage-efficiency","text":"Compact Data Structures : Efficient storage layout Minimal Storage Writes : Reduced storage operations Array Operations : Efficient array handling and iteration","title":"Storage Efficiency"},{"location":"smart-contracts/libraries/fee-distributor-lib/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/libraries/fee-distributor-lib/#common-errors","text":"\"Already initialized\" - Attempt to re-initialize the system \"Array lengths mismatch\" - Mismatched receiver and weight arrays \"Weights must sum to basis\" - Invalid weight configuration \"Insufficient balance\" - Contract lacks funds for distribution \"Transfer failed\" - ETH or token transfer failure","title":"Common Errors"},{"location":"smart-contracts/libraries/fee-distributor-lib/#best-practices","text":"Validate all inputs before processing Check contract balances before distribution Use proper error messages for debugging Handle edge cases gracefully (zero receivers, zero amounts)","title":"Best Practices"},{"location":"smart-contracts/libraries/fee-distributor-lib/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/libraries/fee-distributor-lib/#unit-tests","text":"Fee calculation accuracy Distribution logic validation Edge case handling (zero amounts, single receiver) Error condition testing","title":"Unit Tests"},{"location":"smart-contracts/libraries/fee-distributor-lib/#integration-tests","text":"Multi-contract distribution scenarios Token and ETH distribution workflows Configuration update scenarios Real-world usage patterns","title":"Integration Tests"},{"location":"smart-contracts/libraries/fee-distributor-lib/#security-testing","text":"Overflow/underflow protection Reentrancy attack prevention Access control validation Financial integrity verification","title":"Security Testing"},{"location":"smart-contracts/libraries/fee-distributor-lib/#related-documentation","text":"FeeDistributorFacet - Fee distributor facet implementation Revenue Sharing Guide - Revenue sharing implementation patterns Tokenomics Guide - Token economics best practices Financial Security - Financial security considerations Gas Optimization Guide - Performance optimization techniques This library provides comprehensive utilities for automated fee distribution within the Gemforce platform, supporting flexible revenue sharing mechanisms with configurable weights, multi-currency support, and robust security features for various business models and tokenomics scenarios.","title":"Related Documentation"},{"location":"smart-contracts/libraries/lib-diamond/","text":"LibDiamond Library \u00b6 Overview \u00b6 LibDiamond is the core implementation library for the EIP-2535 Diamond Standard. This library provides all the essential functionality for managing upgradeable smart contracts using the Diamond pattern, including facet management, function selector routing, ownership control, and timelock-based upgrade proposals. Key Features \u00b6 Diamond Storage Management : Implements the diamond storage pattern for upgradeable contracts Facet Management : Add, replace, and remove contract facets dynamically Function Selector Routing : Maps function selectors to their corresponding facet addresses Ownership Control : Manages contract ownership with proper access controls Timelock Upgrades : Implements secure upgrade proposals with configurable timelock periods ERC-165 Support : Interface detection for supported standards Core Data Structures \u00b6 DiamondStorage \u00b6 The main storage structure that holds all diamond-related data: struct DiamondStorage { mapping ( bytes4 => FacetAddressAndPosition ) selectorToFacetAndPosition ; mapping ( address => FacetFunctionSelectors ) facetFunctionSelectors ; address [] facetAddresses ; mapping ( bytes4 => bool ) supportedInterfaces ; address contractOwner ; uint256 upgradeTimelock ; UpgradeProposal upgradeProposal ; } FacetAddressAndPosition \u00b6 Maps function selectors to their facet addresses and positions: struct FacetAddressAndPosition { address facetAddress ; uint96 functionSelectorPosition ; } UpgradeProposal \u00b6 Stores timelock-based upgrade proposals: struct UpgradeProposal { IDiamondCut . FacetCut [] diamondCut ; address initAddress ; bytes initCalldata ; uint256 proposalTime ; bool exists ; } Core Functions \u00b6 Storage Access \u00b6 diamondStorage() \u00b6 function diamondStorage () internal pure returns ( DiamondStorage storage ds ) Returns the diamond storage struct using assembly for gas efficiency. Ownership Management \u00b6 setContractOwner(address _newOwner) \u00b6 function setContractOwner ( address _newOwner ) internal Sets a new contract owner and emits the OwnershipTransferred event. contractOwner() \u00b6 function contractOwner () internal view returns ( address contractOwner_ ) Returns the current contract owner address. enforceIsContractOwner() \u00b6 function enforceIsContractOwner () internal view Reverts if the caller is not the contract owner. Diamond Cut Operations \u00b6 diamondCut() \u00b6 function diamondCut ( IDiamondCut . FacetCut [] memory _diamondCut , address _init , bytes memory _calldata ) internal Executes diamond cut operations to add, replace, or remove functions. Parameters: - _diamondCut : Array of facet cuts to execute - _init : Address of initialization contract (optional) - _calldata : Initialization function call data (optional) Facet Management \u00b6 addFunctions() \u00b6 function addFunctions ( address _facetAddress , bytes4 [] memory _functionSelectors ) internal Adds new functions to the diamond from a specific facet. replaceFunctions() \u00b6 function replaceFunctions ( address _facetAddress , bytes4 [] memory _functionSelectors ) internal Replaces existing functions with new implementations from a facet. removeFunctions() \u00b6 function removeFunctions ( address _facetAddress , bytes4 [] memory _functionSelectors ) internal Removes functions from the diamond. Timelock Upgrade System \u00b6 initializeUpgradeTimelock() \u00b6 function initializeUpgradeTimelock ( uint256 _timelock ) internal Initializes the upgrade timelock system with a specified delay period. proposeDiamondCut() \u00b6 function proposeDiamondCut ( IDiamondCut . FacetCut [] memory _diamondCut , address _init , bytes memory _calldata ) internal Proposes a diamond cut to be executed after the timelock period. executeDiamondCut() \u00b6 function executeDiamondCut () internal Executes a previously proposed diamond cut after the timelock period has elapsed. cancelDiamondCut() \u00b6 function cancelDiamondCut () internal Cancels a pending diamond cut proposal. Security Features \u00b6 Access Control \u00b6 Owner-only operations : Critical functions require contract owner privileges Timelock protection : Upgrades require a waiting period before execution Proposal validation : Ensures only valid upgrade proposals can be executed Safety Checks \u00b6 Contract code validation : Ensures facets have actual contract code Function selector conflicts : Prevents duplicate function selectors Immutable function protection : Prevents removal of core diamond functions Gas Optimization \u00b6 Assembly usage : Direct storage slot access for gas efficiency Efficient data structures : Optimized mappings and arrays for minimal gas costs Batch operations : Process multiple facet cuts in a single transaction Constants \u00b6 bytes32 constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.standard.diamond.storage\" ); uint256 constant DEFAULT_UPGRADE_TIMELOCK = 2 days ; Events \u00b6 The library emits events defined in the IDiamondCut interface: - DiamondCut : Emitted when a diamond cut is executed - DiamondCutProposed : Emitted when an upgrade is proposed - DiamondCutCancelled : Emitted when an upgrade proposal is cancelled Usage Examples \u00b6 Basic Diamond Cut \u00b6 // Add a new facet IDiamondCut . FacetCut [] memory cuts = new IDiamondCut . FacetCut []( 1 ); cuts [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : newFacetAddress , action : IDiamondCut . FacetCutAction . Add , functionSelectors : selectors }); LibDiamond . diamondCut ( cuts , address ( 0 ), \"\" ); Timelock Upgrade Process \u00b6 // 1. Initialize timelock (done once) LibDiamond . initializeUpgradeTimelock ( 7 days ); // 2. Propose upgrade LibDiamond . proposeDiamondCut ( cuts , initAddress , initCalldata ); // 3. Wait for timelock period... // 4. Execute upgrade LibDiamond . executeDiamondCut (); Integration Points \u00b6 Diamond Proxy : Used by the main Diamond contract for all upgrade operations Diamond Cut Facet : Provides external interface for diamond cut operations Diamond Loupe Facet : Uses storage structures for introspection functions Ownership Facet : Integrates with ownership management functions Best Practices \u00b6 Initialize Timelock : Always initialize upgrade timelock for production deployments Validate Facets : Ensure facet contracts are properly tested before adding Batch Operations : Group related function changes into single diamond cuts Monitor Proposals : Track upgrade proposals and their execution status Emergency Procedures : Have procedures for cancelling problematic upgrades Security Considerations \u00b6 Owner Key Security : Protect the contract owner private key with multi-sig or hardware wallets Timelock Duration : Choose appropriate timelock periods based on security requirements Facet Validation : Thoroughly audit facet contracts before deployment Upgrade Testing : Test all upgrades on testnets before mainnet deployment Emergency Response : Have procedures for handling upgrade emergencies Related Documentation \u00b6 Diamond Standard Overview IDiamond Interface Diamond Factory Library EIP-2535 Diamond Standard","title":"LibDiamond"},{"location":"smart-contracts/libraries/lib-diamond/#libdiamond-library","text":"","title":"LibDiamond Library"},{"location":"smart-contracts/libraries/lib-diamond/#overview","text":"LibDiamond is the core implementation library for the EIP-2535 Diamond Standard. This library provides all the essential functionality for managing upgradeable smart contracts using the Diamond pattern, including facet management, function selector routing, ownership control, and timelock-based upgrade proposals.","title":"Overview"},{"location":"smart-contracts/libraries/lib-diamond/#key-features","text":"Diamond Storage Management : Implements the diamond storage pattern for upgradeable contracts Facet Management : Add, replace, and remove contract facets dynamically Function Selector Routing : Maps function selectors to their corresponding facet addresses Ownership Control : Manages contract ownership with proper access controls Timelock Upgrades : Implements secure upgrade proposals with configurable timelock periods ERC-165 Support : Interface detection for supported standards","title":"Key Features"},{"location":"smart-contracts/libraries/lib-diamond/#core-data-structures","text":"","title":"Core Data Structures"},{"location":"smart-contracts/libraries/lib-diamond/#diamondstorage","text":"The main storage structure that holds all diamond-related data: struct DiamondStorage { mapping ( bytes4 => FacetAddressAndPosition ) selectorToFacetAndPosition ; mapping ( address => FacetFunctionSelectors ) facetFunctionSelectors ; address [] facetAddresses ; mapping ( bytes4 => bool ) supportedInterfaces ; address contractOwner ; uint256 upgradeTimelock ; UpgradeProposal upgradeProposal ; }","title":"DiamondStorage"},{"location":"smart-contracts/libraries/lib-diamond/#facetaddressandposition","text":"Maps function selectors to their facet addresses and positions: struct FacetAddressAndPosition { address facetAddress ; uint96 functionSelectorPosition ; }","title":"FacetAddressAndPosition"},{"location":"smart-contracts/libraries/lib-diamond/#upgradeproposal","text":"Stores timelock-based upgrade proposals: struct UpgradeProposal { IDiamondCut . FacetCut [] diamondCut ; address initAddress ; bytes initCalldata ; uint256 proposalTime ; bool exists ; }","title":"UpgradeProposal"},{"location":"smart-contracts/libraries/lib-diamond/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/lib-diamond/#storage-access","text":"","title":"Storage Access"},{"location":"smart-contracts/libraries/lib-diamond/#diamondstorage_1","text":"function diamondStorage () internal pure returns ( DiamondStorage storage ds ) Returns the diamond storage struct using assembly for gas efficiency.","title":"diamondStorage()"},{"location":"smart-contracts/libraries/lib-diamond/#ownership-management","text":"","title":"Ownership Management"},{"location":"smart-contracts/libraries/lib-diamond/#setcontractowneraddress-_newowner","text":"function setContractOwner ( address _newOwner ) internal Sets a new contract owner and emits the OwnershipTransferred event.","title":"setContractOwner(address _newOwner)"},{"location":"smart-contracts/libraries/lib-diamond/#contractowner","text":"function contractOwner () internal view returns ( address contractOwner_ ) Returns the current contract owner address.","title":"contractOwner()"},{"location":"smart-contracts/libraries/lib-diamond/#enforceiscontractowner","text":"function enforceIsContractOwner () internal view Reverts if the caller is not the contract owner.","title":"enforceIsContractOwner()"},{"location":"smart-contracts/libraries/lib-diamond/#diamond-cut-operations","text":"","title":"Diamond Cut Operations"},{"location":"smart-contracts/libraries/lib-diamond/#diamondcut","text":"function diamondCut ( IDiamondCut . FacetCut [] memory _diamondCut , address _init , bytes memory _calldata ) internal Executes diamond cut operations to add, replace, or remove functions. Parameters: - _diamondCut : Array of facet cuts to execute - _init : Address of initialization contract (optional) - _calldata : Initialization function call data (optional)","title":"diamondCut()"},{"location":"smart-contracts/libraries/lib-diamond/#facet-management","text":"","title":"Facet Management"},{"location":"smart-contracts/libraries/lib-diamond/#addfunctions","text":"function addFunctions ( address _facetAddress , bytes4 [] memory _functionSelectors ) internal Adds new functions to the diamond from a specific facet.","title":"addFunctions()"},{"location":"smart-contracts/libraries/lib-diamond/#replacefunctions","text":"function replaceFunctions ( address _facetAddress , bytes4 [] memory _functionSelectors ) internal Replaces existing functions with new implementations from a facet.","title":"replaceFunctions()"},{"location":"smart-contracts/libraries/lib-diamond/#removefunctions","text":"function removeFunctions ( address _facetAddress , bytes4 [] memory _functionSelectors ) internal Removes functions from the diamond.","title":"removeFunctions()"},{"location":"smart-contracts/libraries/lib-diamond/#timelock-upgrade-system","text":"","title":"Timelock Upgrade System"},{"location":"smart-contracts/libraries/lib-diamond/#initializeupgradetimelock","text":"function initializeUpgradeTimelock ( uint256 _timelock ) internal Initializes the upgrade timelock system with a specified delay period.","title":"initializeUpgradeTimelock()"},{"location":"smart-contracts/libraries/lib-diamond/#proposediamondcut","text":"function proposeDiamondCut ( IDiamondCut . FacetCut [] memory _diamondCut , address _init , bytes memory _calldata ) internal Proposes a diamond cut to be executed after the timelock period.","title":"proposeDiamondCut()"},{"location":"smart-contracts/libraries/lib-diamond/#executediamondcut","text":"function executeDiamondCut () internal Executes a previously proposed diamond cut after the timelock period has elapsed.","title":"executeDiamondCut()"},{"location":"smart-contracts/libraries/lib-diamond/#canceldiamondcut","text":"function cancelDiamondCut () internal Cancels a pending diamond cut proposal.","title":"cancelDiamondCut()"},{"location":"smart-contracts/libraries/lib-diamond/#security-features","text":"","title":"Security Features"},{"location":"smart-contracts/libraries/lib-diamond/#access-control","text":"Owner-only operations : Critical functions require contract owner privileges Timelock protection : Upgrades require a waiting period before execution Proposal validation : Ensures only valid upgrade proposals can be executed","title":"Access Control"},{"location":"smart-contracts/libraries/lib-diamond/#safety-checks","text":"Contract code validation : Ensures facets have actual contract code Function selector conflicts : Prevents duplicate function selectors Immutable function protection : Prevents removal of core diamond functions","title":"Safety Checks"},{"location":"smart-contracts/libraries/lib-diamond/#gas-optimization","text":"Assembly usage : Direct storage slot access for gas efficiency Efficient data structures : Optimized mappings and arrays for minimal gas costs Batch operations : Process multiple facet cuts in a single transaction","title":"Gas Optimization"},{"location":"smart-contracts/libraries/lib-diamond/#constants","text":"bytes32 constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.standard.diamond.storage\" ); uint256 constant DEFAULT_UPGRADE_TIMELOCK = 2 days ;","title":"Constants"},{"location":"smart-contracts/libraries/lib-diamond/#events","text":"The library emits events defined in the IDiamondCut interface: - DiamondCut : Emitted when a diamond cut is executed - DiamondCutProposed : Emitted when an upgrade is proposed - DiamondCutCancelled : Emitted when an upgrade proposal is cancelled","title":"Events"},{"location":"smart-contracts/libraries/lib-diamond/#usage-examples","text":"","title":"Usage Examples"},{"location":"smart-contracts/libraries/lib-diamond/#basic-diamond-cut","text":"// Add a new facet IDiamondCut . FacetCut [] memory cuts = new IDiamondCut . FacetCut []( 1 ); cuts [ 0 ] = IDiamondCut . FacetCut ({ facetAddress : newFacetAddress , action : IDiamondCut . FacetCutAction . Add , functionSelectors : selectors }); LibDiamond . diamondCut ( cuts , address ( 0 ), \"\" );","title":"Basic Diamond Cut"},{"location":"smart-contracts/libraries/lib-diamond/#timelock-upgrade-process","text":"// 1. Initialize timelock (done once) LibDiamond . initializeUpgradeTimelock ( 7 days ); // 2. Propose upgrade LibDiamond . proposeDiamondCut ( cuts , initAddress , initCalldata ); // 3. Wait for timelock period... // 4. Execute upgrade LibDiamond . executeDiamondCut ();","title":"Timelock Upgrade Process"},{"location":"smart-contracts/libraries/lib-diamond/#integration-points","text":"Diamond Proxy : Used by the main Diamond contract for all upgrade operations Diamond Cut Facet : Provides external interface for diamond cut operations Diamond Loupe Facet : Uses storage structures for introspection functions Ownership Facet : Integrates with ownership management functions","title":"Integration Points"},{"location":"smart-contracts/libraries/lib-diamond/#best-practices","text":"Initialize Timelock : Always initialize upgrade timelock for production deployments Validate Facets : Ensure facet contracts are properly tested before adding Batch Operations : Group related function changes into single diamond cuts Monitor Proposals : Track upgrade proposals and their execution status Emergency Procedures : Have procedures for cancelling problematic upgrades","title":"Best Practices"},{"location":"smart-contracts/libraries/lib-diamond/#security-considerations","text":"Owner Key Security : Protect the contract owner private key with multi-sig or hardware wallets Timelock Duration : Choose appropriate timelock periods based on security requirements Facet Validation : Thoroughly audit facet contracts before deployment Upgrade Testing : Test all upgrades on testnets before mainnet deployment Emergency Response : Have procedures for handling upgrade emergencies","title":"Security Considerations"},{"location":"smart-contracts/libraries/lib-diamond/#related-documentation","text":"Diamond Standard Overview IDiamond Interface Diamond Factory Library EIP-2535 Diamond Standard","title":"Related Documentation"},{"location":"smart-contracts/libraries/merkle-prover/","text":"MerkleProver Library \u00b6 Overview \u00b6 The MerkleProver library provides core utilities for Merkle tree proof verification within the Gemforce platform. This library implements secure and gas-efficient Merkle proof validation, enabling whitelist systems, airdrop distributions, and other scenarios requiring cryptographic proof of inclusion in a dataset. Key Features \u00b6 Secure Proof Verification : Cryptographically secure Merkle tree validation Gas Efficient : Optimized proof verification algorithms Flexible Leaf Generation : Support for various data types in leaf construction Attack Prevention : Protection against common Merkle tree vulnerabilities Standard Compliance : Compatible with standard Merkle tree implementations Pure Functions : Stateless operations for maximum reusability Library Definition \u00b6 // SPDX-License-Identifier: MIT pragma solidity >= 0.8.0 ; library MerkleProver { // Proof verification function verify ( bytes32 root , bytes32 leaf , bytes32 [] memory proof ) public pure returns ( bool ); // Leaf generation function getHash ( address a , uint256 b ) public pure returns ( bytes32 ); } Core Functions \u00b6 Proof Verification \u00b6 verify() \u00b6 function verify ( bytes32 root , bytes32 leaf , bytes32 [] memory proof ) public pure returns ( bool ) Purpose : Verify that a leaf is included in a Merkle tree with the given root. Parameters : - root : The Merkle root hash to verify against - leaf : The leaf hash to prove inclusion for - proof : Array of sibling hashes forming the proof path Returns : Boolean indicating whether the proof is valid Algorithm : 1. Start with the leaf hash as the computed hash 2. For each proof element, combine with computed hash in sorted order 3. Hash the combination using keccak256 4. Continue until all proof elements are processed 5. Compare final computed hash with provided root Security Features : - Empty Proof Protection : Prevents false positives when leaf equals root with empty proof - Sorted Hashing : Ensures deterministic hash ordering regardless of tree structure - Overflow Protection : Safe array iteration with bounds checking Implementation Details : function verify ( bytes32 root , bytes32 leaf , bytes32 [] memory proof ) public pure returns ( bool ) { // Security check: prevent false positive when leaf == root with empty proof if ( leaf == root && proof . length == 0 ) { return false ; } bytes32 computedHash = leaf ; for ( uint256 i = 0 ; i < proof . length ; i ++ ) { bytes32 proofElement = proof [ i ]; if ( computedHash <= proofElement ) { // Hash(current computed hash + current element of the proof) computedHash = keccak256 ( abi . encodePacked ( computedHash , proofElement )); } else { // Hash(current element of the proof + current computed hash) computedHash = keccak256 ( abi . encodePacked ( proofElement , computedHash )); } } // Check if the computed hash (root) is equal to the provided root return computedHash == root ; } Example Usage : // Verify whitelist inclusion bytes32 merkleRoot = 0x1234 ...; bytes32 userLeaf = MerkleProver . getHash ( msg.sender , allocation ); bytes32 [] memory proof = [ 0xabcd ..., 0xef01 ..., 0x2345 ...]; bool isValid = MerkleProver . verify ( merkleRoot , userLeaf , proof ); require ( isValid , \"Invalid Merkle proof\" ); Leaf Generation \u00b6 getHash() \u00b6 function getHash ( address a , uint256 b ) public pure returns ( bytes32 ) Purpose : Generate a standardized leaf hash from an address and amount. Parameters : - a : Ethereum address (typically user address) - b : Numeric value (typically allocation amount) Returns : keccak256 hash of the packed parameters Implementation : function getHash ( address a , uint256 b ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( a , b )); } Use Cases : - Whitelist leaf generation for address + allocation pairs - Airdrop eligibility proofs - Voting power verification - Access control with quantified permissions Example Usage : // Generate leaf for whitelist entry address user = 0x742d35Cc6634C0532925a3b8D4C9db96590c6C87 ; uint256 allocation = 1000 * 10 ** 18 ; // 1000 tokens bytes32 leaf = MerkleProver . getHash ( user , allocation ); Integration Examples \u00b6 Whitelist Token Sale \u00b6 // Token sale with Merkle tree whitelist contract WhitelistTokenSale { using MerkleProver for bytes32 ; struct WhitelistConfig { bytes32 merkleRoot ; uint256 salePrice ; uint256 maxAllocation ; uint256 startTime ; uint256 endTime ; bool active ; } struct UserPurchase { uint256 purchased ; bool claimed ; } WhitelistConfig public whitelistConfig ; mapping ( address => UserPurchase ) public userPurchases ; mapping ( bytes32 => bool ) public usedLeaves ; event WhitelistConfigured ( bytes32 indexed merkleRoot , uint256 salePrice ); event TokensPurchased ( address indexed user , uint256 amount , uint256 totalCost ); event ProofUsed ( bytes32 indexed leaf , address indexed user ); function configureWhitelist ( bytes32 _merkleRoot , uint256 _salePrice , uint256 _maxAllocation , uint256 _startTime , uint256 _endTime ) external onlyOwner { whitelistConfig = WhitelistConfig ({ merkleRoot : _merkleRoot , salePrice : _salePrice , maxAllocation : _maxAllocation , startTime : _startTime , endTime : _endTime , active : true }); emit WhitelistConfigured ( _merkleRoot , _salePrice ); } function purchaseTokens ( uint256 allocation , uint256 purchaseAmount , bytes32 [] calldata merkleProof ) external payable { require ( whitelistConfig . active , \"Whitelist sale not active\" ); require ( block.timestamp >= whitelistConfig . startTime , \"Sale not started\" ); require ( block.timestamp <= whitelistConfig . endTime , \"Sale ended\" ); require ( purchaseAmount > 0 , \"Purchase amount must be positive\" ); // Generate leaf for this user and allocation bytes32 leaf = MerkleProver . getHash ( msg.sender , allocation ); // Verify Merkle proof bool isValidProof = MerkleProver . verify ( whitelistConfig . merkleRoot , leaf , merkleProof ); require ( isValidProof , \"Invalid Merkle proof\" ); // Prevent proof reuse require ( ! usedLeaves [ leaf ], \"Proof already used\" ); // Check allocation limits UserPurchase storage userPurchase = userPurchases [ msg.sender ]; require ( userPurchase . purchased + purchaseAmount <= allocation , \"Exceeds allocated amount\" ); require ( userPurchase . purchased + purchaseAmount <= whitelistConfig . maxAllocation , \"Exceeds max allocation\" ); // Calculate cost uint256 totalCost = purchaseAmount * whitelistConfig . salePrice ; require ( msg.value >= totalCost , \"Insufficient payment\" ); // Update user purchase record userPurchase . purchased += purchaseAmount ; // Mark leaf as used if fully claimed if ( userPurchase . purchased == allocation ) { usedLeaves [ leaf ] = true ; emit ProofUsed ( leaf , msg.sender ); } // Mint tokens to user _mintTokens ( msg.sender , purchaseAmount ); // Refund excess payment if ( msg.value > totalCost ) { payable ( msg.sender ). transfer ( msg.value - totalCost ); } emit TokensPurchased ( msg.sender , purchaseAmount , totalCost ); } function verifyWhitelistEligibility ( address user , uint256 allocation , bytes32 [] calldata merkleProof ) external view returns ( bool isEligible , uint256 remainingAllocation ) { bytes32 leaf = MerkleProver . getHash ( user , allocation ); isEligible = MerkleProver . verify ( whitelistConfig . merkleRoot , leaf , merkleProof ) && ! usedLeaves [ leaf ]; if ( isEligible ) { remainingAllocation = allocation - userPurchases [ user ]. purchased ; } } function _mintTokens ( address to , uint256 amount ) internal { // Implementation would mint ERC20 tokens } modifier onlyOwner () { // Implementation would check ownership _ ; } } Airdrop Distribution System \u00b6 // Airdrop system with Merkle proof claims contract MerkleAirdrop { using MerkleProver for bytes32 ; struct AirdropRound { bytes32 merkleRoot ; uint256 totalTokens ; uint256 claimedTokens ; uint256 startTime ; uint256 endTime ; bool active ; string description ; } struct ClaimRecord { uint256 roundId ; address claimer ; uint256 amount ; uint256 timestamp ; } mapping ( uint256 => AirdropRound ) public airdropRounds ; mapping ( uint256 => mapping ( bytes32 => bool )) public claimedLeaves ; mapping ( address => ClaimRecord []) public userClaims ; uint256 public nextRoundId ; IERC20 public airdropToken ; event AirdropRoundCreated ( uint256 indexed roundId , bytes32 merkleRoot , uint256 totalTokens ); event TokensClaimed ( uint256 indexed roundId , address indexed claimer , uint256 amount ); event RoundFinalized ( uint256 indexed roundId , uint256 totalClaimed ); constructor ( address _airdropToken ) { airdropToken = IERC20 ( _airdropToken ); } function createAirdropRound ( bytes32 _merkleRoot , uint256 _totalTokens , uint256 _startTime , uint256 _endTime , string memory _description ) external onlyOwner returns ( uint256 roundId ) { roundId = nextRoundId ++ ; airdropRounds [ roundId ] = AirdropRound ({ merkleRoot : _merkleRoot , totalTokens : _totalTokens , claimedTokens : 0 , startTime : _startTime , endTime : _endTime , active : true , description : _description }); emit AirdropRoundCreated ( roundId , _merkleRoot , _totalTokens ); } function claimAirdrop ( uint256 roundId , uint256 amount , bytes32 [] calldata merkleProof ) external { AirdropRound storage round = airdropRounds [ roundId ]; require ( round . active , \"Airdrop round not active\" ); require ( block.timestamp >= round . startTime , \"Airdrop not started\" ); require ( block.timestamp <= round . endTime , \"Airdrop ended\" ); // Generate leaf for this claim bytes32 leaf = MerkleProver . getHash ( msg.sender , amount ); // Verify Merkle proof bool isValidProof = MerkleProver . verify ( round . merkleRoot , leaf , merkleProof ); require ( isValidProof , \"Invalid Merkle proof\" ); // Prevent double claiming require ( ! claimedLeaves [ roundId ][ leaf ], \"Already claimed\" ); // Mark as claimed claimedLeaves [ roundId ][ leaf ] = true ; round . claimedTokens += amount ; // Record claim userClaims [ msg.sender ]. push ( ClaimRecord ({ roundId : roundId , claimer : msg.sender , amount : amount , timestamp : block.timestamp })); // Transfer tokens require ( airdropToken . transfer ( msg.sender , amount ), \"Token transfer failed\" ); emit TokensClaimed ( roundId , msg.sender , amount ); } function batchClaimAirdrop ( uint256 [] calldata roundIds , uint256 [] calldata amounts , bytes32 [][] calldata merkleProofs ) external { require ( roundIds . length == amounts . length && amounts . length == merkleProofs . length , \"Array length mismatch\" ); uint256 totalClaim = 0 ; for ( uint256 i = 0 ; i < roundIds . length ; i ++ ) { uint256 roundId = roundIds [ i ]; uint256 amount = amounts [ i ]; bytes32 [] calldata proof = merkleProofs [ i ]; AirdropRound storage round = airdropRounds [ roundId ]; require ( round . active , \"Airdrop round not active\" ); require ( block.timestamp >= round . startTime , \"Airdrop not started\" ); require ( block.timestamp <= round . endTime , \"Airdrop ended\" ); bytes32 leaf = MerkleProver . getHash ( msg.sender , amount ); bool isValidProof = MerkleProver . verify ( round . merkleRoot , leaf , proof ); require ( isValidProof , \"Invalid Merkle proof\" ); require ( ! claimedLeaves [ roundId ][ leaf ], \"Already claimed\" ); claimedLeaves [ roundId ][ leaf ] = true ; round . claimedTokens += amount ; totalClaim += amount ; userClaims [ msg.sender ]. push ( ClaimRecord ({ roundId : roundId , claimer : msg.sender , amount : amount , timestamp : block.timestamp })); emit TokensClaimed ( roundId , msg.sender , amount ); } // Single token transfer for all claims require ( airdropToken . transfer ( msg.sender , totalClaim ), \"Token transfer failed\" ); } function verifyEligibility ( uint256 roundId , address user , uint256 amount , bytes32 [] calldata merkleProof ) external view returns ( bool isEligible , bool alreadyClaimed ) { AirdropRound memory round = airdropRounds [ roundId ]; bytes32 leaf = MerkleProver . getHash ( user , amount ); isEligible = round . active && block.timestamp >= round . startTime && block.timestamp <= round . endTime && MerkleProver . verify ( round . merkleRoot , leaf , merkleProof ); alreadyClaimed = claimedLeaves [ roundId ][ leaf ]; } function getUserClaims ( address user ) external view returns ( ClaimRecord [] memory ) { return userClaims [ user ]; } function getRoundInfo ( uint256 roundId ) external view returns ( bytes32 merkleRoot , uint256 totalTokens , uint256 claimedTokens , uint256 remainingTokens , uint256 startTime , uint256 endTime , bool active , string memory description ) { AirdropRound memory round = airdropRounds [ roundId ]; return ( round . merkleRoot , round . totalTokens , round . claimedTokens , round . totalTokens - round . claimedTokens , round . startTime , round . endTime , round . active , round . description ); } function finalizeRound ( uint256 roundId ) external onlyOwner { AirdropRound storage round = airdropRounds [ roundId ]; require ( round . active , \"Round not active\" ); require ( block.timestamp > round . endTime , \"Round not ended\" ); round . active = false ; // Reclaim unclaimed tokens uint256 unclaimedTokens = round . totalTokens - round . claimedTokens ; if ( unclaimedTokens > 0 ) { require ( airdropToken . transfer ( msg.sender , unclaimedTokens ), \"Token reclaim failed\" ); } emit RoundFinalized ( roundId , round . claimedTokens ); } modifier onlyOwner () { // Implementation would check ownership _ ; } } Voting System with Merkle Proofs \u00b6 // Voting system with Merkle tree voter eligibility contract MerkleVoting { using MerkleProver for bytes32 ; struct Proposal { uint256 id ; string title ; string description ; bytes32 voterMerkleRoot ; uint256 startTime ; uint256 endTime ; uint256 yesVotes ; uint256 noVotes ; uint256 totalVotingPower ; bool executed ; bool passed ; } struct Vote { address voter ; bool support ; uint256 votingPower ; uint256 timestamp ; } mapping ( uint256 => Proposal ) public proposals ; mapping ( uint256 => mapping ( bytes32 => bool )) public hasVoted ; mapping ( uint256 => Vote []) public proposalVotes ; uint256 public nextProposalId ; uint256 public constant VOTING_DURATION = 7 days ; uint256 public constant EXECUTION_DELAY = 2 days ; event ProposalCreated ( uint256 indexed proposalId , string title , bytes32 voterRoot ); event VoteCast ( uint256 indexed proposalId , address indexed voter , bool support , uint256 votingPower ); event ProposalExecuted ( uint256 indexed proposalId , bool passed ); function createProposal ( string memory title , string memory description , bytes32 voterMerkleRoot , uint256 totalVotingPower ) external onlyGovernance returns ( uint256 proposalId ) { proposalId = nextProposalId ++ ; proposals [ proposalId ] = Proposal ({ id : proposalId , title : title , description : description , voterMerkleRoot : voterMerkleRoot , startTime : block.timestamp , endTime : block.timestamp + VOTING_DURATION , yesVotes : 0 , noVotes : 0 , totalVotingPower : totalVotingPower , executed : false , passed : false }); emit ProposalCreated ( proposalId , title , voterMerkleRoot ); } function vote ( uint256 proposalId , bool support , uint256 votingPower , bytes32 [] calldata merkleProof ) external { Proposal storage proposal = proposals [ proposalId ]; require ( block.timestamp >= proposal . startTime , \"Voting not started\" ); require ( block.timestamp <= proposal . endTime , \"Voting ended\" ); require ( ! proposal . executed , \"Proposal already executed\" ); // Generate leaf for voter eligibility bytes32 leaf = MerkleProver . getHash ( msg.sender , votingPower ); // Verify voter eligibility bool isEligible = MerkleProver . verify ( proposal . voterMerkleRoot , leaf , merkleProof ); require ( isEligible , \"Invalid voting eligibility proof\" ); // Prevent double voting require ( ! hasVoted [ proposalId ][ leaf ], \"Already voted\" ); hasVoted [ proposalId ][ leaf ] = true ; // Record vote if ( support ) { proposal . yesVotes += votingPower ; } else { proposal . noVotes += votingPower ; } proposalVotes [ proposalId ]. push ( Vote ({ voter : msg.sender , support : support , votingPower : votingPower , timestamp : block.timestamp })); emit VoteCast ( proposalId , msg.sender , support , votingPower ); } function executeProposal ( uint256 proposalId ) external { Proposal storage proposal = proposals [ proposalId ]; require ( block.timestamp > proposal . endTime + EXECUTION_DELAY , \"Execution delay not met\" ); require ( ! proposal . executed , \"Proposal already executed\" ); proposal . executed = true ; // Determine if proposal passed (simple majority) uint256 totalVotes = proposal . yesVotes + proposal . noVotes ; proposal . passed = proposal . yesVotes > proposal . noVotes && totalVotes >= ( proposal . totalVotingPower / 4 ); // 25% quorum if ( proposal . passed ) { _executeProposalLogic ( proposalId ); } emit ProposalExecuted ( proposalId , proposal . passed ); } function verifyVoterEligibility ( uint256 proposalId , address voter , uint256 votingPower , bytes32 [] calldata merkleProof ) external view returns ( bool isEligible , bool hasAlreadyVoted ) { Proposal memory proposal = proposals [ proposalId ]; bytes32 leaf = MerkleProver . getHash ( voter , votingPower ); isEligible = MerkleProver . verify ( proposal . voterMerkleRoot , leaf , merkleProof ); hasAlreadyVoted = hasVoted [ proposalId ][ leaf ]; } function getProposalResults ( uint256 proposalId ) external view returns ( uint256 yesVotes , uint256 noVotes , uint256 totalVotes , uint256 participationRate , bool canExecute , bool executed , bool passed ) { Proposal memory proposal = proposals [ proposalId ]; yesVotes = proposal . yesVotes ; noVotes = proposal . noVotes ; totalVotes = yesVotes + noVotes ; participationRate = ( totalVotes * 100 ) / proposal . totalVotingPower ; canExecute = block.timestamp > proposal . endTime + EXECUTION_DELAY && ! proposal . executed ; executed = proposal . executed ; passed = proposal . passed ; } function getProposalVotes ( uint256 proposalId ) external view returns ( Vote [] memory ) { return proposalVotes [ proposalId ]; } function _executeProposalLogic ( uint256 proposalId ) internal { // Implementation would execute the actual proposal logic } modifier onlyGovernance () { // Implementation would check governance authorization _ ; } } Security Considerations \u00b6 Proof Validation Security \u00b6 Empty Proof Protection : Prevents false positives when leaf equals root Deterministic Ordering : Sorted hash combination prevents manipulation Replay Attack Prevention : Leaf tracking prevents proof reuse Input Validation : Proper bounds checking and parameter validation Cryptographic Security \u00b6 Standard Algorithms : Uses keccak256 for cryptographic security Collision Resistance : Merkle tree structure provides collision resistance Preimage Resistance : Hash functions prevent reverse engineering Second Preimage Resistance : Protects against proof forgery Implementation Security \u00b6 Pure Functions : Stateless operations prevent state manipulation Gas Efficiency : Optimized algorithms prevent DoS attacks Overflow Protection : Safe arithmetic operations Memory Safety : Proper array bounds checking Gas Optimization \u00b6 Verification Efficiency \u00b6 Minimal Storage : Pure functions with no storage operations Optimized Loops : Efficient proof iteration Reduced Hashing : Minimal hash operations per verification Batch Operations : Support for batch proof verification Memory Efficiency \u00b6 Stack Operations : Minimal memory allocation Efficient Encoding : Optimized abi.encodePacked usage Proof Size : Logarithmic proof size relative to tree size Reusable Functions : Pure functions for maximum reusability Error Handling \u00b6 Common Errors \u00b6 Invalid Merkle proof verification failure Empty proof with leaf equal to root Array bounds errors in proof iteration Hash computation failures Best Practices \u00b6 Always validate proof arrays before processing Check for edge cases (empty proofs, single-element trees) Implement proper error messages for debugging Use safe arithmetic operations Testing Considerations \u00b6 Unit Tests \u00b6 Proof verification accuracy for various tree sizes Edge case handling (empty proofs, single nodes) Hash generation consistency Security vulnerability testing Integration Tests \u00b6 Whitelist system integration Airdrop distribution workflows Voting system integration Cross-contract proof verification Security Testing \u00b6 Proof forgery attempts Replay attack prevention Edge case exploitation Gas consumption analysis Related Documentation \u00b6 MultiSaleLib - Multi-token sale whitelist integration Whitelist Systems Guide - Whitelist implementation patterns Airdrop Guide - Airdrop distribution best practices Cryptographic Security - Security considerations Gas Optimization Guide - Performance optimization techniques This library provides secure and efficient Merkle proof verification utilities for the Gemforce platform, enabling whitelist systems, airdrop distributions, voting mechanisms, and other scenarios requiring cryptographic proof of inclusion with protection against common attack vectors.","title":"Merkle Prover"},{"location":"smart-contracts/libraries/merkle-prover/#merkleprover-library","text":"","title":"MerkleProver Library"},{"location":"smart-contracts/libraries/merkle-prover/#overview","text":"The MerkleProver library provides core utilities for Merkle tree proof verification within the Gemforce platform. This library implements secure and gas-efficient Merkle proof validation, enabling whitelist systems, airdrop distributions, and other scenarios requiring cryptographic proof of inclusion in a dataset.","title":"Overview"},{"location":"smart-contracts/libraries/merkle-prover/#key-features","text":"Secure Proof Verification : Cryptographically secure Merkle tree validation Gas Efficient : Optimized proof verification algorithms Flexible Leaf Generation : Support for various data types in leaf construction Attack Prevention : Protection against common Merkle tree vulnerabilities Standard Compliance : Compatible with standard Merkle tree implementations Pure Functions : Stateless operations for maximum reusability","title":"Key Features"},{"location":"smart-contracts/libraries/merkle-prover/#library-definition","text":"// SPDX-License-Identifier: MIT pragma solidity >= 0.8.0 ; library MerkleProver { // Proof verification function verify ( bytes32 root , bytes32 leaf , bytes32 [] memory proof ) public pure returns ( bool ); // Leaf generation function getHash ( address a , uint256 b ) public pure returns ( bytes32 ); }","title":"Library Definition"},{"location":"smart-contracts/libraries/merkle-prover/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/merkle-prover/#proof-verification","text":"","title":"Proof Verification"},{"location":"smart-contracts/libraries/merkle-prover/#verify","text":"function verify ( bytes32 root , bytes32 leaf , bytes32 [] memory proof ) public pure returns ( bool ) Purpose : Verify that a leaf is included in a Merkle tree with the given root. Parameters : - root : The Merkle root hash to verify against - leaf : The leaf hash to prove inclusion for - proof : Array of sibling hashes forming the proof path Returns : Boolean indicating whether the proof is valid Algorithm : 1. Start with the leaf hash as the computed hash 2. For each proof element, combine with computed hash in sorted order 3. Hash the combination using keccak256 4. Continue until all proof elements are processed 5. Compare final computed hash with provided root Security Features : - Empty Proof Protection : Prevents false positives when leaf equals root with empty proof - Sorted Hashing : Ensures deterministic hash ordering regardless of tree structure - Overflow Protection : Safe array iteration with bounds checking Implementation Details : function verify ( bytes32 root , bytes32 leaf , bytes32 [] memory proof ) public pure returns ( bool ) { // Security check: prevent false positive when leaf == root with empty proof if ( leaf == root && proof . length == 0 ) { return false ; } bytes32 computedHash = leaf ; for ( uint256 i = 0 ; i < proof . length ; i ++ ) { bytes32 proofElement = proof [ i ]; if ( computedHash <= proofElement ) { // Hash(current computed hash + current element of the proof) computedHash = keccak256 ( abi . encodePacked ( computedHash , proofElement )); } else { // Hash(current element of the proof + current computed hash) computedHash = keccak256 ( abi . encodePacked ( proofElement , computedHash )); } } // Check if the computed hash (root) is equal to the provided root return computedHash == root ; } Example Usage : // Verify whitelist inclusion bytes32 merkleRoot = 0x1234 ...; bytes32 userLeaf = MerkleProver . getHash ( msg.sender , allocation ); bytes32 [] memory proof = [ 0xabcd ..., 0xef01 ..., 0x2345 ...]; bool isValid = MerkleProver . verify ( merkleRoot , userLeaf , proof ); require ( isValid , \"Invalid Merkle proof\" );","title":"verify()"},{"location":"smart-contracts/libraries/merkle-prover/#leaf-generation","text":"","title":"Leaf Generation"},{"location":"smart-contracts/libraries/merkle-prover/#gethash","text":"function getHash ( address a , uint256 b ) public pure returns ( bytes32 ) Purpose : Generate a standardized leaf hash from an address and amount. Parameters : - a : Ethereum address (typically user address) - b : Numeric value (typically allocation amount) Returns : keccak256 hash of the packed parameters Implementation : function getHash ( address a , uint256 b ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( a , b )); } Use Cases : - Whitelist leaf generation for address + allocation pairs - Airdrop eligibility proofs - Voting power verification - Access control with quantified permissions Example Usage : // Generate leaf for whitelist entry address user = 0x742d35Cc6634C0532925a3b8D4C9db96590c6C87 ; uint256 allocation = 1000 * 10 ** 18 ; // 1000 tokens bytes32 leaf = MerkleProver . getHash ( user , allocation );","title":"getHash()"},{"location":"smart-contracts/libraries/merkle-prover/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/libraries/merkle-prover/#whitelist-token-sale","text":"// Token sale with Merkle tree whitelist contract WhitelistTokenSale { using MerkleProver for bytes32 ; struct WhitelistConfig { bytes32 merkleRoot ; uint256 salePrice ; uint256 maxAllocation ; uint256 startTime ; uint256 endTime ; bool active ; } struct UserPurchase { uint256 purchased ; bool claimed ; } WhitelistConfig public whitelistConfig ; mapping ( address => UserPurchase ) public userPurchases ; mapping ( bytes32 => bool ) public usedLeaves ; event WhitelistConfigured ( bytes32 indexed merkleRoot , uint256 salePrice ); event TokensPurchased ( address indexed user , uint256 amount , uint256 totalCost ); event ProofUsed ( bytes32 indexed leaf , address indexed user ); function configureWhitelist ( bytes32 _merkleRoot , uint256 _salePrice , uint256 _maxAllocation , uint256 _startTime , uint256 _endTime ) external onlyOwner { whitelistConfig = WhitelistConfig ({ merkleRoot : _merkleRoot , salePrice : _salePrice , maxAllocation : _maxAllocation , startTime : _startTime , endTime : _endTime , active : true }); emit WhitelistConfigured ( _merkleRoot , _salePrice ); } function purchaseTokens ( uint256 allocation , uint256 purchaseAmount , bytes32 [] calldata merkleProof ) external payable { require ( whitelistConfig . active , \"Whitelist sale not active\" ); require ( block.timestamp >= whitelistConfig . startTime , \"Sale not started\" ); require ( block.timestamp <= whitelistConfig . endTime , \"Sale ended\" ); require ( purchaseAmount > 0 , \"Purchase amount must be positive\" ); // Generate leaf for this user and allocation bytes32 leaf = MerkleProver . getHash ( msg.sender , allocation ); // Verify Merkle proof bool isValidProof = MerkleProver . verify ( whitelistConfig . merkleRoot , leaf , merkleProof ); require ( isValidProof , \"Invalid Merkle proof\" ); // Prevent proof reuse require ( ! usedLeaves [ leaf ], \"Proof already used\" ); // Check allocation limits UserPurchase storage userPurchase = userPurchases [ msg.sender ]; require ( userPurchase . purchased + purchaseAmount <= allocation , \"Exceeds allocated amount\" ); require ( userPurchase . purchased + purchaseAmount <= whitelistConfig . maxAllocation , \"Exceeds max allocation\" ); // Calculate cost uint256 totalCost = purchaseAmount * whitelistConfig . salePrice ; require ( msg.value >= totalCost , \"Insufficient payment\" ); // Update user purchase record userPurchase . purchased += purchaseAmount ; // Mark leaf as used if fully claimed if ( userPurchase . purchased == allocation ) { usedLeaves [ leaf ] = true ; emit ProofUsed ( leaf , msg.sender ); } // Mint tokens to user _mintTokens ( msg.sender , purchaseAmount ); // Refund excess payment if ( msg.value > totalCost ) { payable ( msg.sender ). transfer ( msg.value - totalCost ); } emit TokensPurchased ( msg.sender , purchaseAmount , totalCost ); } function verifyWhitelistEligibility ( address user , uint256 allocation , bytes32 [] calldata merkleProof ) external view returns ( bool isEligible , uint256 remainingAllocation ) { bytes32 leaf = MerkleProver . getHash ( user , allocation ); isEligible = MerkleProver . verify ( whitelistConfig . merkleRoot , leaf , merkleProof ) && ! usedLeaves [ leaf ]; if ( isEligible ) { remainingAllocation = allocation - userPurchases [ user ]. purchased ; } } function _mintTokens ( address to , uint256 amount ) internal { // Implementation would mint ERC20 tokens } modifier onlyOwner () { // Implementation would check ownership _ ; } }","title":"Whitelist Token Sale"},{"location":"smart-contracts/libraries/merkle-prover/#airdrop-distribution-system","text":"// Airdrop system with Merkle proof claims contract MerkleAirdrop { using MerkleProver for bytes32 ; struct AirdropRound { bytes32 merkleRoot ; uint256 totalTokens ; uint256 claimedTokens ; uint256 startTime ; uint256 endTime ; bool active ; string description ; } struct ClaimRecord { uint256 roundId ; address claimer ; uint256 amount ; uint256 timestamp ; } mapping ( uint256 => AirdropRound ) public airdropRounds ; mapping ( uint256 => mapping ( bytes32 => bool )) public claimedLeaves ; mapping ( address => ClaimRecord []) public userClaims ; uint256 public nextRoundId ; IERC20 public airdropToken ; event AirdropRoundCreated ( uint256 indexed roundId , bytes32 merkleRoot , uint256 totalTokens ); event TokensClaimed ( uint256 indexed roundId , address indexed claimer , uint256 amount ); event RoundFinalized ( uint256 indexed roundId , uint256 totalClaimed ); constructor ( address _airdropToken ) { airdropToken = IERC20 ( _airdropToken ); } function createAirdropRound ( bytes32 _merkleRoot , uint256 _totalTokens , uint256 _startTime , uint256 _endTime , string memory _description ) external onlyOwner returns ( uint256 roundId ) { roundId = nextRoundId ++ ; airdropRounds [ roundId ] = AirdropRound ({ merkleRoot : _merkleRoot , totalTokens : _totalTokens , claimedTokens : 0 , startTime : _startTime , endTime : _endTime , active : true , description : _description }); emit AirdropRoundCreated ( roundId , _merkleRoot , _totalTokens ); } function claimAirdrop ( uint256 roundId , uint256 amount , bytes32 [] calldata merkleProof ) external { AirdropRound storage round = airdropRounds [ roundId ]; require ( round . active , \"Airdrop round not active\" ); require ( block.timestamp >= round . startTime , \"Airdrop not started\" ); require ( block.timestamp <= round . endTime , \"Airdrop ended\" ); // Generate leaf for this claim bytes32 leaf = MerkleProver . getHash ( msg.sender , amount ); // Verify Merkle proof bool isValidProof = MerkleProver . verify ( round . merkleRoot , leaf , merkleProof ); require ( isValidProof , \"Invalid Merkle proof\" ); // Prevent double claiming require ( ! claimedLeaves [ roundId ][ leaf ], \"Already claimed\" ); // Mark as claimed claimedLeaves [ roundId ][ leaf ] = true ; round . claimedTokens += amount ; // Record claim userClaims [ msg.sender ]. push ( ClaimRecord ({ roundId : roundId , claimer : msg.sender , amount : amount , timestamp : block.timestamp })); // Transfer tokens require ( airdropToken . transfer ( msg.sender , amount ), \"Token transfer failed\" ); emit TokensClaimed ( roundId , msg.sender , amount ); } function batchClaimAirdrop ( uint256 [] calldata roundIds , uint256 [] calldata amounts , bytes32 [][] calldata merkleProofs ) external { require ( roundIds . length == amounts . length && amounts . length == merkleProofs . length , \"Array length mismatch\" ); uint256 totalClaim = 0 ; for ( uint256 i = 0 ; i < roundIds . length ; i ++ ) { uint256 roundId = roundIds [ i ]; uint256 amount = amounts [ i ]; bytes32 [] calldata proof = merkleProofs [ i ]; AirdropRound storage round = airdropRounds [ roundId ]; require ( round . active , \"Airdrop round not active\" ); require ( block.timestamp >= round . startTime , \"Airdrop not started\" ); require ( block.timestamp <= round . endTime , \"Airdrop ended\" ); bytes32 leaf = MerkleProver . getHash ( msg.sender , amount ); bool isValidProof = MerkleProver . verify ( round . merkleRoot , leaf , proof ); require ( isValidProof , \"Invalid Merkle proof\" ); require ( ! claimedLeaves [ roundId ][ leaf ], \"Already claimed\" ); claimedLeaves [ roundId ][ leaf ] = true ; round . claimedTokens += amount ; totalClaim += amount ; userClaims [ msg.sender ]. push ( ClaimRecord ({ roundId : roundId , claimer : msg.sender , amount : amount , timestamp : block.timestamp })); emit TokensClaimed ( roundId , msg.sender , amount ); } // Single token transfer for all claims require ( airdropToken . transfer ( msg.sender , totalClaim ), \"Token transfer failed\" ); } function verifyEligibility ( uint256 roundId , address user , uint256 amount , bytes32 [] calldata merkleProof ) external view returns ( bool isEligible , bool alreadyClaimed ) { AirdropRound memory round = airdropRounds [ roundId ]; bytes32 leaf = MerkleProver . getHash ( user , amount ); isEligible = round . active && block.timestamp >= round . startTime && block.timestamp <= round . endTime && MerkleProver . verify ( round . merkleRoot , leaf , merkleProof ); alreadyClaimed = claimedLeaves [ roundId ][ leaf ]; } function getUserClaims ( address user ) external view returns ( ClaimRecord [] memory ) { return userClaims [ user ]; } function getRoundInfo ( uint256 roundId ) external view returns ( bytes32 merkleRoot , uint256 totalTokens , uint256 claimedTokens , uint256 remainingTokens , uint256 startTime , uint256 endTime , bool active , string memory description ) { AirdropRound memory round = airdropRounds [ roundId ]; return ( round . merkleRoot , round . totalTokens , round . claimedTokens , round . totalTokens - round . claimedTokens , round . startTime , round . endTime , round . active , round . description ); } function finalizeRound ( uint256 roundId ) external onlyOwner { AirdropRound storage round = airdropRounds [ roundId ]; require ( round . active , \"Round not active\" ); require ( block.timestamp > round . endTime , \"Round not ended\" ); round . active = false ; // Reclaim unclaimed tokens uint256 unclaimedTokens = round . totalTokens - round . claimedTokens ; if ( unclaimedTokens > 0 ) { require ( airdropToken . transfer ( msg.sender , unclaimedTokens ), \"Token reclaim failed\" ); } emit RoundFinalized ( roundId , round . claimedTokens ); } modifier onlyOwner () { // Implementation would check ownership _ ; } }","title":"Airdrop Distribution System"},{"location":"smart-contracts/libraries/merkle-prover/#voting-system-with-merkle-proofs","text":"// Voting system with Merkle tree voter eligibility contract MerkleVoting { using MerkleProver for bytes32 ; struct Proposal { uint256 id ; string title ; string description ; bytes32 voterMerkleRoot ; uint256 startTime ; uint256 endTime ; uint256 yesVotes ; uint256 noVotes ; uint256 totalVotingPower ; bool executed ; bool passed ; } struct Vote { address voter ; bool support ; uint256 votingPower ; uint256 timestamp ; } mapping ( uint256 => Proposal ) public proposals ; mapping ( uint256 => mapping ( bytes32 => bool )) public hasVoted ; mapping ( uint256 => Vote []) public proposalVotes ; uint256 public nextProposalId ; uint256 public constant VOTING_DURATION = 7 days ; uint256 public constant EXECUTION_DELAY = 2 days ; event ProposalCreated ( uint256 indexed proposalId , string title , bytes32 voterRoot ); event VoteCast ( uint256 indexed proposalId , address indexed voter , bool support , uint256 votingPower ); event ProposalExecuted ( uint256 indexed proposalId , bool passed ); function createProposal ( string memory title , string memory description , bytes32 voterMerkleRoot , uint256 totalVotingPower ) external onlyGovernance returns ( uint256 proposalId ) { proposalId = nextProposalId ++ ; proposals [ proposalId ] = Proposal ({ id : proposalId , title : title , description : description , voterMerkleRoot : voterMerkleRoot , startTime : block.timestamp , endTime : block.timestamp + VOTING_DURATION , yesVotes : 0 , noVotes : 0 , totalVotingPower : totalVotingPower , executed : false , passed : false }); emit ProposalCreated ( proposalId , title , voterMerkleRoot ); } function vote ( uint256 proposalId , bool support , uint256 votingPower , bytes32 [] calldata merkleProof ) external { Proposal storage proposal = proposals [ proposalId ]; require ( block.timestamp >= proposal . startTime , \"Voting not started\" ); require ( block.timestamp <= proposal . endTime , \"Voting ended\" ); require ( ! proposal . executed , \"Proposal already executed\" ); // Generate leaf for voter eligibility bytes32 leaf = MerkleProver . getHash ( msg.sender , votingPower ); // Verify voter eligibility bool isEligible = MerkleProver . verify ( proposal . voterMerkleRoot , leaf , merkleProof ); require ( isEligible , \"Invalid voting eligibility proof\" ); // Prevent double voting require ( ! hasVoted [ proposalId ][ leaf ], \"Already voted\" ); hasVoted [ proposalId ][ leaf ] = true ; // Record vote if ( support ) { proposal . yesVotes += votingPower ; } else { proposal . noVotes += votingPower ; } proposalVotes [ proposalId ]. push ( Vote ({ voter : msg.sender , support : support , votingPower : votingPower , timestamp : block.timestamp })); emit VoteCast ( proposalId , msg.sender , support , votingPower ); } function executeProposal ( uint256 proposalId ) external { Proposal storage proposal = proposals [ proposalId ]; require ( block.timestamp > proposal . endTime + EXECUTION_DELAY , \"Execution delay not met\" ); require ( ! proposal . executed , \"Proposal already executed\" ); proposal . executed = true ; // Determine if proposal passed (simple majority) uint256 totalVotes = proposal . yesVotes + proposal . noVotes ; proposal . passed = proposal . yesVotes > proposal . noVotes && totalVotes >= ( proposal . totalVotingPower / 4 ); // 25% quorum if ( proposal . passed ) { _executeProposalLogic ( proposalId ); } emit ProposalExecuted ( proposalId , proposal . passed ); } function verifyVoterEligibility ( uint256 proposalId , address voter , uint256 votingPower , bytes32 [] calldata merkleProof ) external view returns ( bool isEligible , bool hasAlreadyVoted ) { Proposal memory proposal = proposals [ proposalId ]; bytes32 leaf = MerkleProver . getHash ( voter , votingPower ); isEligible = MerkleProver . verify ( proposal . voterMerkleRoot , leaf , merkleProof ); hasAlreadyVoted = hasVoted [ proposalId ][ leaf ]; } function getProposalResults ( uint256 proposalId ) external view returns ( uint256 yesVotes , uint256 noVotes , uint256 totalVotes , uint256 participationRate , bool canExecute , bool executed , bool passed ) { Proposal memory proposal = proposals [ proposalId ]; yesVotes = proposal . yesVotes ; noVotes = proposal . noVotes ; totalVotes = yesVotes + noVotes ; participationRate = ( totalVotes * 100 ) / proposal . totalVotingPower ; canExecute = block.timestamp > proposal . endTime + EXECUTION_DELAY && ! proposal . executed ; executed = proposal . executed ; passed = proposal . passed ; } function getProposalVotes ( uint256 proposalId ) external view returns ( Vote [] memory ) { return proposalVotes [ proposalId ]; } function _executeProposalLogic ( uint256 proposalId ) internal { // Implementation would execute the actual proposal logic } modifier onlyGovernance () { // Implementation would check governance authorization _ ; } }","title":"Voting System with Merkle Proofs"},{"location":"smart-contracts/libraries/merkle-prover/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/merkle-prover/#proof-validation-security","text":"Empty Proof Protection : Prevents false positives when leaf equals root Deterministic Ordering : Sorted hash combination prevents manipulation Replay Attack Prevention : Leaf tracking prevents proof reuse Input Validation : Proper bounds checking and parameter validation","title":"Proof Validation Security"},{"location":"smart-contracts/libraries/merkle-prover/#cryptographic-security","text":"Standard Algorithms : Uses keccak256 for cryptographic security Collision Resistance : Merkle tree structure provides collision resistance Preimage Resistance : Hash functions prevent reverse engineering Second Preimage Resistance : Protects against proof forgery","title":"Cryptographic Security"},{"location":"smart-contracts/libraries/merkle-prover/#implementation-security","text":"Pure Functions : Stateless operations prevent state manipulation Gas Efficiency : Optimized algorithms prevent DoS attacks Overflow Protection : Safe arithmetic operations Memory Safety : Proper array bounds checking","title":"Implementation Security"},{"location":"smart-contracts/libraries/merkle-prover/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/libraries/merkle-prover/#verification-efficiency","text":"Minimal Storage : Pure functions with no storage operations Optimized Loops : Efficient proof iteration Reduced Hashing : Minimal hash operations per verification Batch Operations : Support for batch proof verification","title":"Verification Efficiency"},{"location":"smart-contracts/libraries/merkle-prover/#memory-efficiency","text":"Stack Operations : Minimal memory allocation Efficient Encoding : Optimized abi.encodePacked usage Proof Size : Logarithmic proof size relative to tree size Reusable Functions : Pure functions for maximum reusability","title":"Memory Efficiency"},{"location":"smart-contracts/libraries/merkle-prover/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/libraries/merkle-prover/#common-errors","text":"Invalid Merkle proof verification failure Empty proof with leaf equal to root Array bounds errors in proof iteration Hash computation failures","title":"Common Errors"},{"location":"smart-contracts/libraries/merkle-prover/#best-practices","text":"Always validate proof arrays before processing Check for edge cases (empty proofs, single-element trees) Implement proper error messages for debugging Use safe arithmetic operations","title":"Best Practices"},{"location":"smart-contracts/libraries/merkle-prover/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/libraries/merkle-prover/#unit-tests","text":"Proof verification accuracy for various tree sizes Edge case handling (empty proofs, single nodes) Hash generation consistency Security vulnerability testing","title":"Unit Tests"},{"location":"smart-contracts/libraries/merkle-prover/#integration-tests","text":"Whitelist system integration Airdrop distribution workflows Voting system integration Cross-contract proof verification","title":"Integration Tests"},{"location":"smart-contracts/libraries/merkle-prover/#security-testing","text":"Proof forgery attempts Replay attack prevention Edge case exploitation Gas consumption analysis","title":"Security Testing"},{"location":"smart-contracts/libraries/merkle-prover/#related-documentation","text":"MultiSaleLib - Multi-token sale whitelist integration Whitelist Systems Guide - Whitelist implementation patterns Airdrop Guide - Airdrop distribution best practices Cryptographic Security - Security considerations Gas Optimization Guide - Performance optimization techniques This library provides secure and efficient Merkle proof verification utilities for the Gemforce platform, enabling whitelist systems, airdrop distributions, voting mechanisms, and other scenarios requiring cryptographic proof of inclusion with protection against common attack vectors.","title":"Related Documentation"},{"location":"smart-contracts/libraries/metadata-lib/","text":"MetadataLib Library \u00b6 Overview \u00b6 MetadataLib is a comprehensive NFT metadata management library that handles the generation, storage, and retrieval of token metadata in compliance with ERC721 standards. This library provides advanced features for dynamic metadata generation, SVG image processing, attribute management, and JSON metadata formatting. Key Features \u00b6 Dynamic Metadata Generation : Generate metadata on-chain with customizable attributes SVG Image Integration : Advanced SVG template processing and color replacement Attribute Management : Integration with AttributeLib for token-specific attributes JSON Formatting : Standards-compliant JSON metadata generation Base64 Encoding : Automatic encoding for data URIs Contract-Level Metadata : Support for collection-level metadata Template System : Flexible template replacement for dynamic content Storage Structure \u00b6 MetadataStorage \u00b6 struct MetadataStorage { MetadataContract metadata ; } Storage Position \u00b6 bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nextblock.bitgem.app.MetadataStorage.storage\" ); Core Functions \u00b6 Storage Access \u00b6 metadataStorage() \u00b6 function metadataStorage () internal pure returns ( MetadataStorage storage ds ) Returns the metadata storage struct using assembly for gas efficiency. setMetadata() \u00b6 function setMetadata ( MetadataContract storage , MetadataContract memory _contract ) internal Sets the metadata contract configuration. Basic Metadata Properties \u00b6 name() \u00b6 function name ( MetadataContract storage self ) internal view returns ( string memory ) Returns the collection name. symbol() \u00b6 function symbol ( MetadataContract storage self ) internal view returns ( string memory ) Returns the collection symbol. description() \u00b6 function description ( MetadataContract storage self ) internal view returns ( string memory ) Returns the collection description. image() \u00b6 function image ( MetadataContract storage self ) internal view returns ( string memory ) Returns the collection image as SVG. Image Management \u00b6 getContractImage() \u00b6 function getContractImage ( MetadataContract storage self ) internal view returns ( address addr , string memory svg ) Generates the contract-level image using SVG templates and color replacements. Returns: - addr : Address of the SVG template contract - svg : Generated SVG string Features: - Template Resolution : Resolves SVG templates by name - Color Replacement : Applies color palette to templates - Fallback Handling : Returns image name if template resolution fails getTokenImage() \u00b6 function getTokenImage ( MetadataContract storage , DiamondContract storage , AttributeContract storage a , uint256 tokenId ) internal view returns ( string memory svg , Attribute [] memory attributes ) Generates token-specific image and retrieves associated attributes. Parameters: - tokenId : ID of the token Returns: - svg : Generated or stored SVG for the token - attributes : Array of token attributes setTokenImage() \u00b6 function setTokenImage ( MetadataContract storage , AttributeContract storage a , uint256 tokenId , string memory svg ) internal Sets a custom image for a specific token. Parameters: - tokenId : ID of the token - svg : SVG content to store Configuration Management \u00b6 _setMetadataSource() \u00b6 function _setMetadataSource ( MetadataContract storage self , MetadataSource source ) internal Sets the metadata source type (on-chain, IPFS, HTTP, etc.). _setBaseURI() \u00b6 function _setBaseURI ( MetadataContract storage self , string memory baseURI ) internal Sets the base URI for external metadata sources. URI Generation \u00b6 tokenURI() \u00b6 function tokenURI ( MetadataContract storage self , DiamondContract storage diamond , AttributeContract storage attribs , uint256 tokenId ) internal view returns ( string memory ) Generates the complete token URI with metadata JSON. Process: 1. Retrieves token image and attributes 2. Converts attributes to traits 3. Generates JSON metadata 4. Base64 encodes the result 5. Returns data URI Features: - Dynamic Naming : Adds \"Claim\" suffix for claim tokens - Attribute Integration : Includes all token attributes as traits - Standards Compliance : ERC721 metadata standard compliant contractURI() \u00b6 function contractURI ( MetadataContract storage self ) internal view returns ( string memory ) Generates contract-level metadata URI for collection information. Metadata Generation \u00b6 Trait Creation \u00b6 createTrait() \u00b6 function createTrait ( string memory displayType , string memory key , string memory value ) internal pure returns ( string memory trait ) Creates a JSON trait object for metadata attributes. Parameters: - displayType : Display type for the trait (e.g., \"number\", \"percentage\") - key : Trait name - value : Trait value Features: - Type Handling : Automatic value formatting based on display type - Number Detection : Unquoted values for numeric traits - Validation : Ensures key is not empty arrayizeTraits() \u00b6 function arrayizeTraits ( Trait [] memory _traits ) internal pure returns ( string memory _traitsString ) Converts an array of trait structs into a JSON array string. Features: - JSON Formatting : Proper JSON array formatting - Comma Handling : Correct comma placement between traits - Empty Array Support : Handles empty trait arrays Complete Metadata Generation \u00b6 getTokenMetadata() \u00b6 function getTokenMetadata ( MetadataContract memory definition , Trait [] memory _traits , string memory _imageData ) internal pure returns ( string memory metadata ) Generates complete JSON metadata for a token. Parameters: - definition : Metadata contract definition - _traits : Array of token traits - _imageData : Image data (SVG or URL) Generated Fields: - name : Token name - image : Token image - description : Token description - external_url : External URL (if configured) - attributes : Token attributes array Template Processing \u00b6 SVG Template Integration \u00b6 _getReplacements() \u00b6 function _getReplacements ( string [] memory colorPalette , string [] memory cccc ) internal pure returns ( Replacement [] memory ) Creates replacement arrays for SVG template processing. Parameters: - colorPalette : Array of color values - cccc : Array of attribute values (CUT, COLOR, CARAT, CLARITY) Returns: - Array of replacement objects for template processing Template Variables: - COLOR 0 , COLOR 1 , etc.: Color palette values - CUT : Cut attribute value - COLOR : Color attribute value - CARAT : Carat attribute value - CLARITY : Clarity attribute value Data Structures \u00b6 Trait Structure \u00b6 struct Trait { string displayType ; string key ; string value ; } Replacement Structure \u00b6 struct Replacement { string matchString ; string replaceString ; } Attribute Structure \u00b6 struct Attribute { string key ; AttributeType attributeType ; string value ; } Usage Examples \u00b6 Basic Token URI Generation \u00b6 function getTokenURI ( uint256 tokenId ) external view returns ( string memory ) { MetadataStorage storage ms = MetadataLib . metadataStorage (); DiamondStorage storage ds = DiamondLib . diamondStorage (); AttributeStorage storage as = AttributeLib . attributeStorage (); return MetadataLib . tokenURI ( ms . metadata , ds , as , tokenId ); } Custom Trait Creation \u00b6 function createCustomTraits ( uint256 tokenId ) internal view returns ( Trait [] memory ) { Trait [] memory traits = new Trait []( 3 ); traits [ 0 ] = Trait ( \"\" , \"Rarity\" , \"Legendary\" ); traits [ 1 ] = Trait ( \"number\" , \"Level\" , \"42\" ); traits [ 2 ] = Trait ( \"percentage\" , \"Completion\" , \"85\" ); return traits ; } Dynamic Image Generation \u00b6 function generateTokenImage ( uint256 tokenId ) internal view returns ( string memory ) { MetadataStorage storage ms = MetadataLib . metadataStorage (); DiamondStorage storage ds = DiamondLib . diamondStorage (); AttributeStorage storage as = AttributeLib . attributeStorage (); ( string memory svg , ) = MetadataLib . getTokenImage ( ms . metadata , ds , as , tokenId ); return svg ; } Contract Metadata Setup \u00b6 function setupContractMetadata () internal { MetadataContract memory metadata = MetadataContract ({ _name : \"Gemforce Collection\" , _symbol : \"GEM\" , _description : \"A collection of unique digital gems\" , _imageName : \"gem_template\" , _imageColors : [ \"#FF0000\" , \"#00FF00\" , \"#0000FF\" ], _externalUri : \"https://gemforce.io\" , _baseUri : \"https://api.gemforce.io/metadata/\" , _metadataSource : MetadataSource . OnChain }); MetadataLib . setMetadata ( metadataStorage (). metadata , metadata ); } Integration Points \u00b6 With AttributeLib \u00b6 // Get token attributes for metadata string [] memory keys = AttributeLib . _getAttributeKeys ( attributeStorage , tokenId ); string [] memory values = AttributeLib . _getAttributeValues ( tokenId ); With SVGTemplatesLib \u00b6 // Generate SVG with template replacement SVGManager mgr = SVGManager ( SVGTemplatesLib . svgStorage (). svgManager ); address templateAddr = mgr . svgAddress ( imageName ); string memory svg = ISVGTemplate ( templateAddr ). buildSVG ( replacements ); With StringsLib \u00b6 // String manipulation for metadata processing bool isHex = StringsLib . startsWith ( imageData , \"0x\" ); string memory processed = StringsLib . replace ( template , \"{{value}}\" , replacement ); Special Features \u00b6 Claim Token Detection \u00b6 The library automatically detects claim tokens and modifies the name: if ( TYPE_HASH == keccak256 ( bytes ( attributes [ i ]. key )) && CLAIM_HASH == keccak256 ( bytes ( attributes [ i ]. value )) ) { _name = string ( abi . encodePacked ( _name , \" Claim\" )); } Image Format Detection \u00b6 Supports both SVG content and hex-encoded data: if ( ! _imageData . startsWith ( \"0x\" )) { _imageData = string ( abi . encodePacked ( '\"' , _imageData , '\"' )); } Dynamic Color Replacement \u00b6 Supports dynamic color palette application to SVG templates: string [] memory colors = [ \"#FF0000\" , \"#00FF00\" , \"#0000FF\" ]; Replacement [] memory replacements = _getReplacements ( colors , attributes ); Performance Considerations \u00b6 Gas Optimization \u00b6 String Operations : Efficient string concatenation using abi.encodePacked Memory Management : Careful memory allocation for large metadata Template Caching : SVG templates resolved once per call Storage Efficiency \u00b6 Attribute Integration : Leverages existing attribute storage Template Reuse : Shared SVG templates across tokens Lazy Loading : Images generated on-demand Security Considerations \u00b6 Input Validation \u00b6 Key Validation : Ensures trait keys are not empty Address Validation : Validates SVG template addresses Data Sanitization : Proper JSON escaping for metadata values Access Control \u00b6 Internal Functions : Most functions are internal for controlled access Storage Protection : Diamond storage pattern prevents conflicts Template Security : SVG template resolution with error handling Best Practices \u00b6 Metadata Standards : Follow ERC721 metadata standards Gas Efficiency : Minimize string operations in loops Template Organization : Organize SVG templates logically Attribute Consistency : Maintain consistent attribute naming Error Handling : Implement proper fallbacks for template failures Related Documentation \u00b6 Attribute Library - Token attribute management SVG Templates Library - SVG template processing Strings Library - String manipulation utilities Diamond Library - Diamond pattern integration ERC721 Standard - NFT metadata standard Migration Notes \u00b6 When upgrading metadata systems: - Ensure attribute compatibility with existing tokens - Test SVG template resolution thoroughly - Validate JSON metadata format compliance - Consider gas costs for large collections","title":"MetadataLib Library"},{"location":"smart-contracts/libraries/metadata-lib/#metadatalib-library","text":"","title":"MetadataLib Library"},{"location":"smart-contracts/libraries/metadata-lib/#overview","text":"MetadataLib is a comprehensive NFT metadata management library that handles the generation, storage, and retrieval of token metadata in compliance with ERC721 standards. This library provides advanced features for dynamic metadata generation, SVG image processing, attribute management, and JSON metadata formatting.","title":"Overview"},{"location":"smart-contracts/libraries/metadata-lib/#key-features","text":"Dynamic Metadata Generation : Generate metadata on-chain with customizable attributes SVG Image Integration : Advanced SVG template processing and color replacement Attribute Management : Integration with AttributeLib for token-specific attributes JSON Formatting : Standards-compliant JSON metadata generation Base64 Encoding : Automatic encoding for data URIs Contract-Level Metadata : Support for collection-level metadata Template System : Flexible template replacement for dynamic content","title":"Key Features"},{"location":"smart-contracts/libraries/metadata-lib/#storage-structure","text":"","title":"Storage Structure"},{"location":"smart-contracts/libraries/metadata-lib/#metadatastorage","text":"struct MetadataStorage { MetadataContract metadata ; }","title":"MetadataStorage"},{"location":"smart-contracts/libraries/metadata-lib/#storage-position","text":"bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nextblock.bitgem.app.MetadataStorage.storage\" );","title":"Storage Position"},{"location":"smart-contracts/libraries/metadata-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/metadata-lib/#storage-access","text":"","title":"Storage Access"},{"location":"smart-contracts/libraries/metadata-lib/#metadatastorage_1","text":"function metadataStorage () internal pure returns ( MetadataStorage storage ds ) Returns the metadata storage struct using assembly for gas efficiency.","title":"metadataStorage()"},{"location":"smart-contracts/libraries/metadata-lib/#setmetadata","text":"function setMetadata ( MetadataContract storage , MetadataContract memory _contract ) internal Sets the metadata contract configuration.","title":"setMetadata()"},{"location":"smart-contracts/libraries/metadata-lib/#basic-metadata-properties","text":"","title":"Basic Metadata Properties"},{"location":"smart-contracts/libraries/metadata-lib/#name","text":"function name ( MetadataContract storage self ) internal view returns ( string memory ) Returns the collection name.","title":"name()"},{"location":"smart-contracts/libraries/metadata-lib/#symbol","text":"function symbol ( MetadataContract storage self ) internal view returns ( string memory ) Returns the collection symbol.","title":"symbol()"},{"location":"smart-contracts/libraries/metadata-lib/#description","text":"function description ( MetadataContract storage self ) internal view returns ( string memory ) Returns the collection description.","title":"description()"},{"location":"smart-contracts/libraries/metadata-lib/#image","text":"function image ( MetadataContract storage self ) internal view returns ( string memory ) Returns the collection image as SVG.","title":"image()"},{"location":"smart-contracts/libraries/metadata-lib/#image-management","text":"","title":"Image Management"},{"location":"smart-contracts/libraries/metadata-lib/#getcontractimage","text":"function getContractImage ( MetadataContract storage self ) internal view returns ( address addr , string memory svg ) Generates the contract-level image using SVG templates and color replacements. Returns: - addr : Address of the SVG template contract - svg : Generated SVG string Features: - Template Resolution : Resolves SVG templates by name - Color Replacement : Applies color palette to templates - Fallback Handling : Returns image name if template resolution fails","title":"getContractImage()"},{"location":"smart-contracts/libraries/metadata-lib/#gettokenimage","text":"function getTokenImage ( MetadataContract storage , DiamondContract storage , AttributeContract storage a , uint256 tokenId ) internal view returns ( string memory svg , Attribute [] memory attributes ) Generates token-specific image and retrieves associated attributes. Parameters: - tokenId : ID of the token Returns: - svg : Generated or stored SVG for the token - attributes : Array of token attributes","title":"getTokenImage()"},{"location":"smart-contracts/libraries/metadata-lib/#settokenimage","text":"function setTokenImage ( MetadataContract storage , AttributeContract storage a , uint256 tokenId , string memory svg ) internal Sets a custom image for a specific token. Parameters: - tokenId : ID of the token - svg : SVG content to store","title":"setTokenImage()"},{"location":"smart-contracts/libraries/metadata-lib/#configuration-management","text":"","title":"Configuration Management"},{"location":"smart-contracts/libraries/metadata-lib/#_setmetadatasource","text":"function _setMetadataSource ( MetadataContract storage self , MetadataSource source ) internal Sets the metadata source type (on-chain, IPFS, HTTP, etc.).","title":"_setMetadataSource()"},{"location":"smart-contracts/libraries/metadata-lib/#_setbaseuri","text":"function _setBaseURI ( MetadataContract storage self , string memory baseURI ) internal Sets the base URI for external metadata sources.","title":"_setBaseURI()"},{"location":"smart-contracts/libraries/metadata-lib/#uri-generation","text":"","title":"URI Generation"},{"location":"smart-contracts/libraries/metadata-lib/#tokenuri","text":"function tokenURI ( MetadataContract storage self , DiamondContract storage diamond , AttributeContract storage attribs , uint256 tokenId ) internal view returns ( string memory ) Generates the complete token URI with metadata JSON. Process: 1. Retrieves token image and attributes 2. Converts attributes to traits 3. Generates JSON metadata 4. Base64 encodes the result 5. Returns data URI Features: - Dynamic Naming : Adds \"Claim\" suffix for claim tokens - Attribute Integration : Includes all token attributes as traits - Standards Compliance : ERC721 metadata standard compliant","title":"tokenURI()"},{"location":"smart-contracts/libraries/metadata-lib/#contracturi","text":"function contractURI ( MetadataContract storage self ) internal view returns ( string memory ) Generates contract-level metadata URI for collection information.","title":"contractURI()"},{"location":"smart-contracts/libraries/metadata-lib/#metadata-generation","text":"","title":"Metadata Generation"},{"location":"smart-contracts/libraries/metadata-lib/#trait-creation","text":"","title":"Trait Creation"},{"location":"smart-contracts/libraries/metadata-lib/#createtrait","text":"function createTrait ( string memory displayType , string memory key , string memory value ) internal pure returns ( string memory trait ) Creates a JSON trait object for metadata attributes. Parameters: - displayType : Display type for the trait (e.g., \"number\", \"percentage\") - key : Trait name - value : Trait value Features: - Type Handling : Automatic value formatting based on display type - Number Detection : Unquoted values for numeric traits - Validation : Ensures key is not empty","title":"createTrait()"},{"location":"smart-contracts/libraries/metadata-lib/#arrayizetraits","text":"function arrayizeTraits ( Trait [] memory _traits ) internal pure returns ( string memory _traitsString ) Converts an array of trait structs into a JSON array string. Features: - JSON Formatting : Proper JSON array formatting - Comma Handling : Correct comma placement between traits - Empty Array Support : Handles empty trait arrays","title":"arrayizeTraits()"},{"location":"smart-contracts/libraries/metadata-lib/#complete-metadata-generation","text":"","title":"Complete Metadata Generation"},{"location":"smart-contracts/libraries/metadata-lib/#gettokenmetadata","text":"function getTokenMetadata ( MetadataContract memory definition , Trait [] memory _traits , string memory _imageData ) internal pure returns ( string memory metadata ) Generates complete JSON metadata for a token. Parameters: - definition : Metadata contract definition - _traits : Array of token traits - _imageData : Image data (SVG or URL) Generated Fields: - name : Token name - image : Token image - description : Token description - external_url : External URL (if configured) - attributes : Token attributes array","title":"getTokenMetadata()"},{"location":"smart-contracts/libraries/metadata-lib/#template-processing","text":"","title":"Template Processing"},{"location":"smart-contracts/libraries/metadata-lib/#svg-template-integration","text":"","title":"SVG Template Integration"},{"location":"smart-contracts/libraries/metadata-lib/#_getreplacements","text":"function _getReplacements ( string [] memory colorPalette , string [] memory cccc ) internal pure returns ( Replacement [] memory ) Creates replacement arrays for SVG template processing. Parameters: - colorPalette : Array of color values - cccc : Array of attribute values (CUT, COLOR, CARAT, CLARITY) Returns: - Array of replacement objects for template processing Template Variables: - COLOR 0 , COLOR 1 , etc.: Color palette values - CUT : Cut attribute value - COLOR : Color attribute value - CARAT : Carat attribute value - CLARITY : Clarity attribute value","title":"_getReplacements()"},{"location":"smart-contracts/libraries/metadata-lib/#data-structures","text":"","title":"Data Structures"},{"location":"smart-contracts/libraries/metadata-lib/#trait-structure","text":"struct Trait { string displayType ; string key ; string value ; }","title":"Trait Structure"},{"location":"smart-contracts/libraries/metadata-lib/#replacement-structure","text":"struct Replacement { string matchString ; string replaceString ; }","title":"Replacement Structure"},{"location":"smart-contracts/libraries/metadata-lib/#attribute-structure","text":"struct Attribute { string key ; AttributeType attributeType ; string value ; }","title":"Attribute Structure"},{"location":"smart-contracts/libraries/metadata-lib/#usage-examples","text":"","title":"Usage Examples"},{"location":"smart-contracts/libraries/metadata-lib/#basic-token-uri-generation","text":"function getTokenURI ( uint256 tokenId ) external view returns ( string memory ) { MetadataStorage storage ms = MetadataLib . metadataStorage (); DiamondStorage storage ds = DiamondLib . diamondStorage (); AttributeStorage storage as = AttributeLib . attributeStorage (); return MetadataLib . tokenURI ( ms . metadata , ds , as , tokenId ); }","title":"Basic Token URI Generation"},{"location":"smart-contracts/libraries/metadata-lib/#custom-trait-creation","text":"function createCustomTraits ( uint256 tokenId ) internal view returns ( Trait [] memory ) { Trait [] memory traits = new Trait []( 3 ); traits [ 0 ] = Trait ( \"\" , \"Rarity\" , \"Legendary\" ); traits [ 1 ] = Trait ( \"number\" , \"Level\" , \"42\" ); traits [ 2 ] = Trait ( \"percentage\" , \"Completion\" , \"85\" ); return traits ; }","title":"Custom Trait Creation"},{"location":"smart-contracts/libraries/metadata-lib/#dynamic-image-generation","text":"function generateTokenImage ( uint256 tokenId ) internal view returns ( string memory ) { MetadataStorage storage ms = MetadataLib . metadataStorage (); DiamondStorage storage ds = DiamondLib . diamondStorage (); AttributeStorage storage as = AttributeLib . attributeStorage (); ( string memory svg , ) = MetadataLib . getTokenImage ( ms . metadata , ds , as , tokenId ); return svg ; }","title":"Dynamic Image Generation"},{"location":"smart-contracts/libraries/metadata-lib/#contract-metadata-setup","text":"function setupContractMetadata () internal { MetadataContract memory metadata = MetadataContract ({ _name : \"Gemforce Collection\" , _symbol : \"GEM\" , _description : \"A collection of unique digital gems\" , _imageName : \"gem_template\" , _imageColors : [ \"#FF0000\" , \"#00FF00\" , \"#0000FF\" ], _externalUri : \"https://gemforce.io\" , _baseUri : \"https://api.gemforce.io/metadata/\" , _metadataSource : MetadataSource . OnChain }); MetadataLib . setMetadata ( metadataStorage (). metadata , metadata ); }","title":"Contract Metadata Setup"},{"location":"smart-contracts/libraries/metadata-lib/#integration-points","text":"","title":"Integration Points"},{"location":"smart-contracts/libraries/metadata-lib/#with-attributelib","text":"// Get token attributes for metadata string [] memory keys = AttributeLib . _getAttributeKeys ( attributeStorage , tokenId ); string [] memory values = AttributeLib . _getAttributeValues ( tokenId );","title":"With AttributeLib"},{"location":"smart-contracts/libraries/metadata-lib/#with-svgtemplateslib","text":"// Generate SVG with template replacement SVGManager mgr = SVGManager ( SVGTemplatesLib . svgStorage (). svgManager ); address templateAddr = mgr . svgAddress ( imageName ); string memory svg = ISVGTemplate ( templateAddr ). buildSVG ( replacements );","title":"With SVGTemplatesLib"},{"location":"smart-contracts/libraries/metadata-lib/#with-stringslib","text":"// String manipulation for metadata processing bool isHex = StringsLib . startsWith ( imageData , \"0x\" ); string memory processed = StringsLib . replace ( template , \"{{value}}\" , replacement );","title":"With StringsLib"},{"location":"smart-contracts/libraries/metadata-lib/#special-features","text":"","title":"Special Features"},{"location":"smart-contracts/libraries/metadata-lib/#claim-token-detection","text":"The library automatically detects claim tokens and modifies the name: if ( TYPE_HASH == keccak256 ( bytes ( attributes [ i ]. key )) && CLAIM_HASH == keccak256 ( bytes ( attributes [ i ]. value )) ) { _name = string ( abi . encodePacked ( _name , \" Claim\" )); }","title":"Claim Token Detection"},{"location":"smart-contracts/libraries/metadata-lib/#image-format-detection","text":"Supports both SVG content and hex-encoded data: if ( ! _imageData . startsWith ( \"0x\" )) { _imageData = string ( abi . encodePacked ( '\"' , _imageData , '\"' )); }","title":"Image Format Detection"},{"location":"smart-contracts/libraries/metadata-lib/#dynamic-color-replacement","text":"Supports dynamic color palette application to SVG templates: string [] memory colors = [ \"#FF0000\" , \"#00FF00\" , \"#0000FF\" ]; Replacement [] memory replacements = _getReplacements ( colors , attributes );","title":"Dynamic Color Replacement"},{"location":"smart-contracts/libraries/metadata-lib/#performance-considerations","text":"","title":"Performance Considerations"},{"location":"smart-contracts/libraries/metadata-lib/#gas-optimization","text":"String Operations : Efficient string concatenation using abi.encodePacked Memory Management : Careful memory allocation for large metadata Template Caching : SVG templates resolved once per call","title":"Gas Optimization"},{"location":"smart-contracts/libraries/metadata-lib/#storage-efficiency","text":"Attribute Integration : Leverages existing attribute storage Template Reuse : Shared SVG templates across tokens Lazy Loading : Images generated on-demand","title":"Storage Efficiency"},{"location":"smart-contracts/libraries/metadata-lib/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/metadata-lib/#input-validation","text":"Key Validation : Ensures trait keys are not empty Address Validation : Validates SVG template addresses Data Sanitization : Proper JSON escaping for metadata values","title":"Input Validation"},{"location":"smart-contracts/libraries/metadata-lib/#access-control","text":"Internal Functions : Most functions are internal for controlled access Storage Protection : Diamond storage pattern prevents conflicts Template Security : SVG template resolution with error handling","title":"Access Control"},{"location":"smart-contracts/libraries/metadata-lib/#best-practices","text":"Metadata Standards : Follow ERC721 metadata standards Gas Efficiency : Minimize string operations in loops Template Organization : Organize SVG templates logically Attribute Consistency : Maintain consistent attribute naming Error Handling : Implement proper fallbacks for template failures","title":"Best Practices"},{"location":"smart-contracts/libraries/metadata-lib/#related-documentation","text":"Attribute Library - Token attribute management SVG Templates Library - SVG template processing Strings Library - String manipulation utilities Diamond Library - Diamond pattern integration ERC721 Standard - NFT metadata standard","title":"Related Documentation"},{"location":"smart-contracts/libraries/metadata-lib/#migration-notes","text":"When upgrading metadata systems: - Ensure attribute compatibility with existing tokens - Test SVG template resolution thoroughly - Validate JSON metadata format compliance - Consider gas costs for large collections","title":"Migration Notes"},{"location":"smart-contracts/libraries/multi-sale-lib/","text":"MultiSaleLib Library \u00b6 Overview \u00b6 The MultiSaleLib library provides core utilities and data structures for managing multi-token sales within the Gemforce platform. This library implements comprehensive token sale functionality including whitelist management, Merkle proof validation, variable pricing, and support for multiple payment methods (ETH and ERC20 tokens). Key Features \u00b6 Multi-Token Support : Support for ERC20, ERC721, and ERC1155 token sales Whitelist Management : Merkle tree-based whitelist with proof validation Variable Pricing : Dynamic pricing with configurable price structures Payment Flexibility : Support for ETH and ERC20 token payments Quantity Controls : Min/max quantity limits per sale and per account Time-Based Sales : Configurable start and end times for sales Proof Validation : Secure Merkle proof validation to prevent replay attacks Library Definition \u00b6 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; library MultiSaleLib { using SafeERC20 for IERC20 ; // Core functions function _createTokenSale () internal returns ( uint256 tokenSaleId ); function _validatePurchase ( MultiSaleContract storage self , VariablePriceContract storage priceContract , uint256 quantity , uint256 valueAttached ) internal view ; function _validateProof ( MultiSaleContract storage self , MultiSalePurchase memory purchase , MultiSaleProof memory purchaseProof ) internal ; function _purchaseToken (...) internal ; function _airdropRedeemed ( MultiSaleContract storage self , address recipient ) internal view returns ( bool isRedeemed ); } Data Structures \u00b6 PaymentType Enum \u00b6 enum PaymentType { Ether , // Payment with native ETH ERC20 // Payment with ERC20 tokens } PaymentMethod Enum \u00b6 enum PaymentMethod { Native , // Payment with the native currency (e.g., ETH) ERC20 // Payment with an ERC20 token } MultiSalePurchase Struct \u00b6 struct MultiSalePurchase { uint256 multiSaleId ; // ID of the multi-sale address purchaser ; // Address making the purchase address receiver ; // Address receiving the tokens uint256 quantity ; // Quantity of tokens to purchase } Purpose : Represents a token purchase request with all necessary details. MultiSaleProof Struct \u00b6 struct MultiSaleProof { uint256 leaf ; // Leaf value for Merkle proof uint256 total ; // Total allocation for the address bytes32 [] merkleProof ; // Merkle proof array bytes data ; // Additional proof data } Purpose : Contains Merkle proof data for whitelist validation. MultiSaleSettings Struct \u00b6 struct MultiSaleSettings { TokenType tokenType ; // Type of token being sold address token ; // Token contract address uint256 tokenHash ; // Token hash (0 for auto-creation) uint256 whitelistHash ; // Merkle root for whitelist bool whitelistOnly ; // Whether sale is whitelist-only PaymentMethod paymentMethod ; // Payment method (Native/ERC20) address paymentToken ; // ERC20 token address for payments address owner ; // Owner of the sale address payee ; // Recipient of sale proceeds string symbol ; // Token symbol string name ; // Token name string description ; // Token description bool openState ; // Whether sale is open uint256 startTime ; // Sale start timestamp uint256 endTime ; // Sale end timestamp uint256 maxQuantity ; // Maximum total tokens for sale uint256 maxQuantityPerSale ; // Maximum tokens per transaction uint256 minQuantityPerSale ; // Minimum tokens per transaction uint256 maxQuantityPerAccount ; // Maximum tokens per account PaymentType paymentType ; // Legacy payment type address tokenAddress ; // Legacy token address uint256 nextSaleId ; // Next sale ID counter VariablePriceContract price ; // Variable pricing configuration } Purpose : Comprehensive configuration for a multi-token sale. MultiSaleContract Struct \u00b6 struct MultiSaleContract { MultiSaleSettings settings ; // Sale configuration uint256 nonce ; // Nonce for unique operations uint256 totalPurchased ; // Total tokens purchased mapping ( address => uint256 ) purchased ; // Tokens purchased per address mapping ( uint256 => uint256 ) _redeemedData ; // Redeemed data tracking mapping ( address => uint256 ) _redeemedDataQuantities ; // Redeemed quantities per address mapping ( address => uint256 ) _totalDataQuantities ; // Total allocations per address mapping ( address => uint256 ) _accountQuantities ; // Account quantity tracking } Purpose : Complete state management for a multi-token sale. MultiSaleStorage Struct \u00b6 struct MultiSaleStorage { uint256 tsnonce ; // Token sale nonce mapping ( uint256 => MultiSaleContract ) _tokenSales ; // All token sales uint256 [] _tokenSaleIds ; // Array of sale IDs } Purpose : Diamond storage structure for all multi-sale data. Core Functions \u00b6 Sale Creation \u00b6 _createTokenSale() \u00b6 function _createTokenSale () internal returns ( uint256 tokenSaleId ) Purpose : Generate a unique token sale ID for a new sale. Returns : Unique token sale identifier Implementation : - Uses keccak256 hash of nonce and contract address - Increments global nonce to ensure uniqueness - Returns deterministic but unique sale ID Example Usage : // Create a new token sale uint256 saleId = MultiSaleLib . _createTokenSale (); console . log ( \"Created token sale with ID:\" , saleId ); Purchase Validation \u00b6 _validatePurchase() \u00b6 function _validatePurchase ( MultiSaleContract storage self , VariablePriceContract storage priceContract , uint256 quantity , uint256 valueAttached ) internal view Purpose : Validate a token purchase against sale parameters. Parameters : - self : Storage reference to the multi-sale contract - priceContract : Variable price contract for pricing - quantity : Number of tokens to purchase - valueAttached : ETH value sent with transaction Validation Checks : - Sale not sold out (total quantity limit) - Quantity within min/max per sale limits - Sale has started (if start time set) - Sale has not ended (if end time set) - Sufficient payment value attached Example Usage : // Validate a purchase before processing MultiSaleLib . _validatePurchase ( saleContract , priceContract , 5 , // quantity msg.value ); _validateProof() \u00b6 function _validateProof ( MultiSaleContract storage self , MultiSalePurchase memory purchase , MultiSaleProof memory purchaseProof ) internal Purpose : Validate Merkle proof for whitelist-only sales. Parameters : - self : Storage reference to the multi-sale contract - purchase : Purchase details - purchaseProof : Merkle proof data Validation Process : 1. Check if sale is whitelist-only 2. Verify user hasn't already redeemed allocation 3. Construct leaf data with receiver and total allocation 4. Verify Merkle proof against whitelist root 5. Update redeemed quantities 6. Prevent replay attacks by tracking used leaves Security Features : - Prevents double-spending of whitelist allocations - Protects against replay attacks - Validates total allocation limits Example Usage : // Validate whitelist proof MultiSaleLib . MultiSalePurchase memory purchase = MultiSaleLib . MultiSalePurchase ({ multiSaleId : saleId , purchaser : msg.sender , receiver : msg.sender , quantity : 3 }); MultiSaleLib . MultiSaleProof memory proof = MultiSaleLib . MultiSaleProof ({ leaf : leafValue , total : 10 , // Total allocation merkleProof : merkleProofArray , data : \"\" }); MultiSaleLib . _validateProof ( saleContract , purchase , proof ); Purchase Processing \u00b6 _purchaseToken() (with proof) \u00b6 function _purchaseToken ( MultiSaleContract storage self , VariablePriceContract storage variablePrice , MultiSalePurchase memory purchase , MultiSaleProof memory purchaseProof , uint256 valueAttached ) internal Purpose : Process a token purchase with whitelist proof validation. Process Flow : 1. Validate purchase parameters 2. Validate Merkle proof (if whitelist-only) 3. Process payment and token transfer _purchaseToken() (without proof) \u00b6 function _purchaseToken ( MultiSaleContract storage self , VariablePriceContract storage variablePrice , MultiSalePurchase memory purchase , uint256 valueAttached ) internal Purpose : Process a token purchase without proof (public sale). Process Flow : 1. Validate purchase parameters 2. Process payment and token transfer Utility Functions \u00b6 _airdropRedeemed() \u00b6 function _airdropRedeemed ( MultiSaleContract storage self , address recipient ) internal view returns ( bool isRedeemed ) Purpose : Check if an address has fully redeemed their whitelist allocation. Parameters : - self : Storage reference to the multi-sale contract - recipient : Address to check Returns : Boolean indicating if allocation is fully redeemed Logic : - Compares total allocation with redeemed amount - Returns true if fully redeemed, false otherwise Integration Examples \u00b6 NFT Collection Sale \u00b6 // NFT collection sale with whitelist and public phases contract NFTCollectionSale { using MultiSaleLib for MultiSaleLib . MultiSaleStorage ; struct SalePhase { uint256 saleId ; string name ; bool isWhitelistPhase ; uint256 price ; uint256 maxPerWallet ; uint256 startTime ; uint256 endTime ; } mapping ( uint256 => SalePhase ) public salePhases ; uint256 public currentPhaseId ; event PhaseCreated ( uint256 indexed phaseId , string name , bool isWhitelist ); event TokensPurchased ( uint256 indexed phaseId , address indexed buyer , uint256 quantity ); function createWhitelistPhase ( string memory name , uint256 price , uint256 maxPerWallet , uint256 startTime , uint256 endTime , bytes32 merkleRoot ) external onlyOwner returns ( uint256 phaseId ) { phaseId = MultiSaleLib . _createTokenSale (); // Configure whitelist phase MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( phaseId ); sale . settings . name = name ; sale . settings . whitelistOnly = true ; sale . settings . whitelistHash = uint256 ( merkleRoot ); sale . settings . maxQuantityPerAccount = maxPerWallet ; sale . settings . startTime = startTime ; sale . settings . endTime = endTime ; sale . settings . paymentMethod = MultiSaleLib . PaymentMethod . Native ; // Set pricing sale . settings . price . price = price ; salePhases [ phaseId ] = SalePhase ({ saleId : phaseId , name : name , isWhitelistPhase : true , price : price , maxPerWallet : maxPerWallet , startTime : startTime , endTime : endTime }); currentPhaseId = phaseId ; emit PhaseCreated ( phaseId , name , true ); } function createPublicPhase ( string memory name , uint256 price , uint256 maxPerWallet , uint256 startTime , uint256 endTime ) external onlyOwner returns ( uint256 phaseId ) { phaseId = MultiSaleLib . _createTokenSale (); // Configure public phase MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( phaseId ); sale . settings . name = name ; sale . settings . whitelistOnly = false ; sale . settings . maxQuantityPerAccount = maxPerWallet ; sale . settings . startTime = startTime ; sale . settings . endTime = endTime ; sale . settings . paymentMethod = MultiSaleLib . PaymentMethod . Native ; // Set pricing sale . settings . price . price = price ; salePhases [ phaseId ] = SalePhase ({ saleId : phaseId , name : name , isWhitelistPhase : false , price : price , maxPerWallet : maxPerWallet , startTime : startTime , endTime : endTime }); emit PhaseCreated ( phaseId , name , false ); } function purchaseWhitelist ( uint256 phaseId , uint256 quantity , MultiSaleLib . MultiSaleProof memory proof ) external payable { MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( phaseId ); require ( sale . settings . whitelistOnly , \"Not a whitelist phase\" ); MultiSaleLib . MultiSalePurchase memory purchase = MultiSaleLib . MultiSalePurchase ({ multiSaleId : phaseId , purchaser : msg.sender , receiver : msg.sender , quantity : quantity }); MultiSaleLib . _purchaseToken ( sale , sale . settings . price , purchase , proof , msg.value ); // Mint NFTs to buyer _mintTokens ( msg.sender , quantity ); emit TokensPurchased ( phaseId , msg.sender , quantity ); } function purchasePublic ( uint256 phaseId , uint256 quantity ) external payable { MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( phaseId ); require ( ! sale . settings . whitelistOnly , \"Whitelist phase only\" ); MultiSaleLib . MultiSalePurchase memory purchase = MultiSaleLib . MultiSalePurchase ({ multiSaleId : phaseId , purchaser : msg.sender , receiver : msg.sender , quantity : quantity }); MultiSaleLib . _purchaseToken ( sale , sale . settings . price , purchase , msg.value ); // Mint NFTs to buyer _mintTokens ( msg.sender , quantity ); emit TokensPurchased ( phaseId , msg.sender , quantity ); } function getSaleContract ( uint256 saleId ) internal view returns ( MultiSaleLib . MultiSaleContract storage ) { // Implementation would access Diamond storage } function _mintTokens ( address to , uint256 quantity ) internal { // Implementation would mint NFTs } modifier onlyOwner () { // Implementation would check ownership _ ; } } Gaming Item Sale \u00b6 // Gaming item sale with ERC20 payments and tiered pricing contract GamingItemSale { using MultiSaleLib for MultiSaleLib . MultiSaleStorage ; struct ItemTier { string name ; uint256 basePrice ; uint256 maxSupply ; uint256 sold ; bool active ; } mapping ( uint256 => ItemTier ) public itemTiers ; mapping ( uint256 => uint256 ) public saleToTier ; IERC20 public gameToken ; event ItemTierCreated ( uint256 indexed tierId , string name , uint256 basePrice , uint256 maxSupply ); event ItemsPurchased ( uint256 indexed tierId , address indexed buyer , uint256 quantity , uint256 totalCost ); constructor ( address _gameToken ) { gameToken = IERC20 ( _gameToken ); } function createItemTier ( string memory name , uint256 basePrice , uint256 maxSupply , uint256 maxPerPurchase ) external onlyGameMaster returns ( uint256 tierId ) { tierId = MultiSaleLib . _createTokenSale (); // Configure item tier sale MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( tierId ); sale . settings . name = name ; sale . settings . paymentMethod = MultiSaleLib . PaymentMethod . ERC20 ; sale . settings . paymentToken = address ( gameToken ); sale . settings . maxQuantity = maxSupply ; sale . settings . maxQuantityPerSale = maxPerPurchase ; sale . settings . openState = true ; // Set pricing sale . settings . price . price = basePrice ; itemTiers [ tierId ] = ItemTier ({ name : name , basePrice : basePrice , maxSupply : maxSupply , sold : 0 , active : true }); saleToTier [ tierId ] = tierId ; emit ItemTierCreated ( tierId , name , basePrice , maxSupply ); } function purchaseItems ( uint256 tierId , uint256 quantity ) external { ItemTier storage tier = itemTiers [ tierId ]; require ( tier . active , \"Tier not active\" ); require ( tier . sold + quantity <= tier . maxSupply , \"Exceeds max supply\" ); MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( tierId ); MultiSaleLib . MultiSalePurchase memory purchase = MultiSaleLib . MultiSalePurchase ({ multiSaleId : tierId , purchaser : msg.sender , receiver : msg.sender , quantity : quantity }); // Calculate total cost uint256 totalCost = tier . basePrice * quantity ; // Transfer payment tokens gameToken . safeTransferFrom ( msg.sender , address ( this ), totalCost ); // Process purchase MultiSaleLib . _purchaseToken ( sale , sale . settings . price , purchase , 0 // No ETH value for ERC20 payments ); // Update tier tracking tier . sold += quantity ; // Mint game items _mintGameItems ( msg.sender , tierId , quantity ); emit ItemsPurchased ( tierId , msg.sender , quantity , totalCost ); } function getTierInfo ( uint256 tierId ) external view returns ( string memory name , uint256 basePrice , uint256 maxSupply , uint256 sold , uint256 remaining , bool active ) { ItemTier memory tier = itemTiers [ tierId ]; name = tier . name ; basePrice = tier . basePrice ; maxSupply = tier . maxSupply ; sold = tier . sold ; remaining = tier . maxSupply - tier . sold ; active = tier . active ; } function getSaleContract ( uint256 saleId ) internal view returns ( MultiSaleLib . MultiSaleContract storage ) { // Implementation would access Diamond storage } function _mintGameItems ( address to , uint256 tierId , uint256 quantity ) internal { // Implementation would mint game items } modifier onlyGameMaster () { // Implementation would check game master role _ ; } } Airdrop Distribution System \u00b6 // Airdrop distribution using Merkle proofs contract AirdropDistribution { using MultiSaleLib for MultiSaleLib . MultiSaleStorage ; struct AirdropCampaign { uint256 saleId ; string name ; bytes32 merkleRoot ; uint256 totalTokens ; uint256 claimedTokens ; uint256 startTime ; uint256 endTime ; bool active ; } mapping ( uint256 => AirdropCampaign ) public campaigns ; mapping ( uint256 => mapping ( address => bool )) public hasClaimed ; uint256 public nextCampaignId ; event CampaignCreated ( uint256 indexed campaignId , string name , bytes32 merkleRoot ); event TokensClaimed ( uint256 indexed campaignId , address indexed claimer , uint256 amount ); function createAirdropCampaign ( string memory name , bytes32 merkleRoot , uint256 totalTokens , uint256 startTime , uint256 endTime ) external onlyOwner returns ( uint256 campaignId ) { campaignId = nextCampaignId ++ ; uint256 saleId = MultiSaleLib . _createTokenSale (); // Configure airdrop as a zero-price sale MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( saleId ); sale . settings . name = name ; sale . settings . whitelistOnly = true ; sale . settings . whitelistHash = uint256 ( merkleRoot ); sale . settings . maxQuantity = totalTokens ; sale . settings . startTime = startTime ; sale . settings . endTime = endTime ; sale . settings . openState = true ; // Set price to zero for airdrop sale . settings . price . price = 0 ; campaigns [ campaignId ] = AirdropCampaign ({ saleId : saleId , name : name , merkleRoot : merkleRoot , totalTokens : totalTokens , claimedTokens : 0 , startTime : startTime , endTime : endTime , active : true }); emit CampaignCreated ( campaignId , name , merkleRoot ); } function claimAirdrop ( uint256 campaignId , uint256 amount , MultiSaleLib . MultiSaleProof memory proof ) external { AirdropCampaign storage campaign = campaigns [ campaignId ]; require ( campaign . active , \"Campaign not active\" ); require ( block.timestamp >= campaign . startTime , \"Campaign not started\" ); require ( block.timestamp <= campaign . endTime , \"Campaign ended\" ); require ( ! hasClaimed [ campaignId ][ msg.sender ], \"Already claimed\" ); MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( campaign . saleId ); MultiSaleLib . MultiSalePurchase memory purchase = MultiSaleLib . MultiSalePurchase ({ multiSaleId : campaign . saleId , purchaser : msg.sender , receiver : msg.sender , quantity : amount }); // Validate proof and process claim MultiSaleLib . _validateProof ( sale , purchase , proof ); // Update tracking campaign . claimedTokens += amount ; hasClaimed [ campaignId ][ msg.sender ] = true ; // Transfer tokens _transferAirdropTokens ( msg.sender , amount ); emit TokensClaimed ( campaignId , msg.sender , amount ); } function getCampaignStatus ( uint256 campaignId ) external view returns ( string memory name , uint256 totalTokens , uint256 claimedTokens , uint256 remainingTokens , bool active , bool hasStarted , bool hasEnded ) { AirdropCampaign memory campaign = campaigns [ campaignId ]; name = campaign . name ; totalTokens = campaign . totalTokens ; claimedTokens = campaign . claimedTokens ; remainingTokens = campaign . totalTokens - campaign . claimedTokens ; active = campaign . active ; hasStarted = block.timestamp >= campaign . startTime ; hasEnded = block.timestamp > campaign . endTime ; } function getUserClaimStatus ( uint256 campaignId , address user ) external view returns ( bool claimed , uint256 remainingAllocation ) { claimed = hasClaimed [ campaignId ][ user ]; if ( ! claimed ) { MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( campaigns [ campaignId ]. saleId ); uint256 totalAllocation = sale . _totalDataQuantities [ user ]; uint256 redeemedAmount = sale . _redeemedDataQuantities [ user ]; remainingAllocation = totalAllocation - redeemedAmount ; } } function getSaleContract ( uint256 saleId ) internal view returns ( MultiSaleLib . MultiSaleContract storage ) { // Implementation would access Diamond storage } function _transferAirdropTokens ( address to , uint256 amount ) internal { // Implementation would transfer tokens } modifier onlyOwner () { // Implementation would check ownership _ ; } } Events \u00b6 Multi-Sale Events \u00b6 event MultiSaleCreated ( uint256 indexed tokenSaleId , MultiSaleSettings settings ); event MultiSaleOpen ( uint256 indexed tokenSaleId , MultiSaleSettings tokenSale ); event MultiSaleClosed ( uint256 indexed tokenSaleId ); event MultiSaleSold ( uint256 indexed tokenSaleId , address indexed purchaser , uint256 [] tokenIds , bytes data ); event MultiSaleUpdated ( uint256 indexed tokenSaleId , MultiSaleSettings tokenSale ); Security Considerations \u00b6 Merkle Proof Security \u00b6 Prevents replay attacks by tracking used leaves Validates total allocation limits per address Secure leaf construction with address and allocation data Protection against proof manipulation Payment Security \u00b6 Safe ERC20 token transfers using SafeERC20 Validation of payment amounts before processing Support for both ETH and ERC20 payments Overflow protection in price calculations Access Control \u00b6 Whitelist validation through Merkle proofs Quantity limits per sale and per account Time-based sale controls Owner-only administrative functions Gas Optimization \u00b6 Storage Efficiency \u00b6 Efficient storage layout for sale data Minimal storage writes during purchases Optimized mapping structures for tracking Batch operations where possible Function Efficiency \u00b6 Internal functions for gas savings Efficient validation logic Minimal external calls Optimized Merkle proof verification Error Handling \u00b6 Common Errors \u00b6 \"soldout\" - Sale has reached maximum quantity \"qtytoolow\" / \"qtytoohigh\" - Quantity outside allowed range \"notstarted\" / \"saleended\" - Sale timing violations \"notenoughvalue\" - Insufficient payment \"redeemed\" - Allocation already claimed \"Merkle proof failed\" - Invalid whitelist proof Best Practices \u00b6 Validate all purchase parameters before processing Check Merkle proofs for whitelist sales Verify payment amounts and token transfers Handle edge cases gracefully Provide clear error messages for debugging Testing Considerations \u00b6 Unit Tests \u00b6 Sale creation and configuration Purchase validation logic Merkle proof verification Payment processing (ETH and ERC20) Quantity and timing controls Integration Tests \u00b6 Multi-phase sale workflows Whitelist and public sale combinations Cross-contract token transfers Airdrop distribution scenarios Gaming item sale mechanics Related Documentation \u00b6 IMultiSale Interface - Multi-sale interface definition MultiSaleFacet - Multi-sale facet implementation VariablePriceLib - Variable pricing utilities MerkleProver - Merkle proof verification utilities Token Sale Guide - Implementation guide for token sales This library provides comprehensive utilities for multi-token sales within the Gemforce platform, supporting flexible payment methods, whitelist management, and secure proof validation for various sale scenarios including NFT drops, gaming items, and airdrop distributions.","title":"Multi Sale Lib"},{"location":"smart-contracts/libraries/multi-sale-lib/#multisalelib-library","text":"","title":"MultiSaleLib Library"},{"location":"smart-contracts/libraries/multi-sale-lib/#overview","text":"The MultiSaleLib library provides core utilities and data structures for managing multi-token sales within the Gemforce platform. This library implements comprehensive token sale functionality including whitelist management, Merkle proof validation, variable pricing, and support for multiple payment methods (ETH and ERC20 tokens).","title":"Overview"},{"location":"smart-contracts/libraries/multi-sale-lib/#key-features","text":"Multi-Token Support : Support for ERC20, ERC721, and ERC1155 token sales Whitelist Management : Merkle tree-based whitelist with proof validation Variable Pricing : Dynamic pricing with configurable price structures Payment Flexibility : Support for ETH and ERC20 token payments Quantity Controls : Min/max quantity limits per sale and per account Time-Based Sales : Configurable start and end times for sales Proof Validation : Secure Merkle proof validation to prevent replay attacks","title":"Key Features"},{"location":"smart-contracts/libraries/multi-sale-lib/#library-definition","text":"// SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; library MultiSaleLib { using SafeERC20 for IERC20 ; // Core functions function _createTokenSale () internal returns ( uint256 tokenSaleId ); function _validatePurchase ( MultiSaleContract storage self , VariablePriceContract storage priceContract , uint256 quantity , uint256 valueAttached ) internal view ; function _validateProof ( MultiSaleContract storage self , MultiSalePurchase memory purchase , MultiSaleProof memory purchaseProof ) internal ; function _purchaseToken (...) internal ; function _airdropRedeemed ( MultiSaleContract storage self , address recipient ) internal view returns ( bool isRedeemed ); }","title":"Library Definition"},{"location":"smart-contracts/libraries/multi-sale-lib/#data-structures","text":"","title":"Data Structures"},{"location":"smart-contracts/libraries/multi-sale-lib/#paymenttype-enum","text":"enum PaymentType { Ether , // Payment with native ETH ERC20 // Payment with ERC20 tokens }","title":"PaymentType Enum"},{"location":"smart-contracts/libraries/multi-sale-lib/#paymentmethod-enum","text":"enum PaymentMethod { Native , // Payment with the native currency (e.g., ETH) ERC20 // Payment with an ERC20 token }","title":"PaymentMethod Enum"},{"location":"smart-contracts/libraries/multi-sale-lib/#multisalepurchase-struct","text":"struct MultiSalePurchase { uint256 multiSaleId ; // ID of the multi-sale address purchaser ; // Address making the purchase address receiver ; // Address receiving the tokens uint256 quantity ; // Quantity of tokens to purchase } Purpose : Represents a token purchase request with all necessary details.","title":"MultiSalePurchase Struct"},{"location":"smart-contracts/libraries/multi-sale-lib/#multisaleproof-struct","text":"struct MultiSaleProof { uint256 leaf ; // Leaf value for Merkle proof uint256 total ; // Total allocation for the address bytes32 [] merkleProof ; // Merkle proof array bytes data ; // Additional proof data } Purpose : Contains Merkle proof data for whitelist validation.","title":"MultiSaleProof Struct"},{"location":"smart-contracts/libraries/multi-sale-lib/#multisalesettings-struct","text":"struct MultiSaleSettings { TokenType tokenType ; // Type of token being sold address token ; // Token contract address uint256 tokenHash ; // Token hash (0 for auto-creation) uint256 whitelistHash ; // Merkle root for whitelist bool whitelistOnly ; // Whether sale is whitelist-only PaymentMethod paymentMethod ; // Payment method (Native/ERC20) address paymentToken ; // ERC20 token address for payments address owner ; // Owner of the sale address payee ; // Recipient of sale proceeds string symbol ; // Token symbol string name ; // Token name string description ; // Token description bool openState ; // Whether sale is open uint256 startTime ; // Sale start timestamp uint256 endTime ; // Sale end timestamp uint256 maxQuantity ; // Maximum total tokens for sale uint256 maxQuantityPerSale ; // Maximum tokens per transaction uint256 minQuantityPerSale ; // Minimum tokens per transaction uint256 maxQuantityPerAccount ; // Maximum tokens per account PaymentType paymentType ; // Legacy payment type address tokenAddress ; // Legacy token address uint256 nextSaleId ; // Next sale ID counter VariablePriceContract price ; // Variable pricing configuration } Purpose : Comprehensive configuration for a multi-token sale.","title":"MultiSaleSettings Struct"},{"location":"smart-contracts/libraries/multi-sale-lib/#multisalecontract-struct","text":"struct MultiSaleContract { MultiSaleSettings settings ; // Sale configuration uint256 nonce ; // Nonce for unique operations uint256 totalPurchased ; // Total tokens purchased mapping ( address => uint256 ) purchased ; // Tokens purchased per address mapping ( uint256 => uint256 ) _redeemedData ; // Redeemed data tracking mapping ( address => uint256 ) _redeemedDataQuantities ; // Redeemed quantities per address mapping ( address => uint256 ) _totalDataQuantities ; // Total allocations per address mapping ( address => uint256 ) _accountQuantities ; // Account quantity tracking } Purpose : Complete state management for a multi-token sale.","title":"MultiSaleContract Struct"},{"location":"smart-contracts/libraries/multi-sale-lib/#multisalestorage-struct","text":"struct MultiSaleStorage { uint256 tsnonce ; // Token sale nonce mapping ( uint256 => MultiSaleContract ) _tokenSales ; // All token sales uint256 [] _tokenSaleIds ; // Array of sale IDs } Purpose : Diamond storage structure for all multi-sale data.","title":"MultiSaleStorage Struct"},{"location":"smart-contracts/libraries/multi-sale-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/multi-sale-lib/#sale-creation","text":"","title":"Sale Creation"},{"location":"smart-contracts/libraries/multi-sale-lib/#_createtokensale","text":"function _createTokenSale () internal returns ( uint256 tokenSaleId ) Purpose : Generate a unique token sale ID for a new sale. Returns : Unique token sale identifier Implementation : - Uses keccak256 hash of nonce and contract address - Increments global nonce to ensure uniqueness - Returns deterministic but unique sale ID Example Usage : // Create a new token sale uint256 saleId = MultiSaleLib . _createTokenSale (); console . log ( \"Created token sale with ID:\" , saleId );","title":"_createTokenSale()"},{"location":"smart-contracts/libraries/multi-sale-lib/#purchase-validation","text":"","title":"Purchase Validation"},{"location":"smart-contracts/libraries/multi-sale-lib/#_validatepurchase","text":"function _validatePurchase ( MultiSaleContract storage self , VariablePriceContract storage priceContract , uint256 quantity , uint256 valueAttached ) internal view Purpose : Validate a token purchase against sale parameters. Parameters : - self : Storage reference to the multi-sale contract - priceContract : Variable price contract for pricing - quantity : Number of tokens to purchase - valueAttached : ETH value sent with transaction Validation Checks : - Sale not sold out (total quantity limit) - Quantity within min/max per sale limits - Sale has started (if start time set) - Sale has not ended (if end time set) - Sufficient payment value attached Example Usage : // Validate a purchase before processing MultiSaleLib . _validatePurchase ( saleContract , priceContract , 5 , // quantity msg.value );","title":"_validatePurchase()"},{"location":"smart-contracts/libraries/multi-sale-lib/#_validateproof","text":"function _validateProof ( MultiSaleContract storage self , MultiSalePurchase memory purchase , MultiSaleProof memory purchaseProof ) internal Purpose : Validate Merkle proof for whitelist-only sales. Parameters : - self : Storage reference to the multi-sale contract - purchase : Purchase details - purchaseProof : Merkle proof data Validation Process : 1. Check if sale is whitelist-only 2. Verify user hasn't already redeemed allocation 3. Construct leaf data with receiver and total allocation 4. Verify Merkle proof against whitelist root 5. Update redeemed quantities 6. Prevent replay attacks by tracking used leaves Security Features : - Prevents double-spending of whitelist allocations - Protects against replay attacks - Validates total allocation limits Example Usage : // Validate whitelist proof MultiSaleLib . MultiSalePurchase memory purchase = MultiSaleLib . MultiSalePurchase ({ multiSaleId : saleId , purchaser : msg.sender , receiver : msg.sender , quantity : 3 }); MultiSaleLib . MultiSaleProof memory proof = MultiSaleLib . MultiSaleProof ({ leaf : leafValue , total : 10 , // Total allocation merkleProof : merkleProofArray , data : \"\" }); MultiSaleLib . _validateProof ( saleContract , purchase , proof );","title":"_validateProof()"},{"location":"smart-contracts/libraries/multi-sale-lib/#purchase-processing","text":"","title":"Purchase Processing"},{"location":"smart-contracts/libraries/multi-sale-lib/#_purchasetoken-with-proof","text":"function _purchaseToken ( MultiSaleContract storage self , VariablePriceContract storage variablePrice , MultiSalePurchase memory purchase , MultiSaleProof memory purchaseProof , uint256 valueAttached ) internal Purpose : Process a token purchase with whitelist proof validation. Process Flow : 1. Validate purchase parameters 2. Validate Merkle proof (if whitelist-only) 3. Process payment and token transfer","title":"_purchaseToken() (with proof)"},{"location":"smart-contracts/libraries/multi-sale-lib/#_purchasetoken-without-proof","text":"function _purchaseToken ( MultiSaleContract storage self , VariablePriceContract storage variablePrice , MultiSalePurchase memory purchase , uint256 valueAttached ) internal Purpose : Process a token purchase without proof (public sale). Process Flow : 1. Validate purchase parameters 2. Process payment and token transfer","title":"_purchaseToken() (without proof)"},{"location":"smart-contracts/libraries/multi-sale-lib/#utility-functions","text":"","title":"Utility Functions"},{"location":"smart-contracts/libraries/multi-sale-lib/#_airdropredeemed","text":"function _airdropRedeemed ( MultiSaleContract storage self , address recipient ) internal view returns ( bool isRedeemed ) Purpose : Check if an address has fully redeemed their whitelist allocation. Parameters : - self : Storage reference to the multi-sale contract - recipient : Address to check Returns : Boolean indicating if allocation is fully redeemed Logic : - Compares total allocation with redeemed amount - Returns true if fully redeemed, false otherwise","title":"_airdropRedeemed()"},{"location":"smart-contracts/libraries/multi-sale-lib/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/libraries/multi-sale-lib/#nft-collection-sale","text":"// NFT collection sale with whitelist and public phases contract NFTCollectionSale { using MultiSaleLib for MultiSaleLib . MultiSaleStorage ; struct SalePhase { uint256 saleId ; string name ; bool isWhitelistPhase ; uint256 price ; uint256 maxPerWallet ; uint256 startTime ; uint256 endTime ; } mapping ( uint256 => SalePhase ) public salePhases ; uint256 public currentPhaseId ; event PhaseCreated ( uint256 indexed phaseId , string name , bool isWhitelist ); event TokensPurchased ( uint256 indexed phaseId , address indexed buyer , uint256 quantity ); function createWhitelistPhase ( string memory name , uint256 price , uint256 maxPerWallet , uint256 startTime , uint256 endTime , bytes32 merkleRoot ) external onlyOwner returns ( uint256 phaseId ) { phaseId = MultiSaleLib . _createTokenSale (); // Configure whitelist phase MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( phaseId ); sale . settings . name = name ; sale . settings . whitelistOnly = true ; sale . settings . whitelistHash = uint256 ( merkleRoot ); sale . settings . maxQuantityPerAccount = maxPerWallet ; sale . settings . startTime = startTime ; sale . settings . endTime = endTime ; sale . settings . paymentMethod = MultiSaleLib . PaymentMethod . Native ; // Set pricing sale . settings . price . price = price ; salePhases [ phaseId ] = SalePhase ({ saleId : phaseId , name : name , isWhitelistPhase : true , price : price , maxPerWallet : maxPerWallet , startTime : startTime , endTime : endTime }); currentPhaseId = phaseId ; emit PhaseCreated ( phaseId , name , true ); } function createPublicPhase ( string memory name , uint256 price , uint256 maxPerWallet , uint256 startTime , uint256 endTime ) external onlyOwner returns ( uint256 phaseId ) { phaseId = MultiSaleLib . _createTokenSale (); // Configure public phase MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( phaseId ); sale . settings . name = name ; sale . settings . whitelistOnly = false ; sale . settings . maxQuantityPerAccount = maxPerWallet ; sale . settings . startTime = startTime ; sale . settings . endTime = endTime ; sale . settings . paymentMethod = MultiSaleLib . PaymentMethod . Native ; // Set pricing sale . settings . price . price = price ; salePhases [ phaseId ] = SalePhase ({ saleId : phaseId , name : name , isWhitelistPhase : false , price : price , maxPerWallet : maxPerWallet , startTime : startTime , endTime : endTime }); emit PhaseCreated ( phaseId , name , false ); } function purchaseWhitelist ( uint256 phaseId , uint256 quantity , MultiSaleLib . MultiSaleProof memory proof ) external payable { MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( phaseId ); require ( sale . settings . whitelistOnly , \"Not a whitelist phase\" ); MultiSaleLib . MultiSalePurchase memory purchase = MultiSaleLib . MultiSalePurchase ({ multiSaleId : phaseId , purchaser : msg.sender , receiver : msg.sender , quantity : quantity }); MultiSaleLib . _purchaseToken ( sale , sale . settings . price , purchase , proof , msg.value ); // Mint NFTs to buyer _mintTokens ( msg.sender , quantity ); emit TokensPurchased ( phaseId , msg.sender , quantity ); } function purchasePublic ( uint256 phaseId , uint256 quantity ) external payable { MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( phaseId ); require ( ! sale . settings . whitelistOnly , \"Whitelist phase only\" ); MultiSaleLib . MultiSalePurchase memory purchase = MultiSaleLib . MultiSalePurchase ({ multiSaleId : phaseId , purchaser : msg.sender , receiver : msg.sender , quantity : quantity }); MultiSaleLib . _purchaseToken ( sale , sale . settings . price , purchase , msg.value ); // Mint NFTs to buyer _mintTokens ( msg.sender , quantity ); emit TokensPurchased ( phaseId , msg.sender , quantity ); } function getSaleContract ( uint256 saleId ) internal view returns ( MultiSaleLib . MultiSaleContract storage ) { // Implementation would access Diamond storage } function _mintTokens ( address to , uint256 quantity ) internal { // Implementation would mint NFTs } modifier onlyOwner () { // Implementation would check ownership _ ; } }","title":"NFT Collection Sale"},{"location":"smart-contracts/libraries/multi-sale-lib/#gaming-item-sale","text":"// Gaming item sale with ERC20 payments and tiered pricing contract GamingItemSale { using MultiSaleLib for MultiSaleLib . MultiSaleStorage ; struct ItemTier { string name ; uint256 basePrice ; uint256 maxSupply ; uint256 sold ; bool active ; } mapping ( uint256 => ItemTier ) public itemTiers ; mapping ( uint256 => uint256 ) public saleToTier ; IERC20 public gameToken ; event ItemTierCreated ( uint256 indexed tierId , string name , uint256 basePrice , uint256 maxSupply ); event ItemsPurchased ( uint256 indexed tierId , address indexed buyer , uint256 quantity , uint256 totalCost ); constructor ( address _gameToken ) { gameToken = IERC20 ( _gameToken ); } function createItemTier ( string memory name , uint256 basePrice , uint256 maxSupply , uint256 maxPerPurchase ) external onlyGameMaster returns ( uint256 tierId ) { tierId = MultiSaleLib . _createTokenSale (); // Configure item tier sale MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( tierId ); sale . settings . name = name ; sale . settings . paymentMethod = MultiSaleLib . PaymentMethod . ERC20 ; sale . settings . paymentToken = address ( gameToken ); sale . settings . maxQuantity = maxSupply ; sale . settings . maxQuantityPerSale = maxPerPurchase ; sale . settings . openState = true ; // Set pricing sale . settings . price . price = basePrice ; itemTiers [ tierId ] = ItemTier ({ name : name , basePrice : basePrice , maxSupply : maxSupply , sold : 0 , active : true }); saleToTier [ tierId ] = tierId ; emit ItemTierCreated ( tierId , name , basePrice , maxSupply ); } function purchaseItems ( uint256 tierId , uint256 quantity ) external { ItemTier storage tier = itemTiers [ tierId ]; require ( tier . active , \"Tier not active\" ); require ( tier . sold + quantity <= tier . maxSupply , \"Exceeds max supply\" ); MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( tierId ); MultiSaleLib . MultiSalePurchase memory purchase = MultiSaleLib . MultiSalePurchase ({ multiSaleId : tierId , purchaser : msg.sender , receiver : msg.sender , quantity : quantity }); // Calculate total cost uint256 totalCost = tier . basePrice * quantity ; // Transfer payment tokens gameToken . safeTransferFrom ( msg.sender , address ( this ), totalCost ); // Process purchase MultiSaleLib . _purchaseToken ( sale , sale . settings . price , purchase , 0 // No ETH value for ERC20 payments ); // Update tier tracking tier . sold += quantity ; // Mint game items _mintGameItems ( msg.sender , tierId , quantity ); emit ItemsPurchased ( tierId , msg.sender , quantity , totalCost ); } function getTierInfo ( uint256 tierId ) external view returns ( string memory name , uint256 basePrice , uint256 maxSupply , uint256 sold , uint256 remaining , bool active ) { ItemTier memory tier = itemTiers [ tierId ]; name = tier . name ; basePrice = tier . basePrice ; maxSupply = tier . maxSupply ; sold = tier . sold ; remaining = tier . maxSupply - tier . sold ; active = tier . active ; } function getSaleContract ( uint256 saleId ) internal view returns ( MultiSaleLib . MultiSaleContract storage ) { // Implementation would access Diamond storage } function _mintGameItems ( address to , uint256 tierId , uint256 quantity ) internal { // Implementation would mint game items } modifier onlyGameMaster () { // Implementation would check game master role _ ; } }","title":"Gaming Item Sale"},{"location":"smart-contracts/libraries/multi-sale-lib/#airdrop-distribution-system","text":"// Airdrop distribution using Merkle proofs contract AirdropDistribution { using MultiSaleLib for MultiSaleLib . MultiSaleStorage ; struct AirdropCampaign { uint256 saleId ; string name ; bytes32 merkleRoot ; uint256 totalTokens ; uint256 claimedTokens ; uint256 startTime ; uint256 endTime ; bool active ; } mapping ( uint256 => AirdropCampaign ) public campaigns ; mapping ( uint256 => mapping ( address => bool )) public hasClaimed ; uint256 public nextCampaignId ; event CampaignCreated ( uint256 indexed campaignId , string name , bytes32 merkleRoot ); event TokensClaimed ( uint256 indexed campaignId , address indexed claimer , uint256 amount ); function createAirdropCampaign ( string memory name , bytes32 merkleRoot , uint256 totalTokens , uint256 startTime , uint256 endTime ) external onlyOwner returns ( uint256 campaignId ) { campaignId = nextCampaignId ++ ; uint256 saleId = MultiSaleLib . _createTokenSale (); // Configure airdrop as a zero-price sale MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( saleId ); sale . settings . name = name ; sale . settings . whitelistOnly = true ; sale . settings . whitelistHash = uint256 ( merkleRoot ); sale . settings . maxQuantity = totalTokens ; sale . settings . startTime = startTime ; sale . settings . endTime = endTime ; sale . settings . openState = true ; // Set price to zero for airdrop sale . settings . price . price = 0 ; campaigns [ campaignId ] = AirdropCampaign ({ saleId : saleId , name : name , merkleRoot : merkleRoot , totalTokens : totalTokens , claimedTokens : 0 , startTime : startTime , endTime : endTime , active : true }); emit CampaignCreated ( campaignId , name , merkleRoot ); } function claimAirdrop ( uint256 campaignId , uint256 amount , MultiSaleLib . MultiSaleProof memory proof ) external { AirdropCampaign storage campaign = campaigns [ campaignId ]; require ( campaign . active , \"Campaign not active\" ); require ( block.timestamp >= campaign . startTime , \"Campaign not started\" ); require ( block.timestamp <= campaign . endTime , \"Campaign ended\" ); require ( ! hasClaimed [ campaignId ][ msg.sender ], \"Already claimed\" ); MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( campaign . saleId ); MultiSaleLib . MultiSalePurchase memory purchase = MultiSaleLib . MultiSalePurchase ({ multiSaleId : campaign . saleId , purchaser : msg.sender , receiver : msg.sender , quantity : amount }); // Validate proof and process claim MultiSaleLib . _validateProof ( sale , purchase , proof ); // Update tracking campaign . claimedTokens += amount ; hasClaimed [ campaignId ][ msg.sender ] = true ; // Transfer tokens _transferAirdropTokens ( msg.sender , amount ); emit TokensClaimed ( campaignId , msg.sender , amount ); } function getCampaignStatus ( uint256 campaignId ) external view returns ( string memory name , uint256 totalTokens , uint256 claimedTokens , uint256 remainingTokens , bool active , bool hasStarted , bool hasEnded ) { AirdropCampaign memory campaign = campaigns [ campaignId ]; name = campaign . name ; totalTokens = campaign . totalTokens ; claimedTokens = campaign . claimedTokens ; remainingTokens = campaign . totalTokens - campaign . claimedTokens ; active = campaign . active ; hasStarted = block.timestamp >= campaign . startTime ; hasEnded = block.timestamp > campaign . endTime ; } function getUserClaimStatus ( uint256 campaignId , address user ) external view returns ( bool claimed , uint256 remainingAllocation ) { claimed = hasClaimed [ campaignId ][ user ]; if ( ! claimed ) { MultiSaleLib . MultiSaleContract storage sale = getSaleContract ( campaigns [ campaignId ]. saleId ); uint256 totalAllocation = sale . _totalDataQuantities [ user ]; uint256 redeemedAmount = sale . _redeemedDataQuantities [ user ]; remainingAllocation = totalAllocation - redeemedAmount ; } } function getSaleContract ( uint256 saleId ) internal view returns ( MultiSaleLib . MultiSaleContract storage ) { // Implementation would access Diamond storage } function _transferAirdropTokens ( address to , uint256 amount ) internal { // Implementation would transfer tokens } modifier onlyOwner () { // Implementation would check ownership _ ; } }","title":"Airdrop Distribution System"},{"location":"smart-contracts/libraries/multi-sale-lib/#events","text":"","title":"Events"},{"location":"smart-contracts/libraries/multi-sale-lib/#multi-sale-events","text":"event MultiSaleCreated ( uint256 indexed tokenSaleId , MultiSaleSettings settings ); event MultiSaleOpen ( uint256 indexed tokenSaleId , MultiSaleSettings tokenSale ); event MultiSaleClosed ( uint256 indexed tokenSaleId ); event MultiSaleSold ( uint256 indexed tokenSaleId , address indexed purchaser , uint256 [] tokenIds , bytes data ); event MultiSaleUpdated ( uint256 indexed tokenSaleId , MultiSaleSettings tokenSale );","title":"Multi-Sale Events"},{"location":"smart-contracts/libraries/multi-sale-lib/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/multi-sale-lib/#merkle-proof-security","text":"Prevents replay attacks by tracking used leaves Validates total allocation limits per address Secure leaf construction with address and allocation data Protection against proof manipulation","title":"Merkle Proof Security"},{"location":"smart-contracts/libraries/multi-sale-lib/#payment-security","text":"Safe ERC20 token transfers using SafeERC20 Validation of payment amounts before processing Support for both ETH and ERC20 payments Overflow protection in price calculations","title":"Payment Security"},{"location":"smart-contracts/libraries/multi-sale-lib/#access-control","text":"Whitelist validation through Merkle proofs Quantity limits per sale and per account Time-based sale controls Owner-only administrative functions","title":"Access Control"},{"location":"smart-contracts/libraries/multi-sale-lib/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/libraries/multi-sale-lib/#storage-efficiency","text":"Efficient storage layout for sale data Minimal storage writes during purchases Optimized mapping structures for tracking Batch operations where possible","title":"Storage Efficiency"},{"location":"smart-contracts/libraries/multi-sale-lib/#function-efficiency","text":"Internal functions for gas savings Efficient validation logic Minimal external calls Optimized Merkle proof verification","title":"Function Efficiency"},{"location":"smart-contracts/libraries/multi-sale-lib/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/libraries/multi-sale-lib/#common-errors","text":"\"soldout\" - Sale has reached maximum quantity \"qtytoolow\" / \"qtytoohigh\" - Quantity outside allowed range \"notstarted\" / \"saleended\" - Sale timing violations \"notenoughvalue\" - Insufficient payment \"redeemed\" - Allocation already claimed \"Merkle proof failed\" - Invalid whitelist proof","title":"Common Errors"},{"location":"smart-contracts/libraries/multi-sale-lib/#best-practices","text":"Validate all purchase parameters before processing Check Merkle proofs for whitelist sales Verify payment amounts and token transfers Handle edge cases gracefully Provide clear error messages for debugging","title":"Best Practices"},{"location":"smart-contracts/libraries/multi-sale-lib/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/libraries/multi-sale-lib/#unit-tests","text":"Sale creation and configuration Purchase validation logic Merkle proof verification Payment processing (ETH and ERC20) Quantity and timing controls","title":"Unit Tests"},{"location":"smart-contracts/libraries/multi-sale-lib/#integration-tests","text":"Multi-phase sale workflows Whitelist and public sale combinations Cross-contract token transfers Airdrop distribution scenarios Gaming item sale mechanics","title":"Integration Tests"},{"location":"smart-contracts/libraries/multi-sale-lib/#related-documentation","text":"IMultiSale Interface - Multi-sale interface definition MultiSaleFacet - Multi-sale facet implementation VariablePriceLib - Variable pricing utilities MerkleProver - Merkle proof verification utilities Token Sale Guide - Implementation guide for token sales This library provides comprehensive utilities for multi-token sales within the Gemforce platform, supporting flexible payment methods, whitelist management, and secure proof validation for various sale scenarios including NFT drops, gaming items, and airdrop distributions.","title":"Related Documentation"},{"location":"smart-contracts/libraries/set-libraries/","text":"Set Libraries (AddressSet, Bytes32Set, UInt256Set) \u00b6 Overview \u00b6 The Gemforce platform includes three specialized set libraries that provide efficient, gas-optimized data structures for managing unique collections of different data types. These libraries implement unordered sets with O(1) operations for insertion, deletion, and existence checks, making them ideal for managing collections where uniqueness and fast lookups are required. Libraries Included \u00b6 AddressSet - Set of Ethereum addresses Bytes32Set - Set of bytes32 values UInt256Set - Set of uint256 values Key Features \u00b6 O(1) Operations : All operations (insert, remove, exists) have constant time complexity Enumeration Support : Iterate through set members by index Uniqueness Enforcement : Duplicate values are automatically prevented Gas Optimized : Efficient storage patterns minimize gas costs Swap-and-Pop Deletion : Maintains array compactness without shifting elements Type Safety : Separate libraries for different data types ensure type safety Common Architecture \u00b6 All three set libraries follow the same architectural pattern: Storage Structure \u00b6 struct Set { mapping ( T => uint256 ) keyPointers ; // T = address, bytes32, or uint256 T [] keyList ; } Components: - keyPointers : Maps each key to its position in the keyList array - keyList : Dynamic array containing all set members for enumeration Design Pattern \u00b6 The libraries use a bidirectional mapping pattern: 1. Key \u2192 Index : keyPointers mapping provides O(1) existence checks and position lookup 2. Index \u2192 Key : keyList array enables enumeration and direct access by index Core Functions \u00b6 All three libraries implement the same interface with type-specific parameters: insert(Set storage self, T key) \u00b6 Adds a new key to the set. Parameters: - self : Storage pointer to the Set - key : Value to insert (address, bytes32, or uint256) Requirements: - Key must not already exist in the set - Reverts with error message if duplicate key is inserted Gas Cost: ~20,000-25,000 gas Example: AddressSet . Set storage addresses ; AddressSet . insert ( addresses , 0x1234567890123456789012345678901234567890 ); remove(Set storage self, T key) \u00b6 Removes a key from the set using swap-and-pop optimization. Parameters: - self : Storage pointer to the Set - key : Value to remove Algorithm: 1. Check if key exists (returns early if not) 2. Get position of key to remove 3. If not the last element, swap with last element 4. Update pointer for moved element 5. Delete key pointer and pop last element Gas Cost: ~15,000-20,000 gas Example: UInt256Set . remove ( tokenIds , 12345 ); exists(Set storage self, T key) \u00b6 Checks if a key exists in the set. Parameters: - self : Storage pointer to the Set - key : Value to check Returns: - true if key exists, false otherwise Gas Cost: ~500-1,000 gas Algorithm: if ( self . keyList . length == 0 ) return false ; return self . keyList [ self . keyPointers [ key ]] == key ; count(Set storage self) \u00b6 Returns the number of elements in the set. Returns: - Number of elements in the set Gas Cost: ~200-300 gas keyAtIndex(Set storage self, uint256 index) \u00b6 Retrieves a key by its index position. Parameters: - index : Position in the set (0-based) Returns: - Key at the specified index Requirements: - Index must be less than count() Gas Cost: ~300-500 gas Usage Examples \u00b6 AddressSet - Managing Whitelisted Addresses \u00b6 import { AddressSet } from \"./libraries/AddressSet.sol\" ; contract Whitelist { using AddressSet for AddressSet . Set ; AddressSet . Set private whitelistedAddresses ; function addToWhitelist ( address user ) external onlyOwner { whitelistedAddresses . insert ( user ); } function removeFromWhitelist ( address user ) external onlyOwner { whitelistedAddresses . remove ( user ); } function isWhitelisted ( address user ) external view returns ( bool ) { return whitelistedAddresses . exists ( user ); } function getWhitelistSize () external view returns ( uint256 ) { return whitelistedAddresses . count (); } function getWhitelistedAddress ( uint256 index ) external view returns ( address ) { return whitelistedAddresses . keyAtIndex ( index ); } } Bytes32Set - Managing Content Hashes \u00b6 import { Bytes32Set } from \"./libraries/Bytes32Set.sol\" ; contract ContentRegistry { using Bytes32Set for Bytes32Set . Set ; Bytes32Set . Set private contentHashes ; function registerContent ( bytes32 contentHash ) external { require ( ! contentHashes . exists ( contentHash ), \"Content already registered\" ); contentHashes . insert ( contentHash ); } function removeContent ( bytes32 contentHash ) external onlyOwner { contentHashes . remove ( contentHash ); } function isContentRegistered ( bytes32 contentHash ) external view returns ( bool ) { return contentHashes . exists ( contentHash ); } function getAllContentHashes () external view returns ( bytes32 [] memory ) { uint256 length = contentHashes . count (); bytes32 [] memory hashes = new bytes32 []( length ); for ( uint256 i = 0 ; i < length ; i ++ ) { hashes [ i ] = contentHashes . keyAtIndex ( i ); } return hashes ; } } UInt256Set - Managing Token Collections \u00b6 import { UInt256Set } from \"./libraries/UInt256Set.sol\" ; contract TokenCollection { using UInt256Set for UInt256Set . Set ; mapping ( address => UInt256Set . Set ) private userTokens ; function addTokenToUser ( address user , uint256 tokenId ) external { userTokens [ user ]. insert ( tokenId ); } function removeTokenFromUser ( address user , uint256 tokenId ) external { userTokens [ user ]. remove ( tokenId ); } function userOwnsToken ( address user , uint256 tokenId ) external view returns ( bool ) { return userTokens [ user ]. exists ( tokenId ); } function getUserTokenCount ( address user ) external view returns ( uint256 ) { return userTokens [ user ]. count (); } function getUserTokenAtIndex ( address user , uint256 index ) external view returns ( uint256 ) { return userTokens [ user ]. keyAtIndex ( index ); } function getUserTokens ( address user ) external view returns ( uint256 [] memory ) { UInt256Set . Set storage tokens = userTokens [ user ]; uint256 length = tokens . count (); uint256 [] memory tokenIds = new uint256 []( length ); for ( uint256 i = 0 ; i < length ; i ++ ) { tokenIds [ i ] = tokens . keyAtIndex ( i ); } return tokenIds ; } } Advanced Usage Patterns \u00b6 Set Operations \u00b6 // Union of two sets function unionSets ( UInt256Set . Set storage setA , UInt256Set . Set storage setB ) internal view returns ( uint256 [] memory ) { UInt256Set . Set memory result ; // Add all elements from setA for ( uint256 i = 0 ; i < setA . count (); i ++ ) { uint256 element = setA . keyAtIndex ( i ); if ( ! result . exists ( element )) { result . insert ( element ); } } // Add all elements from setB for ( uint256 i = 0 ; i < setB . count (); i ++ ) { uint256 element = setB . keyAtIndex ( i ); if ( ! result . exists ( element )) { result . insert ( element ); } } // Convert to array uint256 [] memory unionArray = new uint256 []( result . count ()); for ( uint256 i = 0 ; i < result . count (); i ++ ) { unionArray [ i ] = result . keyAtIndex ( i ); } return unionArray ; } Batch Operations \u00b6 function batchInsert ( AddressSet . Set storage set , address [] calldata addresses ) external { for ( uint256 i = 0 ; i < addresses . length ; i ++ ) { if ( ! set . exists ( addresses [ i ])) { set . insert ( addresses [ i ]); } } } function batchRemove ( AddressSet . Set storage set , address [] calldata addresses ) external { for ( uint256 i = 0 ; i < addresses . length ; i ++ ) { if ( set . exists ( addresses [ i ])) { set . remove ( addresses [ i ]); } } } Performance Characteristics \u00b6 Time Complexity \u00b6 Insert : O(1) - Constant time regardless of set size Remove : O(1) - Swap-and-pop maintains constant time Exists : O(1) - Direct mapping lookup Count : O(1) - Array length property KeyAtIndex : O(1) - Direct array access Enumeration : O(n) - Linear in set size Gas Costs (Approximate) \u00b6 Operation Cold Storage Warm Storage Insert 22,000-25,000 5,000-8,000 Remove 15,000-20,000 3,000-5,000 Exists 800-2,100 100-800 Count 200-400 100-200 KeyAtIndex 300-800 100-300 Storage Costs \u00b6 Per Element : 2 storage slots (1 for mapping, 1 for array) Set Overhead : Minimal (just array length) Memory Efficiency : Compact storage with no gaps Security Considerations \u00b6 Input Validation \u00b6 Duplicate Prevention : All libraries prevent duplicate insertions Existence Checks : Remove operations handle non-existent keys gracefully Index Bounds : KeyAtIndex should validate index bounds in calling code Gas Limit Considerations \u00b6 Large Sets : Enumeration operations may hit gas limits for very large sets Batch Operations : Consider gas limits when processing multiple elements State Changes : Multiple insertions/removals in single transaction Best Practices \u00b6 // Always check bounds when enumerating function safeKeyAtIndex ( UInt256Set . Set storage set , uint256 index ) internal view returns ( uint256 ) { require ( index < set . count (), \"Index out of bounds\" ); return set . keyAtIndex ( index ); } // Use exists() before remove() for safety function safeRemove ( AddressSet . Set storage set , address key ) internal { if ( set . exists ( key )) { set . remove ( key ); } } // Paginate large enumerations function getPaginatedKeys ( UInt256Set . Set storage set , uint256 offset , uint256 limit ) internal view returns ( uint256 [] memory ) { uint256 total = set . count (); require ( offset < total , \"Offset out of bounds\" ); uint256 end = offset + limit ; if ( end > total ) { end = total ; } uint256 [] memory keys = new uint256 []( end - offset ); for ( uint256 i = offset ; i < end ; i ++ ) { keys [ i - offset ] = set . keyAtIndex ( i ); } return keys ; } Integration with Diamond Pattern \u00b6 // Storage struct for diamond pattern struct SetStorage { AddressSet . Set admins ; UInt256Set . Set activeTokens ; Bytes32Set . Set validHashes ; } // Storage position bytes32 constant SET_STORAGE_POSITION = keccak256 ( \"diamond.gemforce.set.storage\" ); function setStorage () internal pure returns ( SetStorage storage ds ) { bytes32 position = SET_STORAGE_POSITION ; assembly { ds . slot := position } } Migration and Upgrades \u00b6 Data Migration \u00b6 Sets maintain their structure across upgrades New elements can be added without affecting existing data Consider gas costs when migrating large sets Version Compatibility \u00b6 Libraries are backward compatible Storage layout remains consistent Function signatures are stable Related Documentation \u00b6 Diamond Library - Diamond pattern integration Attribute Library - Token attribute management Multi-Sale Library - Sale management with sets Fee Distributor Library - Revenue sharing with address sets Author Attribution \u00b6 These set libraries are based on the work of Rob Hitchens , providing efficient and gas-optimized set implementations for Solidity smart contracts.","title":"Set Libraries"},{"location":"smart-contracts/libraries/set-libraries/#set-libraries-addressset-bytes32set-uint256set","text":"","title":"Set Libraries (AddressSet, Bytes32Set, UInt256Set)"},{"location":"smart-contracts/libraries/set-libraries/#overview","text":"The Gemforce platform includes three specialized set libraries that provide efficient, gas-optimized data structures for managing unique collections of different data types. These libraries implement unordered sets with O(1) operations for insertion, deletion, and existence checks, making them ideal for managing collections where uniqueness and fast lookups are required.","title":"Overview"},{"location":"smart-contracts/libraries/set-libraries/#libraries-included","text":"AddressSet - Set of Ethereum addresses Bytes32Set - Set of bytes32 values UInt256Set - Set of uint256 values","title":"Libraries Included"},{"location":"smart-contracts/libraries/set-libraries/#key-features","text":"O(1) Operations : All operations (insert, remove, exists) have constant time complexity Enumeration Support : Iterate through set members by index Uniqueness Enforcement : Duplicate values are automatically prevented Gas Optimized : Efficient storage patterns minimize gas costs Swap-and-Pop Deletion : Maintains array compactness without shifting elements Type Safety : Separate libraries for different data types ensure type safety","title":"Key Features"},{"location":"smart-contracts/libraries/set-libraries/#common-architecture","text":"All three set libraries follow the same architectural pattern:","title":"Common Architecture"},{"location":"smart-contracts/libraries/set-libraries/#storage-structure","text":"struct Set { mapping ( T => uint256 ) keyPointers ; // T = address, bytes32, or uint256 T [] keyList ; } Components: - keyPointers : Maps each key to its position in the keyList array - keyList : Dynamic array containing all set members for enumeration","title":"Storage Structure"},{"location":"smart-contracts/libraries/set-libraries/#design-pattern","text":"The libraries use a bidirectional mapping pattern: 1. Key \u2192 Index : keyPointers mapping provides O(1) existence checks and position lookup 2. Index \u2192 Key : keyList array enables enumeration and direct access by index","title":"Design Pattern"},{"location":"smart-contracts/libraries/set-libraries/#core-functions","text":"All three libraries implement the same interface with type-specific parameters:","title":"Core Functions"},{"location":"smart-contracts/libraries/set-libraries/#insertset-storage-self-t-key","text":"Adds a new key to the set. Parameters: - self : Storage pointer to the Set - key : Value to insert (address, bytes32, or uint256) Requirements: - Key must not already exist in the set - Reverts with error message if duplicate key is inserted Gas Cost: ~20,000-25,000 gas Example: AddressSet . Set storage addresses ; AddressSet . insert ( addresses , 0x1234567890123456789012345678901234567890 );","title":"insert(Set storage self, T key)"},{"location":"smart-contracts/libraries/set-libraries/#removeset-storage-self-t-key","text":"Removes a key from the set using swap-and-pop optimization. Parameters: - self : Storage pointer to the Set - key : Value to remove Algorithm: 1. Check if key exists (returns early if not) 2. Get position of key to remove 3. If not the last element, swap with last element 4. Update pointer for moved element 5. Delete key pointer and pop last element Gas Cost: ~15,000-20,000 gas Example: UInt256Set . remove ( tokenIds , 12345 );","title":"remove(Set storage self, T key)"},{"location":"smart-contracts/libraries/set-libraries/#existsset-storage-self-t-key","text":"Checks if a key exists in the set. Parameters: - self : Storage pointer to the Set - key : Value to check Returns: - true if key exists, false otherwise Gas Cost: ~500-1,000 gas Algorithm: if ( self . keyList . length == 0 ) return false ; return self . keyList [ self . keyPointers [ key ]] == key ;","title":"exists(Set storage self, T key)"},{"location":"smart-contracts/libraries/set-libraries/#countset-storage-self","text":"Returns the number of elements in the set. Returns: - Number of elements in the set Gas Cost: ~200-300 gas","title":"count(Set storage self)"},{"location":"smart-contracts/libraries/set-libraries/#keyatindexset-storage-self-uint256-index","text":"Retrieves a key by its index position. Parameters: - index : Position in the set (0-based) Returns: - Key at the specified index Requirements: - Index must be less than count() Gas Cost: ~300-500 gas","title":"keyAtIndex(Set storage self, uint256 index)"},{"location":"smart-contracts/libraries/set-libraries/#usage-examples","text":"","title":"Usage Examples"},{"location":"smart-contracts/libraries/set-libraries/#addressset-managing-whitelisted-addresses","text":"import { AddressSet } from \"./libraries/AddressSet.sol\" ; contract Whitelist { using AddressSet for AddressSet . Set ; AddressSet . Set private whitelistedAddresses ; function addToWhitelist ( address user ) external onlyOwner { whitelistedAddresses . insert ( user ); } function removeFromWhitelist ( address user ) external onlyOwner { whitelistedAddresses . remove ( user ); } function isWhitelisted ( address user ) external view returns ( bool ) { return whitelistedAddresses . exists ( user ); } function getWhitelistSize () external view returns ( uint256 ) { return whitelistedAddresses . count (); } function getWhitelistedAddress ( uint256 index ) external view returns ( address ) { return whitelistedAddresses . keyAtIndex ( index ); } }","title":"AddressSet - Managing Whitelisted Addresses"},{"location":"smart-contracts/libraries/set-libraries/#bytes32set-managing-content-hashes","text":"import { Bytes32Set } from \"./libraries/Bytes32Set.sol\" ; contract ContentRegistry { using Bytes32Set for Bytes32Set . Set ; Bytes32Set . Set private contentHashes ; function registerContent ( bytes32 contentHash ) external { require ( ! contentHashes . exists ( contentHash ), \"Content already registered\" ); contentHashes . insert ( contentHash ); } function removeContent ( bytes32 contentHash ) external onlyOwner { contentHashes . remove ( contentHash ); } function isContentRegistered ( bytes32 contentHash ) external view returns ( bool ) { return contentHashes . exists ( contentHash ); } function getAllContentHashes () external view returns ( bytes32 [] memory ) { uint256 length = contentHashes . count (); bytes32 [] memory hashes = new bytes32 []( length ); for ( uint256 i = 0 ; i < length ; i ++ ) { hashes [ i ] = contentHashes . keyAtIndex ( i ); } return hashes ; } }","title":"Bytes32Set - Managing Content Hashes"},{"location":"smart-contracts/libraries/set-libraries/#uint256set-managing-token-collections","text":"import { UInt256Set } from \"./libraries/UInt256Set.sol\" ; contract TokenCollection { using UInt256Set for UInt256Set . Set ; mapping ( address => UInt256Set . Set ) private userTokens ; function addTokenToUser ( address user , uint256 tokenId ) external { userTokens [ user ]. insert ( tokenId ); } function removeTokenFromUser ( address user , uint256 tokenId ) external { userTokens [ user ]. remove ( tokenId ); } function userOwnsToken ( address user , uint256 tokenId ) external view returns ( bool ) { return userTokens [ user ]. exists ( tokenId ); } function getUserTokenCount ( address user ) external view returns ( uint256 ) { return userTokens [ user ]. count (); } function getUserTokenAtIndex ( address user , uint256 index ) external view returns ( uint256 ) { return userTokens [ user ]. keyAtIndex ( index ); } function getUserTokens ( address user ) external view returns ( uint256 [] memory ) { UInt256Set . Set storage tokens = userTokens [ user ]; uint256 length = tokens . count (); uint256 [] memory tokenIds = new uint256 []( length ); for ( uint256 i = 0 ; i < length ; i ++ ) { tokenIds [ i ] = tokens . keyAtIndex ( i ); } return tokenIds ; } }","title":"UInt256Set - Managing Token Collections"},{"location":"smart-contracts/libraries/set-libraries/#advanced-usage-patterns","text":"","title":"Advanced Usage Patterns"},{"location":"smart-contracts/libraries/set-libraries/#set-operations","text":"// Union of two sets function unionSets ( UInt256Set . Set storage setA , UInt256Set . Set storage setB ) internal view returns ( uint256 [] memory ) { UInt256Set . Set memory result ; // Add all elements from setA for ( uint256 i = 0 ; i < setA . count (); i ++ ) { uint256 element = setA . keyAtIndex ( i ); if ( ! result . exists ( element )) { result . insert ( element ); } } // Add all elements from setB for ( uint256 i = 0 ; i < setB . count (); i ++ ) { uint256 element = setB . keyAtIndex ( i ); if ( ! result . exists ( element )) { result . insert ( element ); } } // Convert to array uint256 [] memory unionArray = new uint256 []( result . count ()); for ( uint256 i = 0 ; i < result . count (); i ++ ) { unionArray [ i ] = result . keyAtIndex ( i ); } return unionArray ; }","title":"Set Operations"},{"location":"smart-contracts/libraries/set-libraries/#batch-operations","text":"function batchInsert ( AddressSet . Set storage set , address [] calldata addresses ) external { for ( uint256 i = 0 ; i < addresses . length ; i ++ ) { if ( ! set . exists ( addresses [ i ])) { set . insert ( addresses [ i ]); } } } function batchRemove ( AddressSet . Set storage set , address [] calldata addresses ) external { for ( uint256 i = 0 ; i < addresses . length ; i ++ ) { if ( set . exists ( addresses [ i ])) { set . remove ( addresses [ i ]); } } }","title":"Batch Operations"},{"location":"smart-contracts/libraries/set-libraries/#performance-characteristics","text":"","title":"Performance Characteristics"},{"location":"smart-contracts/libraries/set-libraries/#time-complexity","text":"Insert : O(1) - Constant time regardless of set size Remove : O(1) - Swap-and-pop maintains constant time Exists : O(1) - Direct mapping lookup Count : O(1) - Array length property KeyAtIndex : O(1) - Direct array access Enumeration : O(n) - Linear in set size","title":"Time Complexity"},{"location":"smart-contracts/libraries/set-libraries/#gas-costs-approximate","text":"Operation Cold Storage Warm Storage Insert 22,000-25,000 5,000-8,000 Remove 15,000-20,000 3,000-5,000 Exists 800-2,100 100-800 Count 200-400 100-200 KeyAtIndex 300-800 100-300","title":"Gas Costs (Approximate)"},{"location":"smart-contracts/libraries/set-libraries/#storage-costs","text":"Per Element : 2 storage slots (1 for mapping, 1 for array) Set Overhead : Minimal (just array length) Memory Efficiency : Compact storage with no gaps","title":"Storage Costs"},{"location":"smart-contracts/libraries/set-libraries/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/set-libraries/#input-validation","text":"Duplicate Prevention : All libraries prevent duplicate insertions Existence Checks : Remove operations handle non-existent keys gracefully Index Bounds : KeyAtIndex should validate index bounds in calling code","title":"Input Validation"},{"location":"smart-contracts/libraries/set-libraries/#gas-limit-considerations","text":"Large Sets : Enumeration operations may hit gas limits for very large sets Batch Operations : Consider gas limits when processing multiple elements State Changes : Multiple insertions/removals in single transaction","title":"Gas Limit Considerations"},{"location":"smart-contracts/libraries/set-libraries/#best-practices","text":"// Always check bounds when enumerating function safeKeyAtIndex ( UInt256Set . Set storage set , uint256 index ) internal view returns ( uint256 ) { require ( index < set . count (), \"Index out of bounds\" ); return set . keyAtIndex ( index ); } // Use exists() before remove() for safety function safeRemove ( AddressSet . Set storage set , address key ) internal { if ( set . exists ( key )) { set . remove ( key ); } } // Paginate large enumerations function getPaginatedKeys ( UInt256Set . Set storage set , uint256 offset , uint256 limit ) internal view returns ( uint256 [] memory ) { uint256 total = set . count (); require ( offset < total , \"Offset out of bounds\" ); uint256 end = offset + limit ; if ( end > total ) { end = total ; } uint256 [] memory keys = new uint256 []( end - offset ); for ( uint256 i = offset ; i < end ; i ++ ) { keys [ i - offset ] = set . keyAtIndex ( i ); } return keys ; }","title":"Best Practices"},{"location":"smart-contracts/libraries/set-libraries/#integration-with-diamond-pattern","text":"// Storage struct for diamond pattern struct SetStorage { AddressSet . Set admins ; UInt256Set . Set activeTokens ; Bytes32Set . Set validHashes ; } // Storage position bytes32 constant SET_STORAGE_POSITION = keccak256 ( \"diamond.gemforce.set.storage\" ); function setStorage () internal pure returns ( SetStorage storage ds ) { bytes32 position = SET_STORAGE_POSITION ; assembly { ds . slot := position } }","title":"Integration with Diamond Pattern"},{"location":"smart-contracts/libraries/set-libraries/#migration-and-upgrades","text":"","title":"Migration and Upgrades"},{"location":"smart-contracts/libraries/set-libraries/#data-migration","text":"Sets maintain their structure across upgrades New elements can be added without affecting existing data Consider gas costs when migrating large sets","title":"Data Migration"},{"location":"smart-contracts/libraries/set-libraries/#version-compatibility","text":"Libraries are backward compatible Storage layout remains consistent Function signatures are stable","title":"Version Compatibility"},{"location":"smart-contracts/libraries/set-libraries/#related-documentation","text":"Diamond Library - Diamond pattern integration Attribute Library - Token attribute management Multi-Sale Library - Sale management with sets Fee Distributor Library - Revenue sharing with address sets","title":"Related Documentation"},{"location":"smart-contracts/libraries/set-libraries/#author-attribution","text":"These set libraries are based on the work of Rob Hitchens , providing efficient and gas-optimized set implementations for Solidity smart contracts.","title":"Author Attribution"},{"location":"smart-contracts/libraries/strings-lib/","text":"StringsLib Library \u00b6 The StringsLib library provides common utility functions for string manipulation within Solidity smart contracts. While Solidity has limited built-in string capabilities, this library extends its functionality, enabling operations such as string conversion, concatenation, and more, which are essential for handling metadata, logging, and human-readable data on-chain. Overview \u00b6 StringsLib provides: String Conversion : Convert various data types (integers, addresses) into their string representations. String Manipulation : Basic operations like concatenation and substring handling. Utility Functions : Helper functions for handling string data. Key Features \u00b6 Type-to-String Conversion \u00b6 toString(uint256) : Convert unsigned integers to strings. toHexString(uint256) : Convert unsigned integers to hexadecimal string representations. toHexString(address) : Convert addresses to hexadecimal string representations. String Concatenation \u00b6 Provide efficient ways to combine multiple strings. Hashing and Comparison \u00b6 Though not explicit in all StringsLib implementations, good string libraries often include keccak256 hashing and byte-based comparison. Library Definition \u00b6 library StringsLib { // Convert a uint256 to its string representation function toString ( uint256 value ) internal pure returns ( string memory ) { if ( value == 0 ) { return \"0\" ; } uint256 temp = value ; uint256 digits ; while ( temp != 0 ) { digits ++ ; temp /= 10 ; } bytes memory buffer = new bytes ( digits ); while ( value != 0 ) { digits -- ; buffer [ digits ] = bytes1 ( uint8 ( 48 + uint256 ( value % 10 ))); value /= 10 ; } return string ( buffer ); } // Convert a bytes32 to its string representation (hexadecimal) function toHexString ( bytes32 value ) internal pure returns ( string memory ) { bytes memory alphabet = \"0123456789abcdef\" ; bytes memory str = new bytes ( 64 ); for ( uint256 i = 0 ; i < 32 ; i ++ ) { str [ i * 2 ] = alphabet [ uint8 ( value [ i ] >> 4 )]; str [ i * 2 + 1 ] = alphabet [ uint8 ( value [ i ] & 0x0f )]; } return string ( str ); } // Convert address to its string representation (hexadecimal) function toHexString ( address value ) internal pure returns ( string memory ) { bytes memory alphabet = \"0123456789abcdef\" ; bytes memory str = new bytes ( 40 ); uint256 temp = uint256 ( value ); for ( uint256 i = 0 ; i < 20 ; i ++ ) { str [ 39 - i * 2 ] = alphabet [ uint8 ( temp & 0x0f )]; temp >>= 4 ; str [ 38 - i * 2 ] = alphabet [ uint8 ( temp & 0x0f )]; temp >>= 4 ; } return string ( str ); } // Convert bytes to their string representation (hexadecimal) function toHexString ( bytes memory value ) internal pure returns ( string memory ) { bytes memory alphabet = \"0123456789abcdef\" ; bytes memory str = new bytes ( value . length * 2 ); for ( uint256 i = 0 ; i < value . length ; i ++ ) { str [ i * 2 ] = alphabet [ uint8 ( value [ i ] >> 4 )]; str [ i * 2 + 1 ] = alphabet [ uint8 ( value [ i ] & 0x0f )]; } return string ( str ); } // Concatenate two strings function concat ( string memory a , string memory b ) internal pure returns ( string memory ) { return string ( abi . encodePacked ( a , b )); } // Concatenate three strings function concat ( string memory a , string memory b , string memory c ) internal pure returns ( string memory ) { return string ( abi . encodePacked ( a , b , c )); } // Concatenate four strings function concat ( string memory a , string memory b , string memory c , string memory d ) internal pure returns ( string memory ) { return string ( abi . encodePacked ( a , b , c , d )); } // Concatenate five strings function concat ( string memory a , string memory b , string memory c , string memory d , string memory e ) internal pure returns ( string memory ) { return string ( abi . encodePacked ( a , b , c , d , e )); } } Core Functions \u00b6 toString(uint256 value) \u00b6 Converts a uint256 integer to its decimal string representation. This is commonly used for generating human-readable token IDs or amounts in metadata. Parameters: - value : The uint256 integer to convert. Returns: - string : The decimal string representation of the integer. Usage: uint256 tokenId = 12345 ; string memory tokenIdStr = StringsLib . toString ( tokenId ); // \"12345\" toHexString(address value) \u00b6 Converts an address into its hexadecimal string representation without the \"0x\" prefix. This is useful for including addresses directly into URIs or other data fields. Parameters: - value : The address to convert. Returns: - string : The hexadecimal string representation of the address (e.g., \"abcdef1234567890abcdef1234567890abcdef12\"). Usage: address ownerAddress = 0x742d35Cc6634C0539Ff34f . . .; string memory ownerAddrHex = StringsLib . toHexString ( ownerAddress ); concat(string a, string b) \u00b6 Concatenates two strings into a single string. Overloaded versions allow concatenating up to five strings. Parameters: - a , b , ...: The strings to concatenate. Returns: - string : The combined string. Usage: string memory prefix = \"https://example.com/nft/\" ; uint256 tokenId = 99 ; string memory suffix = \".json\" ; string memory uri = StringsLib . concat ( prefix , StringsLib . toString ( tokenId ), suffix ); // \"https://example.com/nft/99.json\" Security Considerations \u00b6 Gas Costs \u00b6 String Manipulation : String operations in Solidity, especially concatenation and conversions, are very gas-expensive. This is due to the dynamic memory allocation and copying involved. Use these functions judiciously and preferably for off-chain metadata generation or infrequent on-chain operations. Memory Limits : Be mindful of the maximum string length you intend to generate. Extremely long strings can hit block gas limits. Data Encoding/Decoding \u00b6 ABI Encoding : The concat functions rely on abi.encodePacked . While generally safe for concatenating primitive types that are already strings, be aware of how abi.encodePacked handles different types if you were to extend this library with more complex concatenations (e.g., it packs tightly without padding). Best Practices \u00b6 Off-chain Handling \u00b6 Prefer Off-chain : For complex string formatting, especially for NFT metadata URIs or extensive logging, perform string operations off-chain and then upload the final string (or its hash/URI) to the blockchain. IPFS for Metadata : Store large metadata strings (like SVG content or detailed JSON) on IPFS and only store the IPFS CID on-chain. Concatenation Efficiency \u00b6 Reduce Calls : When concatenating multiple strings, use the overloaded concat function with more arguments (e.g., concat(a, b, c) ) instead of chaining binary concatenations ( concat(a, concat(b, c)) ) to potentially save gas. Integration Examples \u00b6 Smart Contract Usage \u00b6 import \"../libraries/StringsLib.sol\" ; // Adjust path as needed contract MyNFTMetadata { using StringsLib for uint256 ; using StringsLib for address ; using StringsLib for string ; // For concat string public baseURI = \"ipfs://QmbP123abcDEF/\" ; string public constant JSON_SUFFIX = \".json\" ; function tokenURI ( uint256 tokenId ) public view returns ( string memory ) { return StringsLib . concat ( baseURI , tokenId . toString (), JSON_SUFFIX ); } function createLogEntry ( address user , uint256 amount ) public view returns ( string memory ) { string memory userHex = user . toHexString (); string memory amountStr = amount . toString (); return StringsLib . concat ( \"User \" , userHex , \" minted \" , amountStr , \" tokens.\" ); } } Related Documentation \u00b6 Solidity ABI Encoding and Decoding Gemforce Minter Facet (uses StringsLib for URIs) SVG Templates Library (can use StringsLib for SVG composition)","title":"Strings Lib"},{"location":"smart-contracts/libraries/strings-lib/#stringslib-library","text":"The StringsLib library provides common utility functions for string manipulation within Solidity smart contracts. While Solidity has limited built-in string capabilities, this library extends its functionality, enabling operations such as string conversion, concatenation, and more, which are essential for handling metadata, logging, and human-readable data on-chain.","title":"StringsLib Library"},{"location":"smart-contracts/libraries/strings-lib/#overview","text":"StringsLib provides: String Conversion : Convert various data types (integers, addresses) into their string representations. String Manipulation : Basic operations like concatenation and substring handling. Utility Functions : Helper functions for handling string data.","title":"Overview"},{"location":"smart-contracts/libraries/strings-lib/#key-features","text":"","title":"Key Features"},{"location":"smart-contracts/libraries/strings-lib/#type-to-string-conversion","text":"toString(uint256) : Convert unsigned integers to strings. toHexString(uint256) : Convert unsigned integers to hexadecimal string representations. toHexString(address) : Convert addresses to hexadecimal string representations.","title":"Type-to-String Conversion"},{"location":"smart-contracts/libraries/strings-lib/#string-concatenation","text":"Provide efficient ways to combine multiple strings.","title":"String Concatenation"},{"location":"smart-contracts/libraries/strings-lib/#hashing-and-comparison","text":"Though not explicit in all StringsLib implementations, good string libraries often include keccak256 hashing and byte-based comparison.","title":"Hashing and Comparison"},{"location":"smart-contracts/libraries/strings-lib/#library-definition","text":"library StringsLib { // Convert a uint256 to its string representation function toString ( uint256 value ) internal pure returns ( string memory ) { if ( value == 0 ) { return \"0\" ; } uint256 temp = value ; uint256 digits ; while ( temp != 0 ) { digits ++ ; temp /= 10 ; } bytes memory buffer = new bytes ( digits ); while ( value != 0 ) { digits -- ; buffer [ digits ] = bytes1 ( uint8 ( 48 + uint256 ( value % 10 ))); value /= 10 ; } return string ( buffer ); } // Convert a bytes32 to its string representation (hexadecimal) function toHexString ( bytes32 value ) internal pure returns ( string memory ) { bytes memory alphabet = \"0123456789abcdef\" ; bytes memory str = new bytes ( 64 ); for ( uint256 i = 0 ; i < 32 ; i ++ ) { str [ i * 2 ] = alphabet [ uint8 ( value [ i ] >> 4 )]; str [ i * 2 + 1 ] = alphabet [ uint8 ( value [ i ] & 0x0f )]; } return string ( str ); } // Convert address to its string representation (hexadecimal) function toHexString ( address value ) internal pure returns ( string memory ) { bytes memory alphabet = \"0123456789abcdef\" ; bytes memory str = new bytes ( 40 ); uint256 temp = uint256 ( value ); for ( uint256 i = 0 ; i < 20 ; i ++ ) { str [ 39 - i * 2 ] = alphabet [ uint8 ( temp & 0x0f )]; temp >>= 4 ; str [ 38 - i * 2 ] = alphabet [ uint8 ( temp & 0x0f )]; temp >>= 4 ; } return string ( str ); } // Convert bytes to their string representation (hexadecimal) function toHexString ( bytes memory value ) internal pure returns ( string memory ) { bytes memory alphabet = \"0123456789abcdef\" ; bytes memory str = new bytes ( value . length * 2 ); for ( uint256 i = 0 ; i < value . length ; i ++ ) { str [ i * 2 ] = alphabet [ uint8 ( value [ i ] >> 4 )]; str [ i * 2 + 1 ] = alphabet [ uint8 ( value [ i ] & 0x0f )]; } return string ( str ); } // Concatenate two strings function concat ( string memory a , string memory b ) internal pure returns ( string memory ) { return string ( abi . encodePacked ( a , b )); } // Concatenate three strings function concat ( string memory a , string memory b , string memory c ) internal pure returns ( string memory ) { return string ( abi . encodePacked ( a , b , c )); } // Concatenate four strings function concat ( string memory a , string memory b , string memory c , string memory d ) internal pure returns ( string memory ) { return string ( abi . encodePacked ( a , b , c , d )); } // Concatenate five strings function concat ( string memory a , string memory b , string memory c , string memory d , string memory e ) internal pure returns ( string memory ) { return string ( abi . encodePacked ( a , b , c , d , e )); } }","title":"Library Definition"},{"location":"smart-contracts/libraries/strings-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/strings-lib/#tostringuint256-value","text":"Converts a uint256 integer to its decimal string representation. This is commonly used for generating human-readable token IDs or amounts in metadata. Parameters: - value : The uint256 integer to convert. Returns: - string : The decimal string representation of the integer. Usage: uint256 tokenId = 12345 ; string memory tokenIdStr = StringsLib . toString ( tokenId ); // \"12345\"","title":"toString(uint256 value)"},{"location":"smart-contracts/libraries/strings-lib/#tohexstringaddress-value","text":"Converts an address into its hexadecimal string representation without the \"0x\" prefix. This is useful for including addresses directly into URIs or other data fields. Parameters: - value : The address to convert. Returns: - string : The hexadecimal string representation of the address (e.g., \"abcdef1234567890abcdef1234567890abcdef12\"). Usage: address ownerAddress = 0x742d35Cc6634C0539Ff34f . . .; string memory ownerAddrHex = StringsLib . toHexString ( ownerAddress );","title":"toHexString(address value)"},{"location":"smart-contracts/libraries/strings-lib/#concatstring-a-string-b","text":"Concatenates two strings into a single string. Overloaded versions allow concatenating up to five strings. Parameters: - a , b , ...: The strings to concatenate. Returns: - string : The combined string. Usage: string memory prefix = \"https://example.com/nft/\" ; uint256 tokenId = 99 ; string memory suffix = \".json\" ; string memory uri = StringsLib . concat ( prefix , StringsLib . toString ( tokenId ), suffix ); // \"https://example.com/nft/99.json\"","title":"concat(string a, string b)"},{"location":"smart-contracts/libraries/strings-lib/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/strings-lib/#gas-costs","text":"String Manipulation : String operations in Solidity, especially concatenation and conversions, are very gas-expensive. This is due to the dynamic memory allocation and copying involved. Use these functions judiciously and preferably for off-chain metadata generation or infrequent on-chain operations. Memory Limits : Be mindful of the maximum string length you intend to generate. Extremely long strings can hit block gas limits.","title":"Gas Costs"},{"location":"smart-contracts/libraries/strings-lib/#data-encodingdecoding","text":"ABI Encoding : The concat functions rely on abi.encodePacked . While generally safe for concatenating primitive types that are already strings, be aware of how abi.encodePacked handles different types if you were to extend this library with more complex concatenations (e.g., it packs tightly without padding).","title":"Data Encoding/Decoding"},{"location":"smart-contracts/libraries/strings-lib/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/libraries/strings-lib/#off-chain-handling","text":"Prefer Off-chain : For complex string formatting, especially for NFT metadata URIs or extensive logging, perform string operations off-chain and then upload the final string (or its hash/URI) to the blockchain. IPFS for Metadata : Store large metadata strings (like SVG content or detailed JSON) on IPFS and only store the IPFS CID on-chain.","title":"Off-chain Handling"},{"location":"smart-contracts/libraries/strings-lib/#concatenation-efficiency","text":"Reduce Calls : When concatenating multiple strings, use the overloaded concat function with more arguments (e.g., concat(a, b, c) ) instead of chaining binary concatenations ( concat(a, concat(b, c)) ) to potentially save gas.","title":"Concatenation Efficiency"},{"location":"smart-contracts/libraries/strings-lib/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/libraries/strings-lib/#smart-contract-usage","text":"import \"../libraries/StringsLib.sol\" ; // Adjust path as needed contract MyNFTMetadata { using StringsLib for uint256 ; using StringsLib for address ; using StringsLib for string ; // For concat string public baseURI = \"ipfs://QmbP123abcDEF/\" ; string public constant JSON_SUFFIX = \".json\" ; function tokenURI ( uint256 tokenId ) public view returns ( string memory ) { return StringsLib . concat ( baseURI , tokenId . toString (), JSON_SUFFIX ); } function createLogEntry ( address user , uint256 amount ) public view returns ( string memory ) { string memory userHex = user . toHexString (); string memory amountStr = amount . toString (); return StringsLib . concat ( \"User \" , userHex , \" minted \" , amountStr , \" tokens.\" ); } }","title":"Smart Contract Usage"},{"location":"smart-contracts/libraries/strings-lib/#related-documentation","text":"Solidity ABI Encoding and Decoding Gemforce Minter Facet (uses StringsLib for URIs) SVG Templates Library (can use StringsLib for SVG composition)","title":"Related Documentation"},{"location":"smart-contracts/libraries/svg-templates-lib/","text":"SVGTemplatesLib Library \u00b6 Overview \u00b6 The SVGTemplatesLib library provides core utilities for creating and managing on-chain SVG templates within the Gemforce platform. This library enables dynamic generation of SVG graphics for NFT metadata, supporting template-based rendering with variable substitution and multi-part composition. Key Features \u00b6 On-Chain SVG Storage : Store SVG templates directly on the blockchain Deterministic Deployment : CREATE2-based template contract deployment Template Management : Named template registry with unique addressing Dynamic Rendering : Variable substitution for customizable graphics Multi-Part Support : Composition of complex SVG graphics from components Ownership Transfer : Template ownership management for creators Library Definition \u00b6 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.6 ; library SVGTemplatesLib { // Storage management function svgStorage () internal pure returns ( SVGStorage storage ); // Template management function _svgs ( SVGTemplatesContract storage self ) internal view returns ( string [] memory ); function _svgAddress ( SVGTemplatesContract storage , string memory _name ) internal view returns ( address ); function _svgString ( SVGTemplatesContract storage self , string memory _name ) internal view returns ( string memory ); function _svgData ( SVGTemplatesContract storage self , string memory _name ) internal view returns ( address ); // Template creation function _createSVG ( SVGTemplatesContract storage self , address sender , string memory _name ) internal returns ( address ); } Data Structures \u00b6 SVGTemplatesContract Struct \u00b6 struct SVGTemplatesContract { mapping ( string => address ) _templates ; // Template name to contract address mapping string [] _templateNames ; // Array of all template names } Purpose : Core storage structure for managing SVG template contracts. Components : - _templates : Maps template names to deployed contract addresses - _templateNames : Maintains ordered list of all template names SaltStorage Struct \u00b6 struct SaltStorage { uint256 salt ; // Salt for CREATE2 operations } Purpose : Storage for CREATE2 salt values to ensure deterministic addressing. MultiPartContract Struct \u00b6 struct MultiPartContract { string name_ ; // Name of the multi-part template bytes [] data_ ; // Array of SVG component data } Purpose : Storage structure for multi-part SVG compositions. SVGStorage Struct \u00b6 struct SVGStorage { SVGTemplatesContract svgTemplates ; // Main template storage SaltStorage salt ; // CREATE2 salt storage address svgManager ; // SVG manager contract address MultiPartContract multiPart ; // Multi-part template storage } Purpose : Complete Diamond storage structure for SVG functionality. Storage Position : bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nextblock.bitgem.app.SVGStorage.storage\" ); Replacement Struct \u00b6 struct Replacement { string matchString ; // String to find in template string replaceString ; // String to replace with } Purpose : Variable substitution data for dynamic SVG rendering. Core Functions \u00b6 Storage Management \u00b6 svgStorage() \u00b6 function svgStorage () internal pure returns ( SVGStorage storage ds ) Purpose : Access Diamond storage for SVG template data using assembly. Implementation : function svgStorage () internal pure returns ( SVGStorage storage ds ) { bytes32 position = DIAMOND_STORAGE_POSITION ; assembly { ds . slot := position } } Returns : Storage reference to SVG template data Usage : All SVG functions use this to access persistent storage. Template Management \u00b6 _svgs() \u00b6 function _svgs ( SVGTemplatesContract storage self ) internal view returns ( string [] memory ) Purpose : Retrieve all template names stored in the contract. Parameters : - self : Storage reference to SVG templates contract Returns : Array of all template names Example Usage : // Get all available template names string [] memory templateNames = SVGTemplatesLib . _svgs ( svgTemplates ); console . log ( \"Available templates:\" , templateNames . length ); _svgAddress() \u00b6 function _svgAddress ( SVGTemplatesContract storage , string memory _name ) internal view returns ( address ) Purpose : Calculate the deterministic address for a template contract. Parameters : - _name : Name of the template Implementation : return Create2 . computeAddress ( keccak256 ( abi . encodePacked ( _name )), keccak256 ( type ( SVGTemplate ). creationCode ) ); Returns : Predicted contract address for the named template Benefits : - Enables address prediction before deployment - Supports deterministic template addressing - Allows for efficient template lookup _svgString() \u00b6 function _svgString ( SVGTemplatesContract storage self , string memory _name ) internal view returns ( string memory data_ ) Purpose : Retrieve the SVG string content from a deployed template. Parameters : - self : Storage reference to SVG templates contract - _name : Name of the template Implementation : try SVGTemplate ( _svgAddress ( self , _name )). svgString () returns ( string memory _data ) { data_ = _data ; } catch ( bytes memory ) {} Returns : SVG string content or empty string if template doesn't exist Error Handling : Uses try-catch to gracefully handle non-existent templates Example Usage : // Get SVG content for rendering string memory svgContent = SVGTemplatesLib . _svgString ( svgTemplates , \"avatar_base\" ); if ( bytes ( svgContent ). length > 0 ) { // Process SVG content } _svgData() \u00b6 function _svgData ( SVGTemplatesContract storage self , string memory _name ) internal view returns ( address ) Purpose : Get the stored contract address for a named template. Parameters : - self : Storage reference to SVG templates contract - _name : Name of the template Returns : Contract address of the template or zero address if not found Example Usage : // Check if template exists address templateAddress = SVGTemplatesLib . _svgData ( svgTemplates , \"background\" ); require ( templateAddress != address ( 0 ), \"Template not found\" ); Template Creation \u00b6 _createSVG() \u00b6 function _createSVG ( SVGTemplatesContract storage self , address sender , string memory _name ) internal returns ( address _tplAddress ) Purpose : Deploy a new SVG template contract with deterministic addressing. Parameters : - self : Storage reference to SVG templates contract - sender : Address that will own the template - _name : Unique name for the template Process : 1. Verify template name is unique 2. Calculate target address using CREATE2 3. Deploy template contract with deterministic salt 4. Verify deployment address matches prediction 5. Transfer ownership to sender 6. Update storage with new template Security Features : - Prevents duplicate template names - Verifies deployment integrity - Transfers ownership to creator Example Usage : // Create a new SVG template address templateAddress = SVGTemplatesLib . _createSVG ( svgTemplates , msg.sender , \"character_base\" ); // Template is now deployed and owned by msg.sender console . log ( \"Template deployed at:\" , templateAddress ); Integration Examples \u00b6 NFT Avatar System \u00b6 // NFT collection with dynamic SVG avatars contract AvatarNFT { using SVGTemplatesLib for SVGTemplatesLib . SVGStorage ; struct AvatarTraits { string background ; string body ; string eyes ; string mouth ; string accessory ; uint256 colorScheme ; } mapping ( uint256 => AvatarTraits ) public avatarTraits ; mapping ( string => string []) public traitOptions ; event TemplateCreated ( string indexed templateName , address templateAddress ); event AvatarGenerated ( uint256 indexed tokenId , AvatarTraits traits ); function initializeTemplates () external onlyOwner { SVGTemplatesLib . SVGStorage storage svgStorage = SVGTemplatesLib . svgStorage (); // Create base templates for avatar components string [] memory templateNames = new string []( 5 ); templateNames [ 0 ] = \"background_template\" ; templateNames [ 1 ] = \"body_template\" ; templateNames [ 2 ] = \"eyes_template\" ; templateNames [ 3 ] = \"mouth_template\" ; templateNames [ 4 ] = \"accessory_template\" ; for ( uint256 i = 0 ; i < templateNames . length ; i ++ ) { address templateAddress = SVGTemplatesLib . _createSVG ( svgStorage . svgTemplates , address ( this ), templateNames [ i ] ); emit TemplateCreated ( templateNames [ i ], templateAddress ); } // Initialize trait options traitOptions [ \"background\" ] = [ \"forest\" , \"ocean\" , \"space\" , \"city\" ]; traitOptions [ \"body\" ] = [ \"human\" , \"robot\" , \"alien\" , \"animal\" ]; traitOptions [ \"eyes\" ] = [ \"normal\" , \"glowing\" , \"mechanical\" , \"large\" ]; traitOptions [ \"mouth\" ] = [ \"smile\" , \"frown\" , \"neutral\" , \"fangs\" ]; traitOptions [ \"accessory\" ] = [ \"hat\" , \"glasses\" , \"necklace\" , \"none\" ]; } function generateAvatar ( uint256 tokenId , uint256 seed ) external { require ( _exists ( tokenId ), \"Token does not exist\" ); // Generate random traits based on seed AvatarTraits memory traits = AvatarTraits ({ background : traitOptions [ \"background\" ][ seed % traitOptions [ \"background\" ]. length ], body : traitOptions [ \"body\" ][( seed / 10 ) % traitOptions [ \"body\" ]. length ], eyes : traitOptions [ \"eyes\" ][( seed / 100 ) % traitOptions [ \"eyes\" ]. length ], mouth : traitOptions [ \"mouth\" ][( seed / 1000 ) % traitOptions [ \"mouth\" ]. length ], accessory : traitOptions [ \"accessory\" ][( seed / 10000 ) % traitOptions [ \"accessory\" ]. length ], colorScheme : seed % 10 }); avatarTraits [ tokenId ] = traits ; emit AvatarGenerated ( tokenId , traits ); } function tokenURI ( uint256 tokenId ) public view override returns ( string memory ) { require ( _exists ( tokenId ), \"Token does not exist\" ); string memory svgContent = generateSVG ( tokenId ); string memory json = Base64 . encode ( bytes ( string ( abi . encodePacked ( '{\"name\": \"Avatar #' , Strings . toString ( tokenId ), '\", \"description\": \"Dynamic SVG Avatar\", \"image\": \"data:image/svg+xml;base64,' , Base64 . encode ( bytes ( svgContent )), '\", \"attributes\": ' , generateAttributes ( tokenId ), '}' ) ) ) ); return string ( abi . encodePacked ( \"data:application/json;base64,\" , json )); } function generateSVG ( uint256 tokenId ) public view returns ( string memory ) { SVGTemplatesLib . SVGStorage storage svgStorage = SVGTemplatesLib . svgStorage (); AvatarTraits memory traits = avatarTraits [ tokenId ]; // Get base templates string memory backgroundSVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , \"background_template\" ); string memory bodySVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , \"body_template\" ); string memory eyesSVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , \"eyes_template\" ); string memory mouthSVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , \"mouth_template\" ); string memory accessorySVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , \"accessory_template\" ); // Create replacements for dynamic content Replacement [] memory replacements = new Replacement []( 6 ); replacements [ 0 ] = Replacement ( \"{{BACKGROUND_TYPE}}\" , traits . background ); replacements [ 1 ] = Replacement ( \"{{BODY_TYPE}}\" , traits . body ); replacements [ 2 ] = Replacement ( \"{{EYES_TYPE}}\" , traits . eyes ); replacements [ 3 ] = Replacement ( \"{{MOUTH_TYPE}}\" , traits . mouth ); replacements [ 4 ] = Replacement ( \"{{ACCESSORY_TYPE}}\" , traits . accessory ); replacements [ 5 ] = Replacement ( \"{{COLOR_SCHEME}}\" , Strings . toString ( traits . colorScheme )); // Build complete SVG return string ( abi . encodePacked ( '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 400\">' , applyReplacements ( backgroundSVG , replacements ), applyReplacements ( bodySVG , replacements ), applyReplacements ( eyesSVG , replacements ), applyReplacements ( mouthSVG , replacements ), applyReplacements ( accessorySVG , replacements ), '</svg>' ) ); } function generateAttributes ( uint256 tokenId ) internal view returns ( string memory ) { AvatarTraits memory traits = avatarTraits [ tokenId ]; return string ( abi . encodePacked ( '[' , '{\"trait_type\": \"Background\", \"value\": \"' , traits . background , '\"},' , '{\"trait_type\": \"Body\", \"value\": \"' , traits . body , '\"},' , '{\"trait_type\": \"Eyes\", \"value\": \"' , traits . eyes , '\"},' , '{\"trait_type\": \"Mouth\", \"value\": \"' , traits . mouth , '\"},' , '{\"trait_type\": \"Accessory\", \"value\": \"' , traits . accessory , '\"},' , '{\"trait_type\": \"Color Scheme\", \"value\": ' , Strings . toString ( traits . colorScheme ), '}' , ']' ) ); } function applyReplacements ( string memory template , Replacement [] memory replacements ) internal pure returns ( string memory ) { string memory result = template ; for ( uint256 i = 0 ; i < replacements . length ; i ++ ) { result = StringsLib . replace ( result , replacements [ i ]. matchString , replacements [ i ]. replaceString ); } return result ; } modifier onlyOwner () { // Implementation _ ; } function _exists ( uint256 tokenId ) internal view returns ( bool ) { // Implementation return true ; } } Gaming Asset Renderer \u00b6 // Dynamic SVG rendering for gaming assets contract GameAssetRenderer { using SVGTemplatesLib for SVGTemplatesLib . SVGStorage ; struct AssetTemplate { string name ; string category ; string [] requiredVariables ; bool active ; } struct AssetInstance { string templateName ; mapping ( string => string ) variables ; uint256 lastUpdated ; } mapping ( string => AssetTemplate ) public assetTemplates ; mapping ( uint256 => AssetInstance ) public assetInstances ; mapping ( string => string []) public categoryTemplates ; event AssetTemplateRegistered ( string indexed templateName , string category ); event AssetRendered ( uint256 indexed assetId , string templateName ); event AssetVariableUpdated ( uint256 indexed assetId , string variable , string value ); function registerAssetTemplate ( string memory templateName , string memory category , string [] memory requiredVariables , string memory svgTemplate ) external onlyGameMaster { SVGTemplatesLib . SVGStorage storage svgStorage = SVGTemplatesLib . svgStorage (); // Create SVG template contract address templateAddress = SVGTemplatesLib . _createSVG ( svgStorage . svgTemplates , address ( this ), templateName ); // Initialize template with SVG content ISVGTemplate ( templateAddress ). clear (); ISVGTemplate ( templateAddress ). add ( svgTemplate ); // Register template metadata assetTemplates [ templateName ] = AssetTemplate ({ name : templateName , category : category , requiredVariables : requiredVariables , active : true }); categoryTemplates [ category ]. push ( templateName ); emit AssetTemplateRegistered ( templateName , category ); } function createAsset ( uint256 assetId , string memory templateName , string [] memory variableNames , string [] memory variableValues ) external { require ( assetTemplates [ templateName ]. active , \"Template not active\" ); require ( variableNames . length == variableValues . length , \"Variable arrays length mismatch\" ); AssetInstance storage instance = assetInstances [ assetId ]; instance . templateName = templateName ; instance . lastUpdated = block.timestamp ; // Set variables for ( uint256 i = 0 ; i < variableNames . length ; i ++ ) { instance . variables [ variableNames [ i ]] = variableValues [ i ]; } emit AssetRendered ( assetId , templateName ); } function updateAssetVariable ( uint256 assetId , string memory variableName , string memory variableValue ) external { AssetInstance storage instance = assetInstances [ assetId ]; require ( bytes ( instance . templateName ). length > 0 , \"Asset does not exist\" ); instance . variables [ variableName ] = variableValue ; instance . lastUpdated = block.timestamp ; emit AssetVariableUpdated ( assetId , variableName , variableValue ); } function renderAsset ( uint256 assetId ) external view returns ( string memory ) { AssetInstance storage instance = assetInstances [ assetId ]; require ( bytes ( instance . templateName ). length > 0 , \"Asset does not exist\" ); SVGTemplatesLib . SVGStorage storage svgStorage = SVGTemplatesLib . svgStorage (); AssetTemplate memory template = assetTemplates [ instance . templateName ]; // Get template SVG string memory templateSVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , instance . templateName ); // Build replacements array Replacement [] memory replacements = new Replacement []( template . requiredVariables . length ); for ( uint256 i = 0 ; i < template . requiredVariables . length ; i ++ ) { string memory variable = template . requiredVariables [ i ]; replacements [ i ] = Replacement ({ matchString : string ( abi . encodePacked ( \"{{\" , variable , \"}}\" )), replaceString : instance . variables [ variable ] }); } // Apply replacements using template contract address templateAddress = SVGTemplatesLib . _svgAddress ( svgStorage . svgTemplates , instance . templateName ); return ISVGTemplate ( templateAddress ). buildSVG ( replacements ); } function getAssetMetadata ( uint256 assetId ) external view returns ( string memory templateName , string memory category , uint256 lastUpdated ) { AssetInstance storage instance = assetInstances [ assetId ]; AssetTemplate memory template = assetTemplates [ instance . templateName ]; return ( instance . templateName , template . category , instance . lastUpdated ); } function getCategoryTemplates ( string memory category ) external view returns ( string [] memory ) { return categoryTemplates [ category ]; } function getTemplateVariables ( string memory templateName ) external view returns ( string [] memory ) { return assetTemplates [ templateName ]. requiredVariables ; } modifier onlyGameMaster () { // Implementation _ ; } } Certificate Generator \u00b6 // Dynamic certificate generation with SVG templates contract CertificateGenerator { using SVGTemplatesLib for SVGTemplatesLib . SVGStorage ; struct CertificateType { string name ; string templateName ; string [] requiredFields ; address issuer ; bool active ; } struct Certificate { uint256 certificateId ; string certificateType ; mapping ( string => string ) fields ; address recipient ; uint256 issuedAt ; bool revoked ; } mapping ( string => CertificateType ) public certificateTypes ; mapping ( uint256 => Certificate ) public certificates ; mapping ( address => uint256 []) public recipientCertificates ; uint256 public nextCertificateId ; event CertificateTypeCreated ( string indexed typeName , address indexed issuer ); event CertificateIssued ( uint256 indexed certificateId , address indexed recipient , string typeName ); event CertificateRevoked ( uint256 indexed certificateId ); function createCertificateType ( string memory typeName , string [] memory requiredFields , string memory svgTemplate ) external returns ( string memory templateName ) { templateName = string ( abi . encodePacked ( \"cert_\" , typeName )); SVGTemplatesLib . SVGStorage storage svgStorage = SVGTemplatesLib . svgStorage (); // Create SVG template address templateAddress = SVGTemplatesLib . _createSVG ( svgStorage . svgTemplates , address ( this ), templateName ); // Initialize template with certificate SVG ISVGTemplate ( templateAddress ). clear (); ISVGTemplate ( templateAddress ). add ( svgTemplate ); // Register certificate type certificateTypes [ typeName ] = CertificateType ({ name : typeName , templateName : templateName , requiredFields : requiredFields , issuer : msg.sender , active : true }); emit CertificateTypeCreated ( typeName , msg.sender ); } function issueCertificate ( string memory typeName , address recipient , string [] memory fieldNames , string [] memory fieldValues ) external returns ( uint256 certificateId ) { CertificateType memory certType = certificateTypes [ typeName ]; require ( certType . active , \"Certificate type not active\" ); require ( msg.sender == certType . issuer , \"Not authorized issuer\" ); require ( fieldNames . length == fieldValues . length , \"Field arrays length mismatch\" ); certificateId = nextCertificateId ++ ; Certificate storage cert = certificates [ certificateId ]; cert . certificateId = certificateId ; cert . certificateType = typeName ; cert . recipient = recipient ; cert . issuedAt = block.timestamp ; cert . revoked = false ; // Set certificate fields for ( uint256 i = 0 ; i < fieldNames . length ; i ++ ) { cert . fields [ fieldNames [ i ]] = fieldValues [ i ]; } recipientCertificates [ recipient ]. push ( certificateId ); emit CertificateIssued ( certificateId , recipient , typeName ); } function revokeCertificate ( uint256 certificateId ) external { Certificate storage cert = certificates [ certificateId ]; CertificateType memory certType = certificateTypes [ cert . certificateType ]; require ( msg.sender == certType . issuer , \"Not authorized issuer\" ); require ( ! cert . revoked , \"Certificate already revoked\" ); cert . revoked = true ; emit CertificateRevoked ( certificateId ); } function generateCertificateSVG ( uint256 certificateId ) external view returns ( string memory ) { Certificate storage cert = certificates [ certificateId ]; require ( cert . issuedAt > 0 , \"Certificate does not exist\" ); require ( ! cert . revoked , \"Certificate revoked\" ); CertificateType memory certType = certificateTypes [ cert . certificateType ]; SVGTemplatesLib . SVGStorage storage svgStorage = SVGTemplatesLib . svgStorage (); // Get template SVG string memory templateSVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , certType . templateName ); // Build replacements for certificate fields Replacement [] memory replacements = new Replacement []( certType . requiredFields . length + 4 ); // Standard certificate fields replacements [ 0 ] = Replacement ( \"{{CERTIFICATE_ID}}\" , Strings . toString ( certificateId )); replacements [ 1 ] = Replacement ( \"{{RECIPIENT}}\" , Strings . toHexString ( uint160 ( cert . recipient ), 20 )); replacements [ 2 ] = Replacement ( \"{{ISSUE_DATE}}\" , formatTimestamp ( cert . issuedAt )); replacements [ 3 ] = Replacement ( \"{{CERTIFICATE_TYPE}}\" , cert . certificateType ); // Custom fields for ( uint256 i = 0 ; i < certType . requiredFields . length ; i ++ ) { string memory fieldName = certType . requiredFields [ i ]; replacements [ i + 4 ] = Replacement ({ matchString : string ( abi . encodePacked ( \"{{\" , fieldName , \"}}\" )), replaceString : cert . fields [ fieldName ] }); } // Apply replacements address templateAddress = SVGTemplatesLib . _svgAddress ( svgStorage . svgTemplates , certType . templateName ); return ISVGTemplate ( templateAddress ). buildSVG ( replacements ); } function getCertificateMetadata ( uint256 certificateId ) external view returns ( string memory certificateType , address recipient , uint256 issuedAt , bool revoked ) { Certificate storage cert = certificates [ certificateId ]; return ( cert . certificateType , cert . recipient , cert . issuedAt , cert . revoked ); } function getRecipientCertificates ( address recipient ) external view returns ( uint256 [] memory ) { return recipientCertificates [ recipient ]; } function formatTimestamp ( uint256 timestamp ) internal pure returns ( string memory ) { // Simple timestamp formatting - in production, use a proper date library return Strings . toString ( timestamp ); } } Events \u00b6 SVG Template Events \u00b6 event SVGTemplateCreated ( string name , address template ); Security Considerations \u00b6 Template Deployment Security \u00b6 CREATE2 ensures deterministic addressing Ownership transfer to template creator Unique name validation prevents conflicts Address verification ensures deployment integrity Access Control \u00b6 Template ownership controls content updates Manager role for SVG system administration Template-specific permissions for modifications Secure template registry management Content Validation \u00b6 SVG content validation before storage Safe string replacement operations Protection against malicious template content Graceful error handling for missing templates Gas Optimization \u00b6 Storage Efficiency \u00b6 Efficient template name storage Minimal storage writes during creation Optimized address calculation Batch template operations where possible Rendering Efficiency \u00b6 Lazy template loading Efficient string operations Minimal external calls Optimized replacement algorithms Error Handling \u00b6 Common Errors \u00b6 \"template already deployed\" - Duplicate template name \"template address mismatch\" - CREATE2 deployment failure Template not found - Graceful empty string return Invalid template content - Validation failures Best Practices \u00b6 Validate template names before creation Check template existence before rendering Handle missing templates gracefully Provide clear error messages for debugging Testing Considerations \u00b6 Unit Tests \u00b6 Template creation and deployment Address calculation accuracy SVG content retrieval Ownership transfer functionality Integration Tests \u00b6 Multi-template rendering workflows Variable substitution accuracy Template registry management Cross-contract template usage Related Documentation \u00b6 ISVG Interface - SVG interface definitions SVGTemplatesFacet - SVG templates facet implementation StringsLib - String manipulation utilities NFT Metadata Guide - NFT metadata best practices SVG Generation Guide - SVG template creation guide This library provides comprehensive utilities for on-chain SVG template management within the Gemforce platform, enabling dynamic generation of graphics for NFTs, certificates, gaming assets, and other visual content with variable substitution and multi-part composition capabilities.","title":"SVG Templates Lib"},{"location":"smart-contracts/libraries/svg-templates-lib/#svgtemplateslib-library","text":"","title":"SVGTemplatesLib Library"},{"location":"smart-contracts/libraries/svg-templates-lib/#overview","text":"The SVGTemplatesLib library provides core utilities for creating and managing on-chain SVG templates within the Gemforce platform. This library enables dynamic generation of SVG graphics for NFT metadata, supporting template-based rendering with variable substitution and multi-part composition.","title":"Overview"},{"location":"smart-contracts/libraries/svg-templates-lib/#key-features","text":"On-Chain SVG Storage : Store SVG templates directly on the blockchain Deterministic Deployment : CREATE2-based template contract deployment Template Management : Named template registry with unique addressing Dynamic Rendering : Variable substitution for customizable graphics Multi-Part Support : Composition of complex SVG graphics from components Ownership Transfer : Template ownership management for creators","title":"Key Features"},{"location":"smart-contracts/libraries/svg-templates-lib/#library-definition","text":"// SPDX-License-Identifier: MIT pragma solidity ^ 0.8.6 ; library SVGTemplatesLib { // Storage management function svgStorage () internal pure returns ( SVGStorage storage ); // Template management function _svgs ( SVGTemplatesContract storage self ) internal view returns ( string [] memory ); function _svgAddress ( SVGTemplatesContract storage , string memory _name ) internal view returns ( address ); function _svgString ( SVGTemplatesContract storage self , string memory _name ) internal view returns ( string memory ); function _svgData ( SVGTemplatesContract storage self , string memory _name ) internal view returns ( address ); // Template creation function _createSVG ( SVGTemplatesContract storage self , address sender , string memory _name ) internal returns ( address ); }","title":"Library Definition"},{"location":"smart-contracts/libraries/svg-templates-lib/#data-structures","text":"","title":"Data Structures"},{"location":"smart-contracts/libraries/svg-templates-lib/#svgtemplatescontract-struct","text":"struct SVGTemplatesContract { mapping ( string => address ) _templates ; // Template name to contract address mapping string [] _templateNames ; // Array of all template names } Purpose : Core storage structure for managing SVG template contracts. Components : - _templates : Maps template names to deployed contract addresses - _templateNames : Maintains ordered list of all template names","title":"SVGTemplatesContract Struct"},{"location":"smart-contracts/libraries/svg-templates-lib/#saltstorage-struct","text":"struct SaltStorage { uint256 salt ; // Salt for CREATE2 operations } Purpose : Storage for CREATE2 salt values to ensure deterministic addressing.","title":"SaltStorage Struct"},{"location":"smart-contracts/libraries/svg-templates-lib/#multipartcontract-struct","text":"struct MultiPartContract { string name_ ; // Name of the multi-part template bytes [] data_ ; // Array of SVG component data } Purpose : Storage structure for multi-part SVG compositions.","title":"MultiPartContract Struct"},{"location":"smart-contracts/libraries/svg-templates-lib/#svgstorage-struct","text":"struct SVGStorage { SVGTemplatesContract svgTemplates ; // Main template storage SaltStorage salt ; // CREATE2 salt storage address svgManager ; // SVG manager contract address MultiPartContract multiPart ; // Multi-part template storage } Purpose : Complete Diamond storage structure for SVG functionality. Storage Position : bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nextblock.bitgem.app.SVGStorage.storage\" );","title":"SVGStorage Struct"},{"location":"smart-contracts/libraries/svg-templates-lib/#replacement-struct","text":"struct Replacement { string matchString ; // String to find in template string replaceString ; // String to replace with } Purpose : Variable substitution data for dynamic SVG rendering.","title":"Replacement Struct"},{"location":"smart-contracts/libraries/svg-templates-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/svg-templates-lib/#storage-management","text":"","title":"Storage Management"},{"location":"smart-contracts/libraries/svg-templates-lib/#svgstorage","text":"function svgStorage () internal pure returns ( SVGStorage storage ds ) Purpose : Access Diamond storage for SVG template data using assembly. Implementation : function svgStorage () internal pure returns ( SVGStorage storage ds ) { bytes32 position = DIAMOND_STORAGE_POSITION ; assembly { ds . slot := position } } Returns : Storage reference to SVG template data Usage : All SVG functions use this to access persistent storage.","title":"svgStorage()"},{"location":"smart-contracts/libraries/svg-templates-lib/#template-management","text":"","title":"Template Management"},{"location":"smart-contracts/libraries/svg-templates-lib/#_svgs","text":"function _svgs ( SVGTemplatesContract storage self ) internal view returns ( string [] memory ) Purpose : Retrieve all template names stored in the contract. Parameters : - self : Storage reference to SVG templates contract Returns : Array of all template names Example Usage : // Get all available template names string [] memory templateNames = SVGTemplatesLib . _svgs ( svgTemplates ); console . log ( \"Available templates:\" , templateNames . length );","title":"_svgs()"},{"location":"smart-contracts/libraries/svg-templates-lib/#_svgaddress","text":"function _svgAddress ( SVGTemplatesContract storage , string memory _name ) internal view returns ( address ) Purpose : Calculate the deterministic address for a template contract. Parameters : - _name : Name of the template Implementation : return Create2 . computeAddress ( keccak256 ( abi . encodePacked ( _name )), keccak256 ( type ( SVGTemplate ). creationCode ) ); Returns : Predicted contract address for the named template Benefits : - Enables address prediction before deployment - Supports deterministic template addressing - Allows for efficient template lookup","title":"_svgAddress()"},{"location":"smart-contracts/libraries/svg-templates-lib/#_svgstring","text":"function _svgString ( SVGTemplatesContract storage self , string memory _name ) internal view returns ( string memory data_ ) Purpose : Retrieve the SVG string content from a deployed template. Parameters : - self : Storage reference to SVG templates contract - _name : Name of the template Implementation : try SVGTemplate ( _svgAddress ( self , _name )). svgString () returns ( string memory _data ) { data_ = _data ; } catch ( bytes memory ) {} Returns : SVG string content or empty string if template doesn't exist Error Handling : Uses try-catch to gracefully handle non-existent templates Example Usage : // Get SVG content for rendering string memory svgContent = SVGTemplatesLib . _svgString ( svgTemplates , \"avatar_base\" ); if ( bytes ( svgContent ). length > 0 ) { // Process SVG content }","title":"_svgString()"},{"location":"smart-contracts/libraries/svg-templates-lib/#_svgdata","text":"function _svgData ( SVGTemplatesContract storage self , string memory _name ) internal view returns ( address ) Purpose : Get the stored contract address for a named template. Parameters : - self : Storage reference to SVG templates contract - _name : Name of the template Returns : Contract address of the template or zero address if not found Example Usage : // Check if template exists address templateAddress = SVGTemplatesLib . _svgData ( svgTemplates , \"background\" ); require ( templateAddress != address ( 0 ), \"Template not found\" );","title":"_svgData()"},{"location":"smart-contracts/libraries/svg-templates-lib/#template-creation","text":"","title":"Template Creation"},{"location":"smart-contracts/libraries/svg-templates-lib/#_createsvg","text":"function _createSVG ( SVGTemplatesContract storage self , address sender , string memory _name ) internal returns ( address _tplAddress ) Purpose : Deploy a new SVG template contract with deterministic addressing. Parameters : - self : Storage reference to SVG templates contract - sender : Address that will own the template - _name : Unique name for the template Process : 1. Verify template name is unique 2. Calculate target address using CREATE2 3. Deploy template contract with deterministic salt 4. Verify deployment address matches prediction 5. Transfer ownership to sender 6. Update storage with new template Security Features : - Prevents duplicate template names - Verifies deployment integrity - Transfers ownership to creator Example Usage : // Create a new SVG template address templateAddress = SVGTemplatesLib . _createSVG ( svgTemplates , msg.sender , \"character_base\" ); // Template is now deployed and owned by msg.sender console . log ( \"Template deployed at:\" , templateAddress );","title":"_createSVG()"},{"location":"smart-contracts/libraries/svg-templates-lib/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/libraries/svg-templates-lib/#nft-avatar-system","text":"// NFT collection with dynamic SVG avatars contract AvatarNFT { using SVGTemplatesLib for SVGTemplatesLib . SVGStorage ; struct AvatarTraits { string background ; string body ; string eyes ; string mouth ; string accessory ; uint256 colorScheme ; } mapping ( uint256 => AvatarTraits ) public avatarTraits ; mapping ( string => string []) public traitOptions ; event TemplateCreated ( string indexed templateName , address templateAddress ); event AvatarGenerated ( uint256 indexed tokenId , AvatarTraits traits ); function initializeTemplates () external onlyOwner { SVGTemplatesLib . SVGStorage storage svgStorage = SVGTemplatesLib . svgStorage (); // Create base templates for avatar components string [] memory templateNames = new string []( 5 ); templateNames [ 0 ] = \"background_template\" ; templateNames [ 1 ] = \"body_template\" ; templateNames [ 2 ] = \"eyes_template\" ; templateNames [ 3 ] = \"mouth_template\" ; templateNames [ 4 ] = \"accessory_template\" ; for ( uint256 i = 0 ; i < templateNames . length ; i ++ ) { address templateAddress = SVGTemplatesLib . _createSVG ( svgStorage . svgTemplates , address ( this ), templateNames [ i ] ); emit TemplateCreated ( templateNames [ i ], templateAddress ); } // Initialize trait options traitOptions [ \"background\" ] = [ \"forest\" , \"ocean\" , \"space\" , \"city\" ]; traitOptions [ \"body\" ] = [ \"human\" , \"robot\" , \"alien\" , \"animal\" ]; traitOptions [ \"eyes\" ] = [ \"normal\" , \"glowing\" , \"mechanical\" , \"large\" ]; traitOptions [ \"mouth\" ] = [ \"smile\" , \"frown\" , \"neutral\" , \"fangs\" ]; traitOptions [ \"accessory\" ] = [ \"hat\" , \"glasses\" , \"necklace\" , \"none\" ]; } function generateAvatar ( uint256 tokenId , uint256 seed ) external { require ( _exists ( tokenId ), \"Token does not exist\" ); // Generate random traits based on seed AvatarTraits memory traits = AvatarTraits ({ background : traitOptions [ \"background\" ][ seed % traitOptions [ \"background\" ]. length ], body : traitOptions [ \"body\" ][( seed / 10 ) % traitOptions [ \"body\" ]. length ], eyes : traitOptions [ \"eyes\" ][( seed / 100 ) % traitOptions [ \"eyes\" ]. length ], mouth : traitOptions [ \"mouth\" ][( seed / 1000 ) % traitOptions [ \"mouth\" ]. length ], accessory : traitOptions [ \"accessory\" ][( seed / 10000 ) % traitOptions [ \"accessory\" ]. length ], colorScheme : seed % 10 }); avatarTraits [ tokenId ] = traits ; emit AvatarGenerated ( tokenId , traits ); } function tokenURI ( uint256 tokenId ) public view override returns ( string memory ) { require ( _exists ( tokenId ), \"Token does not exist\" ); string memory svgContent = generateSVG ( tokenId ); string memory json = Base64 . encode ( bytes ( string ( abi . encodePacked ( '{\"name\": \"Avatar #' , Strings . toString ( tokenId ), '\", \"description\": \"Dynamic SVG Avatar\", \"image\": \"data:image/svg+xml;base64,' , Base64 . encode ( bytes ( svgContent )), '\", \"attributes\": ' , generateAttributes ( tokenId ), '}' ) ) ) ); return string ( abi . encodePacked ( \"data:application/json;base64,\" , json )); } function generateSVG ( uint256 tokenId ) public view returns ( string memory ) { SVGTemplatesLib . SVGStorage storage svgStorage = SVGTemplatesLib . svgStorage (); AvatarTraits memory traits = avatarTraits [ tokenId ]; // Get base templates string memory backgroundSVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , \"background_template\" ); string memory bodySVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , \"body_template\" ); string memory eyesSVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , \"eyes_template\" ); string memory mouthSVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , \"mouth_template\" ); string memory accessorySVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , \"accessory_template\" ); // Create replacements for dynamic content Replacement [] memory replacements = new Replacement []( 6 ); replacements [ 0 ] = Replacement ( \"{{BACKGROUND_TYPE}}\" , traits . background ); replacements [ 1 ] = Replacement ( \"{{BODY_TYPE}}\" , traits . body ); replacements [ 2 ] = Replacement ( \"{{EYES_TYPE}}\" , traits . eyes ); replacements [ 3 ] = Replacement ( \"{{MOUTH_TYPE}}\" , traits . mouth ); replacements [ 4 ] = Replacement ( \"{{ACCESSORY_TYPE}}\" , traits . accessory ); replacements [ 5 ] = Replacement ( \"{{COLOR_SCHEME}}\" , Strings . toString ( traits . colorScheme )); // Build complete SVG return string ( abi . encodePacked ( '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 400\">' , applyReplacements ( backgroundSVG , replacements ), applyReplacements ( bodySVG , replacements ), applyReplacements ( eyesSVG , replacements ), applyReplacements ( mouthSVG , replacements ), applyReplacements ( accessorySVG , replacements ), '</svg>' ) ); } function generateAttributes ( uint256 tokenId ) internal view returns ( string memory ) { AvatarTraits memory traits = avatarTraits [ tokenId ]; return string ( abi . encodePacked ( '[' , '{\"trait_type\": \"Background\", \"value\": \"' , traits . background , '\"},' , '{\"trait_type\": \"Body\", \"value\": \"' , traits . body , '\"},' , '{\"trait_type\": \"Eyes\", \"value\": \"' , traits . eyes , '\"},' , '{\"trait_type\": \"Mouth\", \"value\": \"' , traits . mouth , '\"},' , '{\"trait_type\": \"Accessory\", \"value\": \"' , traits . accessory , '\"},' , '{\"trait_type\": \"Color Scheme\", \"value\": ' , Strings . toString ( traits . colorScheme ), '}' , ']' ) ); } function applyReplacements ( string memory template , Replacement [] memory replacements ) internal pure returns ( string memory ) { string memory result = template ; for ( uint256 i = 0 ; i < replacements . length ; i ++ ) { result = StringsLib . replace ( result , replacements [ i ]. matchString , replacements [ i ]. replaceString ); } return result ; } modifier onlyOwner () { // Implementation _ ; } function _exists ( uint256 tokenId ) internal view returns ( bool ) { // Implementation return true ; } }","title":"NFT Avatar System"},{"location":"smart-contracts/libraries/svg-templates-lib/#gaming-asset-renderer","text":"// Dynamic SVG rendering for gaming assets contract GameAssetRenderer { using SVGTemplatesLib for SVGTemplatesLib . SVGStorage ; struct AssetTemplate { string name ; string category ; string [] requiredVariables ; bool active ; } struct AssetInstance { string templateName ; mapping ( string => string ) variables ; uint256 lastUpdated ; } mapping ( string => AssetTemplate ) public assetTemplates ; mapping ( uint256 => AssetInstance ) public assetInstances ; mapping ( string => string []) public categoryTemplates ; event AssetTemplateRegistered ( string indexed templateName , string category ); event AssetRendered ( uint256 indexed assetId , string templateName ); event AssetVariableUpdated ( uint256 indexed assetId , string variable , string value ); function registerAssetTemplate ( string memory templateName , string memory category , string [] memory requiredVariables , string memory svgTemplate ) external onlyGameMaster { SVGTemplatesLib . SVGStorage storage svgStorage = SVGTemplatesLib . svgStorage (); // Create SVG template contract address templateAddress = SVGTemplatesLib . _createSVG ( svgStorage . svgTemplates , address ( this ), templateName ); // Initialize template with SVG content ISVGTemplate ( templateAddress ). clear (); ISVGTemplate ( templateAddress ). add ( svgTemplate ); // Register template metadata assetTemplates [ templateName ] = AssetTemplate ({ name : templateName , category : category , requiredVariables : requiredVariables , active : true }); categoryTemplates [ category ]. push ( templateName ); emit AssetTemplateRegistered ( templateName , category ); } function createAsset ( uint256 assetId , string memory templateName , string [] memory variableNames , string [] memory variableValues ) external { require ( assetTemplates [ templateName ]. active , \"Template not active\" ); require ( variableNames . length == variableValues . length , \"Variable arrays length mismatch\" ); AssetInstance storage instance = assetInstances [ assetId ]; instance . templateName = templateName ; instance . lastUpdated = block.timestamp ; // Set variables for ( uint256 i = 0 ; i < variableNames . length ; i ++ ) { instance . variables [ variableNames [ i ]] = variableValues [ i ]; } emit AssetRendered ( assetId , templateName ); } function updateAssetVariable ( uint256 assetId , string memory variableName , string memory variableValue ) external { AssetInstance storage instance = assetInstances [ assetId ]; require ( bytes ( instance . templateName ). length > 0 , \"Asset does not exist\" ); instance . variables [ variableName ] = variableValue ; instance . lastUpdated = block.timestamp ; emit AssetVariableUpdated ( assetId , variableName , variableValue ); } function renderAsset ( uint256 assetId ) external view returns ( string memory ) { AssetInstance storage instance = assetInstances [ assetId ]; require ( bytes ( instance . templateName ). length > 0 , \"Asset does not exist\" ); SVGTemplatesLib . SVGStorage storage svgStorage = SVGTemplatesLib . svgStorage (); AssetTemplate memory template = assetTemplates [ instance . templateName ]; // Get template SVG string memory templateSVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , instance . templateName ); // Build replacements array Replacement [] memory replacements = new Replacement []( template . requiredVariables . length ); for ( uint256 i = 0 ; i < template . requiredVariables . length ; i ++ ) { string memory variable = template . requiredVariables [ i ]; replacements [ i ] = Replacement ({ matchString : string ( abi . encodePacked ( \"{{\" , variable , \"}}\" )), replaceString : instance . variables [ variable ] }); } // Apply replacements using template contract address templateAddress = SVGTemplatesLib . _svgAddress ( svgStorage . svgTemplates , instance . templateName ); return ISVGTemplate ( templateAddress ). buildSVG ( replacements ); } function getAssetMetadata ( uint256 assetId ) external view returns ( string memory templateName , string memory category , uint256 lastUpdated ) { AssetInstance storage instance = assetInstances [ assetId ]; AssetTemplate memory template = assetTemplates [ instance . templateName ]; return ( instance . templateName , template . category , instance . lastUpdated ); } function getCategoryTemplates ( string memory category ) external view returns ( string [] memory ) { return categoryTemplates [ category ]; } function getTemplateVariables ( string memory templateName ) external view returns ( string [] memory ) { return assetTemplates [ templateName ]. requiredVariables ; } modifier onlyGameMaster () { // Implementation _ ; } }","title":"Gaming Asset Renderer"},{"location":"smart-contracts/libraries/svg-templates-lib/#certificate-generator","text":"// Dynamic certificate generation with SVG templates contract CertificateGenerator { using SVGTemplatesLib for SVGTemplatesLib . SVGStorage ; struct CertificateType { string name ; string templateName ; string [] requiredFields ; address issuer ; bool active ; } struct Certificate { uint256 certificateId ; string certificateType ; mapping ( string => string ) fields ; address recipient ; uint256 issuedAt ; bool revoked ; } mapping ( string => CertificateType ) public certificateTypes ; mapping ( uint256 => Certificate ) public certificates ; mapping ( address => uint256 []) public recipientCertificates ; uint256 public nextCertificateId ; event CertificateTypeCreated ( string indexed typeName , address indexed issuer ); event CertificateIssued ( uint256 indexed certificateId , address indexed recipient , string typeName ); event CertificateRevoked ( uint256 indexed certificateId ); function createCertificateType ( string memory typeName , string [] memory requiredFields , string memory svgTemplate ) external returns ( string memory templateName ) { templateName = string ( abi . encodePacked ( \"cert_\" , typeName )); SVGTemplatesLib . SVGStorage storage svgStorage = SVGTemplatesLib . svgStorage (); // Create SVG template address templateAddress = SVGTemplatesLib . _createSVG ( svgStorage . svgTemplates , address ( this ), templateName ); // Initialize template with certificate SVG ISVGTemplate ( templateAddress ). clear (); ISVGTemplate ( templateAddress ). add ( svgTemplate ); // Register certificate type certificateTypes [ typeName ] = CertificateType ({ name : typeName , templateName : templateName , requiredFields : requiredFields , issuer : msg.sender , active : true }); emit CertificateTypeCreated ( typeName , msg.sender ); } function issueCertificate ( string memory typeName , address recipient , string [] memory fieldNames , string [] memory fieldValues ) external returns ( uint256 certificateId ) { CertificateType memory certType = certificateTypes [ typeName ]; require ( certType . active , \"Certificate type not active\" ); require ( msg.sender == certType . issuer , \"Not authorized issuer\" ); require ( fieldNames . length == fieldValues . length , \"Field arrays length mismatch\" ); certificateId = nextCertificateId ++ ; Certificate storage cert = certificates [ certificateId ]; cert . certificateId = certificateId ; cert . certificateType = typeName ; cert . recipient = recipient ; cert . issuedAt = block.timestamp ; cert . revoked = false ; // Set certificate fields for ( uint256 i = 0 ; i < fieldNames . length ; i ++ ) { cert . fields [ fieldNames [ i ]] = fieldValues [ i ]; } recipientCertificates [ recipient ]. push ( certificateId ); emit CertificateIssued ( certificateId , recipient , typeName ); } function revokeCertificate ( uint256 certificateId ) external { Certificate storage cert = certificates [ certificateId ]; CertificateType memory certType = certificateTypes [ cert . certificateType ]; require ( msg.sender == certType . issuer , \"Not authorized issuer\" ); require ( ! cert . revoked , \"Certificate already revoked\" ); cert . revoked = true ; emit CertificateRevoked ( certificateId ); } function generateCertificateSVG ( uint256 certificateId ) external view returns ( string memory ) { Certificate storage cert = certificates [ certificateId ]; require ( cert . issuedAt > 0 , \"Certificate does not exist\" ); require ( ! cert . revoked , \"Certificate revoked\" ); CertificateType memory certType = certificateTypes [ cert . certificateType ]; SVGTemplatesLib . SVGStorage storage svgStorage = SVGTemplatesLib . svgStorage (); // Get template SVG string memory templateSVG = SVGTemplatesLib . _svgString ( svgStorage . svgTemplates , certType . templateName ); // Build replacements for certificate fields Replacement [] memory replacements = new Replacement []( certType . requiredFields . length + 4 ); // Standard certificate fields replacements [ 0 ] = Replacement ( \"{{CERTIFICATE_ID}}\" , Strings . toString ( certificateId )); replacements [ 1 ] = Replacement ( \"{{RECIPIENT}}\" , Strings . toHexString ( uint160 ( cert . recipient ), 20 )); replacements [ 2 ] = Replacement ( \"{{ISSUE_DATE}}\" , formatTimestamp ( cert . issuedAt )); replacements [ 3 ] = Replacement ( \"{{CERTIFICATE_TYPE}}\" , cert . certificateType ); // Custom fields for ( uint256 i = 0 ; i < certType . requiredFields . length ; i ++ ) { string memory fieldName = certType . requiredFields [ i ]; replacements [ i + 4 ] = Replacement ({ matchString : string ( abi . encodePacked ( \"{{\" , fieldName , \"}}\" )), replaceString : cert . fields [ fieldName ] }); } // Apply replacements address templateAddress = SVGTemplatesLib . _svgAddress ( svgStorage . svgTemplates , certType . templateName ); return ISVGTemplate ( templateAddress ). buildSVG ( replacements ); } function getCertificateMetadata ( uint256 certificateId ) external view returns ( string memory certificateType , address recipient , uint256 issuedAt , bool revoked ) { Certificate storage cert = certificates [ certificateId ]; return ( cert . certificateType , cert . recipient , cert . issuedAt , cert . revoked ); } function getRecipientCertificates ( address recipient ) external view returns ( uint256 [] memory ) { return recipientCertificates [ recipient ]; } function formatTimestamp ( uint256 timestamp ) internal pure returns ( string memory ) { // Simple timestamp formatting - in production, use a proper date library return Strings . toString ( timestamp ); } }","title":"Certificate Generator"},{"location":"smart-contracts/libraries/svg-templates-lib/#events","text":"","title":"Events"},{"location":"smart-contracts/libraries/svg-templates-lib/#svg-template-events","text":"event SVGTemplateCreated ( string name , address template );","title":"SVG Template Events"},{"location":"smart-contracts/libraries/svg-templates-lib/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/svg-templates-lib/#template-deployment-security","text":"CREATE2 ensures deterministic addressing Ownership transfer to template creator Unique name validation prevents conflicts Address verification ensures deployment integrity","title":"Template Deployment Security"},{"location":"smart-contracts/libraries/svg-templates-lib/#access-control","text":"Template ownership controls content updates Manager role for SVG system administration Template-specific permissions for modifications Secure template registry management","title":"Access Control"},{"location":"smart-contracts/libraries/svg-templates-lib/#content-validation","text":"SVG content validation before storage Safe string replacement operations Protection against malicious template content Graceful error handling for missing templates","title":"Content Validation"},{"location":"smart-contracts/libraries/svg-templates-lib/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/libraries/svg-templates-lib/#storage-efficiency","text":"Efficient template name storage Minimal storage writes during creation Optimized address calculation Batch template operations where possible","title":"Storage Efficiency"},{"location":"smart-contracts/libraries/svg-templates-lib/#rendering-efficiency","text":"Lazy template loading Efficient string operations Minimal external calls Optimized replacement algorithms","title":"Rendering Efficiency"},{"location":"smart-contracts/libraries/svg-templates-lib/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/libraries/svg-templates-lib/#common-errors","text":"\"template already deployed\" - Duplicate template name \"template address mismatch\" - CREATE2 deployment failure Template not found - Graceful empty string return Invalid template content - Validation failures","title":"Common Errors"},{"location":"smart-contracts/libraries/svg-templates-lib/#best-practices","text":"Validate template names before creation Check template existence before rendering Handle missing templates gracefully Provide clear error messages for debugging","title":"Best Practices"},{"location":"smart-contracts/libraries/svg-templates-lib/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/libraries/svg-templates-lib/#unit-tests","text":"Template creation and deployment Address calculation accuracy SVG content retrieval Ownership transfer functionality","title":"Unit Tests"},{"location":"smart-contracts/libraries/svg-templates-lib/#integration-tests","text":"Multi-template rendering workflows Variable substitution accuracy Template registry management Cross-contract template usage","title":"Integration Tests"},{"location":"smart-contracts/libraries/svg-templates-lib/#related-documentation","text":"ISVG Interface - SVG interface definitions SVGTemplatesFacet - SVG templates facet implementation StringsLib - String manipulation utilities NFT Metadata Guide - NFT metadata best practices SVG Generation Guide - SVG template creation guide This library provides comprehensive utilities for on-chain SVG template management within the Gemforce platform, enabling dynamic generation of graphics for NFTs, certificates, gaming assets, and other visual content with variable substitution and multi-part composition capabilities.","title":"Related Documentation"},{"location":"smart-contracts/libraries/trade-deal-lib/","text":"TradeDealLib Library \u00b6 Overview \u00b6 The TradeDealLib library provides core utilities and data structures for managing collateralized trade deals within the Gemforce platform. This library implements the Diamond Standard storage pattern and provides essential functions for trade deal creation, management, participant handling, and financial operations including funding, repayment, and collateral management. Key Features \u00b6 Diamond Storage Pattern : Secure storage isolation using Diamond Standard Trade Deal Lifecycle Management : Complete CRUD operations for trade deals Role-Based Access Control : Flexible permission system with multiple operation modes Collateral Management : Invoice NFT collateral handling and redemption Financial Operations : USDC funding, withdrawal, and repayment tracking Interest Distribution : Automated interest calculation and distribution Multi-Mode Operations : Support for centralized, self-service, and hybrid models Library Definition \u00b6 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; library TradeDealLib { // Enums enum OperationMode { CENTRALIZED , SELF_SERVICE , HYBRID , CUSTOM } enum Role { NONE , ADMIN , LENDER , BORROWER , UNDERWRITER , LIQUIDATOR } // Permission constants uint256 constant PERMISSION_DEPOSIT_FUNDS = 1 ; uint256 constant PERMISSION_WITHDRAW_FUNDS = 2 ; uint256 constant PERMISSION_DEPOSIT_COLLATERAL = 4 ; uint256 constant PERMISSION_WITHDRAW_COLLATERAL = 8 ; uint256 constant PERMISSION_DISTRIBUTE_INTEREST = 16 ; // Core data structures struct TradeDeal { ... } struct TradeDealStorage { ... } struct CreateTradeDealParams { ... } struct CreateTradeDealResult { ... } // Core functions function _createTradeDeal ( CreateTradeDealParams memory params ) internal returns ( CreateTradeDealResult memory ); function _updateTradeDeal (...) internal returns ( UpdateTradeDealResult memory ); function _activateTradeDeal ( uint256 tradeDealId ) internal returns ( TradeDealStateChangeResult memory ); function _deactivateTradeDeal ( uint256 tradeDealId ) internal returns ( TradeDealStateChangeResult memory ); } Data Structures \u00b6 OperationMode Enum \u00b6 enum OperationMode { CENTRALIZED , // Contract owner manages all fund operations SELF_SERVICE , // Borrowers can directly withdraw/repay funds HYBRID , // Mixed model with configurable permissions CUSTOM // Fine-grained permission configuration } Purpose : Defines the operational model for trade deal management. Values : - CENTRALIZED (0): All operations controlled by contract owner/admin - SELF_SERVICE (1): Borrowers have direct access to fund operations - HYBRID (2): Mixed model with some automated and some manual operations - CUSTOM (3): Fine-grained permission configuration per user Role Enum \u00b6 enum Role { NONE , // No special role (default) ADMIN , // Full control over the trade deal LENDER , // Can deposit funds and receive Collateral tokens BORROWER , // Can deposit invoices and withdraw funds (in self-service) UNDERWRITER , // Can approve/reject deals, modify terms LIQUIDATOR // Can liquidate collateral if terms are violated } Purpose : Defines user roles within the trade deal system. Permission Constants \u00b6 uint256 constant PERMISSION_DEPOSIT_FUNDS = 1 ; uint256 constant PERMISSION_WITHDRAW_FUNDS = 2 ; uint256 constant PERMISSION_DEPOSIT_COLLATERAL = 4 ; uint256 constant PERMISSION_WITHDRAW_COLLATERAL = 8 ; uint256 constant PERMISSION_DISTRIBUTE_INTEREST = 16 ; Purpose : Bit flags for fine-grained permission control. TradeDeal Struct \u00b6 struct TradeDeal { uint256 id ; string name ; string symbol ; // Symbol for the trade deal Collateral token uint256 interestRate ; uint256 collateralToInterestRatio ; bool active ; uint256 [] requiredClaimTopics ; // Claim topics required for participation address collateralAddress ; // Address of the Collateral token contract address interestAddress ; // Address of the VABI token contract address usdcAddress ; // Address of the USDC token contract OperationMode operationMode ; // Operation mode for the trade deal } Purpose : Core data structure representing a trade deal. Key Fields : - id : Unique identifier for the trade deal - name : Human-readable name for the trade deal - symbol : Symbol used for the associated Collateral token - interestRate : Interest rate for the trade deal (basis points) - collateralToInterestRatio : Ratio of collateral to interest tokens - requiredClaimTopics : Array of claim topics required for participation - operationMode : Operational model for the trade deal TradeDealStorage Struct \u00b6 struct TradeDealStorage { // Trade deal tracking mapping ( uint256 => TradeDeal ) tradeDeals ; uint256 [] tradeDealIds ; uint256 nextTradeDealId ; // Per-trade deal mappings mapping ( uint256 => uint256 []) tradeDealInvoices ; mapping ( uint256 => uint256 ) tradeDealUsdcBalances ; mapping ( uint256 => mapping ( address => bool )) tradeDealParticipants ; mapping ( uint256 => uint256 []) tradeDealRequiredClaimTopics ; // Role-based access control mapping ( uint256 => mapping ( address => Role )) userRoles ; mapping ( uint256 => mapping ( address => uint256 )) userPermissions ; // Enhanced functionality mapping ( uint256 => uint256 ) tradeDealFundingTargets ; mapping ( uint256 => bool ) tradeDealFundingWithdrawn ; mapping ( uint256 => uint256 ) tradeDealRepaidAmounts ; mapping ( uint256 => uint256 ) tradeDealTotalDebt ; mapping ( uint256 => uint256 ) tradeDealTotalWithdrawn ; mapping ( uint256 => mapping ( uint256 => address )) invoiceDepositors ; } Purpose : Diamond storage structure for all trade deal data. Core Functions \u00b6 Trade Deal Creation \u00b6 _createTradeDeal() \u00b6 function _createTradeDeal ( CreateTradeDealParams memory params ) internal returns ( CreateTradeDealResult memory ) Purpose : Create a new trade deal with specified parameters. Parameters : - params (CreateTradeDealParams): Struct containing all creation parameters CreateTradeDealParams Structure : struct CreateTradeDealParams { string name ; string symbol ; uint256 interestRate ; uint256 collateralToInterestRatio ; uint256 [] requiredClaimTopics ; address collateralAddress ; address interestAddress ; address usdcAddress ; OperationMode operationMode ; } Returns : CreateTradeDealResult struct with trade deal information Key Operations : - Assigns unique trade deal ID - Initializes trade deal data structure - Creates or assigns collateral token contract - Sets up required claim topics - Initializes financial tracking (funding targets, repayment amounts) Example Usage : // Create a new trade deal TradeDealLib . CreateTradeDealParams memory params = TradeDealLib . CreateTradeDealParams ({ name : \"Invoice Financing Deal #1\" , symbol : \"IFD1\" , interestRate : 1200 , // 12% APR collateralToInterestRatio : 1000000 , // 1:1 ratio requiredClaimTopics : new uint256 []( 1 ), collateralAddress : address ( 0 ), // Will create new token interestAddress : interestTokenAddress , usdcAddress : usdcTokenAddress , operationMode : TradeDealLib . OperationMode . SELF_SERVICE }); params . requiredClaimTopics [ 0 ] = 1 ; // KYC required TradeDealLib . CreateTradeDealResult memory result = TradeDealLib . _createTradeDeal ( params ); Trade Deal Management \u00b6 _updateTradeDeal() \u00b6 function _updateTradeDeal ( uint256 tradeDealId , string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , address collateralAddress , address interestAddress , address usdcAddress ) internal returns ( UpdateTradeDealResult memory ) Purpose : Update an existing trade deal's parameters. Parameters : - tradeDealId : ID of the trade deal to update - Various parameters to update (name, symbol, rates, addresses) Requirements : - Trade deal must exist - Caller must have appropriate permissions Example Usage : // Update trade deal interest rate TradeDealLib . UpdateTradeDealResult memory result = TradeDealLib . _updateTradeDeal ( tradeDealId , \"Updated Invoice Financing Deal #1\" , \"IFD1\" , 1500 , // Updated to 15% APR 1000000 , collateralAddress , interestAddress , usdcAddress ); _activateTradeDeal() / _deactivateTradeDeal() \u00b6 function _activateTradeDeal ( uint256 tradeDealId ) internal returns ( TradeDealStateChangeResult memory ) function _deactivateTradeDeal ( uint256 tradeDealId ) internal returns ( TradeDealStateChangeResult memory ) Purpose : Activate or deactivate a trade deal. Parameters : - tradeDealId : ID of the trade deal to activate/deactivate Requirements : - Trade deal must exist - Appropriate permissions required Example Usage : // Activate a trade deal TradeDealLib . TradeDealStateChangeResult memory result = TradeDealLib . _activateTradeDeal ( tradeDealId ); // Deactivate a trade deal TradeDealLib . TradeDealStateChangeResult memory result = TradeDealLib . _deactivateTradeDeal ( tradeDealId ); Integration Examples \u00b6 Trade Deal Factory Contract \u00b6 // Factory contract for creating and managing trade deals contract TradeDealFactory { using TradeDealLib for TradeDealLib . TradeDealStorage ; event TradeDealCreated ( uint256 indexed tradeDealId , string name , address indexed creator , TradeDealLib . OperationMode operationMode ); event TradeDealUpdated ( uint256 indexed tradeDealId , string name ); function createStandardTradeDeal ( string memory name , string memory symbol , uint256 interestRate , address interestTokenAddress , address usdcTokenAddress ) external returns ( uint256 tradeDealId ) { // Prepare creation parameters TradeDealLib . CreateTradeDealParams memory params = TradeDealLib . CreateTradeDealParams ({ name : name , symbol : symbol , interestRate : interestRate , collateralToInterestRatio : 1000000 , // 1:1 ratio requiredClaimTopics : new uint256 []( 1 ), collateralAddress : address ( 0 ), // Will create new token interestAddress : interestTokenAddress , usdcAddress : usdcTokenAddress , operationMode : TradeDealLib . OperationMode . SELF_SERVICE }); // Set KYC requirement params . requiredClaimTopics [ 0 ] = 1 ; // Create the trade deal TradeDealLib . CreateTradeDealResult memory result = TradeDealLib . _createTradeDeal ( params ); emit TradeDealCreated ( result . tradeDealId , result . name , msg.sender , result . operationMode ); return result . tradeDealId ; } function createCustomTradeDeal ( TradeDealLib . CreateTradeDealParams memory params ) external returns ( uint256 tradeDealId ) { require ( bytes ( params . name ). length > 0 , \"Name cannot be empty\" ); require ( params . interestRate > 0 , \"Interest rate must be positive\" ); TradeDealLib . CreateTradeDealResult memory result = TradeDealLib . _createTradeDeal ( params ); emit TradeDealCreated ( result . tradeDealId , result . name , msg.sender , result . operationMode ); return result . tradeDealId ; } function updateTradeDeal ( uint256 tradeDealId , string memory name , string memory symbol , uint256 interestRate ) external onlyTradeDealAdmin ( tradeDealId ) { // Get current trade deal info TradeDealLib . TradeDeal memory tradeDeal = getTradeDeal ( tradeDealId ); TradeDealLib . UpdateTradeDealResult memory result = TradeDealLib . _updateTradeDeal ( tradeDealId , name , symbol , interestRate , tradeDeal . collateralToInterestRatio , tradeDeal . collateralAddress , tradeDeal . interestAddress , tradeDeal . usdcAddress ); emit TradeDealUpdated ( tradeDealId , name ); } function getTradeDeal ( uint256 tradeDealId ) public view returns ( TradeDealLib . TradeDeal memory ) { // Implementation would access storage and return trade deal // This is a simplified example } modifier onlyTradeDealAdmin ( uint256 tradeDealId ) { // Implementation would check if caller has admin role for the trade deal _ ; } } Trade Deal Analytics System \u00b6 // Analytics system for trade deal performance tracking contract TradeDealAnalytics { using TradeDealLib for TradeDealLib . TradeDealStorage ; struct TradeDealMetrics { uint256 totalFunded ; uint256 totalRepaid ; uint256 totalInterestEarned ; uint256 averageInterestRate ; uint256 defaultRate ; uint256 averageFundingTime ; } struct TradeDealPerformance { uint256 tradeDealId ; uint256 fundingTarget ; uint256 currentFunding ; uint256 repaidAmount ; uint256 outstandingDebt ; uint256 daysActive ; bool fullyFunded ; bool fullyRepaid ; TradeDealLib . OperationMode operationMode ; } mapping ( uint256 => uint256 ) public tradeDealCreationTime ; mapping ( uint256 => uint256 ) public tradeDealFundingTime ; mapping ( uint256 => uint256 ) public tradeDealRepaymentTime ; event MetricsUpdated ( TradeDealMetrics metrics ); event PerformanceCalculated ( uint256 indexed tradeDealId , TradeDealPerformance performance ); function calculateTradeDealPerformance ( uint256 tradeDealId ) external view returns ( TradeDealPerformance memory performance ) { // Get trade deal information TradeDealLib . TradeDeal memory tradeDeal = getTradeDeal ( tradeDealId ); performance . tradeDealId = tradeDealId ; performance . operationMode = tradeDeal . operationMode ; // Get financial metrics from storage performance . fundingTarget = getFundingTarget ( tradeDealId ); performance . currentFunding = getCurrentFunding ( tradeDealId ); performance . repaidAmount = getRepaidAmount ( tradeDealId ); performance . outstandingDebt = getOutstandingDebt ( tradeDealId ); // Calculate status performance . fullyFunded = performance . currentFunding >= performance . fundingTarget ; performance . fullyRepaid = performance . repaidAmount >= performance . outstandingDebt ; // Calculate days active uint256 creationTime = tradeDealCreationTime [ tradeDealId ]; if ( creationTime > 0 ) { performance . daysActive = ( block.timestamp - creationTime ) / 1 days ; } } function calculateOverallMetrics () external returns ( TradeDealMetrics memory metrics ) { uint256 [] memory allTradeDealIds = getAllTradeDealIds (); uint256 totalDeals = allTradeDealIds . length ; uint256 totalInterestRateSum = 0 ; uint256 defaultedDeals = 0 ; uint256 totalFundingTimeSum = 0 ; uint256 fundedDealsCount = 0 ; for ( uint256 i = 0 ; i < totalDeals ; i ++ ) { uint256 tradeDealId = allTradeDealIds [ i ]; TradeDealLib . TradeDeal memory tradeDeal = getTradeDeal ( tradeDealId ); // Accumulate metrics totalInterestRateSum += tradeDeal . interestRate ; metrics . totalFunded += getCurrentFunding ( tradeDealId ); metrics . totalRepaid += getRepaidAmount ( tradeDealId ); // Calculate funding time if deal is funded uint256 creationTime = tradeDealCreationTime [ tradeDealId ]; uint256 fundingTime = tradeDealFundingTime [ tradeDealId ]; if ( fundingTime > creationTime ) { totalFundingTimeSum += ( fundingTime - creationTime ); fundedDealsCount ++ ; } // Check for defaults (simplified logic) if ( isDefaulted ( tradeDealId )) { defaultedDeals ++ ; } } // Calculate averages if ( totalDeals > 0 ) { metrics . averageInterestRate = totalInterestRateSum / totalDeals ; metrics . defaultRate = ( defaultedDeals * 10000 ) / totalDeals ; // Basis points } if ( fundedDealsCount > 0 ) { metrics . averageFundingTime = totalFundingTimeSum / fundedDealsCount ; } metrics . totalInterestEarned = metrics . totalRepaid > metrics . totalFunded ? metrics . totalRepaid - metrics . totalFunded : 0 ; emit MetricsUpdated ( metrics ); return metrics ; } function getTradeDealsByOperationMode ( TradeDealLib . OperationMode mode ) external view returns ( uint256 [] memory tradeDealIds ) { uint256 [] memory allIds = getAllTradeDealIds (); uint256 count = 0 ; // Count matching trade deals for ( uint256 i = 0 ; i < allIds . length ; i ++ ) { TradeDealLib . TradeDeal memory tradeDeal = getTradeDeal ( allIds [ i ]); if ( tradeDeal . operationMode == mode ) { count ++ ; } } // Create result array tradeDealIds = new uint256 []( count ); uint256 index = 0 ; for ( uint256 i = 0 ; i < allIds . length ; i ++ ) { TradeDealLib . TradeDeal memory tradeDeal = getTradeDeal ( allIds [ i ]); if ( tradeDeal . operationMode == mode ) { tradeDealIds [ index ] = allIds [ i ]; index ++ ; } } } // Helper functions (would be implemented to access actual storage) function getTradeDeal ( uint256 tradeDealId ) internal view returns ( TradeDealLib . TradeDeal memory ) { // Implementation would access Diamond storage } function getFundingTarget ( uint256 tradeDealId ) internal view returns ( uint256 ) { // Implementation would access storage } function getCurrentFunding ( uint256 tradeDealId ) internal view returns ( uint256 ) { // Implementation would access storage } function getRepaidAmount ( uint256 tradeDealId ) internal view returns ( uint256 ) { // Implementation would access storage } function getOutstandingDebt ( uint256 tradeDealId ) internal view returns ( uint256 ) { // Implementation would access storage } function getAllTradeDealIds () internal view returns ( uint256 [] memory ) { // Implementation would access storage } function isDefaulted ( uint256 tradeDealId ) internal view returns ( bool ) { // Implementation would check default conditions } } Role-Based Access Control Manager \u00b6 // Manager for trade deal roles and permissions contract TradeDealAccessManager { using TradeDealLib for TradeDealLib . TradeDealStorage ; event RoleAssigned ( uint256 indexed tradeDealId , address indexed user , TradeDealLib . Role role ); event PermissionGranted ( uint256 indexed tradeDealId , address indexed user , uint256 permission ); event PermissionRevoked ( uint256 indexed tradeDealId , address indexed user , uint256 permission ); function assignRole ( uint256 tradeDealId , address user , TradeDealLib . Role role ) external onlyTradeDealAdmin ( tradeDealId ) { // Set user role in storage setUserRole ( tradeDealId , user , role ); // Assign default permissions based on role uint256 defaultPermissions = getDefaultPermissionsForRole ( role ); setUserPermissions ( tradeDealId , user , defaultPermissions ); emit RoleAssigned ( tradeDealId , user , role ); } function grantPermission ( uint256 tradeDealId , address user , uint256 permission ) external onlyTradeDealAdmin ( tradeDealId ) { uint256 currentPermissions = getUserPermissions ( tradeDealId , user ); uint256 newPermissions = currentPermissions | permission ; setUserPermissions ( tradeDealId , user , newPermissions ); emit PermissionGranted ( tradeDealId , user , permission ); } function revokePermission ( uint256 tradeDealId , address user , uint256 permission ) external onlyTradeDealAdmin ( tradeDealId ) { uint256 currentPermissions = getUserPermissions ( tradeDealId , user ); uint256 newPermissions = currentPermissions & ~ permission ; setUserPermissions ( tradeDealId , user , newPermissions ); emit PermissionRevoked ( tradeDealId , user , permission ); } function hasPermission ( uint256 tradeDealId , address user , uint256 permission ) external view returns ( bool ) { uint256 userPermissions = getUserPermissions ( tradeDealId , user ); return ( userPermissions & permission ) != 0 ; } function getDefaultPermissionsForRole ( TradeDealLib . Role role ) public pure returns ( uint256 permissions ) { if ( role == TradeDealLib . Role . ADMIN ) { permissions = TradeDealLib . PERMISSION_DEPOSIT_FUNDS | TradeDealLib . PERMISSION_WITHDRAW_FUNDS | TradeDealLib . PERMISSION_DEPOSIT_COLLATERAL | TradeDealLib . PERMISSION_WITHDRAW_COLLATERAL | TradeDealLib . PERMISSION_DISTRIBUTE_INTEREST ; } else if ( role == TradeDealLib . Role . LENDER ) { permissions = TradeDealLib . PERMISSION_DEPOSIT_FUNDS ; } else if ( role == TradeDealLib . Role . BORROWER ) { permissions = TradeDealLib . PERMISSION_DEPOSIT_COLLATERAL | TradeDealLib . PERMISSION_WITHDRAW_FUNDS ; } else if ( role == TradeDealLib . Role . UNDERWRITER ) { permissions = TradeDealLib . PERMISSION_DEPOSIT_FUNDS | TradeDealLib . PERMISSION_DISTRIBUTE_INTEREST ; } else if ( role == TradeDealLib . Role . LIQUIDATOR ) { permissions = TradeDealLib . PERMISSION_WITHDRAW_COLLATERAL ; } // NONE role gets no permissions } function getUserAccessSummary ( uint256 tradeDealId , address user ) external view returns ( TradeDealLib . Role role , uint256 permissions , bool canDepositFunds , bool canWithdrawFunds , bool canDepositCollateral , bool canWithdrawCollateral , bool canDistributeInterest ) { role = getUserRole ( tradeDealId , user ); permissions = getUserPermissions ( tradeDealId , user ); canDepositFunds = ( permissions & TradeDealLib . PERMISSION_DEPOSIT_FUNDS ) != 0 ; canWithdrawFunds = ( permissions & TradeDealLib . PERMISSION_WITHDRAW_FUNDS ) != 0 ; canDepositCollateral = ( permissions & TradeDealLib . PERMISSION_DEPOSIT_COLLATERAL ) != 0 ; canWithdrawCollateral = ( permissions & TradeDealLib . PERMISSION_WITHDRAW_COLLATERAL ) != 0 ; canDistributeInterest = ( permissions & TradeDealLib . PERMISSION_DISTRIBUTE_INTEREST ) != 0 ; } // Helper functions (would access Diamond storage) function setUserRole ( uint256 tradeDealId , address user , TradeDealLib . Role role ) internal { // Implementation would access storage } function getUserRole ( uint256 tradeDealId , address user ) internal view returns ( TradeDealLib . Role ) { // Implementation would access storage } function setUserPermissions ( uint256 tradeDealId , address user , uint256 permissions ) internal { // Implementation would access storage } function getUserPermissions ( uint256 tradeDealId , address user ) internal view returns ( uint256 ) { // Implementation would access storage } modifier onlyTradeDealAdmin ( uint256 tradeDealId ) { require ( getUserRole ( tradeDealId , msg.sender ) == TradeDealLib . Role . ADMIN , \"Only trade deal admin can perform this action\" ); _ ; } } Events \u00b6 The library defines comprehensive events for trade deal lifecycle tracking: Core Trade Deal Events \u00b6 event TradeDealCreated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address nftAddress , address collateralAddress , address interestAddress , address usdcAddress ); event TradeDealActivated ( uint256 indexed tradeDealId ); event TradeDealDeactivated ( uint256 indexed tradeDealId ); Participant Management Events \u00b6 event TradeDealParticipantAdded ( uint256 indexed tradeDealId , address indexed participant ); event TradeDealParticipantRemoved ( uint256 indexed tradeDealId , address indexed participant ); event TradeDealRequiredClaimTopicsSet ( uint256 indexed tradeDealId , uint256 [] claimTopics ); Financial Operation Events \u00b6 event InvoiceDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event InvoiceWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event USDCDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 amount ); event USDCWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 amount ); event InterestDistributedForTradeDeal ( uint256 indexed tradeDealId , uint256 totalInterest , uint256 invoicePoolInterest , uint256 interestInterest , uint256 interestTokensMinted ); Enhanced Financial Events \u00b6 event TradeDealFullyFunded ( uint256 indexed tradeDealId , uint256 fundingTarget ); event TradeDealFundingWithdrawn ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount ); event TradeDealRepaid ( uint256 indexed tradeDealId , address indexed repayer , uint256 amount , bool fullyRepaid ); event CollateralTokensRedeemed ( uint256 indexed tradeDealId , address indexed redeemer , uint256 collateralAmount , uint256 usdcAmount ); Security Considerations \u00b6 Access Control Security \u00b6 Role-based permissions with fine-grained control Operation mode validation for different access patterns Participant verification through claim topics Admin-only functions for critical operations Financial Security \u00b6 Precise tracking of funding, withdrawals, and repayments Collateral validation and ownership verification Interest calculation accuracy and overflow protection Secure token transfer mechanisms Storage Security \u00b6 Diamond Standard storage pattern for isolation Consistent state management across operations Prevention of storage collisions Secure access to storage slots Gas Optimization \u00b6 Storage Efficiency \u00b6 Optimized storage layout for trade deal data Efficient mapping structures for lookups Minimal storage writes during operations Packed data structures where possible Function Efficiency \u00b6 Internal functions for gas savings Batch operations for multiple updates Efficient event emission patterns Optimized validation logic Error Handling \u00b6 Common Errors \u00b6 \"Trade deal does not exist\" - Operating on non-existent trade deal Permission denied errors for unauthorized operations Invalid parameter errors during creation/updates Insufficient balance errors during financial operations Claim topic validation failures Best Practices \u00b6 Validate trade deal existence before operations Check permissions before executing functions Validate all input parameters Handle edge cases gracefully Provide clear error messages for debugging Testing Considerations \u00b6 Unit Tests \u00b6 Trade deal creation and management functions Role and permission system testing Financial operation validation Storage pattern implementation Event emission verification Integration Tests \u00b6 Diamond facet integration Multi-user workflow testing Financial operation sequences Access control scenarios Cross-contract interactions Related Documentation \u00b6 ITradeDeal Interface - Trade deal interface definition TradeDealManagementFacet - Trade deal management implementation TradeDealAdminFacet - Administrative functions TradeDealOperationsFacet - Operational functions Diamond Standard Guide - Diamond pattern implementation Trade Deal Guide - Implementation guide for trade deals This library provides the core utilities and data structures for trade deal management within the Gemforce platform, implementing secure storage patterns, role-based access control, and comprehensive financial operations for collateralized finance instruments.","title":"Trade Deal Lib"},{"location":"smart-contracts/libraries/trade-deal-lib/#tradedeallib-library","text":"","title":"TradeDealLib Library"},{"location":"smart-contracts/libraries/trade-deal-lib/#overview","text":"The TradeDealLib library provides core utilities and data structures for managing collateralized trade deals within the Gemforce platform. This library implements the Diamond Standard storage pattern and provides essential functions for trade deal creation, management, participant handling, and financial operations including funding, repayment, and collateral management.","title":"Overview"},{"location":"smart-contracts/libraries/trade-deal-lib/#key-features","text":"Diamond Storage Pattern : Secure storage isolation using Diamond Standard Trade Deal Lifecycle Management : Complete CRUD operations for trade deals Role-Based Access Control : Flexible permission system with multiple operation modes Collateral Management : Invoice NFT collateral handling and redemption Financial Operations : USDC funding, withdrawal, and repayment tracking Interest Distribution : Automated interest calculation and distribution Multi-Mode Operations : Support for centralized, self-service, and hybrid models","title":"Key Features"},{"location":"smart-contracts/libraries/trade-deal-lib/#library-definition","text":"// SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; library TradeDealLib { // Enums enum OperationMode { CENTRALIZED , SELF_SERVICE , HYBRID , CUSTOM } enum Role { NONE , ADMIN , LENDER , BORROWER , UNDERWRITER , LIQUIDATOR } // Permission constants uint256 constant PERMISSION_DEPOSIT_FUNDS = 1 ; uint256 constant PERMISSION_WITHDRAW_FUNDS = 2 ; uint256 constant PERMISSION_DEPOSIT_COLLATERAL = 4 ; uint256 constant PERMISSION_WITHDRAW_COLLATERAL = 8 ; uint256 constant PERMISSION_DISTRIBUTE_INTEREST = 16 ; // Core data structures struct TradeDeal { ... } struct TradeDealStorage { ... } struct CreateTradeDealParams { ... } struct CreateTradeDealResult { ... } // Core functions function _createTradeDeal ( CreateTradeDealParams memory params ) internal returns ( CreateTradeDealResult memory ); function _updateTradeDeal (...) internal returns ( UpdateTradeDealResult memory ); function _activateTradeDeal ( uint256 tradeDealId ) internal returns ( TradeDealStateChangeResult memory ); function _deactivateTradeDeal ( uint256 tradeDealId ) internal returns ( TradeDealStateChangeResult memory ); }","title":"Library Definition"},{"location":"smart-contracts/libraries/trade-deal-lib/#data-structures","text":"","title":"Data Structures"},{"location":"smart-contracts/libraries/trade-deal-lib/#operationmode-enum","text":"enum OperationMode { CENTRALIZED , // Contract owner manages all fund operations SELF_SERVICE , // Borrowers can directly withdraw/repay funds HYBRID , // Mixed model with configurable permissions CUSTOM // Fine-grained permission configuration } Purpose : Defines the operational model for trade deal management. Values : - CENTRALIZED (0): All operations controlled by contract owner/admin - SELF_SERVICE (1): Borrowers have direct access to fund operations - HYBRID (2): Mixed model with some automated and some manual operations - CUSTOM (3): Fine-grained permission configuration per user","title":"OperationMode Enum"},{"location":"smart-contracts/libraries/trade-deal-lib/#role-enum","text":"enum Role { NONE , // No special role (default) ADMIN , // Full control over the trade deal LENDER , // Can deposit funds and receive Collateral tokens BORROWER , // Can deposit invoices and withdraw funds (in self-service) UNDERWRITER , // Can approve/reject deals, modify terms LIQUIDATOR // Can liquidate collateral if terms are violated } Purpose : Defines user roles within the trade deal system.","title":"Role Enum"},{"location":"smart-contracts/libraries/trade-deal-lib/#permission-constants","text":"uint256 constant PERMISSION_DEPOSIT_FUNDS = 1 ; uint256 constant PERMISSION_WITHDRAW_FUNDS = 2 ; uint256 constant PERMISSION_DEPOSIT_COLLATERAL = 4 ; uint256 constant PERMISSION_WITHDRAW_COLLATERAL = 8 ; uint256 constant PERMISSION_DISTRIBUTE_INTEREST = 16 ; Purpose : Bit flags for fine-grained permission control.","title":"Permission Constants"},{"location":"smart-contracts/libraries/trade-deal-lib/#tradedeal-struct","text":"struct TradeDeal { uint256 id ; string name ; string symbol ; // Symbol for the trade deal Collateral token uint256 interestRate ; uint256 collateralToInterestRatio ; bool active ; uint256 [] requiredClaimTopics ; // Claim topics required for participation address collateralAddress ; // Address of the Collateral token contract address interestAddress ; // Address of the VABI token contract address usdcAddress ; // Address of the USDC token contract OperationMode operationMode ; // Operation mode for the trade deal } Purpose : Core data structure representing a trade deal. Key Fields : - id : Unique identifier for the trade deal - name : Human-readable name for the trade deal - symbol : Symbol used for the associated Collateral token - interestRate : Interest rate for the trade deal (basis points) - collateralToInterestRatio : Ratio of collateral to interest tokens - requiredClaimTopics : Array of claim topics required for participation - operationMode : Operational model for the trade deal","title":"TradeDeal Struct"},{"location":"smart-contracts/libraries/trade-deal-lib/#tradedealstorage-struct","text":"struct TradeDealStorage { // Trade deal tracking mapping ( uint256 => TradeDeal ) tradeDeals ; uint256 [] tradeDealIds ; uint256 nextTradeDealId ; // Per-trade deal mappings mapping ( uint256 => uint256 []) tradeDealInvoices ; mapping ( uint256 => uint256 ) tradeDealUsdcBalances ; mapping ( uint256 => mapping ( address => bool )) tradeDealParticipants ; mapping ( uint256 => uint256 []) tradeDealRequiredClaimTopics ; // Role-based access control mapping ( uint256 => mapping ( address => Role )) userRoles ; mapping ( uint256 => mapping ( address => uint256 )) userPermissions ; // Enhanced functionality mapping ( uint256 => uint256 ) tradeDealFundingTargets ; mapping ( uint256 => bool ) tradeDealFundingWithdrawn ; mapping ( uint256 => uint256 ) tradeDealRepaidAmounts ; mapping ( uint256 => uint256 ) tradeDealTotalDebt ; mapping ( uint256 => uint256 ) tradeDealTotalWithdrawn ; mapping ( uint256 => mapping ( uint256 => address )) invoiceDepositors ; } Purpose : Diamond storage structure for all trade deal data.","title":"TradeDealStorage Struct"},{"location":"smart-contracts/libraries/trade-deal-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/trade-deal-lib/#trade-deal-creation","text":"","title":"Trade Deal Creation"},{"location":"smart-contracts/libraries/trade-deal-lib/#_createtradedeal","text":"function _createTradeDeal ( CreateTradeDealParams memory params ) internal returns ( CreateTradeDealResult memory ) Purpose : Create a new trade deal with specified parameters. Parameters : - params (CreateTradeDealParams): Struct containing all creation parameters CreateTradeDealParams Structure : struct CreateTradeDealParams { string name ; string symbol ; uint256 interestRate ; uint256 collateralToInterestRatio ; uint256 [] requiredClaimTopics ; address collateralAddress ; address interestAddress ; address usdcAddress ; OperationMode operationMode ; } Returns : CreateTradeDealResult struct with trade deal information Key Operations : - Assigns unique trade deal ID - Initializes trade deal data structure - Creates or assigns collateral token contract - Sets up required claim topics - Initializes financial tracking (funding targets, repayment amounts) Example Usage : // Create a new trade deal TradeDealLib . CreateTradeDealParams memory params = TradeDealLib . CreateTradeDealParams ({ name : \"Invoice Financing Deal #1\" , symbol : \"IFD1\" , interestRate : 1200 , // 12% APR collateralToInterestRatio : 1000000 , // 1:1 ratio requiredClaimTopics : new uint256 []( 1 ), collateralAddress : address ( 0 ), // Will create new token interestAddress : interestTokenAddress , usdcAddress : usdcTokenAddress , operationMode : TradeDealLib . OperationMode . SELF_SERVICE }); params . requiredClaimTopics [ 0 ] = 1 ; // KYC required TradeDealLib . CreateTradeDealResult memory result = TradeDealLib . _createTradeDeal ( params );","title":"_createTradeDeal()"},{"location":"smart-contracts/libraries/trade-deal-lib/#trade-deal-management","text":"","title":"Trade Deal Management"},{"location":"smart-contracts/libraries/trade-deal-lib/#_updatetradedeal","text":"function _updateTradeDeal ( uint256 tradeDealId , string memory name , string memory symbol , uint256 interestRate , uint256 collateralToInterestRatio , address collateralAddress , address interestAddress , address usdcAddress ) internal returns ( UpdateTradeDealResult memory ) Purpose : Update an existing trade deal's parameters. Parameters : - tradeDealId : ID of the trade deal to update - Various parameters to update (name, symbol, rates, addresses) Requirements : - Trade deal must exist - Caller must have appropriate permissions Example Usage : // Update trade deal interest rate TradeDealLib . UpdateTradeDealResult memory result = TradeDealLib . _updateTradeDeal ( tradeDealId , \"Updated Invoice Financing Deal #1\" , \"IFD1\" , 1500 , // Updated to 15% APR 1000000 , collateralAddress , interestAddress , usdcAddress );","title":"_updateTradeDeal()"},{"location":"smart-contracts/libraries/trade-deal-lib/#_activatetradedeal-_deactivatetradedeal","text":"function _activateTradeDeal ( uint256 tradeDealId ) internal returns ( TradeDealStateChangeResult memory ) function _deactivateTradeDeal ( uint256 tradeDealId ) internal returns ( TradeDealStateChangeResult memory ) Purpose : Activate or deactivate a trade deal. Parameters : - tradeDealId : ID of the trade deal to activate/deactivate Requirements : - Trade deal must exist - Appropriate permissions required Example Usage : // Activate a trade deal TradeDealLib . TradeDealStateChangeResult memory result = TradeDealLib . _activateTradeDeal ( tradeDealId ); // Deactivate a trade deal TradeDealLib . TradeDealStateChangeResult memory result = TradeDealLib . _deactivateTradeDeal ( tradeDealId );","title":"_activateTradeDeal() / _deactivateTradeDeal()"},{"location":"smart-contracts/libraries/trade-deal-lib/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/libraries/trade-deal-lib/#trade-deal-factory-contract","text":"// Factory contract for creating and managing trade deals contract TradeDealFactory { using TradeDealLib for TradeDealLib . TradeDealStorage ; event TradeDealCreated ( uint256 indexed tradeDealId , string name , address indexed creator , TradeDealLib . OperationMode operationMode ); event TradeDealUpdated ( uint256 indexed tradeDealId , string name ); function createStandardTradeDeal ( string memory name , string memory symbol , uint256 interestRate , address interestTokenAddress , address usdcTokenAddress ) external returns ( uint256 tradeDealId ) { // Prepare creation parameters TradeDealLib . CreateTradeDealParams memory params = TradeDealLib . CreateTradeDealParams ({ name : name , symbol : symbol , interestRate : interestRate , collateralToInterestRatio : 1000000 , // 1:1 ratio requiredClaimTopics : new uint256 []( 1 ), collateralAddress : address ( 0 ), // Will create new token interestAddress : interestTokenAddress , usdcAddress : usdcTokenAddress , operationMode : TradeDealLib . OperationMode . SELF_SERVICE }); // Set KYC requirement params . requiredClaimTopics [ 0 ] = 1 ; // Create the trade deal TradeDealLib . CreateTradeDealResult memory result = TradeDealLib . _createTradeDeal ( params ); emit TradeDealCreated ( result . tradeDealId , result . name , msg.sender , result . operationMode ); return result . tradeDealId ; } function createCustomTradeDeal ( TradeDealLib . CreateTradeDealParams memory params ) external returns ( uint256 tradeDealId ) { require ( bytes ( params . name ). length > 0 , \"Name cannot be empty\" ); require ( params . interestRate > 0 , \"Interest rate must be positive\" ); TradeDealLib . CreateTradeDealResult memory result = TradeDealLib . _createTradeDeal ( params ); emit TradeDealCreated ( result . tradeDealId , result . name , msg.sender , result . operationMode ); return result . tradeDealId ; } function updateTradeDeal ( uint256 tradeDealId , string memory name , string memory symbol , uint256 interestRate ) external onlyTradeDealAdmin ( tradeDealId ) { // Get current trade deal info TradeDealLib . TradeDeal memory tradeDeal = getTradeDeal ( tradeDealId ); TradeDealLib . UpdateTradeDealResult memory result = TradeDealLib . _updateTradeDeal ( tradeDealId , name , symbol , interestRate , tradeDeal . collateralToInterestRatio , tradeDeal . collateralAddress , tradeDeal . interestAddress , tradeDeal . usdcAddress ); emit TradeDealUpdated ( tradeDealId , name ); } function getTradeDeal ( uint256 tradeDealId ) public view returns ( TradeDealLib . TradeDeal memory ) { // Implementation would access storage and return trade deal // This is a simplified example } modifier onlyTradeDealAdmin ( uint256 tradeDealId ) { // Implementation would check if caller has admin role for the trade deal _ ; } }","title":"Trade Deal Factory Contract"},{"location":"smart-contracts/libraries/trade-deal-lib/#trade-deal-analytics-system","text":"// Analytics system for trade deal performance tracking contract TradeDealAnalytics { using TradeDealLib for TradeDealLib . TradeDealStorage ; struct TradeDealMetrics { uint256 totalFunded ; uint256 totalRepaid ; uint256 totalInterestEarned ; uint256 averageInterestRate ; uint256 defaultRate ; uint256 averageFundingTime ; } struct TradeDealPerformance { uint256 tradeDealId ; uint256 fundingTarget ; uint256 currentFunding ; uint256 repaidAmount ; uint256 outstandingDebt ; uint256 daysActive ; bool fullyFunded ; bool fullyRepaid ; TradeDealLib . OperationMode operationMode ; } mapping ( uint256 => uint256 ) public tradeDealCreationTime ; mapping ( uint256 => uint256 ) public tradeDealFundingTime ; mapping ( uint256 => uint256 ) public tradeDealRepaymentTime ; event MetricsUpdated ( TradeDealMetrics metrics ); event PerformanceCalculated ( uint256 indexed tradeDealId , TradeDealPerformance performance ); function calculateTradeDealPerformance ( uint256 tradeDealId ) external view returns ( TradeDealPerformance memory performance ) { // Get trade deal information TradeDealLib . TradeDeal memory tradeDeal = getTradeDeal ( tradeDealId ); performance . tradeDealId = tradeDealId ; performance . operationMode = tradeDeal . operationMode ; // Get financial metrics from storage performance . fundingTarget = getFundingTarget ( tradeDealId ); performance . currentFunding = getCurrentFunding ( tradeDealId ); performance . repaidAmount = getRepaidAmount ( tradeDealId ); performance . outstandingDebt = getOutstandingDebt ( tradeDealId ); // Calculate status performance . fullyFunded = performance . currentFunding >= performance . fundingTarget ; performance . fullyRepaid = performance . repaidAmount >= performance . outstandingDebt ; // Calculate days active uint256 creationTime = tradeDealCreationTime [ tradeDealId ]; if ( creationTime > 0 ) { performance . daysActive = ( block.timestamp - creationTime ) / 1 days ; } } function calculateOverallMetrics () external returns ( TradeDealMetrics memory metrics ) { uint256 [] memory allTradeDealIds = getAllTradeDealIds (); uint256 totalDeals = allTradeDealIds . length ; uint256 totalInterestRateSum = 0 ; uint256 defaultedDeals = 0 ; uint256 totalFundingTimeSum = 0 ; uint256 fundedDealsCount = 0 ; for ( uint256 i = 0 ; i < totalDeals ; i ++ ) { uint256 tradeDealId = allTradeDealIds [ i ]; TradeDealLib . TradeDeal memory tradeDeal = getTradeDeal ( tradeDealId ); // Accumulate metrics totalInterestRateSum += tradeDeal . interestRate ; metrics . totalFunded += getCurrentFunding ( tradeDealId ); metrics . totalRepaid += getRepaidAmount ( tradeDealId ); // Calculate funding time if deal is funded uint256 creationTime = tradeDealCreationTime [ tradeDealId ]; uint256 fundingTime = tradeDealFundingTime [ tradeDealId ]; if ( fundingTime > creationTime ) { totalFundingTimeSum += ( fundingTime - creationTime ); fundedDealsCount ++ ; } // Check for defaults (simplified logic) if ( isDefaulted ( tradeDealId )) { defaultedDeals ++ ; } } // Calculate averages if ( totalDeals > 0 ) { metrics . averageInterestRate = totalInterestRateSum / totalDeals ; metrics . defaultRate = ( defaultedDeals * 10000 ) / totalDeals ; // Basis points } if ( fundedDealsCount > 0 ) { metrics . averageFundingTime = totalFundingTimeSum / fundedDealsCount ; } metrics . totalInterestEarned = metrics . totalRepaid > metrics . totalFunded ? metrics . totalRepaid - metrics . totalFunded : 0 ; emit MetricsUpdated ( metrics ); return metrics ; } function getTradeDealsByOperationMode ( TradeDealLib . OperationMode mode ) external view returns ( uint256 [] memory tradeDealIds ) { uint256 [] memory allIds = getAllTradeDealIds (); uint256 count = 0 ; // Count matching trade deals for ( uint256 i = 0 ; i < allIds . length ; i ++ ) { TradeDealLib . TradeDeal memory tradeDeal = getTradeDeal ( allIds [ i ]); if ( tradeDeal . operationMode == mode ) { count ++ ; } } // Create result array tradeDealIds = new uint256 []( count ); uint256 index = 0 ; for ( uint256 i = 0 ; i < allIds . length ; i ++ ) { TradeDealLib . TradeDeal memory tradeDeal = getTradeDeal ( allIds [ i ]); if ( tradeDeal . operationMode == mode ) { tradeDealIds [ index ] = allIds [ i ]; index ++ ; } } } // Helper functions (would be implemented to access actual storage) function getTradeDeal ( uint256 tradeDealId ) internal view returns ( TradeDealLib . TradeDeal memory ) { // Implementation would access Diamond storage } function getFundingTarget ( uint256 tradeDealId ) internal view returns ( uint256 ) { // Implementation would access storage } function getCurrentFunding ( uint256 tradeDealId ) internal view returns ( uint256 ) { // Implementation would access storage } function getRepaidAmount ( uint256 tradeDealId ) internal view returns ( uint256 ) { // Implementation would access storage } function getOutstandingDebt ( uint256 tradeDealId ) internal view returns ( uint256 ) { // Implementation would access storage } function getAllTradeDealIds () internal view returns ( uint256 [] memory ) { // Implementation would access storage } function isDefaulted ( uint256 tradeDealId ) internal view returns ( bool ) { // Implementation would check default conditions } }","title":"Trade Deal Analytics System"},{"location":"smart-contracts/libraries/trade-deal-lib/#role-based-access-control-manager","text":"// Manager for trade deal roles and permissions contract TradeDealAccessManager { using TradeDealLib for TradeDealLib . TradeDealStorage ; event RoleAssigned ( uint256 indexed tradeDealId , address indexed user , TradeDealLib . Role role ); event PermissionGranted ( uint256 indexed tradeDealId , address indexed user , uint256 permission ); event PermissionRevoked ( uint256 indexed tradeDealId , address indexed user , uint256 permission ); function assignRole ( uint256 tradeDealId , address user , TradeDealLib . Role role ) external onlyTradeDealAdmin ( tradeDealId ) { // Set user role in storage setUserRole ( tradeDealId , user , role ); // Assign default permissions based on role uint256 defaultPermissions = getDefaultPermissionsForRole ( role ); setUserPermissions ( tradeDealId , user , defaultPermissions ); emit RoleAssigned ( tradeDealId , user , role ); } function grantPermission ( uint256 tradeDealId , address user , uint256 permission ) external onlyTradeDealAdmin ( tradeDealId ) { uint256 currentPermissions = getUserPermissions ( tradeDealId , user ); uint256 newPermissions = currentPermissions | permission ; setUserPermissions ( tradeDealId , user , newPermissions ); emit PermissionGranted ( tradeDealId , user , permission ); } function revokePermission ( uint256 tradeDealId , address user , uint256 permission ) external onlyTradeDealAdmin ( tradeDealId ) { uint256 currentPermissions = getUserPermissions ( tradeDealId , user ); uint256 newPermissions = currentPermissions & ~ permission ; setUserPermissions ( tradeDealId , user , newPermissions ); emit PermissionRevoked ( tradeDealId , user , permission ); } function hasPermission ( uint256 tradeDealId , address user , uint256 permission ) external view returns ( bool ) { uint256 userPermissions = getUserPermissions ( tradeDealId , user ); return ( userPermissions & permission ) != 0 ; } function getDefaultPermissionsForRole ( TradeDealLib . Role role ) public pure returns ( uint256 permissions ) { if ( role == TradeDealLib . Role . ADMIN ) { permissions = TradeDealLib . PERMISSION_DEPOSIT_FUNDS | TradeDealLib . PERMISSION_WITHDRAW_FUNDS | TradeDealLib . PERMISSION_DEPOSIT_COLLATERAL | TradeDealLib . PERMISSION_WITHDRAW_COLLATERAL | TradeDealLib . PERMISSION_DISTRIBUTE_INTEREST ; } else if ( role == TradeDealLib . Role . LENDER ) { permissions = TradeDealLib . PERMISSION_DEPOSIT_FUNDS ; } else if ( role == TradeDealLib . Role . BORROWER ) { permissions = TradeDealLib . PERMISSION_DEPOSIT_COLLATERAL | TradeDealLib . PERMISSION_WITHDRAW_FUNDS ; } else if ( role == TradeDealLib . Role . UNDERWRITER ) { permissions = TradeDealLib . PERMISSION_DEPOSIT_FUNDS | TradeDealLib . PERMISSION_DISTRIBUTE_INTEREST ; } else if ( role == TradeDealLib . Role . LIQUIDATOR ) { permissions = TradeDealLib . PERMISSION_WITHDRAW_COLLATERAL ; } // NONE role gets no permissions } function getUserAccessSummary ( uint256 tradeDealId , address user ) external view returns ( TradeDealLib . Role role , uint256 permissions , bool canDepositFunds , bool canWithdrawFunds , bool canDepositCollateral , bool canWithdrawCollateral , bool canDistributeInterest ) { role = getUserRole ( tradeDealId , user ); permissions = getUserPermissions ( tradeDealId , user ); canDepositFunds = ( permissions & TradeDealLib . PERMISSION_DEPOSIT_FUNDS ) != 0 ; canWithdrawFunds = ( permissions & TradeDealLib . PERMISSION_WITHDRAW_FUNDS ) != 0 ; canDepositCollateral = ( permissions & TradeDealLib . PERMISSION_DEPOSIT_COLLATERAL ) != 0 ; canWithdrawCollateral = ( permissions & TradeDealLib . PERMISSION_WITHDRAW_COLLATERAL ) != 0 ; canDistributeInterest = ( permissions & TradeDealLib . PERMISSION_DISTRIBUTE_INTEREST ) != 0 ; } // Helper functions (would access Diamond storage) function setUserRole ( uint256 tradeDealId , address user , TradeDealLib . Role role ) internal { // Implementation would access storage } function getUserRole ( uint256 tradeDealId , address user ) internal view returns ( TradeDealLib . Role ) { // Implementation would access storage } function setUserPermissions ( uint256 tradeDealId , address user , uint256 permissions ) internal { // Implementation would access storage } function getUserPermissions ( uint256 tradeDealId , address user ) internal view returns ( uint256 ) { // Implementation would access storage } modifier onlyTradeDealAdmin ( uint256 tradeDealId ) { require ( getUserRole ( tradeDealId , msg.sender ) == TradeDealLib . Role . ADMIN , \"Only trade deal admin can perform this action\" ); _ ; } }","title":"Role-Based Access Control Manager"},{"location":"smart-contracts/libraries/trade-deal-lib/#events","text":"The library defines comprehensive events for trade deal lifecycle tracking:","title":"Events"},{"location":"smart-contracts/libraries/trade-deal-lib/#core-trade-deal-events","text":"event TradeDealCreated ( uint256 indexed tradeDealId , string name , string symbol , uint256 interestRate , uint256 collateralToInterestRatio , bool active , address nftAddress , address collateralAddress , address interestAddress , address usdcAddress ); event TradeDealActivated ( uint256 indexed tradeDealId ); event TradeDealDeactivated ( uint256 indexed tradeDealId );","title":"Core Trade Deal Events"},{"location":"smart-contracts/libraries/trade-deal-lib/#participant-management-events","text":"event TradeDealParticipantAdded ( uint256 indexed tradeDealId , address indexed participant ); event TradeDealParticipantRemoved ( uint256 indexed tradeDealId , address indexed participant ); event TradeDealRequiredClaimTopicsSet ( uint256 indexed tradeDealId , uint256 [] claimTopics );","title":"Participant Management Events"},{"location":"smart-contracts/libraries/trade-deal-lib/#financial-operation-events","text":"event InvoiceDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event InvoiceWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 indexed tokenId ); event USDCDepositedToTradeDeal ( uint256 indexed tradeDealId , uint256 amount ); event USDCWithdrawnFromTradeDeal ( uint256 indexed tradeDealId , uint256 amount ); event InterestDistributedForTradeDeal ( uint256 indexed tradeDealId , uint256 totalInterest , uint256 invoicePoolInterest , uint256 interestInterest , uint256 interestTokensMinted );","title":"Financial Operation Events"},{"location":"smart-contracts/libraries/trade-deal-lib/#enhanced-financial-events","text":"event TradeDealFullyFunded ( uint256 indexed tradeDealId , uint256 fundingTarget ); event TradeDealFundingWithdrawn ( uint256 indexed tradeDealId , address indexed recipient , uint256 amount ); event TradeDealRepaid ( uint256 indexed tradeDealId , address indexed repayer , uint256 amount , bool fullyRepaid ); event CollateralTokensRedeemed ( uint256 indexed tradeDealId , address indexed redeemer , uint256 collateralAmount , uint256 usdcAmount );","title":"Enhanced Financial Events"},{"location":"smart-contracts/libraries/trade-deal-lib/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/trade-deal-lib/#access-control-security","text":"Role-based permissions with fine-grained control Operation mode validation for different access patterns Participant verification through claim topics Admin-only functions for critical operations","title":"Access Control Security"},{"location":"smart-contracts/libraries/trade-deal-lib/#financial-security","text":"Precise tracking of funding, withdrawals, and repayments Collateral validation and ownership verification Interest calculation accuracy and overflow protection Secure token transfer mechanisms","title":"Financial Security"},{"location":"smart-contracts/libraries/trade-deal-lib/#storage-security","text":"Diamond Standard storage pattern for isolation Consistent state management across operations Prevention of storage collisions Secure access to storage slots","title":"Storage Security"},{"location":"smart-contracts/libraries/trade-deal-lib/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/libraries/trade-deal-lib/#storage-efficiency","text":"Optimized storage layout for trade deal data Efficient mapping structures for lookups Minimal storage writes during operations Packed data structures where possible","title":"Storage Efficiency"},{"location":"smart-contracts/libraries/trade-deal-lib/#function-efficiency","text":"Internal functions for gas savings Batch operations for multiple updates Efficient event emission patterns Optimized validation logic","title":"Function Efficiency"},{"location":"smart-contracts/libraries/trade-deal-lib/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/libraries/trade-deal-lib/#common-errors","text":"\"Trade deal does not exist\" - Operating on non-existent trade deal Permission denied errors for unauthorized operations Invalid parameter errors during creation/updates Insufficient balance errors during financial operations Claim topic validation failures","title":"Common Errors"},{"location":"smart-contracts/libraries/trade-deal-lib/#best-practices","text":"Validate trade deal existence before operations Check permissions before executing functions Validate all input parameters Handle edge cases gracefully Provide clear error messages for debugging","title":"Best Practices"},{"location":"smart-contracts/libraries/trade-deal-lib/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/libraries/trade-deal-lib/#unit-tests","text":"Trade deal creation and management functions Role and permission system testing Financial operation validation Storage pattern implementation Event emission verification","title":"Unit Tests"},{"location":"smart-contracts/libraries/trade-deal-lib/#integration-tests","text":"Diamond facet integration Multi-user workflow testing Financial operation sequences Access control scenarios Cross-contract interactions","title":"Integration Tests"},{"location":"smart-contracts/libraries/trade-deal-lib/#related-documentation","text":"ITradeDeal Interface - Trade deal interface definition TradeDealManagementFacet - Trade deal management implementation TradeDealAdminFacet - Administrative functions TradeDealOperationsFacet - Operational functions Diamond Standard Guide - Diamond pattern implementation Trade Deal Guide - Implementation guide for trade deals This library provides the core utilities and data structures for trade deal management within the Gemforce platform, implementing secure storage patterns, role-based access control, and comprehensive financial operations for collateralized finance instruments.","title":"Related Documentation"},{"location":"smart-contracts/libraries/trusted-issuer-lib/","text":"TrustedIssuerLib Library \u00b6 Overview \u00b6 TrustedIssuerLib is a comprehensive library for managing trusted claim issuers in the Gemforce identity system. This library implements the trusted issuer registry functionality, allowing the platform to maintain a list of authorized entities that can issue identity claims for KYC/AML compliance and other verification purposes. Key Features \u00b6 Trusted Issuer Management : Add, remove, and update trusted claim issuers Claim Topic Authorization : Control which claim topics each issuer can validate Identity Verification : Integration with ERC734/ERC735 identity standards Access Control : Owner-based permissions for issuer management Efficient Lookups : Optimized storage for fast issuer validation Batch Operations : Support for multiple claim topics per issuer Storage Structure \u00b6 TrustedIssuerContract \u00b6 struct TrustedIssuerContract { mapping ( address => TrustedIssuer ) trustedIssuers ; address [] trustedIssuerAddresses ; address owner ; } TrustedIssuerStorage \u00b6 struct TrustedIssuerStorage { TrustedIssuerContract trustedIssuerContract ; } Storage Position \u00b6 bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nomyx.gemforce.TrustedIssuerStorage.storage\" ); Core Functions \u00b6 Storage Access \u00b6 trustedIssuerStorage() \u00b6 function trustedIssuerStorage () internal pure returns ( TrustedIssuerStorage storage ds ) Returns the trusted issuer storage struct using assembly for gas efficiency. Issuer Management \u00b6 _addTrustedIssuer() \u00b6 function _addTrustedIssuer ( TrustedIssuerContract storage , address _trustedIssuer , uint [] calldata _claimTopics ) internal Adds a new trusted issuer with specified claim topics. Parameters: - _trustedIssuer : Address of the claim issuer contract - _claimTopics : Array of claim topic IDs the issuer can validate Features: - Duplicate Prevention : Only adds issuer if not already present - Topic Assignment : Associates specific claim topics with the issuer - Address Tracking : Maintains array of issuer addresses for enumeration removeTrustedIssuer() \u00b6 function removeTrustedIssuer ( TrustedIssuerContract storage self , address _trustedIssuer ) internal Removes a trusted issuer from the registry. Parameters: - _trustedIssuer : Address of the issuer to remove Note: This function only removes the issuer mapping but doesn't clean up the address array for gas efficiency. updateIssuerClaimTopics() \u00b6 function updateIssuerClaimTopics ( TrustedIssuerContract storage self , address _trustedIssuer , uint [] calldata _claimTopics ) internal Updates the claim topics that a trusted issuer is authorized to validate. Parameters: - _trustedIssuer : Address of the issuer to update - _claimTopics : New array of authorized claim topics Issuer Queries \u00b6 _getTrustedIssuer() \u00b6 function _getTrustedIssuer ( TrustedIssuerContract storage , address issuerAddress ) internal view returns ( TrustedIssuer memory trustedIssuer ) Retrieves the trusted issuer struct for a given address. getTrustedIssuers() \u00b6 function getTrustedIssuers ( TrustedIssuerContract storage self ) internal view returns ( TrustedIssuer [] memory trustedIssuers ) Returns an array of all trusted issuers in the registry. Returns: - Array of TrustedIssuer structs containing issuer details isTrustedIssuer() \u00b6 function isTrustedIssuer ( address _issuer ) internal view returns ( bool isTrusted ) Checks if an address is a trusted issuer. Parameters: - _issuer : Address to check Returns: - true if the address is a trusted issuer, false otherwise Claim Topic Management \u00b6 getTrustedIssuerClaimTopics() \u00b6 function getTrustedIssuerClaimTopics ( address _trustedIssuer ) external view returns ( uint [] memory ) Returns the claim topics that a trusted issuer is authorized to validate. Parameters: - _trustedIssuer : Address of the trusted issuer Returns: - Array of claim topic IDs hasTrustedIssuerClaimTopic() \u00b6 function hasTrustedIssuerClaimTopic ( address _issuer , uint _claimTopic ) external view returns ( bool hasTopic ) Checks if a trusted issuer is authorized for a specific claim topic. Parameters: - _issuer : Address of the issuer - _claimTopic : Claim topic ID to check Returns: - true if the issuer is authorized for the topic, false otherwise Internal Helper Functions \u00b6 _setTrustedIssuer() \u00b6 function _setTrustedIssuer ( TrustedIssuerContract storage self , address issuerAddress , TrustedIssuer memory trustedIssuer ) internal Internal function to set or update a trusted issuer. Features: - Address Tracking : Adds to address array if new issuer - Mapping Update : Updates the issuer mapping - Efficient Storage : Avoids duplicate address entries Data Structures \u00b6 TrustedIssuer \u00b6 struct TrustedIssuer { address claimIssuer ; uint [] claimTopics ; } Fields: - claimIssuer : Address of the claim issuer contract - claimTopics : Array of claim topic IDs the issuer can validate Usage Examples \u00b6 Adding a Trusted Issuer \u00b6 function addKYCIssuer ( address issuerAddress ) external onlyOwner { uint [] memory kycTopics = new uint []( 2 ); kycTopics [ 0 ] = 1 ; // KYC topic kycTopics [ 1 ] = 2 ; // AML topic TrustedIssuerLib . _addTrustedIssuer ( trustedIssuerStorage (). trustedIssuerContract , issuerAddress , kycTopics ); } Validating an Issuer \u00b6 function validateClaim ( address issuer , uint claimTopic ) external view returns ( bool ) { return TrustedIssuerLib . isTrustedIssuer ( issuer ) && TrustedIssuerLib . hasTrustedIssuerClaimTopic ( issuer , claimTopic ); } Getting All Trusted Issuers \u00b6 function getAllTrustedIssuers () external view returns ( TrustedIssuer [] memory ) { return TrustedIssuerLib . getTrustedIssuers ( trustedIssuerStorage (). trustedIssuerContract ); } Updating Issuer Permissions \u00b6 function updateIssuerTopics ( address issuer , uint [] calldata newTopics ) external onlyOwner { TrustedIssuerLib . updateIssuerClaimTopics ( trustedIssuerStorage (). trustedIssuerContract , issuer , newTopics ); } Integration with Identity System \u00b6 ERC734/ERC735 Integration \u00b6 // Validate a claim during identity verification function validateIdentityClaim ( address identity , uint claimTopic , address issuer ) external view returns ( bool ) { // Check if issuer is trusted if ( ! TrustedIssuerLib . isTrustedIssuer ( issuer )) { return false ; } // Check if issuer can validate this topic if ( ! TrustedIssuerLib . hasTrustedIssuerClaimTopic ( issuer , claimTopic )) { return false ; } // Additional validation logic... return true ; } Claim Topic Constants \u00b6 Common claim topics used in the system: uint256 constant KYC_TOPIC = 1 ; uint256 constant AML_TOPIC = 2 ; uint256 constant ACCREDITED_INVESTOR_TOPIC = 3 ; uint256 constant RESIDENCE_TOPIC = 4 ; uint256 constant SANCTIONS_TOPIC = 5 ; Security Features \u00b6 Access Control \u00b6 Owner-Only Operations : Critical functions require owner permissions Issuer Validation : Comprehensive validation before adding issuers Topic Authorization : Granular control over claim topic permissions Validation Mechanisms \u00b6 Address Verification : Ensures issuer addresses are valid contracts Topic Consistency : Validates claim topic assignments State Integrity : Maintains consistent storage state Gas Optimization \u00b6 Efficient Lookups : O(1) issuer validation using mappings Batch Operations : Support for multiple topics in single transaction Storage Patterns : Optimized storage layout for minimal gas costs Common Claim Topics \u00b6 Identity Verification \u00b6 KYC (Know Your Customer) : Topic ID 1 AML (Anti-Money Laundering) : Topic ID 2 Sanctions Screening : Topic ID 5 Financial Compliance \u00b6 Accredited Investor : Topic ID 3 Residence Verification : Topic ID 4 Tax Status : Topic ID 6 Platform-Specific \u00b6 Whitelist Status : Topic ID 100 VIP Status : Topic ID 101 Trading Permissions : Topic ID 102 Best Practices \u00b6 Issuer Management \u00b6 Thorough Vetting : Carefully vet all trusted issuers before adding Regular Audits : Periodically review and update issuer list Topic Specificity : Assign only necessary claim topics to each issuer Documentation : Maintain clear documentation of issuer purposes Security Considerations \u00b6 Multi-Sig Control : Use multi-signature wallets for owner operations Gradual Rollout : Add new issuers gradually and monitor performance Emergency Procedures : Have procedures for quickly removing compromised issuers Backup Systems : Maintain backup issuer systems for critical topics Gas Optimization \u00b6 Batch Updates : Group multiple issuer updates in single transactions Efficient Queries : Use view functions for validation checks Storage Cleanup : Periodically clean up removed issuer addresses Topic Grouping : Group related claim topics for efficiency Error Handling \u00b6 Common Validation Checks \u00b6 modifier onlyTrustedIssuer ( address issuer , uint claimTopic ) { require ( TrustedIssuerLib . isTrustedIssuer ( issuer ), \"TrustedIssuerLib: Issuer not trusted\" ); require ( TrustedIssuerLib . hasTrustedIssuerClaimTopic ( issuer , claimTopic ), \"TrustedIssuerLib: Issuer not authorized for topic\" ); _ ; } Event Logging \u00b6 event TrustedIssuerAdded ( address indexed issuer , uint [] claimTopics ); event TrustedIssuerRemoved ( address indexed issuer ); event IssuerTopicsUpdated ( address indexed issuer , uint [] newTopics ); Related Documentation \u00b6 Identity Registry Facet - Identity management interface Trusted Issuers Registry Facet - Registry management interface ERC734 Interface - Key Manager interface ERC735 Interface - Claim Holder interface Enhanced Identity System EIP - Identity system specification Migration and Upgrades \u00b6 Storage Compatibility \u00b6 Maintains backward compatibility with existing issuer data Supports incremental updates to claim topic assignments Provides migration paths for issuer address changes Upgrade Considerations \u00b6 Storage position remains constant across upgrades New claim topics can be added without affecting existing issuers Issuer removal requires careful consideration of dependent systems","title":"Trusted Issuer Lib"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#trustedissuerlib-library","text":"","title":"TrustedIssuerLib Library"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#overview","text":"TrustedIssuerLib is a comprehensive library for managing trusted claim issuers in the Gemforce identity system. This library implements the trusted issuer registry functionality, allowing the platform to maintain a list of authorized entities that can issue identity claims for KYC/AML compliance and other verification purposes.","title":"Overview"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#key-features","text":"Trusted Issuer Management : Add, remove, and update trusted claim issuers Claim Topic Authorization : Control which claim topics each issuer can validate Identity Verification : Integration with ERC734/ERC735 identity standards Access Control : Owner-based permissions for issuer management Efficient Lookups : Optimized storage for fast issuer validation Batch Operations : Support for multiple claim topics per issuer","title":"Key Features"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#storage-structure","text":"","title":"Storage Structure"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#trustedissuercontract","text":"struct TrustedIssuerContract { mapping ( address => TrustedIssuer ) trustedIssuers ; address [] trustedIssuerAddresses ; address owner ; }","title":"TrustedIssuerContract"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#trustedissuerstorage","text":"struct TrustedIssuerStorage { TrustedIssuerContract trustedIssuerContract ; }","title":"TrustedIssuerStorage"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#storage-position","text":"bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nomyx.gemforce.TrustedIssuerStorage.storage\" );","title":"Storage Position"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#storage-access","text":"","title":"Storage Access"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#trustedissuerstorage_1","text":"function trustedIssuerStorage () internal pure returns ( TrustedIssuerStorage storage ds ) Returns the trusted issuer storage struct using assembly for gas efficiency.","title":"trustedIssuerStorage()"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#issuer-management","text":"","title":"Issuer Management"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#_addtrustedissuer","text":"function _addTrustedIssuer ( TrustedIssuerContract storage , address _trustedIssuer , uint [] calldata _claimTopics ) internal Adds a new trusted issuer with specified claim topics. Parameters: - _trustedIssuer : Address of the claim issuer contract - _claimTopics : Array of claim topic IDs the issuer can validate Features: - Duplicate Prevention : Only adds issuer if not already present - Topic Assignment : Associates specific claim topics with the issuer - Address Tracking : Maintains array of issuer addresses for enumeration","title":"_addTrustedIssuer()"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#removetrustedissuer","text":"function removeTrustedIssuer ( TrustedIssuerContract storage self , address _trustedIssuer ) internal Removes a trusted issuer from the registry. Parameters: - _trustedIssuer : Address of the issuer to remove Note: This function only removes the issuer mapping but doesn't clean up the address array for gas efficiency.","title":"removeTrustedIssuer()"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#updateissuerclaimtopics","text":"function updateIssuerClaimTopics ( TrustedIssuerContract storage self , address _trustedIssuer , uint [] calldata _claimTopics ) internal Updates the claim topics that a trusted issuer is authorized to validate. Parameters: - _trustedIssuer : Address of the issuer to update - _claimTopics : New array of authorized claim topics","title":"updateIssuerClaimTopics()"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#issuer-queries","text":"","title":"Issuer Queries"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#_gettrustedissuer","text":"function _getTrustedIssuer ( TrustedIssuerContract storage , address issuerAddress ) internal view returns ( TrustedIssuer memory trustedIssuer ) Retrieves the trusted issuer struct for a given address.","title":"_getTrustedIssuer()"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#gettrustedissuers","text":"function getTrustedIssuers ( TrustedIssuerContract storage self ) internal view returns ( TrustedIssuer [] memory trustedIssuers ) Returns an array of all trusted issuers in the registry. Returns: - Array of TrustedIssuer structs containing issuer details","title":"getTrustedIssuers()"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#istrustedissuer","text":"function isTrustedIssuer ( address _issuer ) internal view returns ( bool isTrusted ) Checks if an address is a trusted issuer. Parameters: - _issuer : Address to check Returns: - true if the address is a trusted issuer, false otherwise","title":"isTrustedIssuer()"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#claim-topic-management","text":"","title":"Claim Topic Management"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#gettrustedissuerclaimtopics","text":"function getTrustedIssuerClaimTopics ( address _trustedIssuer ) external view returns ( uint [] memory ) Returns the claim topics that a trusted issuer is authorized to validate. Parameters: - _trustedIssuer : Address of the trusted issuer Returns: - Array of claim topic IDs","title":"getTrustedIssuerClaimTopics()"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#hastrustedissuerclaimtopic","text":"function hasTrustedIssuerClaimTopic ( address _issuer , uint _claimTopic ) external view returns ( bool hasTopic ) Checks if a trusted issuer is authorized for a specific claim topic. Parameters: - _issuer : Address of the issuer - _claimTopic : Claim topic ID to check Returns: - true if the issuer is authorized for the topic, false otherwise","title":"hasTrustedIssuerClaimTopic()"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#internal-helper-functions","text":"","title":"Internal Helper Functions"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#_settrustedissuer","text":"function _setTrustedIssuer ( TrustedIssuerContract storage self , address issuerAddress , TrustedIssuer memory trustedIssuer ) internal Internal function to set or update a trusted issuer. Features: - Address Tracking : Adds to address array if new issuer - Mapping Update : Updates the issuer mapping - Efficient Storage : Avoids duplicate address entries","title":"_setTrustedIssuer()"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#data-structures","text":"","title":"Data Structures"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#trustedissuer","text":"struct TrustedIssuer { address claimIssuer ; uint [] claimTopics ; } Fields: - claimIssuer : Address of the claim issuer contract - claimTopics : Array of claim topic IDs the issuer can validate","title":"TrustedIssuer"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#usage-examples","text":"","title":"Usage Examples"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#adding-a-trusted-issuer","text":"function addKYCIssuer ( address issuerAddress ) external onlyOwner { uint [] memory kycTopics = new uint []( 2 ); kycTopics [ 0 ] = 1 ; // KYC topic kycTopics [ 1 ] = 2 ; // AML topic TrustedIssuerLib . _addTrustedIssuer ( trustedIssuerStorage (). trustedIssuerContract , issuerAddress , kycTopics ); }","title":"Adding a Trusted Issuer"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#validating-an-issuer","text":"function validateClaim ( address issuer , uint claimTopic ) external view returns ( bool ) { return TrustedIssuerLib . isTrustedIssuer ( issuer ) && TrustedIssuerLib . hasTrustedIssuerClaimTopic ( issuer , claimTopic ); }","title":"Validating an Issuer"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#getting-all-trusted-issuers","text":"function getAllTrustedIssuers () external view returns ( TrustedIssuer [] memory ) { return TrustedIssuerLib . getTrustedIssuers ( trustedIssuerStorage (). trustedIssuerContract ); }","title":"Getting All Trusted Issuers"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#updating-issuer-permissions","text":"function updateIssuerTopics ( address issuer , uint [] calldata newTopics ) external onlyOwner { TrustedIssuerLib . updateIssuerClaimTopics ( trustedIssuerStorage (). trustedIssuerContract , issuer , newTopics ); }","title":"Updating Issuer Permissions"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#integration-with-identity-system","text":"","title":"Integration with Identity System"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#erc734erc735-integration","text":"// Validate a claim during identity verification function validateIdentityClaim ( address identity , uint claimTopic , address issuer ) external view returns ( bool ) { // Check if issuer is trusted if ( ! TrustedIssuerLib . isTrustedIssuer ( issuer )) { return false ; } // Check if issuer can validate this topic if ( ! TrustedIssuerLib . hasTrustedIssuerClaimTopic ( issuer , claimTopic )) { return false ; } // Additional validation logic... return true ; }","title":"ERC734/ERC735 Integration"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#claim-topic-constants","text":"Common claim topics used in the system: uint256 constant KYC_TOPIC = 1 ; uint256 constant AML_TOPIC = 2 ; uint256 constant ACCREDITED_INVESTOR_TOPIC = 3 ; uint256 constant RESIDENCE_TOPIC = 4 ; uint256 constant SANCTIONS_TOPIC = 5 ;","title":"Claim Topic Constants"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#security-features","text":"","title":"Security Features"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#access-control","text":"Owner-Only Operations : Critical functions require owner permissions Issuer Validation : Comprehensive validation before adding issuers Topic Authorization : Granular control over claim topic permissions","title":"Access Control"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#validation-mechanisms","text":"Address Verification : Ensures issuer addresses are valid contracts Topic Consistency : Validates claim topic assignments State Integrity : Maintains consistent storage state","title":"Validation Mechanisms"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#gas-optimization","text":"Efficient Lookups : O(1) issuer validation using mappings Batch Operations : Support for multiple topics in single transaction Storage Patterns : Optimized storage layout for minimal gas costs","title":"Gas Optimization"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#common-claim-topics","text":"","title":"Common Claim Topics"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#identity-verification","text":"KYC (Know Your Customer) : Topic ID 1 AML (Anti-Money Laundering) : Topic ID 2 Sanctions Screening : Topic ID 5","title":"Identity Verification"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#financial-compliance","text":"Accredited Investor : Topic ID 3 Residence Verification : Topic ID 4 Tax Status : Topic ID 6","title":"Financial Compliance"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#platform-specific","text":"Whitelist Status : Topic ID 100 VIP Status : Topic ID 101 Trading Permissions : Topic ID 102","title":"Platform-Specific"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#best-practices","text":"","title":"Best Practices"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#issuer-management_1","text":"Thorough Vetting : Carefully vet all trusted issuers before adding Regular Audits : Periodically review and update issuer list Topic Specificity : Assign only necessary claim topics to each issuer Documentation : Maintain clear documentation of issuer purposes","title":"Issuer Management"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#security-considerations","text":"Multi-Sig Control : Use multi-signature wallets for owner operations Gradual Rollout : Add new issuers gradually and monitor performance Emergency Procedures : Have procedures for quickly removing compromised issuers Backup Systems : Maintain backup issuer systems for critical topics","title":"Security Considerations"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#gas-optimization_1","text":"Batch Updates : Group multiple issuer updates in single transactions Efficient Queries : Use view functions for validation checks Storage Cleanup : Periodically clean up removed issuer addresses Topic Grouping : Group related claim topics for efficiency","title":"Gas Optimization"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#common-validation-checks","text":"modifier onlyTrustedIssuer ( address issuer , uint claimTopic ) { require ( TrustedIssuerLib . isTrustedIssuer ( issuer ), \"TrustedIssuerLib: Issuer not trusted\" ); require ( TrustedIssuerLib . hasTrustedIssuerClaimTopic ( issuer , claimTopic ), \"TrustedIssuerLib: Issuer not authorized for topic\" ); _ ; }","title":"Common Validation Checks"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#event-logging","text":"event TrustedIssuerAdded ( address indexed issuer , uint [] claimTopics ); event TrustedIssuerRemoved ( address indexed issuer ); event IssuerTopicsUpdated ( address indexed issuer , uint [] newTopics );","title":"Event Logging"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#related-documentation","text":"Identity Registry Facet - Identity management interface Trusted Issuers Registry Facet - Registry management interface ERC734 Interface - Key Manager interface ERC735 Interface - Claim Holder interface Enhanced Identity System EIP - Identity system specification","title":"Related Documentation"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#migration-and-upgrades","text":"","title":"Migration and Upgrades"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#storage-compatibility","text":"Maintains backward compatibility with existing issuer data Supports incremental updates to claim topic assignments Provides migration paths for issuer address changes","title":"Storage Compatibility"},{"location":"smart-contracts/libraries/trusted-issuer-lib/#upgrade-considerations","text":"Storage position remains constant across upgrades New claim topics can be added without affecting existing issuers Issuer removal requires careful consideration of dependent systems","title":"Upgrade Considerations"},{"location":"smart-contracts/libraries/variable-price-lib/","text":"VariablePriceLib Library \u00b6 Overview \u00b6 The VariablePriceLib library provides core utilities for managing dynamic pricing mechanisms within the Gemforce platform. This library implements flexible pricing strategies that automatically adjust prices based on configurable modifiers, supporting fixed increments, exponential growth, and inverse logarithmic scaling for various tokenomics scenarios. Key Features \u00b6 Dynamic Pricing : Automatic price adjustments after each transaction Multiple Price Modifiers : Fixed, exponential, and inverse logarithmic pricing strategies Configurable Parameters : Customizable price modifier factors and maximum price limits Gas Efficient : Optimized calculations for on-chain price updates Event Tracking : Price change notifications for external monitoring Integration Ready : Seamless integration with token sales and marketplace systems Library Definition \u00b6 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; library VariablePriceLib { // Storage management function variablePriceStorage () internal pure returns ( VariablePriceStorage storage ); // Price operations function _updatePrice ( VariablePriceContract storage self ) internal returns ( uint256 _price , uint256 updatedPrice ); function _currentPrice ( VariablePriceContract storage self ) internal view returns ( uint256 _price ); function _setPrice ( VariablePriceContract storage self , uint256 _price ) internal returns ( uint256 _newPrice ); // Price modification function _increaseClaimPrice ( VariablePriceContract storage self ) internal ; } Data Structures \u00b6 PriceModifier Enum \u00b6 enum PriceModifier { None , // No price modification Fixed , // Fixed amount increase Exponential , // Exponential price growth InverseLog // Inverse logarithmic scaling } Purpose : Defines the pricing strategy for automatic price adjustments. Strategies : - None : Price remains constant - Fixed : Price increases by a fixed amount each time - Exponential : Price increases by a percentage of current price - InverseLog : Price increases diminish as price grows (dampening effect) VariablePriceContract Struct \u00b6 struct VariablePriceContract { uint256 price ; // Current price of the token PriceModifier priceModifier ; // Price modification strategy uint256 priceModifierFactor ; // Factor for price calculations uint256 maxPrice ; // Maximum price limit } Purpose : Complete configuration for variable pricing behavior. Components : - price : Current token price in wei - priceModifier : Strategy for price increases - priceModifierFactor : Calculation parameter for price adjustments - maxPrice : Upper limit to prevent excessive pricing VariablePriceStorage Struct \u00b6 struct VariablePriceStorage { VariablePriceContract variablePrices ; } Purpose : Diamond storage wrapper for variable pricing data. Storage Position : bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nextblock.bitgem.app.VariablePriceStorage.storage\" ); Core Functions \u00b6 Storage Management \u00b6 variablePriceStorage() \u00b6 function variablePriceStorage () internal pure returns ( VariablePriceStorage storage ds ) Purpose : Access Diamond storage for variable pricing data using assembly. Implementation : function variablePriceStorage () internal pure returns ( VariablePriceStorage storage ds ) { bytes32 position = DIAMOND_STORAGE_POSITION ; assembly { ds . slot := position } } Returns : Storage reference to variable pricing data Usage : All pricing functions use this to access persistent storage. Price Operations \u00b6 _updatePrice() \u00b6 function _updatePrice ( VariablePriceContract storage self ) internal returns ( uint256 _price , uint256 updatedPrice ) Purpose : Update the price and return both old and new values. Parameters : - self : Storage reference to variable price contract Returns : - _price : Previous price before update - updatedPrice : New price after increase Process : 1. Capture current price 2. Apply price increase based on modifier 3. Return both old and new prices Example Usage : // Update price after a sale ( uint256 oldPrice , uint256 newPrice ) = VariablePriceLib . _updatePrice ( priceContract ); console . log ( \"Price updated from\" , oldPrice , \"to\" , newPrice ); _currentPrice() \u00b6 function _currentPrice ( VariablePriceContract storage self ) internal view returns ( uint256 _price ) Purpose : Get the current price without modification. Parameters : - self : Storage reference to variable price contract Returns : Current price in wei Example Usage : // Check current price before purchase uint256 currentPrice = VariablePriceLib . _currentPrice ( priceContract ); require ( msg.value >= currentPrice , \"Insufficient payment\" ); _setPrice() \u00b6 function _setPrice ( VariablePriceContract storage self , uint256 _price ) internal returns ( uint256 _newPrice ) Purpose : Manually set a new price value. Parameters : - self : Storage reference to variable price contract - _price : New price to set Returns : The newly set price Use Cases : - Initial price configuration - Administrative price adjustments - Price resets or corrections Example Usage : // Set initial price for a new token sale uint256 initialPrice = 0 . 1 ether ; VariablePriceLib . _setPrice ( priceContract , initialPrice ); Price Modification \u00b6 _increaseClaimPrice() \u00b6 function _increaseClaimPrice ( VariablePriceContract storage self ) internal Purpose : Apply price increase based on the configured price modifier. Parameters : - self : Storage reference to variable price contract Price Modification Logic : Fixed Modifier : if ( currentModifier == PriceModifier . Fixed ) { currentPrice = currentPrice + currentModifierFactor ; } Increases price by a fixed amount each time priceModifierFactor = fixed increase amount in wei Exponential Modifier : else if ( currentModifier == PriceModifier . Exponential ) { currentPrice = currentPrice + ( currentPrice / currentModifierFactor ); } Increases price by a percentage of current price priceModifierFactor = divisor for percentage calculation Example: factor of 10 = 10% increase, factor of 5 = 20% increase Inverse Logarithmic Modifier : else if ( currentModifier == PriceModifier . InverseLog ) { currentPrice = currentPrice + ( currentPrice / ( currentModifierFactor * currentPrice )); } Diminishing price increases as price grows Creates a dampening effect for high-value items priceModifierFactor affects the rate of dampening Example Usage : // Apply price increase after successful purchase VariablePriceLib . _increaseClaimPrice ( priceContract ); emit PriceIncreased ( tokenId , newPrice ); Integration Examples \u00b6 NFT Collection with Bonding Curve \u00b6 // NFT collection with exponential pricing contract BondingCurveNFT { using VariablePriceLib for VariablePriceLib . VariablePriceStorage ; struct CollectionConfig { uint256 startPrice ; uint256 maxPrice ; PriceModifier priceStrategy ; uint256 modifierFactor ; uint256 maxSupply ; uint256 currentSupply ; } CollectionConfig public config ; mapping ( uint256 => uint256 ) public tokenPrices ; event TokenMinted ( uint256 indexed tokenId , address indexed to , uint256 price ); event PriceUpdated ( uint256 oldPrice , uint256 newPrice ); constructor ( uint256 _startPrice , uint256 _maxPrice , PriceModifier _priceStrategy , uint256 _modifierFactor , uint256 _maxSupply ) { config = CollectionConfig ({ startPrice : _startPrice , maxPrice : _maxPrice , priceStrategy : _priceStrategy , modifierFactor : _modifierFactor , maxSupply : _maxSupply , currentSupply : 0 }); // Initialize pricing VariablePriceLib . VariablePriceStorage storage priceStorage = VariablePriceLib . variablePriceStorage (); priceStorage . variablePrices = VariablePriceContract ({ price : _startPrice , priceModifier : _priceStrategy , priceModifierFactor : _modifierFactor , maxPrice : _maxPrice }); } function mint ( address to ) external payable returns ( uint256 tokenId ) { require ( config . currentSupply < config . maxSupply , \"Max supply reached\" ); VariablePriceLib . VariablePriceStorage storage priceStorage = VariablePriceLib . variablePriceStorage (); // Get current price uint256 currentPrice = VariablePriceLib . _currentPrice ( priceStorage . variablePrices ); require ( msg.value >= currentPrice , \"Insufficient payment\" ); // Mint token tokenId = config . currentSupply + 1 ; config . currentSupply ++ ; _mint ( to , tokenId ); // Record purchase price tokenPrices [ tokenId ] = currentPrice ; // Update price for next mint ( uint256 oldPrice , uint256 newPrice ) = VariablePriceLib . _updatePrice ( priceStorage . variablePrices ); // Refund excess payment if ( msg.value > currentPrice ) { payable ( msg.sender ). transfer ( msg.value - currentPrice ); } emit TokenMinted ( tokenId , to , currentPrice ); emit PriceUpdated ( oldPrice , newPrice ); } function getCurrentPrice () external view returns ( uint256 ) { VariablePriceLib . VariablePriceStorage storage priceStorage = VariablePriceLib . variablePriceStorage (); return VariablePriceLib . _currentPrice ( priceStorage . variablePrices ); } function getNextPrice () external view returns ( uint256 ) { VariablePriceLib . VariablePriceStorage storage priceStorage = VariablePriceLib . variablePriceStorage (); // Simulate price increase uint256 currentPrice = priceStorage . variablePrices . price ; PriceModifier modifier = priceStorage . variablePrices . priceModifier ; uint256 factor = priceStorage . variablePrices . priceModifierFactor ; if ( modifier == PriceModifier . Fixed ) { return currentPrice + factor ; } else if ( modifier == PriceModifier . Exponential ) { return currentPrice + ( currentPrice / factor ); } else if ( modifier == PriceModifier . InverseLog ) { return currentPrice + ( currentPrice / ( factor * currentPrice )); } return currentPrice ; } function getPriceHistory () external view returns ( uint256 [] memory prices ) { prices = new uint256 []( config . currentSupply ); for ( uint256 i = 1 ; i <= config . currentSupply ; i ++ ) { prices [ i - 1 ] = tokenPrices [ i ]; } } function _mint ( address to , uint256 tokenId ) internal { // ERC721 mint implementation } } Gaming Item Marketplace \u00b6 // Gaming marketplace with dynamic item pricing contract GameItemMarketplace { using VariablePriceLib for VariablePriceLib . VariablePriceStorage ; struct ItemType { string name ; string category ; VariablePriceContract pricing ; uint256 totalSold ; bool active ; } struct PurchaseHistory { uint256 itemTypeId ; uint256 price ; uint256 timestamp ; address buyer ; } mapping ( uint256 => ItemType ) public itemTypes ; mapping ( uint256 => PurchaseHistory []) public purchaseHistory ; uint256 public nextItemTypeId ; event ItemTypeCreated ( uint256 indexed itemTypeId , string name , uint256 startPrice ); event ItemPurchased ( uint256 indexed itemTypeId , address indexed buyer , uint256 price ); event PricingUpdated ( uint256 indexed itemTypeId , uint256 oldPrice , uint256 newPrice ); function createItemType ( string memory name , string memory category , uint256 startPrice , uint256 maxPrice , PriceModifier priceStrategy , uint256 modifierFactor ) external onlyGameMaster returns ( uint256 itemTypeId ) { itemTypeId = nextItemTypeId ++ ; itemTypes [ itemTypeId ] = ItemType ({ name : name , category : category , pricing : VariablePriceContract ({ price : startPrice , priceModifier : priceStrategy , priceModifierFactor : modifierFactor , maxPrice : maxPrice }), totalSold : 0 , active : true }); emit ItemTypeCreated ( itemTypeId , name , startPrice ); } function purchaseItem ( uint256 itemTypeId ) external payable returns ( uint256 itemId ) { ItemType storage itemType = itemTypes [ itemTypeId ]; require ( itemType . active , \"Item type not active\" ); // Get current price uint256 currentPrice = VariablePriceLib . _currentPrice ( itemType . pricing ); require ( msg.value >= currentPrice , \"Insufficient payment\" ); // Update price ( uint256 oldPrice , uint256 newPrice ) = VariablePriceLib . _updatePrice ( itemType . pricing ); // Mint item to buyer itemId = _mintGameItem ( msg.sender , itemTypeId ); // Update statistics itemType . totalSold ++ ; // Record purchase purchaseHistory [ itemTypeId ]. push ( PurchaseHistory ({ itemTypeId : itemTypeId , price : currentPrice , timestamp : block.timestamp , buyer : msg.sender })); // Refund excess payment if ( msg.value > currentPrice ) { payable ( msg.sender ). transfer ( msg.value - currentPrice ); } emit ItemPurchased ( itemTypeId , msg.sender , currentPrice ); emit PricingUpdated ( itemTypeId , oldPrice , newPrice ); } function getItemPrice ( uint256 itemTypeId ) external view returns ( uint256 ) { return VariablePriceLib . _currentPrice ( itemTypes [ itemTypeId ]. pricing ); } function getItemPriceInfo ( uint256 itemTypeId ) external view returns ( uint256 currentPrice , uint256 nextPrice , PriceModifier strategy , uint256 factor , uint256 maxPrice , uint256 totalSold ) { ItemType memory itemType = itemTypes [ itemTypeId ]; currentPrice = itemType . pricing . price ; strategy = itemType . pricing . priceModifier ; factor = itemType . pricing . priceModifierFactor ; maxPrice = itemType . pricing . maxPrice ; totalSold = itemType . totalSold ; // Calculate next price if ( strategy == PriceModifier . Fixed ) { nextPrice = currentPrice + factor ; } else if ( strategy == PriceModifier . Exponential ) { nextPrice = currentPrice + ( currentPrice / factor ); } else if ( strategy == PriceModifier . InverseLog ) { nextPrice = currentPrice + ( currentPrice / ( factor * currentPrice )); } else { nextPrice = currentPrice ; } // Cap at max price if ( nextPrice > maxPrice ) { nextPrice = maxPrice ; } } function getPurchaseHistory ( uint256 itemTypeId ) external view returns ( PurchaseHistory [] memory ) { return purchaseHistory [ itemTypeId ]; } function updateItemPricing ( uint256 itemTypeId , uint256 newPrice , PriceModifier newStrategy , uint256 newFactor , uint256 newMaxPrice ) external onlyGameMaster { ItemType storage itemType = itemTypes [ itemTypeId ]; require ( itemType . active , \"Item type not active\" ); itemType . pricing . price = newPrice ; itemType . pricing . priceModifier = newStrategy ; itemType . pricing . priceModifierFactor = newFactor ; itemType . pricing . maxPrice = newMaxPrice ; } function _mintGameItem ( address to , uint256 itemTypeId ) internal returns ( uint256 ) { // Implementation would mint game item NFT return 1 ; } modifier onlyGameMaster () { // Implementation would check game master role _ ; } } Auction System with Dynamic Reserve Prices \u00b6 // Auction system with variable reserve pricing contract DynamicAuction { using VariablePriceLib for VariablePriceLib . VariablePriceStorage ; struct Auction { uint256 tokenId ; address seller ; VariablePriceContract reservePricing ; uint256 startTime ; uint256 endTime ; address highestBidder ; uint256 highestBid ; bool ended ; uint256 auctionCount ; // Number of times this item has been auctioned } struct Bid { address bidder ; uint256 amount ; uint256 timestamp ; } mapping ( uint256 => Auction ) public auctions ; mapping ( uint256 => Bid []) public auctionBids ; mapping ( uint256 => bool ) public tokenInAuction ; uint256 public nextAuctionId ; event AuctionCreated ( uint256 indexed auctionId , uint256 indexed tokenId , uint256 reservePrice ); event BidPlaced ( uint256 indexed auctionId , address indexed bidder , uint256 amount ); event AuctionEnded ( uint256 indexed auctionId , address indexed winner , uint256 finalPrice ); event ReservePriceUpdated ( uint256 indexed auctionId , uint256 newReservePrice ); function createAuction ( uint256 tokenId , uint256 duration , uint256 initialReservePrice , PriceModifier reserveStrategy , uint256 reserveFactor , uint256 maxReservePrice ) external returns ( uint256 auctionId ) { require ( ! tokenInAuction [ tokenId ], \"Token already in auction\" ); require ( _isApprovedOrOwner ( msg.sender , tokenId ), \"Not authorized\" ); auctionId = nextAuctionId ++ ; auctions [ auctionId ] = Auction ({ tokenId : tokenId , seller : msg.sender , reservePricing : VariablePriceContract ({ price : initialReservePrice , priceModifier : reserveStrategy , priceModifierFactor : reserveFactor , maxPrice : maxReservePrice }), startTime : block.timestamp , endTime : block.timestamp + duration , highestBidder : address ( 0 ), highestBid : 0 , ended : false , auctionCount : _getAuctionCount ( tokenId ) + 1 }); tokenInAuction [ tokenId ] = true ; emit AuctionCreated ( auctionId , tokenId , initialReservePrice ); } function placeBid ( uint256 auctionId ) external payable { Auction storage auction = auctions [ auctionId ]; require ( block.timestamp < auction . endTime , \"Auction ended\" ); require ( ! auction . ended , \"Auction already ended\" ); uint256 currentReserve = VariablePriceLib . _currentPrice ( auction . reservePricing ); require ( msg.value >= currentReserve , \"Bid below reserve price\" ); require ( msg.value > auction . highestBid , \"Bid too low\" ); // Refund previous highest bidder if ( auction . highestBidder != address ( 0 )) { payable ( auction . highestBidder ). transfer ( auction . highestBid ); } auction . highestBidder = msg.sender ; auction . highestBid = msg.value ; // Record bid auctionBids [ auctionId ]. push ( Bid ({ bidder : msg.sender , amount : msg.value , timestamp : block.timestamp })); // Increase reserve price for future auctions of this item ( uint256 oldReserve , uint256 newReserve ) = VariablePriceLib . _updatePrice ( auction . reservePricing ); emit BidPlaced ( auctionId , msg.sender , msg.value ); emit ReservePriceUpdated ( auctionId , newReserve ); } function endAuction ( uint256 auctionId ) external { Auction storage auction = auctions [ auctionId ]; require ( block.timestamp >= auction . endTime || msg.sender == auction . seller , \"Auction not ended\" ); require ( ! auction . ended , \"Auction already ended\" ); auction . ended = true ; tokenInAuction [ auction . tokenId ] = false ; if ( auction . highestBidder != address ( 0 )) { // Transfer token to winner _transfer ( auction . seller , auction . highestBidder , auction . tokenId ); // Transfer payment to seller (minus fees) uint256 fee = auction . highestBid * 25 / 1000 ; // 2.5% fee payable ( auction . seller ). transfer ( auction . highestBid - fee ); emit AuctionEnded ( auctionId , auction . highestBidder , auction . highestBid ); } else { // No bids, return token to seller emit AuctionEnded ( auctionId , address ( 0 ), 0 ); } } function getCurrentReservePrice ( uint256 auctionId ) external view returns ( uint256 ) { return VariablePriceLib . _currentPrice ( auctions [ auctionId ]. reservePricing ); } function getAuctionInfo ( uint256 auctionId ) external view returns ( uint256 tokenId , address seller , uint256 currentReserve , uint256 nextReserve , uint256 startTime , uint256 endTime , address highestBidder , uint256 highestBid , bool ended , uint256 auctionCount ) { Auction memory auction = auctions [ auctionId ]; tokenId = auction . tokenId ; seller = auction . seller ; currentReserve = auction . reservePricing . price ; startTime = auction . startTime ; endTime = auction . endTime ; highestBidder = auction . highestBidder ; highestBid = auction . highestBid ; ended = auction . ended ; auctionCount = auction . auctionCount ; // Calculate next reserve price PriceModifier strategy = auction . reservePricing . priceModifier ; uint256 factor = auction . reservePricing . priceModifierFactor ; if ( strategy == PriceModifier . Fixed ) { nextReserve = currentReserve + factor ; } else if ( strategy == PriceModifier . Exponential ) { nextReserve = currentReserve + ( currentReserve / factor ); } else if ( strategy == PriceModifier . InverseLog ) { nextReserve = currentReserve + ( currentReserve / ( factor * currentReserve )); } else { nextReserve = currentReserve ; } if ( nextReserve > auction . reservePricing . maxPrice ) { nextReserve = auction . reservePricing . maxPrice ; } } function getBidHistory ( uint256 auctionId ) external view returns ( Bid [] memory ) { return auctionBids [ auctionId ]; } function _getAuctionCount ( uint256 tokenId ) internal view returns ( uint256 ) { // Implementation would track auction history return 0 ; } function _isApprovedOrOwner ( address spender , uint256 tokenId ) internal view returns ( bool ) { // Implementation would check ERC721 authorization return true ; } function _transfer ( address from , address to , uint256 tokenId ) internal { // Implementation would transfer ERC721 token } } Events \u00b6 Variable Price Events \u00b6 event VariablePriceChanged ( address eventContract , VariablePriceContract price ); Security Considerations \u00b6 Price Manipulation Protection \u00b6 Maximum price limits prevent excessive pricing Configurable modifier factors allow controlled growth Transparent pricing algorithms prevent manipulation Event emission for price change monitoring Overflow Protection \u00b6 Safe arithmetic operations for price calculations Bounds checking for modifier factors Maximum price enforcement Graceful handling of edge cases Economic Security \u00b6 Predictable pricing algorithms Configurable parameters for different use cases Protection against price manipulation attacks Fair pricing progression for all participants Gas Optimization \u00b6 Calculation Efficiency \u00b6 Optimized arithmetic operations Minimal storage reads and writes Efficient price update algorithms Batch price operations where possible Storage Efficiency \u00b6 Compact data structures Minimal storage footprint Efficient parameter encoding Optimized Diamond storage access Error Handling \u00b6 Common Errors \u00b6 Division by zero in modifier calculations Price overflow in exponential growth Invalid modifier factor values Maximum price exceeded Best Practices \u00b6 Validate modifier factors before use Implement maximum price limits Handle edge cases gracefully Provide clear error messages for debugging Testing Considerations \u00b6 Unit Tests \u00b6 Price calculation accuracy for each modifier type Boundary condition testing Overflow and underflow protection Storage operations verification Integration Tests \u00b6 Multi-transaction pricing scenarios Cross-contract price integration Economic model validation Long-term pricing behavior analysis Economic Testing \u00b6 Bonding curve validation Market dynamics simulation Price discovery mechanisms Tokenomics model verification Related Documentation \u00b6 IVariablePrice Interface - Variable price interface definition MultiSaleLib - Multi-token sale integration Pricing Strategies Guide - Economic model implementation Tokenomics Guide - Token economics best practices Auction Systems Guide - Auction implementation patterns This library provides comprehensive utilities for dynamic pricing mechanisms within the Gemforce platform, supporting flexible pricing strategies, automatic price adjustments, and configurable economic models for various tokenomics scenarios including bonding curves, auctions, and marketplace systems.","title":"Variable Price Lib"},{"location":"smart-contracts/libraries/variable-price-lib/#variablepricelib-library","text":"","title":"VariablePriceLib Library"},{"location":"smart-contracts/libraries/variable-price-lib/#overview","text":"The VariablePriceLib library provides core utilities for managing dynamic pricing mechanisms within the Gemforce platform. This library implements flexible pricing strategies that automatically adjust prices based on configurable modifiers, supporting fixed increments, exponential growth, and inverse logarithmic scaling for various tokenomics scenarios.","title":"Overview"},{"location":"smart-contracts/libraries/variable-price-lib/#key-features","text":"Dynamic Pricing : Automatic price adjustments after each transaction Multiple Price Modifiers : Fixed, exponential, and inverse logarithmic pricing strategies Configurable Parameters : Customizable price modifier factors and maximum price limits Gas Efficient : Optimized calculations for on-chain price updates Event Tracking : Price change notifications for external monitoring Integration Ready : Seamless integration with token sales and marketplace systems","title":"Key Features"},{"location":"smart-contracts/libraries/variable-price-lib/#library-definition","text":"// SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; library VariablePriceLib { // Storage management function variablePriceStorage () internal pure returns ( VariablePriceStorage storage ); // Price operations function _updatePrice ( VariablePriceContract storage self ) internal returns ( uint256 _price , uint256 updatedPrice ); function _currentPrice ( VariablePriceContract storage self ) internal view returns ( uint256 _price ); function _setPrice ( VariablePriceContract storage self , uint256 _price ) internal returns ( uint256 _newPrice ); // Price modification function _increaseClaimPrice ( VariablePriceContract storage self ) internal ; }","title":"Library Definition"},{"location":"smart-contracts/libraries/variable-price-lib/#data-structures","text":"","title":"Data Structures"},{"location":"smart-contracts/libraries/variable-price-lib/#pricemodifier-enum","text":"enum PriceModifier { None , // No price modification Fixed , // Fixed amount increase Exponential , // Exponential price growth InverseLog // Inverse logarithmic scaling } Purpose : Defines the pricing strategy for automatic price adjustments. Strategies : - None : Price remains constant - Fixed : Price increases by a fixed amount each time - Exponential : Price increases by a percentage of current price - InverseLog : Price increases diminish as price grows (dampening effect)","title":"PriceModifier Enum"},{"location":"smart-contracts/libraries/variable-price-lib/#variablepricecontract-struct","text":"struct VariablePriceContract { uint256 price ; // Current price of the token PriceModifier priceModifier ; // Price modification strategy uint256 priceModifierFactor ; // Factor for price calculations uint256 maxPrice ; // Maximum price limit } Purpose : Complete configuration for variable pricing behavior. Components : - price : Current token price in wei - priceModifier : Strategy for price increases - priceModifierFactor : Calculation parameter for price adjustments - maxPrice : Upper limit to prevent excessive pricing","title":"VariablePriceContract Struct"},{"location":"smart-contracts/libraries/variable-price-lib/#variablepricestorage-struct","text":"struct VariablePriceStorage { VariablePriceContract variablePrices ; } Purpose : Diamond storage wrapper for variable pricing data. Storage Position : bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256 ( \"diamond.nextblock.bitgem.app.VariablePriceStorage.storage\" );","title":"VariablePriceStorage Struct"},{"location":"smart-contracts/libraries/variable-price-lib/#core-functions","text":"","title":"Core Functions"},{"location":"smart-contracts/libraries/variable-price-lib/#storage-management","text":"","title":"Storage Management"},{"location":"smart-contracts/libraries/variable-price-lib/#variablepricestorage","text":"function variablePriceStorage () internal pure returns ( VariablePriceStorage storage ds ) Purpose : Access Diamond storage for variable pricing data using assembly. Implementation : function variablePriceStorage () internal pure returns ( VariablePriceStorage storage ds ) { bytes32 position = DIAMOND_STORAGE_POSITION ; assembly { ds . slot := position } } Returns : Storage reference to variable pricing data Usage : All pricing functions use this to access persistent storage.","title":"variablePriceStorage()"},{"location":"smart-contracts/libraries/variable-price-lib/#price-operations","text":"","title":"Price Operations"},{"location":"smart-contracts/libraries/variable-price-lib/#_updateprice","text":"function _updatePrice ( VariablePriceContract storage self ) internal returns ( uint256 _price , uint256 updatedPrice ) Purpose : Update the price and return both old and new values. Parameters : - self : Storage reference to variable price contract Returns : - _price : Previous price before update - updatedPrice : New price after increase Process : 1. Capture current price 2. Apply price increase based on modifier 3. Return both old and new prices Example Usage : // Update price after a sale ( uint256 oldPrice , uint256 newPrice ) = VariablePriceLib . _updatePrice ( priceContract ); console . log ( \"Price updated from\" , oldPrice , \"to\" , newPrice );","title":"_updatePrice()"},{"location":"smart-contracts/libraries/variable-price-lib/#_currentprice","text":"function _currentPrice ( VariablePriceContract storage self ) internal view returns ( uint256 _price ) Purpose : Get the current price without modification. Parameters : - self : Storage reference to variable price contract Returns : Current price in wei Example Usage : // Check current price before purchase uint256 currentPrice = VariablePriceLib . _currentPrice ( priceContract ); require ( msg.value >= currentPrice , \"Insufficient payment\" );","title":"_currentPrice()"},{"location":"smart-contracts/libraries/variable-price-lib/#_setprice","text":"function _setPrice ( VariablePriceContract storage self , uint256 _price ) internal returns ( uint256 _newPrice ) Purpose : Manually set a new price value. Parameters : - self : Storage reference to variable price contract - _price : New price to set Returns : The newly set price Use Cases : - Initial price configuration - Administrative price adjustments - Price resets or corrections Example Usage : // Set initial price for a new token sale uint256 initialPrice = 0 . 1 ether ; VariablePriceLib . _setPrice ( priceContract , initialPrice );","title":"_setPrice()"},{"location":"smart-contracts/libraries/variable-price-lib/#price-modification","text":"","title":"Price Modification"},{"location":"smart-contracts/libraries/variable-price-lib/#_increaseclaimprice","text":"function _increaseClaimPrice ( VariablePriceContract storage self ) internal Purpose : Apply price increase based on the configured price modifier. Parameters : - self : Storage reference to variable price contract Price Modification Logic : Fixed Modifier : if ( currentModifier == PriceModifier . Fixed ) { currentPrice = currentPrice + currentModifierFactor ; } Increases price by a fixed amount each time priceModifierFactor = fixed increase amount in wei Exponential Modifier : else if ( currentModifier == PriceModifier . Exponential ) { currentPrice = currentPrice + ( currentPrice / currentModifierFactor ); } Increases price by a percentage of current price priceModifierFactor = divisor for percentage calculation Example: factor of 10 = 10% increase, factor of 5 = 20% increase Inverse Logarithmic Modifier : else if ( currentModifier == PriceModifier . InverseLog ) { currentPrice = currentPrice + ( currentPrice / ( currentModifierFactor * currentPrice )); } Diminishing price increases as price grows Creates a dampening effect for high-value items priceModifierFactor affects the rate of dampening Example Usage : // Apply price increase after successful purchase VariablePriceLib . _increaseClaimPrice ( priceContract ); emit PriceIncreased ( tokenId , newPrice );","title":"_increaseClaimPrice()"},{"location":"smart-contracts/libraries/variable-price-lib/#integration-examples","text":"","title":"Integration Examples"},{"location":"smart-contracts/libraries/variable-price-lib/#nft-collection-with-bonding-curve","text":"// NFT collection with exponential pricing contract BondingCurveNFT { using VariablePriceLib for VariablePriceLib . VariablePriceStorage ; struct CollectionConfig { uint256 startPrice ; uint256 maxPrice ; PriceModifier priceStrategy ; uint256 modifierFactor ; uint256 maxSupply ; uint256 currentSupply ; } CollectionConfig public config ; mapping ( uint256 => uint256 ) public tokenPrices ; event TokenMinted ( uint256 indexed tokenId , address indexed to , uint256 price ); event PriceUpdated ( uint256 oldPrice , uint256 newPrice ); constructor ( uint256 _startPrice , uint256 _maxPrice , PriceModifier _priceStrategy , uint256 _modifierFactor , uint256 _maxSupply ) { config = CollectionConfig ({ startPrice : _startPrice , maxPrice : _maxPrice , priceStrategy : _priceStrategy , modifierFactor : _modifierFactor , maxSupply : _maxSupply , currentSupply : 0 }); // Initialize pricing VariablePriceLib . VariablePriceStorage storage priceStorage = VariablePriceLib . variablePriceStorage (); priceStorage . variablePrices = VariablePriceContract ({ price : _startPrice , priceModifier : _priceStrategy , priceModifierFactor : _modifierFactor , maxPrice : _maxPrice }); } function mint ( address to ) external payable returns ( uint256 tokenId ) { require ( config . currentSupply < config . maxSupply , \"Max supply reached\" ); VariablePriceLib . VariablePriceStorage storage priceStorage = VariablePriceLib . variablePriceStorage (); // Get current price uint256 currentPrice = VariablePriceLib . _currentPrice ( priceStorage . variablePrices ); require ( msg.value >= currentPrice , \"Insufficient payment\" ); // Mint token tokenId = config . currentSupply + 1 ; config . currentSupply ++ ; _mint ( to , tokenId ); // Record purchase price tokenPrices [ tokenId ] = currentPrice ; // Update price for next mint ( uint256 oldPrice , uint256 newPrice ) = VariablePriceLib . _updatePrice ( priceStorage . variablePrices ); // Refund excess payment if ( msg.value > currentPrice ) { payable ( msg.sender ). transfer ( msg.value - currentPrice ); } emit TokenMinted ( tokenId , to , currentPrice ); emit PriceUpdated ( oldPrice , newPrice ); } function getCurrentPrice () external view returns ( uint256 ) { VariablePriceLib . VariablePriceStorage storage priceStorage = VariablePriceLib . variablePriceStorage (); return VariablePriceLib . _currentPrice ( priceStorage . variablePrices ); } function getNextPrice () external view returns ( uint256 ) { VariablePriceLib . VariablePriceStorage storage priceStorage = VariablePriceLib . variablePriceStorage (); // Simulate price increase uint256 currentPrice = priceStorage . variablePrices . price ; PriceModifier modifier = priceStorage . variablePrices . priceModifier ; uint256 factor = priceStorage . variablePrices . priceModifierFactor ; if ( modifier == PriceModifier . Fixed ) { return currentPrice + factor ; } else if ( modifier == PriceModifier . Exponential ) { return currentPrice + ( currentPrice / factor ); } else if ( modifier == PriceModifier . InverseLog ) { return currentPrice + ( currentPrice / ( factor * currentPrice )); } return currentPrice ; } function getPriceHistory () external view returns ( uint256 [] memory prices ) { prices = new uint256 []( config . currentSupply ); for ( uint256 i = 1 ; i <= config . currentSupply ; i ++ ) { prices [ i - 1 ] = tokenPrices [ i ]; } } function _mint ( address to , uint256 tokenId ) internal { // ERC721 mint implementation } }","title":"NFT Collection with Bonding Curve"},{"location":"smart-contracts/libraries/variable-price-lib/#gaming-item-marketplace","text":"// Gaming marketplace with dynamic item pricing contract GameItemMarketplace { using VariablePriceLib for VariablePriceLib . VariablePriceStorage ; struct ItemType { string name ; string category ; VariablePriceContract pricing ; uint256 totalSold ; bool active ; } struct PurchaseHistory { uint256 itemTypeId ; uint256 price ; uint256 timestamp ; address buyer ; } mapping ( uint256 => ItemType ) public itemTypes ; mapping ( uint256 => PurchaseHistory []) public purchaseHistory ; uint256 public nextItemTypeId ; event ItemTypeCreated ( uint256 indexed itemTypeId , string name , uint256 startPrice ); event ItemPurchased ( uint256 indexed itemTypeId , address indexed buyer , uint256 price ); event PricingUpdated ( uint256 indexed itemTypeId , uint256 oldPrice , uint256 newPrice ); function createItemType ( string memory name , string memory category , uint256 startPrice , uint256 maxPrice , PriceModifier priceStrategy , uint256 modifierFactor ) external onlyGameMaster returns ( uint256 itemTypeId ) { itemTypeId = nextItemTypeId ++ ; itemTypes [ itemTypeId ] = ItemType ({ name : name , category : category , pricing : VariablePriceContract ({ price : startPrice , priceModifier : priceStrategy , priceModifierFactor : modifierFactor , maxPrice : maxPrice }), totalSold : 0 , active : true }); emit ItemTypeCreated ( itemTypeId , name , startPrice ); } function purchaseItem ( uint256 itemTypeId ) external payable returns ( uint256 itemId ) { ItemType storage itemType = itemTypes [ itemTypeId ]; require ( itemType . active , \"Item type not active\" ); // Get current price uint256 currentPrice = VariablePriceLib . _currentPrice ( itemType . pricing ); require ( msg.value >= currentPrice , \"Insufficient payment\" ); // Update price ( uint256 oldPrice , uint256 newPrice ) = VariablePriceLib . _updatePrice ( itemType . pricing ); // Mint item to buyer itemId = _mintGameItem ( msg.sender , itemTypeId ); // Update statistics itemType . totalSold ++ ; // Record purchase purchaseHistory [ itemTypeId ]. push ( PurchaseHistory ({ itemTypeId : itemTypeId , price : currentPrice , timestamp : block.timestamp , buyer : msg.sender })); // Refund excess payment if ( msg.value > currentPrice ) { payable ( msg.sender ). transfer ( msg.value - currentPrice ); } emit ItemPurchased ( itemTypeId , msg.sender , currentPrice ); emit PricingUpdated ( itemTypeId , oldPrice , newPrice ); } function getItemPrice ( uint256 itemTypeId ) external view returns ( uint256 ) { return VariablePriceLib . _currentPrice ( itemTypes [ itemTypeId ]. pricing ); } function getItemPriceInfo ( uint256 itemTypeId ) external view returns ( uint256 currentPrice , uint256 nextPrice , PriceModifier strategy , uint256 factor , uint256 maxPrice , uint256 totalSold ) { ItemType memory itemType = itemTypes [ itemTypeId ]; currentPrice = itemType . pricing . price ; strategy = itemType . pricing . priceModifier ; factor = itemType . pricing . priceModifierFactor ; maxPrice = itemType . pricing . maxPrice ; totalSold = itemType . totalSold ; // Calculate next price if ( strategy == PriceModifier . Fixed ) { nextPrice = currentPrice + factor ; } else if ( strategy == PriceModifier . Exponential ) { nextPrice = currentPrice + ( currentPrice / factor ); } else if ( strategy == PriceModifier . InverseLog ) { nextPrice = currentPrice + ( currentPrice / ( factor * currentPrice )); } else { nextPrice = currentPrice ; } // Cap at max price if ( nextPrice > maxPrice ) { nextPrice = maxPrice ; } } function getPurchaseHistory ( uint256 itemTypeId ) external view returns ( PurchaseHistory [] memory ) { return purchaseHistory [ itemTypeId ]; } function updateItemPricing ( uint256 itemTypeId , uint256 newPrice , PriceModifier newStrategy , uint256 newFactor , uint256 newMaxPrice ) external onlyGameMaster { ItemType storage itemType = itemTypes [ itemTypeId ]; require ( itemType . active , \"Item type not active\" ); itemType . pricing . price = newPrice ; itemType . pricing . priceModifier = newStrategy ; itemType . pricing . priceModifierFactor = newFactor ; itemType . pricing . maxPrice = newMaxPrice ; } function _mintGameItem ( address to , uint256 itemTypeId ) internal returns ( uint256 ) { // Implementation would mint game item NFT return 1 ; } modifier onlyGameMaster () { // Implementation would check game master role _ ; } }","title":"Gaming Item Marketplace"},{"location":"smart-contracts/libraries/variable-price-lib/#auction-system-with-dynamic-reserve-prices","text":"// Auction system with variable reserve pricing contract DynamicAuction { using VariablePriceLib for VariablePriceLib . VariablePriceStorage ; struct Auction { uint256 tokenId ; address seller ; VariablePriceContract reservePricing ; uint256 startTime ; uint256 endTime ; address highestBidder ; uint256 highestBid ; bool ended ; uint256 auctionCount ; // Number of times this item has been auctioned } struct Bid { address bidder ; uint256 amount ; uint256 timestamp ; } mapping ( uint256 => Auction ) public auctions ; mapping ( uint256 => Bid []) public auctionBids ; mapping ( uint256 => bool ) public tokenInAuction ; uint256 public nextAuctionId ; event AuctionCreated ( uint256 indexed auctionId , uint256 indexed tokenId , uint256 reservePrice ); event BidPlaced ( uint256 indexed auctionId , address indexed bidder , uint256 amount ); event AuctionEnded ( uint256 indexed auctionId , address indexed winner , uint256 finalPrice ); event ReservePriceUpdated ( uint256 indexed auctionId , uint256 newReservePrice ); function createAuction ( uint256 tokenId , uint256 duration , uint256 initialReservePrice , PriceModifier reserveStrategy , uint256 reserveFactor , uint256 maxReservePrice ) external returns ( uint256 auctionId ) { require ( ! tokenInAuction [ tokenId ], \"Token already in auction\" ); require ( _isApprovedOrOwner ( msg.sender , tokenId ), \"Not authorized\" ); auctionId = nextAuctionId ++ ; auctions [ auctionId ] = Auction ({ tokenId : tokenId , seller : msg.sender , reservePricing : VariablePriceContract ({ price : initialReservePrice , priceModifier : reserveStrategy , priceModifierFactor : reserveFactor , maxPrice : maxReservePrice }), startTime : block.timestamp , endTime : block.timestamp + duration , highestBidder : address ( 0 ), highestBid : 0 , ended : false , auctionCount : _getAuctionCount ( tokenId ) + 1 }); tokenInAuction [ tokenId ] = true ; emit AuctionCreated ( auctionId , tokenId , initialReservePrice ); } function placeBid ( uint256 auctionId ) external payable { Auction storage auction = auctions [ auctionId ]; require ( block.timestamp < auction . endTime , \"Auction ended\" ); require ( ! auction . ended , \"Auction already ended\" ); uint256 currentReserve = VariablePriceLib . _currentPrice ( auction . reservePricing ); require ( msg.value >= currentReserve , \"Bid below reserve price\" ); require ( msg.value > auction . highestBid , \"Bid too low\" ); // Refund previous highest bidder if ( auction . highestBidder != address ( 0 )) { payable ( auction . highestBidder ). transfer ( auction . highestBid ); } auction . highestBidder = msg.sender ; auction . highestBid = msg.value ; // Record bid auctionBids [ auctionId ]. push ( Bid ({ bidder : msg.sender , amount : msg.value , timestamp : block.timestamp })); // Increase reserve price for future auctions of this item ( uint256 oldReserve , uint256 newReserve ) = VariablePriceLib . _updatePrice ( auction . reservePricing ); emit BidPlaced ( auctionId , msg.sender , msg.value ); emit ReservePriceUpdated ( auctionId , newReserve ); } function endAuction ( uint256 auctionId ) external { Auction storage auction = auctions [ auctionId ]; require ( block.timestamp >= auction . endTime || msg.sender == auction . seller , \"Auction not ended\" ); require ( ! auction . ended , \"Auction already ended\" ); auction . ended = true ; tokenInAuction [ auction . tokenId ] = false ; if ( auction . highestBidder != address ( 0 )) { // Transfer token to winner _transfer ( auction . seller , auction . highestBidder , auction . tokenId ); // Transfer payment to seller (minus fees) uint256 fee = auction . highestBid * 25 / 1000 ; // 2.5% fee payable ( auction . seller ). transfer ( auction . highestBid - fee ); emit AuctionEnded ( auctionId , auction . highestBidder , auction . highestBid ); } else { // No bids, return token to seller emit AuctionEnded ( auctionId , address ( 0 ), 0 ); } } function getCurrentReservePrice ( uint256 auctionId ) external view returns ( uint256 ) { return VariablePriceLib . _currentPrice ( auctions [ auctionId ]. reservePricing ); } function getAuctionInfo ( uint256 auctionId ) external view returns ( uint256 tokenId , address seller , uint256 currentReserve , uint256 nextReserve , uint256 startTime , uint256 endTime , address highestBidder , uint256 highestBid , bool ended , uint256 auctionCount ) { Auction memory auction = auctions [ auctionId ]; tokenId = auction . tokenId ; seller = auction . seller ; currentReserve = auction . reservePricing . price ; startTime = auction . startTime ; endTime = auction . endTime ; highestBidder = auction . highestBidder ; highestBid = auction . highestBid ; ended = auction . ended ; auctionCount = auction . auctionCount ; // Calculate next reserve price PriceModifier strategy = auction . reservePricing . priceModifier ; uint256 factor = auction . reservePricing . priceModifierFactor ; if ( strategy == PriceModifier . Fixed ) { nextReserve = currentReserve + factor ; } else if ( strategy == PriceModifier . Exponential ) { nextReserve = currentReserve + ( currentReserve / factor ); } else if ( strategy == PriceModifier . InverseLog ) { nextReserve = currentReserve + ( currentReserve / ( factor * currentReserve )); } else { nextReserve = currentReserve ; } if ( nextReserve > auction . reservePricing . maxPrice ) { nextReserve = auction . reservePricing . maxPrice ; } } function getBidHistory ( uint256 auctionId ) external view returns ( Bid [] memory ) { return auctionBids [ auctionId ]; } function _getAuctionCount ( uint256 tokenId ) internal view returns ( uint256 ) { // Implementation would track auction history return 0 ; } function _isApprovedOrOwner ( address spender , uint256 tokenId ) internal view returns ( bool ) { // Implementation would check ERC721 authorization return true ; } function _transfer ( address from , address to , uint256 tokenId ) internal { // Implementation would transfer ERC721 token } }","title":"Auction System with Dynamic Reserve Prices"},{"location":"smart-contracts/libraries/variable-price-lib/#events","text":"","title":"Events"},{"location":"smart-contracts/libraries/variable-price-lib/#variable-price-events","text":"event VariablePriceChanged ( address eventContract , VariablePriceContract price );","title":"Variable Price Events"},{"location":"smart-contracts/libraries/variable-price-lib/#security-considerations","text":"","title":"Security Considerations"},{"location":"smart-contracts/libraries/variable-price-lib/#price-manipulation-protection","text":"Maximum price limits prevent excessive pricing Configurable modifier factors allow controlled growth Transparent pricing algorithms prevent manipulation Event emission for price change monitoring","title":"Price Manipulation Protection"},{"location":"smart-contracts/libraries/variable-price-lib/#overflow-protection","text":"Safe arithmetic operations for price calculations Bounds checking for modifier factors Maximum price enforcement Graceful handling of edge cases","title":"Overflow Protection"},{"location":"smart-contracts/libraries/variable-price-lib/#economic-security","text":"Predictable pricing algorithms Configurable parameters for different use cases Protection against price manipulation attacks Fair pricing progression for all participants","title":"Economic Security"},{"location":"smart-contracts/libraries/variable-price-lib/#gas-optimization","text":"","title":"Gas Optimization"},{"location":"smart-contracts/libraries/variable-price-lib/#calculation-efficiency","text":"Optimized arithmetic operations Minimal storage reads and writes Efficient price update algorithms Batch price operations where possible","title":"Calculation Efficiency"},{"location":"smart-contracts/libraries/variable-price-lib/#storage-efficiency","text":"Compact data structures Minimal storage footprint Efficient parameter encoding Optimized Diamond storage access","title":"Storage Efficiency"},{"location":"smart-contracts/libraries/variable-price-lib/#error-handling","text":"","title":"Error Handling"},{"location":"smart-contracts/libraries/variable-price-lib/#common-errors","text":"Division by zero in modifier calculations Price overflow in exponential growth Invalid modifier factor values Maximum price exceeded","title":"Common Errors"},{"location":"smart-contracts/libraries/variable-price-lib/#best-practices","text":"Validate modifier factors before use Implement maximum price limits Handle edge cases gracefully Provide clear error messages for debugging","title":"Best Practices"},{"location":"smart-contracts/libraries/variable-price-lib/#testing-considerations","text":"","title":"Testing Considerations"},{"location":"smart-contracts/libraries/variable-price-lib/#unit-tests","text":"Price calculation accuracy for each modifier type Boundary condition testing Overflow and underflow protection Storage operations verification","title":"Unit Tests"},{"location":"smart-contracts/libraries/variable-price-lib/#integration-tests","text":"Multi-transaction pricing scenarios Cross-contract price integration Economic model validation Long-term pricing behavior analysis","title":"Integration Tests"},{"location":"smart-contracts/libraries/variable-price-lib/#economic-testing","text":"Bonding curve validation Market dynamics simulation Price discovery mechanisms Tokenomics model verification","title":"Economic Testing"},{"location":"smart-contracts/libraries/variable-price-lib/#related-documentation","text":"IVariablePrice Interface - Variable price interface definition MultiSaleLib - Multi-token sale integration Pricing Strategies Guide - Economic model implementation Tokenomics Guide - Token economics best practices Auction Systems Guide - Auction implementation patterns This library provides comprehensive utilities for dynamic pricing mechanisms within the Gemforce platform, supporting flexible pricing strategies, automatic price adjustments, and configurable economic models for various tokenomics scenarios including bonding curves, auctions, and marketplace systems.","title":"Related Documentation"},{"location":"system-architecture/gemforce-system-architecture/","text":"Gemforce System Architecture \u00b6 Overview \u00b6 Gemforce is a comprehensive blockchain-based platform that combines on-chain smart contracts with off-chain cloud services to provide a robust system for digital identity, asset management, and carbon credit tracking. This document provides a technical overview of the system's architecture and integration points. System Components \u00b6 Smart Contract Layer \u00b6 The smart contract layer is built on the Ethereum blockchain (with support for multiple networks) and uses the Diamond pattern (EIP-2535) for upgradeability. Key Components: \u00b6 Diamond Contract Central proxy contract that delegates calls to facet contracts Implements EIP-2535 for upgradeable contracts Supports multiple interfaces through facets Maintains common storage for all facets DiamondFactory Creates new Diamond contracts Manages facet sets for deployment Registers diamonds by symbol Identity System Identity Contract : Represents user identities IdentityFactory : Creates and manages identities IdentityRegistry : Maps addresses to identities ClaimTopicsRegistry : Manages claim topics TrustedIssuersRegistry : Manages authorized issuers Asset Management GemforceMinterFacet : Mints tokens with metadata MarketplaceFacet : Handles buying and selling Treasury : Manages funds and withdrawals CarbonCreditFacet : Handles carbon credit operations Cloud Service Layer \u00b6 The cloud service layer is built on Parse Server and provides API endpoints for interacting with the blockchain and managing user data. Key Components: \u00b6 Parse Server User authentication and management Data storage and retrieval Cloud functions for blockchain interaction Scheduled jobs for background tasks DFNS Integration Wallet management service Transaction signing Key management Recovery mechanisms Bridge API Integration External account management Transfer operations KYC/AML compliance Plaid integration for banking connections Blockchain Connection Service Provider management Contract deployment and interaction Network configuration Architecture Diagram \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Client Applications \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Parse Server API Layer \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Authentication \u2502 \u2502 Blockchain \u2502 \u2502 DFNS Wallet \u2502 \u2502 \u2502 \u2502 Functions \u2502 \u2502 Functions \u2502 \u2502 Functions \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Bridge API \u2502 \u2502 Contract \u2502 \u2502 Project \u2502 \u2502 \u2502 \u2502 Integration \u2502 \u2502 Interaction \u2502 \u2502 Management \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Blockchain Layer \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Diamond \u2502\u25c4\u2500\u253c\u2500\u2524 Identity \u2502\u25c4\u2500\u253c\u2500\u2524 Asset \u2502 \u2502 \u2502 \u2502 Contract \u2502 \u2502 System \u2502 \u2502 Management \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 DiamondFactory \u2502 \u2502 Marketplace \u2502 \u2502 Carbon Credits \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Integration Points \u00b6 Client Applications to Parse Server \u00b6 RESTful API endpoints Authentication via Parse Server DFNS wallet integration WebSocket connections for real-time updates Parse Server to Blockchain \u00b6 Contract Deployment : Deploys Diamond contracts, facets, and initializes systems Transaction Submission : Handles transaction creation, signing, and submission Event Monitoring : Listens for relevant blockchain events State Synchronization : Keeps off-chain database in sync with blockchain state Parse Server to External Services \u00b6 DFNS : API integration for wallet creation and management Bridge API : Integration for financial operations and compliance Plaid : Integration for banking connections Email Services : Notifications and verification Data Flow \u00b6 Identity Creation and Management \u00b6 User registers through Parse Server DFNS wallet is created for the user IdentityFactory creates a new Identity contract IdentityRegistry registers the Identity Claims can be added by trusted issuers Asset Management \u00b6 GemforceMinterFacet creates new tokens with metadata MarketplaceFacet handles buying and selling Treasury manages funds CarbonCreditFacet tracks and retires carbon credits Transaction Flow \u00b6 Client initiates transaction through Parse Server Parse Server creates transaction data DFNS handles transaction signing Transaction is submitted to the blockchain Events are monitored for transaction confirmation Client is notified of transaction status Security Considerations \u00b6 Smart Contract Security \u00b6 Diamond pattern for upgradeability Role-based access control Function-level permissions Reentrancy protection Cloud Service Security \u00b6 Authentication and authorization API key management Rate limiting Input validation Encrypted data storage Wallet Security (DFNS) \u00b6 Delegated transaction signing Multi-factor authentication Key recovery mechanisms Transaction approval flows Deployment Model \u00b6 Smart Contracts \u00b6 Multiple environments (development, staging, production) Network-specific deployments Facet management Upgrade paths Cloud Services \u00b6 Parse Server deployment Database configuration Cache layer API gateway Monitoring and logging Scalability Considerations \u00b6 Smart Contract Scalability \u00b6 Gas optimization State minimization L2 solutions when needed Batched operations Cloud Service Scalability \u00b6 Horizontal scaling of Parse Server Database sharding Load balancing Caching strategies Conclusion \u00b6 The Gemforce system leverages the Diamond pattern for upgradeable smart contracts, combined with a powerful cloud service layer, to create a flexible and robust platform for digital identity and asset management. The integration with DFNS provides secure wallet management, while the Bridge API integration enables financial operations and compliance.","title":"System Architecture"},{"location":"system-architecture/gemforce-system-architecture/#gemforce-system-architecture","text":"","title":"Gemforce System Architecture"},{"location":"system-architecture/gemforce-system-architecture/#overview","text":"Gemforce is a comprehensive blockchain-based platform that combines on-chain smart contracts with off-chain cloud services to provide a robust system for digital identity, asset management, and carbon credit tracking. This document provides a technical overview of the system's architecture and integration points.","title":"Overview"},{"location":"system-architecture/gemforce-system-architecture/#system-components","text":"","title":"System Components"},{"location":"system-architecture/gemforce-system-architecture/#smart-contract-layer","text":"The smart contract layer is built on the Ethereum blockchain (with support for multiple networks) and uses the Diamond pattern (EIP-2535) for upgradeability.","title":"Smart Contract Layer"},{"location":"system-architecture/gemforce-system-architecture/#key-components","text":"Diamond Contract Central proxy contract that delegates calls to facet contracts Implements EIP-2535 for upgradeable contracts Supports multiple interfaces through facets Maintains common storage for all facets DiamondFactory Creates new Diamond contracts Manages facet sets for deployment Registers diamonds by symbol Identity System Identity Contract : Represents user identities IdentityFactory : Creates and manages identities IdentityRegistry : Maps addresses to identities ClaimTopicsRegistry : Manages claim topics TrustedIssuersRegistry : Manages authorized issuers Asset Management GemforceMinterFacet : Mints tokens with metadata MarketplaceFacet : Handles buying and selling Treasury : Manages funds and withdrawals CarbonCreditFacet : Handles carbon credit operations","title":"Key Components:"},{"location":"system-architecture/gemforce-system-architecture/#cloud-service-layer","text":"The cloud service layer is built on Parse Server and provides API endpoints for interacting with the blockchain and managing user data.","title":"Cloud Service Layer"},{"location":"system-architecture/gemforce-system-architecture/#key-components_1","text":"Parse Server User authentication and management Data storage and retrieval Cloud functions for blockchain interaction Scheduled jobs for background tasks DFNS Integration Wallet management service Transaction signing Key management Recovery mechanisms Bridge API Integration External account management Transfer operations KYC/AML compliance Plaid integration for banking connections Blockchain Connection Service Provider management Contract deployment and interaction Network configuration","title":"Key Components:"},{"location":"system-architecture/gemforce-system-architecture/#architecture-diagram","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Client Applications \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Parse Server API Layer \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Authentication \u2502 \u2502 Blockchain \u2502 \u2502 DFNS Wallet \u2502 \u2502 \u2502 \u2502 Functions \u2502 \u2502 Functions \u2502 \u2502 Functions \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Bridge API \u2502 \u2502 Contract \u2502 \u2502 Project \u2502 \u2502 \u2502 \u2502 Integration \u2502 \u2502 Interaction \u2502 \u2502 Management \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Blockchain Layer \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Diamond \u2502\u25c4\u2500\u253c\u2500\u2524 Identity \u2502\u25c4\u2500\u253c\u2500\u2524 Asset \u2502 \u2502 \u2502 \u2502 Contract \u2502 \u2502 System \u2502 \u2502 Management \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 DiamondFactory \u2502 \u2502 Marketplace \u2502 \u2502 Carbon Credits \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Architecture Diagram"},{"location":"system-architecture/gemforce-system-architecture/#integration-points","text":"","title":"Integration Points"},{"location":"system-architecture/gemforce-system-architecture/#client-applications-to-parse-server","text":"RESTful API endpoints Authentication via Parse Server DFNS wallet integration WebSocket connections for real-time updates","title":"Client Applications to Parse Server"},{"location":"system-architecture/gemforce-system-architecture/#parse-server-to-blockchain","text":"Contract Deployment : Deploys Diamond contracts, facets, and initializes systems Transaction Submission : Handles transaction creation, signing, and submission Event Monitoring : Listens for relevant blockchain events State Synchronization : Keeps off-chain database in sync with blockchain state","title":"Parse Server to Blockchain"},{"location":"system-architecture/gemforce-system-architecture/#parse-server-to-external-services","text":"DFNS : API integration for wallet creation and management Bridge API : Integration for financial operations and compliance Plaid : Integration for banking connections Email Services : Notifications and verification","title":"Parse Server to External Services"},{"location":"system-architecture/gemforce-system-architecture/#data-flow","text":"","title":"Data Flow"},{"location":"system-architecture/gemforce-system-architecture/#identity-creation-and-management","text":"User registers through Parse Server DFNS wallet is created for the user IdentityFactory creates a new Identity contract IdentityRegistry registers the Identity Claims can be added by trusted issuers","title":"Identity Creation and Management"},{"location":"system-architecture/gemforce-system-architecture/#asset-management","text":"GemforceMinterFacet creates new tokens with metadata MarketplaceFacet handles buying and selling Treasury manages funds CarbonCreditFacet tracks and retires carbon credits","title":"Asset Management"},{"location":"system-architecture/gemforce-system-architecture/#transaction-flow","text":"Client initiates transaction through Parse Server Parse Server creates transaction data DFNS handles transaction signing Transaction is submitted to the blockchain Events are monitored for transaction confirmation Client is notified of transaction status","title":"Transaction Flow"},{"location":"system-architecture/gemforce-system-architecture/#security-considerations","text":"","title":"Security Considerations"},{"location":"system-architecture/gemforce-system-architecture/#smart-contract-security","text":"Diamond pattern for upgradeability Role-based access control Function-level permissions Reentrancy protection","title":"Smart Contract Security"},{"location":"system-architecture/gemforce-system-architecture/#cloud-service-security","text":"Authentication and authorization API key management Rate limiting Input validation Encrypted data storage","title":"Cloud Service Security"},{"location":"system-architecture/gemforce-system-architecture/#wallet-security-dfns","text":"Delegated transaction signing Multi-factor authentication Key recovery mechanisms Transaction approval flows","title":"Wallet Security (DFNS)"},{"location":"system-architecture/gemforce-system-architecture/#deployment-model","text":"","title":"Deployment Model"},{"location":"system-architecture/gemforce-system-architecture/#smart-contracts","text":"Multiple environments (development, staging, production) Network-specific deployments Facet management Upgrade paths","title":"Smart Contracts"},{"location":"system-architecture/gemforce-system-architecture/#cloud-services","text":"Parse Server deployment Database configuration Cache layer API gateway Monitoring and logging","title":"Cloud Services"},{"location":"system-architecture/gemforce-system-architecture/#scalability-considerations","text":"","title":"Scalability Considerations"},{"location":"system-architecture/gemforce-system-architecture/#smart-contract-scalability","text":"Gas optimization State minimization L2 solutions when needed Batched operations","title":"Smart Contract Scalability"},{"location":"system-architecture/gemforce-system-architecture/#cloud-service-scalability","text":"Horizontal scaling of Parse Server Database sharding Load balancing Caching strategies","title":"Cloud Service Scalability"},{"location":"system-architecture/gemforce-system-architecture/#conclusion","text":"The Gemforce system leverages the Diamond pattern for upgradeable smart contracts, combined with a powerful cloud service layer, to create a flexible and robust platform for digital identity and asset management. The integration with DFNS provides secure wallet management, while the Bridge API integration enables financial operations and compliance.","title":"Conclusion"}]}